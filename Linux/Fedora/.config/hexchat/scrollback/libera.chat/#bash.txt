T 1709527983 18<22tirnanog18>	upon -prune being reached and its effect applied, that which follows must surely be an alternative.
T 1709527995 18<22tirnanog18>	it does more than just be true, after all.
T 1709527997 18<22pj18>	if the preceding conditions return false then it short-circuits the -prune.
T 1709528019 18<22tirnanog18>	yes. all primaries are joined by an implicit -a where neither -a nor -o is given.
T 1709528054 18<22pj18>	so prune may return true, but only if it reaches -prune.
T 1709528072 18<22tirnanog18>	yes.
T 1709528074 18<22pj18>	which it won't if the -path conditions aren't satisfied.
T 1709528128 18<22pj18>	loganlee: does this help? ^^^^^^
T 1709528199 18<22loganlee18>	pj, i'm a little tired today. i'll have a look at it later. :D
T 1709536002 18<27chomwitt18>	Why a glob's wild chars can not match a '/' but using globbing in other commands , like for example in debian's dpgk-query --search' can ?
T 1709536549 18<20bent_fingers18>	loganlee: i used to think the same thing.
T 1709536600 18<28emanuele618>	then you tried drinking coffee and now you are not tired anymore
T 1709536617 18<27larryv18>	chomwitt: what dpkg-query does is not globbing
T 1709536641 18<24ano18>	there is no such a thing as glob(bing) std/spec, glob(bing) mostly mean https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_13 but it can be anything
T 1709536670 18<28emanuele618>	cool link
T 1709536687 18<27larryv18>	chomwitt: you're really comparing filename generation/expansion to pattern matching. the former has extra restrictions over general pattern matching
T 1709536694 18<27chomwitt18>	larryv: so dpkg-query doesnt it's own expansion ?
T 1709536704 18<27chomwitt18>	/s/doesnt/does
T 1709536712 18<27larryv18>	chomwitt: it's not doing filename expansion at all
T 1709536744 18<27larryv18>	not as understood in the shell language, at any rate
T 1709536780 18<28emanuele618>	* ? [] does not match / mostly because the glob is compared against a file name, not an entire path; however if you use the glob patter in case  case $var in *a*) ;; esac   or [[ $var == *a* ]]   then * will be able to match /
T 1709536830 18<27chomwitt18>	larryv: so dpkg-query does on its own a search on the space of all installed files and the similarity to unix shell glob is that is using glob like wildchars ?
T 1709536855 18<27larryv18>	more or less
T 1709536884 18<27larryv18>	like emanuele6 just said, even the shell itself uses patterns in slightly different ways
T 1709537012 18<27chomwitt18>	emanuele6: so that is like having relative meaning according to the context used . Is that behavior documented somewhere ?
T 1709537037 18<27larryv18>	https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_13_03
T 1709537070 18<28emanuele618>	you don't even have to think of it as working differently in different context; the glob pattern is matches against the file name which will not contain a /
T 1709537167 18<27larryv18>	yeah but there's also other stuff like initial '.' having to be matched explicitly
T 1709537187 18<28emanuele618>	also that  *  cannot match an empty string when the entire glob is *
T 1709537201 18<28emanuele618>	e.g.  /usr/bin/*/bash    cannot match /usr/bin//bash
T 1709537243 18<28emanuele618>	because it actually compares * against the file names of the files in /usr/bin/ which will not contain any file with a empty name, because those cannot exist
T 1709537283 18*	27chomwitt thanks for the clarification , insights and the opengroup link larryv and emmanuelux
T 1709537341 18<28emanuele618>	thank you for thanking emmanuelux, i always think they are underappreciated
T 1709537359 18<27colo18>	:D
T 1709537376 18<27larryv18>	is that your evil twin
T 1709537388 18<27colo18>	or maybe the good twin?
T 1709537393 18<27larryv18>	:O
T 1709537412 18<28emanuele618>	maybe; i had a vanishing twin, maybe that is where it has gone :o
T 1709537541 18<27chomwitt18>	emanuele6: sorry!
T 1709537578 18*	27chomwitt thanks emanuele6 .
T 1709537629 18<24ano18>	does anyone use less as pager at daily basis? looks like lesspipe.sh and gentoo builtin lessopen are awful
T 1709537947 18<20bent_fingers18>	ano: everyone uses less
T 1709538051 18<20cappy18>	bent_fingers: less is more but cat is a bat with wings and it flies circles around less, at least for this guy.
T 1709538079 18<20bent_fingers18>	chomwitt: please consider the plight of he who serves you https://www.givesendgo.com/GBH2M
T 1709538152 18<20bent_fingers18>	ano: you can fix that, and yes, it's awful
T 1709538160 18<24ano18>	fat bat
T 1709538199 18<20cappy18>	s/bat is a cat.../
T 1709538270 18<28emanuele618>	bats are not flying felines; that is a common misconception
T 1709538404 18<20cappy18>	emanuele6: Yes, truly. But seriously, I've found the bat(1) pager far superior with its language syntax highlighting.
T 1709538506 18<20bent_fingers18>	i'm colorblind. doesn't matter to me
T 1709538551 18<20cappy18>	Perhaps ano is not?
T 1709538569 18<20bent_fingers18>	i open my texts with less, press f, and i'm good
T 1709538578 18<20bent_fingers18>	sometimes i press /
T 1709538608 18<20bent_fingers18>	not much else to it really
T 1709538660 18<28emanuele618>	i use the occasional ?
T 1709538663 18<20bent_fingers18>	cappy: perhaps he's eyeless?
T 1709538687 18<28emanuele618>	either that or bat eyesight
T 1709538698 18<20cappy18>	That could make for difficult debugging of a missing quote here and there.
T 1709538905 18<20cappy18>	bat automatically pipes its output through a pager (by default: less).  So the foundation remains viable.
T 1709538940 18<28emanuele618>	how much does it cost?
T 1709538962 18<20bent_fingers18>	were any bats harmed in it's making?
T 1709538962 18<20cappy18>	It's in the debian repo.
T 1709538999 18<28emanuele618>	oh, i don't use debian
T 1709539002 18<20cappy18>	DEB package bat-musl
T 1709539048 18<20cappy18>	emanuele6: https://github.com/sharkdp/bat
T 1709539051 18<20bent_fingers18>	sounds like a lot of piping when you use bat
T 1709539068 18<20bent_fingers18>	he can't access that
T 1709539085 18<20bent_fingers18>	cappy: consider helping  https://www.givesendgo.com/GBH2M
T 1709539094 18<28emanuele618>	wow advertisements in the readme file :o
T 1709539104 18<24ano18>	bat will cost ~3MB of rusty bloatness
T 1709539117 18<28emanuele618>	ano: how much does that cost?
T 1709539127 18<28emanuele618>	i heard rust is free
T 1709539160 18<20bent_fingers18>	could be
T 1709539174 18<28emanuele618>	rust removal however... quite expensive
T 1709539175 18<20bent_fingers18>	some things are free out there, after all
T 1709539217 18<28emanuele618>	i installed bat
T 1709539228 18<28emanuele618>	and printed out a .bat file with it
T 1709539237 18<28emanuele618>	fancy colours
T 1709539268 18<28emanuele618>	it is using a salmon colour to highlight "echo"
T 1709539296 18<19sphertext18>	does any body have a suggestion for a good sed tutorial?
T 1709539297 18<24ano18>	think free as in "free coc", not "free memory"
T 1709539311 18<20bent_fingers18>	atlantic pink salmon, to be precise
T 1709539318 18<20cappy18>	emanuele6: try --list-themes and --list-colors
T 1709539323 18<28emanuele618>	highlight -Oansi uses the regular green colour, not special truecolour
T 1709539335 18<20cappy18>	sorry --list-languages
T 1709539354 18<20bent_fingers18>	sphertext: the one in the title of #sed
T 1709539362 18<28emanuele618>	hmm. i ran  --list-themes  and it dumped a bunch of text; not what i would expect from a pager
T 1709539384 18<28emanuele618>	unbuffer bat --list-themes | less -R   to the rescue...
T 1709539410 18<28emanuele618>	needed to unbuffer, or bat --list-themes just outputs the theme names separated by newline
T 1709539420 18<20bent_fingers18>	this is nerve wracking
T 1709539421 18<20cappy18>	Ha. bat --list-themes | bat
T 1709539425 18<19sphertext18>	bent_fingers oh hmm.. i had that saved in my bookmarks, don't remember where i got it from. i was going to use it, but i checked the one about find on the same website and it didn't seem very comprehensive. so i assumed the sed one maybe isn't either
T 1709539432 18<28emanuele618>	cappy...
T 1709539440 18<28emanuele618>	why are you being so mean? D:
T 1709539447 18<28emanuele618>	with the wrong suggestions D:
T 1709539463 18<20cappy18>	Not mean at all.
T 1709539463 18<28emanuele618>	i just told you that will list only the theme names
T 1709539472 18<20bent_fingers18>	will emanuele6 like the app or not? we're sitting on our seats biting our nails in anticipation of the oucome
T 1709539472 18<24ano18>	sphertext: chk #sed /topic
T 1709539482 18<19sphertext18>	ano i just replied to that
T 1709539500 18<19sphertext18>	i guess if multiple ppl say it's good i should check it
T 1709539507 18<28emanuele618>	also even if you use   unbuffer bat --list-themes | bat    that messes up the colours because it re-highlights the text
T 1709539526 18<28emanuele618>	unbuffer bat --list-themes | less -R   is just better to see look at the themes
T 1709539594 18<20cappy18>	emanuele6: Yeah, hadn't tried that. But the language list is extensive and works well for bash.
T 1709539603 18<20bent_fingers18>	ano: i told him that already. you can't snatch my kudos from me
T 1709539611 18<28emanuele618>	mean suggestion :(
T 1709539628 18<20bent_fingers18>	i need 997 more kudos to gain immunity from channel banning
T 1709539630 18<28emanuele618>	there is an  ansi  theme to use standard colours instead of truecolors
T 1709539712 18<28emanuele618>	bat --theme=ansi foo.bat   now echo is purple :o
T 1709539722 18<28emanuele618>	err, magenta
T 1709539731 18<28emanuele618>	the same colours as cappy's nickname in weechat :D
T 1709539763 18<20bent_fingers18>	sphertext: multiple people also believed influenza wsa influenced by the stars
T 1709539811 18<20bent_fingers18>	but i wouldn't recommend communing with them in hopes of alleviating any future illness that unhappily visits upon you
T 1709539814 18<19sphertext18>	my 16 ansi theme in my terminal is 15 shades of grey + one shade of red
T 1709539825 18<28emanuele618>	ew
T 1709539860 18<19sphertext18>	i find that collapsing the dimensionality of visual design spares my cognitive resources which are limited
T 1709539875 18<28emanuele618>	wow, upgrade your brain?
T 1709539888 18<28emanuele618>	lol
T 1709539907 18<20bent_fingers18>	mine is black, white, red, and blue for the 16
T 1709539911 18<28emanuele618>	doesn't that just make colours harder to differenciate?
T 1709539928 18<19sphertext18>	https://0x0.st/HdcG.png
T 1709539932 18<28emanuele618>	s/differenciate/differentiate/ i know how to spell
T 1709539952 18<28emanuele618>	sphertext: i don't even know how many colours you are showing
T 1709539953 18<19sphertext18>	no, i find it's actually sufficient
T 1709539963 18<19sphertext18>	15 colors
T 1709539973 18<19sphertext18>	the red is omitted and left as an exercise of imagination for the beholder
T 1709539975 18<28emanuele618>	you didn't reduce the number of colours, you just made them harder to differenciate
T 1709539996 18<19sphertext18>	no, i reduced the dimensionality of visual information
T 1709540002 18<28emanuele618>	there are clearly different shades, there; but i cannot easily tell if shades that are far apart are different or not
T 1709540015 18<19sphertext18>	i can tell the shades apart, easily
T 1709540036 18<28emanuele618>	wow
T 1709540040 18<28emanuele618>	impressive
T 1709540075 18<19sphertext18>	when there's information across the hue dimension as well, i find it distracting
T 1709540078 18<20bent_fingers18>	and yet we still are left on edge over the verdict of whether or not bat wins approval
T 1709540087 18<19sphertext18>	i need more mental effort to process it
T 1709540121 18<28emanuele618>	with that colour palette for sure
T 1709540126 18<19sphertext18>	which leaves means mental energy for other things
T 1709540134 18<19sphertext18>	* less
T 1709540136 18<20bent_fingers18>	you can see color but choose not to do so?
T 1709540137 18<28emanuele618>	lol
T 1709540141 18<20bent_fingers18>	what in the world?
T 1709540175 18<19sphertext18>	hue is a redundant dimensions of visual representation
T 1709540221 18<20bent_fingers18>	i agree
T 1709540236 18<20bent_fingers18>	we should all have surgery and become monochromatics
T 1709540247 18<19sphertext18>	i still use 1 shade of red
T 1709540253 18<20bent_fingers18>	black & white forever!
T 1709540254 18<19sphertext18>	it's the only one that has a semantic justification
T 1709540311 18<20bent_fingers18>	when i have a child, if he or she or whatever can see color, i'm dropping it off at the fire station
T 1709540355 18<19sphertext18>	my desktop wallpaper is pitch black
T 1709540366 18<20bent_fingers18>	my child can only see black and white, damn the reduntant dimensions! damn them all!
T 1709540368 18<19sphertext18>	like the abyss of existence
T 1709540499 18<28emanuele618>	my desktop wallpaper is https://commons.wikimedia.org/wiki/File:Cow_Moos_-_geograph.org.uk_-_1885583.jpg
T 1709540514 18<19sphertext18>	exhausting
T 1709540535 18<20bent_fingers18>	pastroal
T 1709540539 18<20bent_fingers18>	pastoral
T 1709540542 18<20bent_fingers18>	idyllic
T 1709540563 18<19sphertext18>	anyway i'm not a psycho, i actually run this in a window constantly on one of my screens https://www.youtube.com/watch?v=VZUkuY3oo2k
T 1709540564 18<20bent_fingers18>	Van Goph would have been proud
T 1709540664 18<20bent_fingers18>	sphertext: i'm not convinced
T 1709540722 18<19sphertext18>	i wrote a bash script that starts that video every day. i'm vaguely using it to regulate my circadian rhythm
T 1709541295 18<26razamatan18>	an encrypted loopback file mounting bash alias (on smartos [illumos]) used to work fine to have a nested command that prompted for a decrypting password, but oddly, something changed that it no longer blocks for user input for the password
T 1709541317 18<26razamatan18>	would this be bash or the password prompting command?
T 1709541696 18<24geirha18>	a bit odd to pack that much logic into an alias. I would use a function. Anyway, no generic answer to your question. It depends on what exactly it runs, and in what context
T 1709541715 18<26razamatan18>	are you familiar w/ the lofiadm command in solaris?
T 1709541769 18<26razamatan18>	it's really not that bad.. the alias is just: mount $(lofiadm -c aes-256-cbc -a /path/to/enc/file) /mnt/path
T 1709541827 18<24geirha18>	if lofiadm uses the tty on stdin to read password, that should work. I'd add the missing quotes though
T 1709541831 18<26razamatan18>	the lofiadm returns the /dev/ path to the loopback device holding the unencrypted file handle after getting the password to unlock
T 1709541850 18<26razamatan18>	(i have the quotes, i just retyped from memory)
T 1709541926 18<26razamatan18>	the odd thing is, it works fine if i reorder the commands (and explicitly set the /dev device path which makes the whole thing a bit more brittle: lofiadm -c aes-256-cbc -a /path/to/en/file /dev/lofi/2 && mount /dev/lofi/2 /mnt/path
T 1709541984 18<26razamatan18>	again, the original version used to work fine prior to doing a system upgrade (so it's hard to tell what is causing issues)
T 1709542471 18<24geirha18>	See what it shows when you enable xtrace (set -x):  (set -x ; youralias)
T 1709542567 18<24geirha18>	oh and, if you run the same  lofiadm command as you do inside the command subsittution, it still asks for password? (i.e. without specifying the lofi dev)
T 1709542590 18<26razamatan18>	it correctly does the nested lofiadm as the first command, and does the bad behavior of asking for the password 4 times without actually blocking for the read
T 1709542627 18<26razamatan18>	the behavior is that it just keeps prompting the full retry count (i think 4 based on what i'm seeing) and failing
T 1709542677 18<24geirha18>	printf '<%s>\n' "$(read -rp "type something: " var && printf %s "$var")
T 1709542683 18<24geirha18>	does that one wait for input?
T 1709542719 18<26razamatan18>	should i just cut and paste that in a live prompt, or put that in an alias?
T 1709542750 18<24geirha18>	alias shouldn't really affect it, but try both just to be sure
T 1709542789 18<24geirha18>	oh and it's missing the closing " at the very end there
T 1709542793 18<24geirha18>	printf '<%s>\n' "$(read -rp "type something: " var && printf %s "$var")"
T 1709542816 18<26razamatan18>	i had to switch it up to: printf '<%s>\n' "$(read -rp 'type something: ' var && printf %s \$var)"
T 1709542822 18<26razamatan18>	and it did prompt correctly
T 1709542912 18<26razamatan18>	https://github.com/illumos/illumos-gate/tree/b70bf3ee79d81df3ccc36e553e0ff11049a2b51a/usr/src/cmd/lofiadm
T 1709542925 18<24geirha18>	well, sounds like lofiadm is the one that has changed behavior somehow. It should definitely have the same ability as that read to read from the tty
T 1709542937 18<26razamatan18>	ok.. :/
T 1709542944 18<26razamatan18>	i'll follow up w/ the illumos folks
T 1709543126 18<26razamatan18>	geirha: thanks..
T 1709543174 18<27Soliton18>	having to change that code seems suspicious...
T 1709546167 18<19Clocked18>	Hi! When I need the last 3 parts of this-is-a-sting-where-I-need-to-get-1-2-3 should I do this with 3 times ${string##*:-} and glue it back together or use cut/awk/or so ?
T 1709546219 18<20osse18>	Clocked: is the part you want always numbers and the rest never numbers?
T 1709546243 18<19Clocked18>	osse nope otherwise it would have been easy indeed
T 1709546316 18<27Soliton18>	# string=this-is-a-sting-where-I-need-to-get-1-2-3; echo "${string#"${string%-*-*-*}"-}"
T 1709546319 18<25shbot18>	Soliton: 1-2-3
T 1709546352 18<19Clocked18>	oh yeah in this case that would be possible!
T 1709546372 18<19Clocked18>	I thought such inner was never possible
T 1709546756 18<27Earnestly18>	Clocked: It is in the parameter section of parameter expansion, but not in the expansion part
T 1709546788 18<19Clocked18>	indeed!
T 1709547501 18<24xmb18>	# s() { for s ; do printf %s\\t "${s#${s%%+(-+([0-9]))}-}" ; done ; } ; s a-b-c-1-2-3-4 1-d-e-8-2 a-8-b-9-7
T 1709547503 18<25shbot18>	xmb: 1-2-3-4 8-2     9-7
T 1709547702 18<19Clocked18>	nice!
T 1709547759 18<19mawk18>	what's the command from detaching a background job?
T 1709547764 18<19mawk18>	I have a void
T 1709547796 18<27Soliton18>	perhaps you mean disown.
T 1709547804 18<19mawk18>	aaaaaa disown yes
T 1709547805 18<19mawk18>	thanks
T 1709547879 18<19mawk18>	^Z; bg; disown
T 1709547891 18<19mawk18>	it doesn't work on all programs though for some reason
T 1709547895 18<19mawk18>	I guess it's when they mess up the terminal
T 1709547961 18<19mawk18>	and we can always stop them from another terminal, as SIGSTOP cannot be caught
T 1709555614 18<24RhineDevil18>	I need to define a config file containing a structure for "objects" whose data I'll dispatch in multiple associative arrays. In order to do so I'd like to use a proper config file format, easy to edit and that also can refer to some internal variables defined by the script. What could I do?
T 1709555679 18<28emanuele618>	dconf
T 1709555778 18<29fb`18>	redirecting a long running stdout through a fifo to netcat. need it to not block script execution. script eventually blocks on a full output buffer
T 1709556022 18<27Soliton18>	perhaps you can ask your os for a bigger pipe size.
T 1709556037 18<25ormaaj18>	prod the reader and tell it to get busy. Either don't let it fill or don't write to a pipe
T 1709556065 18<25ormaaj18>	Or use nonblocking or polled i/o which shell doesn't really support.
T 1709556209 18<29fb`18>	stdbuf has not helped. script is designed to be unattended, as in a reader may or may not connect to drain the buffer
T 1709556238 18<27Soliton18>	how is that design supposed to work in practice?
T 1709556263 18<27colo18>	"named pipes considered footguns"
T 1709556366 18<29fb`18>	in practice the output can top out around 1MB. script blocks around 132K which has been an issue
T 1709556401 18<27Soliton18>	# cat /proc/sys/fs/pipe-max-size
T 1709556403 18<25shbot18>	Soliton: 1048576
T 1709556437 18<27Soliton18>	sounds like you should ask your os for a bigger pipe.
T 1709556460 18<27Soliton18>	you could also use pv -B as an additional buffer.
T 1709556586 18<29fb`18>	tried pv, still blocks ~132K. pipe-max-size is ~1MB
T 1709556667 18<27Soliton18>	so set your pipe to that size.
T 1709556759 18<27colo18>	what exactly causes the nc process involved not to send off the data to its TCP peer?
T 1709556788 18<29fb`18>	environment is limited doesn't have perl, for example to run fcntl
T 1709556834 18<29fb`18>	a tcp peer may not connect, it's an optional output
T 1709556994 18<29fb`18>	considering a watchdog to detect blocking. it would connect a local dummy peer to and flush the buffer
T 1709557324 18<24RhineDevil18>	emanuele6: I'd prefer a config file format parsable by native bash
T 1709557362 18<24RhineDevil18>	Or by standard tools
T 1709557480 18<28emanuele618>	as opposed to foreign bash
T 1709557512 18<29fb`18>	RhineDevil a config file formatted like a shell script with simple key-value variables wouldn't work? values could be post-processed with cli tools
T 1709559527 18<24RhineDevil18>	fb`: That was my initial idea, but if it's a standard format even better
T 1709559622 18<24RhineDevil18>	In general I'd want either a standard format or something easily parseable for my objective (organized key/value pairs representing fictional objects), with preference for standard format
T 1709559634 18<29fb`18>	maybe xml, yaml, or json then? a tool like this can read/write: https://github.com/mikefarah/yq
T 1709559748 18<24geirha18>	A better yq implementation at   https://github.com/kislyuk/yq
T 1709559982 18<24RhineDevil18>	fb`: As said before I'd use these formats only if they're parseable from bash and standard tools
T 1709560026 18<24RhineDevil18>	Since I'm making a tool that should be generally usable as long you have bash and basic tools like jq I don't wanna request weird dependencies users will have problems in installing
T 1709560066 18<29fb`18>	standard tools defined as.. what your package manager can installer? basic posix commands?
T 1709560075 18<29fb`18>	*install
T 1709560085 18<24RhineDevil18>	basic posix commands
T 1709560100 18<24RhineDevil18>	As now requested dependencies are aapt find gawk sed jq zstd grep
T 1709560110 18<24geirha18>	jq is certainly not posix
T 1709560113 18<24geirha18>	nor gawk or zstd
T 1709560142 18<24RhineDevil18>	They're generally available also originally it wasn't my work
T 1709560150 18<27Soliton18>	but since you apparently already use jq what is even the question...
T 1709560177 18<24RhineDevil18>	Soliton: would be a mess writing a config file for all packages in json...
T 1709560183 18<24RhineDevil18>	Imagine mantaining the package list
T 1709560207 18<24RhineDevil18>	I mean there's a reason why people use stuff like toml and yaml instead of json
T 1709560214 18<20osse18>	how about using bash syntax for the file? read the file by sourcing it and update it by declare -p
T 1709560219 18<27Soliton18>	but you don't want to...
T 1709560220 18<29fb`18>	uhm, tell nodejs devs that
T 1709560291 18<24RhineDevil18>	osse: I remember I've read in this chat a better solution that did exactly this but with parsing instead of sourcing
T 1709560365 18<24RhineDevil18>	fb`: I use javascript only cause I'm forced by circumstances and I think the world would be better if it wasn't invented
T 1709560431 18<29fb`18>	fair enough. so you prefer bash instead?
T 1709560452 18<24RhineDevil18>	No
T 1709560468 18<24RhineDevil18>	Or I mean
T 1709560472 18<24RhineDevil18>	Depends on the task
T 1709560570 18<24RhineDevil18>	So anyway, approved solution is bash-like config file. But wasn't there a way for including just variables instead of code?
T 1709565207 18<24OnlineCop18>	Within a local git repo, I'm usually okay doing `grep 'PATTERN' $(git ls-files)` to limit my searches to only checked-in files, except in a few cases where those files contain spaces or special characters. Do I have to modify IFS, or assign all $(git ls-files) results to an array, in order to do something like this, or is there an alternate command/method I could use?
T 1709565244 18<28emanuele618>	hmm, git grep
T 1709565288 18<27Soliton18>	yeah, use git grep. your current approach is broken and cannot be fixed.
T 1709565317 18<24OnlineCop18>	I just thought of `git grep` after I wrote that... that may be what I'll end up doing. :) Thanks, both.
T 1709565329 18<28selckin18>	git ls-files -oc --exclude-standard | ack -x
T 1709565350 18<22ash_worksi18>	sometimes I want to write a blob of crap to sed or awk. I use heredocs for this, but it pollutes the command history; so I thought of just using stdin, (eg `awk '1' -`) but the result will interweave lines because it doesn't wait for me to finish (eg with ^D)
T 1709565401 18<22ash_worksi18>	is there a way to get a program to wait for my to finish? ... like what happens when you do `foo="$(cat)"`
T 1709565592 18<22ash_worksi18>	I guess `echo "$(cat)" | awk`
T 1709565593 18<27JanC18>	'sponge' from moreutils ?
T 1709565598 18<25greycat18>	if you simply do    foo; bar   bar won't run until foo exits
T 1709565623 18<22ash_worksi18>	oh
T 1709565695 18<27JanC18>	https://manpages.org/sponge
T 1709565719 18<25greycat18>	I would avoid sponge.  It's not safe (data can be lost).
T 1709565793 18<25greycat18>	!sponge
T 1709565793 18<29greybot18>	sponge() ( tmp=$(mktemp) && cat > "$tmp" && cat -- "$tmp" > "$1" && rm -- "$tmp"; ) # read and write the same file in a pipeline: grep -v '^#' file | sponge file
T 1709565867 18<27JanC18>	lost in what way?
T 1709565875 18<22ash_worksi18>	greycat: hmm. in `awk; echo`, awk waits, but it still processes each line after hitting enter so you get an AA'BB' effect if you write lines interactively
T 1709565920 18<26KillerWasp18>	JanC: maybe he want write a big documentation and don't exist Ctrl+S
T 1709565932 18<25greycat18>	People usually want to do something like the man page's example (sed '...' file | grep '...' | sponge [-a] file) but this will truncate the file before writing to it.  If the system crashes during that write, the original data's gone.
T 1709565959 18<27JanC18>	for anything that isn't throwaway you would just use a real file, no?
T 1709565985 18<25greycat18>	You want to write to a new/temp file and only replace the original once the writing is done.
T 1709566001 18<25greycat18>	ash_worksi: I have no idea what you're doing.
T 1709566006 18<27JanC18>	this would be writing to stdout
T 1709566014 18<27JanC18>	not a file
T 1709566030 18<27JanC18>	if I undestand ash_worksi correctly
T 1709566045 18<26KillerWasp18>	sponge() ( cat > "$1.temp" && cat -- "$1.temp" > "$1" && rm -- "$1.temp"; )
T 1709566086 18<26KillerWasp18>	now is more secure, not Ctrl+S, it's always saved.
T 1709566150 18<22ash_worksi18>	JanC: that is correct and the input is not a file, it just my fingers... or pasting
T 1709566185 18<27JanC18>	but ash_worksi wants something like: sponge | grep foo
T 1709566212 18<22ash_worksi18>	In this particular case, I wanted to add few lines of spacing to my paste.
T 1709566213 18<27JanC18>	well, with sed or awk instead of grep  :)
T 1709566235 18<25greycat18>	I can't tell what they want at all.  Is it something like "I type a command and it takes a while to run, which catches me by surprise, because I'm already typing the next command, and now the output of the first command and my typing of the second command are all jumbled"?
T 1709566297 18<27JanC18>	yes, that's what ash_worksi mentioned: "but the result will interweave lines because it doesn't wait for me to finish"
T 1709566322 18<27JanC18>	they mean "interweave input & output", I suppose
T 1709566341 18<25greycat18>	you think they're running an *interactive* command?
T 1709566346 18<27JanC18>	yes
T 1709566355 18<22ash_worksi18>	yes to all of that
T 1709566371 18<27JanC18>	based on "but it pollutes the command history"
T 1709566384 18<25greycat18>	... I'm totally lost.
T 1709566388 18<27Soliton18>	you could disable the terminal echo.
T 1709566389 18<27JanC18>	that would not happen in a script...
T 1709566413 18<27JanC18>	they want to see input & output, I'm sure
T 1709566594 18<27JanC18>	ash_worksi: when this is just text from the "clipboard" (without manual editing & where you don't need to see the source), another option might be to use a utility that reads data directly from there instead of pasting it...
T 1709566741 18<22ash_worksi18>	JanC: the copied source is an interactive docker container that doesn't have access to the awk script; I could add it, but it's torn down frequently enough to be a nusance and infrequent enough not to added it to a new image
T 1709566811 18<27Soliton18>	pretty sure they mean  xclip | awk  or similar.
T 1709566850 18<22ash_worksi18>	oh
T 1709566935 18<22ash_worksi18>	I'm surprised greycat gave me the time of day on that question. I figured they'd think, "whatever they're trying to do is too stupid for me to engage"
T 1709566974 18<22ash_worksi18>	they must be in a pretty generous mood.
T 1709567156 18<27JanC18>	xclip only works for X11, on wayland you'd need wl-paste or something like that I think
T 1709567210 18<27JanC18>	or an appropriate clipboard tool for whatever else your system uses  :)
T 1709567666 18<22ash_worksi18>	thanks for the help, and also interpretation JanC
T 1709569849 18<24RhineDevil18>	Do I remember uncorrectly or there was a placeholder technique for config files where you placed a placeholder and then you could substitute it with a variable before echoing it?
T 1709569859 18<24RhineDevil18>	Without sourcing of course
T 1709569878 18<27Soliton18>	!template
T 1709569878 18<29greybot18>	http://mywiki.wooledge.org/TemplateFiles
T 1709570019 18<27Soliton18>	if you're blindly injecting into shell code that is not a good idea of course.
T 1709570613 18<22ash_worksi18>	RhineDevil: nginx containers use `envsubst`
T 1709570663 18<22ash_worksi18>	I just realized that's on that page Soliton linked anyway
T 1709573310 18<29luva18>	Hello, I want to write a bash script that does a backup. In that bash script, I want to just for every DNS lookup use a specific nameserver, since it needs to use a private one, without setting one in the OS. Can someone help me on how to do it?
T 1709573501 18<27Soliton18>	sounds like you need to check the documentation of the tool that does the lookup on how to specify the server.
T 1709573586 18<29luva18>	well I cant change the host OS Soliton
T 1709573601 18<29luva18>	host DNS*
T 1709573640 18<26lopid18>	`man dig`
T 1709576816 18<25greycat18>	luva: some DNS lookup programs have a way to specify a server; some do not.  Find one that does, that you can use, and then do whatever it takes to specify the server.  E.g. with dig, you use @ip.add.res.ss.  With some others it'll be a mandatory or optional argument.
T 1709579605 18<20bent_fingers18>	Grymoires sed tutorial shows this example: sed s/day/night/ <old >new
T 1709579627 18<20bent_fingers18>	And says for unix beginners to try this one: sed s/day/night/ old >new
T 1709579642 18<20bent_fingers18>	Why the second for beginners?
T 1709579666 18<25greycat18>	Most likely they're trying to get you to think about those two commands, and understand how they differ, if at all.
T 1709579733 18<25greycat18>	It's equivalent to comparing   cat file1   and  cat <file1
T 1709579836 18<28emanuele618>	meow
T 1709580059 18<19Liver_K18>	Is there any difference between ${name:-} and ${name}?
T 1709580072 18<25greycat18>	probably when set -u is in effect
T 1709580078 18<29phy172918>	If set -u explodes
T 1709580264 18<20bent_fingers18>	one has sed read from stdin, the other from an argument/positional parameter
T 1709580303 18<20bent_fingers18>	What difference does it make?
T 1709580432 18<29phy172918>	If it's seekable, what error messages say, where in the command it can go
T 1709580434 18<20bent_fingers18>	I suppose it has something to do with bragging rights
T 1709580530 18<20bent_fingers18>	Seekable? Never heard of it. Must be why I don't have any pull requests to respond to
T 1709580557 18<25greycat18>	I don't think sed cares about seekability, but other commands might.
T 1709580576 18<29phy172918>	iirc diff generally does
T 1709580598 18<25greycat18>	diff <() <() works, though
T 1709580624 18<29phy172918>	Does it? I though I had to use diff =() =()   (zshism)
T 1709580640 18<29phy172918>	Maybe GNU diff is fancier
T 1709580699 18<20bent_fingers18>	Join us in GNU. We enjoy awkard acronyms.
T 1709620790 19*	Now talking on 22#bash
T 1709620790 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709620790 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709636674 18<26dionys18>	[_]‚ÜÑ ... cheers
T 1709637169 18<19Artfaith18>	c[‚ñÖ]
T 1709637347 18<28emanuele618>	!pizza
T 1709637438 18<24ano18>	!gastritis
T 1709643423 18<29nvz18>	heh
T 1709643452 18*	29nvz looks that up
T 1709643552 18<29nvz18>	na.. not gastritis.. but I do seem to have somethin goin on
T 1709643734 18<24ruvik18>	Hello guys
T 1709643758 18<29nvz18>	no guys here.. just us chickens
T 1709643795 18<29nvz18>	right scooby?
T 1709644023 18<28emanuele618>	https://www.youtube.com/watch?v=miomuSGoPzI
T 1709645315 18<24depesz18>	hi. given such input (array of strings): ns=( "m 1" "m 2" "s 1" "b 1" ) - what would be the sanest way to get number of elements that start with "m " ?
T 1709645328 18<24depesz18>	I can grep|wc -l, but it doesn't look sane.
T 1709645487 18<19Artfaith18>	depesz, do you want with loop or not?
T 1709645509 18<24depesz18>	ideally simple one-liner. but I'll take anything.
T 1709645526 18<24depesz18>	currently my "best" approach is: printf '%s\n' "${ns[@]}" | grep -c "^m "
T 1709645560 18<24depesz18>	only one execve, and no interpreted loops. but i somehow feel that there should be better way‚Ä¶
T 1709645857 18<19Artfaith18>	# declare ns=( "m 1" "m 2" "s 1" "b 1" ); declare el r=(); for el in "${ns[@]}"; do if [[ "$el" =~ ^m ]]; then r+=( "${el//[A-Za-z +]/}" ); fi; done; declare -p -- r;
T 1709645860 18<25shbot18>	Artfaith: declare -a r=([0]="1" [1]="2")
T 1709645860 18<27Soliton18>	unless you have loop phobia you'd just loop over the element and count.
T 1709645945 18<19Artfaith18>	`+` in the regex is redundant though.
T 1709645946 18<27Soliton18>	that grep approach only works if the elements contain no newline, btw.
T 1709645969 18<24depesz18>	they don't. the original value comes from mapfile-t
T 1709646025 18<27Soliton18>	you can use mapfile to handle NUL delimited input.
T 1709646031 18<24depesz18>	sorry, not sure what the r+= does. you are extracting some value form the ns elements? sorry. it was meant to *count* the elements, not check their "appendages" :)
T 1709646041 18<24depesz18>	Soliton: i know, but not in this case :)
T 1709646050 18<24geirha18>	you could do a while read loop instead of mapfile and do the count at the same time
T 1709646064 18<27Soliton18>	# ns=( "m 1" "m 2" "s 1" "b 1" ); for n in "${ns[@]}"; do [[ $n = m\ * ]] && count=$((count + 1)); done; echo "$count"
T 1709646066 18<25shbot18>	Soliton: 2
T 1709646075 18<24depesz18>	i could, but then I would have to rebuild the array anyway, as it is needed in array form later on.
T 1709646098 18<24geirha18>	count in addition to populating the array ...
T 1709646107 18<24depesz18>	Soliton: any reason to not use (( count++ )) ?
T 1709646123 18<27Soliton18>	not really.
T 1709646176 18<24geirha18>	while IFS= read -r line ; do ns+=( "$line" ) ; [[ $line = m\ * ]] && (( mcount++ )) ; done
T 1709646268 18<24depesz18>	yeah. that looks ok.
T 1709646276 18<24depesz18>	not sure why IFS=, though
T 1709646297 18<24geirha18>	without it it will trim leading and trailing whitespace
T 1709646323 18<28emanuele618>	the BEST way is    IFS= eval printf -v _ '"${arr[*]/*/%c}%n"' '"${arr[@]%%[!m]*}"' mcount    there is no competition
T 1709646347 18<19Artfaith18>	The best they may not understand.
T 1709646364 18<19Artfaith18>	The above will allow to move on, and get into this part later.
T 1709646387 18<19Artfaith18>	Though, I see "EVAL"!
T 1709646394 18<19Artfaith18>	Eval is Evil!
T 1709646443 18<19Artfaith18>	Even if we know that Bash being REPL is eval itself ^^"
T 1709646673 18<28emanuele618>	hmm, something is wrong
T 1709646708 18<28emanuele618>	# arr=( mauris cursus mattis molestie a. elementum eu facilisis sed odio morbi quis commodo odio aenean. sociis natoque penatibus et magnis dis parturient. fermentum odio eu feugiat pretium nibh. eu sem integer vitae justo eget magna fermentum. ); (IFS= eval set -x\; printf -v m '"${arr[*]/*/%c}%n"' '"${arr[@]%%[!m]*}"' mcount)
T 1709646709 18<25shbot18>	emanuele6: ++ printf -v m %c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%n m '' m m '' '' '' '' '' '' m '' '' '' '' '' '' '' '' m '' '' '' '' '' '' '' '' '' '' '' '' '' '' m '' mcount
T 1709646714 18<28emanuele618>	that looks correct, but
T 1709646730 18<28emanuele618>	# arr=( mauris cursus mattis molestie a. elementum eu facilisis sed odio morbi quis commodo odio aenean. sociis natoque penatibus et magnis dis parturient. fermentum odio eu feugiat pretium nibh. eu sem integer vitae justo eget magna fermentum. ); IFS= eval printf -v m '"${arr[*]/*/%c}%n"' '"${arr[@]%%[!m]*}"' mcount;  declare -p m mcount
T 1709646732 18<25shbot18>	emanuele6: declare -- m="m"
T 1709646732 18<25shbot18>	emanuele6: declare -- mcount="36"
T 1709646741 18<28emanuele618>	m only contains one m, and mcount in 36
T 1709646759 18<19Artfaith18>	depesz, the `+=` adds to the array.
T 1709646768 18<19Artfaith18>	++ adds to the integer.
T 1709646789 18<28emanuele618>	# arr=( mauris cursus mattis molestie a. elementum eu facilisis sed odio morbi quis commodo odio aenean. sociis natoque penatibus et magnis dis parturient. fermentum odio eu feugiat pretium nibh. eu sem integer vitae justo eget magna fermentum. ); IFS= eval printf -v m '"${arr[*]/*/%.1s}%n"' '"${arr[@]%%[!m]*}"' mcount;  declare -p m mcount
T 1709646790 18<25shbot18>	emanuele6: declare -- m="mmmmmm"
T 1709646790 18<25shbot18>	emanuele6: declare -- mcount="6"
T 1709646834 18<19Artfaith18>	As in the most languages.
T 1709646837 18<28emanuele618>	i think that is just a bug in bash; with printf's %c specifier and %n; it always assumes %c prints a byte even when it does not
T 1709646853 18<28emanuele618>	%.1s works correctly
T 1709646879 18<28emanuele618>	i am not sure why m is set to m when using -v m and %c, but that is probably also a bug
T 1709646896 18<28emanuele618>	%c ''  messes up some internal count
T 1709647046 18<28emanuele618>	# arr=( mauris cursus mattis molestie a. elementum eu facilisis sed odio morbi quis commodo odio aenean. sociis natoque penatibus et magnis dis parturient. fermentum odio eu feugiat pretium nibh. eu sem integer vitae justo eget magna fermentum. ); IFS= eval printf '"${arr[*]/*/%c}%n"' '"${arr[@]%%[!m]*}"' mcount;  declare -p mcount
T 1709647047 18<25shbot18>	emanuele6: mmmmmmdeclare -- mcount="36"
T 1709647053 18<28emanuele618>	without -v the output is correct
T 1709647060 18<28emanuele618>	but mcount is still wrong
T 1709647198 18<24ano18>	what does "${!var[@]*}" mean?
T 1709647205 18<28emanuele618>	# dash -c 'printf %c ""' | od -An -tc
T 1709647207 18<25shbot18>	emanuele6:   \0
T 1709647209 18<28emanuele618>	# ksh -c 'printf %c ""' | od -An -tc
T 1709647211 18<25shbot18>	emanuele6:   \0
T 1709647217 18<28emanuele618>	# printf %c '' | od -An -tc
T 1709647219 18<25shbot18>	emanuele6:   \0
T 1709647219 18<28emanuele618>	wow
T 1709647240 18<28emanuele618>	so %c ''  prints a NUL, it is not the same as %.1s :o
T 1709647245 18<28emanuele618>	i didn't know that
T 1709647251 18<28emanuele618>	printf %c in sh truly sucks
T 1709647272 18<28emanuele618>	ano: it expands to the variable names that start with "var"
T 1709647320 18<24ano18>	# var2=var1; var1=var2; printf {%s} "${!var[@]*}"
T 1709647320 18<28emanuele618>	oh, i misread that as ${!var@} sorry
T 1709647322 18<25shbot18>	ano: {}
T 1709647336 18<28emanuele618>	there var is an array
T 1709647342 18<28emanuele618>	it concatenates the values of var by space
T 1709647364 18<28emanuele618>	# var=(var) var1= var2=; printf {%s} "${!var[@]*}"
T 1709647366 18<25shbot18>	emanuele6: {}
T 1709647372 18<28emanuele618>	then i am not sure what it does
T 1709647380 18<28emanuele618>	# var=(var) var1= var2=; printf {%s} "${!var[1]*}"
T 1709647382 18<25shbot18>	emanuele6: {}
T 1709647394 18<28emanuele618>	i don't know; maybe it is not even that
T 1709647417 18<28emanuele618>	maybe it is trying to expand to variables that start with var[@] that cannot exist
T 1709647491 18<28emanuele618>	yes, that is what it does
T 1709647493 18<27Soliton18>	given that it only works with @ or * appended i'd guess it is a parser quirk because of the variable name prefix matching.
T 1709647725 18<28emanuele618>	i guess you can use it to write inline comments :)
T 1709647755 18<28emanuele618>	$ ./bash -c 'var=(var) var1= var2=; printf {%s}\\n "${!var[1]*}"'
T 1709647757 18<28emanuele618>	emanuele6debug: all_variables_matching_prefix("var[1]") was called.
T 1709647759 18<28emanuele618>	{}
T 1709647769 18<28emanuele618>	so yeah, that is what it is doing; confirmed
T 1709647800 18<28emanuele618>	# echo hi ${!a[@]i am a comment he he he he*} hello
T 1709647802 18<25shbot18>	emanuele6: hi hello
T 1709647858 18<28emanuele618>	!learn %c #redirect printf%c
T 1709647858 18<29greybot18>	OK, emanuele6
T 1709648143 18<28emanuele618>	!learn printf%c The `%c' format specifier in sh's printf does not print the character of the ASCII code corresponding to its number argument as it does for other languages' printf; it takes a string argument, and prints its first byte; it is similar to `%.1s', except that if the argument is an empty string, it will print a NUL character (\0) instead of printing nothing.
T 1709648143 18<29greybot18>	OK, emanuele6
T 1709648147 18<28emanuele618>	>:(
T 1709648404 18<28emanuele618>	(POSIX) The argument to the c conversion specifier can be a string containing zero or more bytes. If it contains one or more bytes, the first byte shall be written and any additional bytes shall be ignored. If the argument is an empty string, it is unspecified whether nothing is written or a null byte is written.
T 1709648549 18<28emanuele618>	!forget printf%c
T 1709648550 18<29greybot18>	OK, emanuele6
T 1709648620 18<28emanuele618>	!learn printf%c The %c format specifier in sh's printf does not print the character of the ASCII code corresponding to its number argument as it does for other languages' printf; it takes a string argument, and prints its first byte; it is similar to %.1s, except that its behaviour is unspecified if the argument is an empty string (in bash, it prints a NUL character instead of printing nothing.)
T 1709648620 18<29greybot18>	OK, emanuele6
T 1709648629 18<28emanuele618>	so printf %c in sh sucks even more
T 1709648652 18<28emanuele618>	at least you can use it in bash as a golfed   printf \\0 :   printf %c   is one byte shorter
T 1709652139 18<24depesz18>	this is *not* bash question, but you are smart, maybe you will be able to help - on one machine `man grep` (or other man pages) doesn't show colors. I checked, and both this box, and another (that does show color) have the same pager, pager options, and LESS_TERMCAP_.. env variables.
T 1709652195 18<24depesz18>	https://dpaste.org/aftGn
T 1709652229 18<26lopid18>	have you tried #linux?
T 1709652238 18<24depesz18>	i didn't. thanks.
T 1709652436 18<27Soliton18>	see what  tput colors  outputs.
T 1709652559 18<24depesz18>	256 in both cases.
T 1709653855 18<27Earnestly18>	https://github.com/landley/toybox/commit/a2419ad52d489bf1a84a9f3aa73afb351642c765
T 1709654248 18<28emanuele618>	https
T 1709655547 18<24depesz18>	solved. in case you'd stumble upon it - it seems to be broken by groff 1.23. fix is to either "export MANROFFOPT=-c" or "export GROFF_NO_SGR=1"
T 1709656200 18<27Earnestly18>	depesz: Is the goal to disable colours?
T 1709656211 18<24depesz18>	Earnestly: enable them. they got disabled by groff upgrade
T 1709656246 18<27Earnestly18>	depesz: I have 1.23 and -c is to "start with color output disabled"
T 1709656260 18<24depesz18>	Earnestly: where do you see that ?
T 1709656265 18<27Earnestly18>	In the manual
T 1709656270 18<24depesz18>	manual to what?
T 1709656285 18<24depesz18>	please note that -c is *not* option to man
T 1709656289 18<27Earnestly18>	depesz: groff, but it appears to be related to grotty
T 1709656294 18<27Earnestly18>	-c     Use grotty's legacy output format (see subsection ‚ÄúLegacy output format‚Äù above).  SGR and OSC escape sequences are not emitted.
T 1709656307 18<24depesz18>	exactly. it changes how color is outputted.
T 1709656307 18<27Earnestly18>	This also appears to exclude them
T 1709656312 18<24depesz18>	not for me.
T 1709656321 18<27Earnestly18>	depesz: Is this on a linux tty?
T 1709656324 18<24depesz18>	for me setting either of these things, or both of them, brings back color to manpages
T 1709656337 18<24depesz18>	linux, yes, in various terminal emulators.
T 1709656386 18<27Earnestly18>	NO_SGR: If set, grotty's legacy output format is used just as if the -c option were specified; see subsection ‚ÄúLegacy output format‚Äù above.
T 1709656482 18<24depesz18>	not sure what that has to do with it. are you saying that what I said is not true? well, it seems to be rather obscure, but known, bug: https://unix.stackexchange.com/a/771560/70436
T 1709656496 18<27Earnestly18>	depesz: Yeah it appears specific to SGR sequences, so bold and underline, etc. works but obviously it's expecting something different for colour
T 1709656564 18<27Earnestly18>	I wonder if there's a new way
T 1709656691 18<24depesz18>	if you'll find another, i'll gladly read about it.
T 1709656709 18<24depesz18>	you will need to find computer with broken man/groff/less/term* first, though :)
T 1709656979 18<27Earnestly18>	depesz: Seems like they just removed sgr (the command specifically) but provide it via -c and NO_SGR, but it's not very clear
T 1709657002 18<27Earnestly18>	provide "it", not being the command but "remain supported"
T 1709657032 18<27Earnestly18>	depesz: It seems a bit odd that "NO"_SGR would enable SGR
T 1709658822 19*	Now talking on 22#bash
T 1709658822 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709658822 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709658916 18<22FakuVe18>	I am changing it to plaintext
T 1709658923 18<22FakuVe18>	But actually it should be the same
T 1709658928 18<22FakuVe18>	You are right
T 1709658937 18<22FakuVe18>	no need to pass it to plaintext
T 1709659069 18<22FakuVe18>	it is taking ages though
T 1709659075 18<22FakuVe18>	Maybe my potato computer
T 1709659079 18<27Earnestly18>	FakuVe: Yeah it would
T 1709659085 18<22FakuVe18>	Also that is operating in an sdcard
T 1709659091 18<22FakuVe18>	:D
T 1709659123 18<27Earnestly18>	FakuVe: A nested for-loop like this is alone O^2 (quadratic), but that's probably unavoidable. But you're also forking quite a lot of stuff in this fairly fast, nested, loop
T 1709659126 18<22FakuVe18>	definitely rsync is not written this way "D
T 1709659147 18<27Earnestly18>	FakuVe: Here's a basic rewrite: https://0x0.st/H7pJ.txt (find of -maxdepth 1 means you probably want a for loop)
T 1709659162 18<27Earnestly18>	FakuVe: Sorry, <= should be > 1
T 1709659180 18<27Earnestly18>	Although that doesn't really need to exist
T 1709659206 18<27Earnestly18>	Because if the array has 1 element, then your file = fileb will always succeed
T 1709659240 18<27Earnestly18>	FakuVe: Instead of forking pup for *every* fileb and file comparison, you can fork it once for just file and then only fork pup for fileb
T 1709659305 18<22FakuVe18>	Thats looking nice
T 1709659311 18<27Earnestly18>	FakuVe: Another way to do this, which is what I'd do, is generate a list of all files and their titles. Then sort that list and extracting the duplicates
T 1709659318 18<22FakuVe18>	does pup work without quoting
T 1709659343 18<27Earnestly18>	FakuVe: What do you mean?
T 1709659351 18<27Earnestly18>	For the .css-selector?
T 1709659403 18<27Earnestly18>	You only need to quote if there's something that would undergo glob file expansions, quoting is used to suppress the meaning the shell gives to strings. If there's no shell specific syntax then there's no need to quote
T 1709659414 18<27Earnestly18>	literal quoting anyway
T 1709659426 18<22FakuVe18>	yeah let me try yours
T 1709659460 18<27Earnestly18>	FakuVe: You also don't need -name '*' that's the default behaviour
T 1709659462 18<22FakuVe18>	Mine may be the worse algorythm ever. It took 10 mins to find the second ocurrence
T 1709659474 18<22FakuVe18>	alright
T 1709659553 18<27Earnestly18>	FakuVe: It's mostly bad because of the amount of forking you do which is particularly slow. Yes it's also quadratic but unless you have thousands of files that shouldn't be very noticible
T 1709659591 18<22FakuVe18>	I think its also my computer
T 1709659600 18<22FakuVe18>	But yours didnt give any output
T 1709659767 18<22FakuVe18>	yeah if files > 1  , instead
T 1709659774 18<22FakuVe18>	instead of <= 1
T 1709659861 18<27Earnestly18>	FakuVe: Yeah I suggested that correction earlier
T 1709659911 18<27Earnestly18>	FakuVe: The other problem is you call pup on fileb way more times than necessary
T 1709660072 18<22FakuVe18>	it has got an issue
T 1709660078 18<22FakuVe18>	once it removes a file
T 1709660100 18<22FakuVe18>	It will iterate through that file afterwards  , and will have a warning of file doesnt exists
T 1709660107 18<22FakuVe18>	it doesnt matter though
T 1709660137 18<27Earnestly18>	If you have files a b c, then looping a a b c, b a b c, c a b c will call pup on a b c 3 times more than necessary. Also as your loops are complete file lists, removing one file will fail when it attempts to access it if it already existed in the for loop's "list"
T 1709660175 18<22FakuVe18>	yeah , whatever
T 1709660183 18<22FakuVe18>	It works , thats ok for me
T 1709660189 18<22FakuVe18>	good to learn how to do it properly
T 1709660197 18<22FakuVe18>	And I appreciate so much your help
T 1709660209 18<22FakuVe18>	For this case is more than fine Earnestly thank you
T 1709660277 18<25Lynx-18>	Can anyone advise on an especially CPU-friendly way to prepend a word to line outputs of a binary file and pass the result onto a FIFO without buffering more than each line?
T 1709660332 18<25Lynx-18>	right now I simply do while read line; printf term line >; done, but I'm hoping there is a way to avoid the byte-by-byte read penalty that that incurs
T 1709660558 18<25Lynx-18>	And bonus would be to use bash builtins
T 1709660561 18<22FakuVe18>	it was the sd card , I used it in my internal memory and like 8 times faster at least
T 1709660574 18<20twkm18>	i'd likely use awk or sed, along with unbuffer.
T 1709660601 18<22FakuVe18>	Yeah cheers
T 1709660677 18<22FakuVe18>	I am going for a run will check this back , cheers all
T 1709660759 18<25Lynx-18>	twkm thanks. Is the only way in bash to just use a byte-by-byte read? No clever trick to avoid that?
T 1709660778 18<27Earnestly18>	FakuVe: Consider: https://0x0.st/H7pk.txt
T 1709661070 18<27Earnestly18>	FakuVe: Or https://0x0.st/H7pF.txt
T 1709661143 18<27Earnestly18>	Lynx-: read will read(2) one byte at a time if the input is a pipe. It buffers if the input is a file. Bash's read has -N if you want to do buffered reads yourself
T 1709661238 18<27Earnestly18>	Lynx-: Which then means you'll need to pay careful attention to the exit status of read as to whether the buffer was filled, wasn't filled or was a read error or read timeout.
T 1709661365 18<25Lynx-18>	Earnestly thanks. Is the output from binaries like ping typically such that it outputs line by line such that if you read -t 0 the exit status will show you data is available after complete line has been written?
T 1709661404 18<27Earnestly18>	Lynx-: I would use awk
T 1709661468 18<27Earnestly18>	Don't try to do read -t 0 hacks for this, and no. As I write, read -N lets you do buffered reads, but like C, you just have to manage the input, i.e. detecting record separation and building variables until you do
T 1709661930 19*	Now talking on 22#bash
T 1709661930 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709661930 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709662197 18<25Lynx-18>	Earnestly once the data has been read in with say -N 512, what's the most efficient way to split up the lines without byte-by-byte read then at that point? So far I have this: https://pastebin.com/raw/Y7gwst09
T 1709662265 18<25Lynx-18>	echo $line shows indeed how you get the nice 512 bytes at a time, but then I'm wondering how to avoid then having to end up reading every character to work out the positions of the new lines.
T 1709662373 18<25Lynx-18>	ultimately I'd like to just print out the complete lines as they are completed, without requiring a byte-by-byte read on the read-in 512 byte chunks, if this is at all possible
T 1709662538 18<25Lynx-18>	ah, I can just printf "${line}" .. I see.
T 1709662604 18<25Lynx-18>	intereting - strace shows: "read(10, "64 bytes from localhost (::1): i"..., 155) = 64" reads
T 1709662636 18<25Lynx-18>	do I read that correctly that when -N 512 is specified it is resulting in 64 byte reads?
T 1709662685 18<25Lynx-18>	here is the strace: https://pastebin.com/raw/eUbcRhyJ
T 1709667679 19*	Now talking on 22#bash
T 1709667679 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709667679 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709674382 19*	Now talking on 22#bash
T 1709674382 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709674382 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709675352 18<22FakuVe18>	Earnestly: those two lastones work fast , but they do delete all files
T 1709675354 18<22FakuVe18>	https://0x0.st/H7pF.txt
T 1709675519 18<25Lynx-18>	So -N 512 results in several read calls like: <<<read(10, "64 bytes from localhost (::1): i"..., 475) = 64>>> - what governs the number 64?
T 1709675595 18<25greycat18>	That's how many you got.  I'm more curious about the 475, which is how many were requested.
T 1709675857 18<28emanuele618>	ping outputs a line every few seconds; so that already read 37 bytes from the previous line (or lines), and only requests 475 this time
T 1709675897 18<28emanuele618>	with -N512, read won't return until bash has put 512 characters on the variable, or EOF is reached, so it just keeps collecting
T 1709675917 18<25greycat18>	yeah, makes sense if they didn't show us the first line
T 1709675923 18<25Lynx-18>	so the chunk size of collection is dictated by the manner in which the binary outputs the chunks?
T 1709675944 18<25greycat18>	64 is how many bytes you *actually got*.  It's how many were *there*.
T 1709675957 18<25Lynx-18>	greycat here: https://pastebin.com/raw/eUbcRhyJ
T 1709676051 18<25Lynx-18>	isn't it 64 read and 475 of the 512 remaining
T 1709676053 18<24Nintendo18>	Bitching about jq a few weeks ago paid off, because today I used ‚Äú// empty‚Äù, and it made me happy.
T 1709676067 18<25Lynx-18>	you see the number decreasing with each line
T 1709676108 18<25Lynx-18>	and then: rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0; rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
T 1709676233 18<28nphard18>	what's the difference between alteranet uses of '>'?
T 1709676242 18<28nphard18>	cut file > nu_file
T 1709676260 18<28nphard18>	cut -f1 < file > nu_file
T 1709676264 18<28nphard18>	both do the same
T 1709676283 18<28nphard18>	even the difference between 'cut -f1 file' and cut -f1 < file'
T 1709676308 18<28emanuele618>	if file is -,  cut -f1 -  reads from stdin; while  cut -f1 < -  reads from a file named - in the current directory
T 1709676333 18<25greycat18>	In the last line, the first command, cut opens the file itself, and therefore it knows the file name and can report it in error messages and so on.  In the second command, bash opens the file and cut only receives the already-opened file descriptor.
T 1709676466 18<25greycat18>	In the redirection command, if the file *can't* be opened, cut never even gets executed.  Bash tries to open it, fails, gives an error message, and never calls cut.
T 1709676476 18<28nphard18>	the next logical question begged is: which one is better?
T 1709676486 18<25Lynx-18>	what's the most efficient way to split up a string including newline characters into an array with elements having those separate lines from string? Is there a way to do that without byte-by-byte read?
T 1709676498 18<25greycat18>	Lynx-: mapfile / readarray
T 1709676521 18<25Lynx-18>	ah, yes
T 1709676919 18<27xx18>	# echo abc `#def` ghi
T 1709676921 18<25shbot18>	xx: abc ghi
T 1709676931 18<27xx18>	# echo abc "$(#def)" ghi
T 1709676938 18<25shbot18>	xx: Missing terminating quote, bracket or keyword
T 1709676944 18<27xx18>	why?
T 1709677009 18<20arraybolt318>	# echo abc \"\$(#def)\" ghi
T 1709677011 18<25shbot18>	arraybolt3: bash: syntax error near unexpected token `('
T 1709677055 18<27xx18>	# echo abc "$(\#def)" ghi
T 1709677055 18<25shbot18>	xx: no output
T 1709677649 18<27larryv18>	xx: the parser probably closes ` by simply looking for the next unquoted `. the contents of $(...) are parsed more rigorously
T 1709686297 19*	Now talking on 22#bash
T 1709686297 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709686297 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709686298 18<19puchu18>	fifi
T 1709686319 18<19puchu18>	$PROXY_PREFIX cmd
T 1709686339 18<19puchu18>	this doesnt seem to work, how i make this work?
T 1709686356 18<29nightstrike18>	djph: yes
T 1709686369 18<19puchu18>	PROXY_PREFIX="http_proxy=http://127.0.0.1:8118 https_proxy=${http_proxy}"
T 1709686375 18<19puchu18>	$PROXY_PREFIX cmd
T 1709686378 18<29nightstrike18>	tirnanog: ok, I'll keep debugging
T 1709686446 18<22tirnanog18>	puchu: a) PROXY_PREFIX=$PROXY_PREFIX cmd or ... b) export PROXY_PREFIX; cmd
T 1709686470 18<22tirnanog18>	or c) export it at the same time as assigning
T 1709686502 18<19puchu18>	tirnanog: thanks
T 1709686561 18<27larryv18>	hm, i assumed puchu was trying to export http{,s}_proxy in a particularly convoluted manner
T 1709686573 18<22tirnanog18>	oh yeah.
T 1709686579 18<22tirnanog18>	just looked at the value. oh dear.
T 1709686741 18<22tirnanog18>	puchu: more like this then: if [[ ${PROXY_ENABLED} -eq 1 ]]; then export http_proxy=http://127.0.0.1:8118; export https_proxy=${http_proxy}; fi
T 1709686750 18<25ormaaj18>	I'd create the heredoc after running sudo using the execline heredoc command.
T 1709686786 18<25ormaaj18>	"Oh but I can't install anything". hax0r that b0x0r. permission granted.
T 1709686869 18<22tirnanog18>	nightstrike: I take it you can't rely on the exit status?
T 1709686873 18<22tirnanog18>	(of cmd)
T 1709686982 18<25ormaaj18>	I guess technically you can do that anyway using just bash.
T 1709687175 18<19puchu18>	tirnanog thanks, i did it exactly like your - like this - :)
T 1709687257 18<22tirnanog18>	otherwise, you would have had to issue http_proxy=$http_proxy https_proxy=$http_proxy cmd after assigning. seems simpler just to export to begin with.
T 1709687515 18<29nightstrike18>	tirnanog: correct, it's poorly written
T 1709687847 18<25ormaaj18>	sudo -- bash +o monitor -O lastpipe -c '{ printf %s "$2" | { shift; { BASH_ENV=/proc/self/fd/${fd} exec -- "$@"; } {fd}<&0 <&"$tty"-; } {tty}<&0' bash bash 'cd /server && source blahblah; shift; unset -v fd BASH_ENV {fd}<&-' arg1 arg2 ...
T 1709687872 18<29nightstrike18>	tirnanog: it seems to have almost random return statuses
T 1709687971 18<25ormaaj18>	sudo -- bash +o monitor -O lastpipe -c '{ printf %s "$2" | { shift; { BASH_ENV=/proc/self/fd/${fd} exec -- "$@"; } {fd}<&0 <&"$tty"-; } {tty}<&0' bash bash 'cd /server && source blahblah; unset -v fd BASH_ENV {fd}<&-' arg1 arg2 ...
T 1709687978 18<25ormaaj18>	shift in wrong place.
T 1709688000 18<22tirnanog18>	nightstrike: how awful.
T 1709688075 18<25ormaaj18>	If only bash were posix I wouldn't need those extra {}'s
T 1709688278 18<24yuesbeez18>	ormaaj: thanks. what would arg1 arg2 be passed to in this case?
T 1709688303 18<25ormaaj18>	the exec'd bash shell
T 1709688339 18<25ormaaj18>	$1 stores the "heredoc" data. then dump it into a pipe, shift it away, exec remaining args
T 1709688376 18<25ormaaj18>	Oh and I have them in the wrong order duh
T 1709688399 18<25ormaaj18>	sudo -- bash +o monitor -O lastpipe -c '{ printf %s "$2" | { shift; { BASH_ENV=/proc/self/fd/${fd} exec -- "$@"; } {fd}<&0 <&"$tty"-; } {tty}<&0' bash 'cd /server && source blahblah; unset -v fd BASH_ENV {fd}<&-' bash arg1 arg2 ...
T 1709688408 18<25ormaaj18>	the first "bash" is argv[0]
T 1709688432 18<26sybariten18>	Is the "bind" command a bash specific thing?
T 1709688443 18<25ormaaj18>	sybariten: mostly
T 1709688457 18<25ormaaj18>	basically yes. some other shells have different bind command.
T 1709688567 18<26sybariten18>	Someone in the fzf channel said that in order to change a key shortcut binding, for a tool called fzf, i would just need to export an env var.  I fail to understand how he meant exactly, if i look into the config today the line which is originally used is    bind -m emacs-standard '"\ec": " \C-b\C-k \C-u`__fzf_cd__`\e\C-e\er\C-m\C-y\C-h\e \C-y\ey\C-x\C-x\C-d"'
T 1709688696 18<26sybariten18>	Hm, maybe he meant something else actually. Oh well.
T 1709688777 18<22tirnanog18>	the bind builtin is for altering readline(3) bindings, as applied specifically to bash. as concerns environment variables, it's unclear what they meant.
T 1709688827 18<22tirnanog18>	it's quite possible that they didn't know either.
T 1709688852 18<26sybariten18>	Yep, i think they may have meant what that key binding _does_ , judging from how its worded.... i realize now.
T 1709688888 18<22tirnanog18>	the only env vars recognised by fzf itself are FZF_DEFAULT_COMMAND, FZF_DEFAULT_OPS and FZF_API_KEY, according to a brief skim of its manual.
T 1709688892 18<22tirnanog18>	OPTS*
T 1709688921 18<26sybariten18>	And i think i know which variable to export in that case. But for picking up the key itself, i dont think i should do that, i should probably make a new /usr/share/doc/fzf/examples/key-bindings.bash , modify that and source it from my .bashrc
T 1709688932 18<25ormaaj18>	heh i tried it and got an error from my own code
T 1709688937 18<25ormaaj18>	libinit: Error: The shell failed to set the (E)UID and re-execing it with the correct values somehow failed to fix it. That should never happen. Not trying again to prevent an exec loop.
T 1709688949 18<25ormaaj18>	that branch should never be taken...
T 1709688965 18<25ormaaj18>	also I used --norc --noprofile. wtf
T 1709688966 18<26sybariten18>	s/"make a new"/"copy"
T 1709688971 18<22tirnanog18>	what manner of Lovecraftian horror have you unearthed now.
T 1709689306 18<25ormaaj18>	https://bpa.st/raw/2OIA that is "init.bash" which is sourced from .bashrc
T 1709689307 18<28checkbot18>	ormaaj: I think the problem is on line 20. Parameter expansions can't start with .. Double check syntax. See 25 issues on https://shellcheck.net/?id=cb89307
T 1709689319 18<25ormaaj18>	ah checkbot loves me
T 1709689352 18<25ormaaj18>	somehow sudo triggers this, but normally it doesn't, and should never.
T 1709689429 18<25ormaaj18>	it means it tried to run `exec -- env UID=correct uid bash`, then tried measuring it in the new shell and it still didn't match. Does sudo have something that blocks overwriting UID somehow?
T 1709689539 18<25ormaaj18>	probably not that doesn't seem possible.
T 1709689578 18<25ormaaj18>	unless env looks for SUDO being set and env has some misfeature that does that
T 1709689739 18*	25ormaaj stracing...
T 1709690319 18<25ormaaj18>	i wonder why sudo is unsetting UID and EUID to begin with. It just unsets them and lets the child fill them in? I never noticed that.
T 1709690446 18<25ormaaj18>	hmm lets try my new bash ebuild that doesn't have that stupid SSH define. Maybe it's f'd because gentoo
T 1709690556 18<25ormaaj18>	I wouldn't think sudo would trigger that either
T 1709690862 18<25ormaaj18>	maybe it is. it shouldn't be forcing my .bashrc to run with --norc
T 1709693155 18<22des_h18>	any chance i can read a file from the end backwards (for performance reasons) in either awk or sed?
T 1709693391 18<20tanath18>	des_h: `awk '{a[i++]=$0} END {for (j=i-1; j>=0;) print a[j--] }' FILE`
T 1709693405 18<20tanath18>	where FILE is your filename
T 1709693474 18<22des_h18>	doesn't that still read the whole file from top to bottom before the END block is executed?
T 1709693509 18<25hleneto18>	des_h, there's tac.
T 1709693519 18<20tanath18>	yeah
T 1709693541 18<22des_h18>	i'd like to start reading from the bottom backwards and stop after X < FNR lines (once a condition is met), so that i don't actually read all of the lines
T 1709693603 18<20tanath18>	i hadn't paid attn to the performance part since i didn't have context. just saw you wanted to read in reverse and grabbed a method. sorry
T 1709693706 18<22des_h18>	is there a reason this way of reading a file is not built into canonical terminal programs?
T 1709693749 18<27larryv18>	it's a weird requirement.
T 1709693775 18<27larryv18>	and it could only work on regular files, not streams, adding complexity
T 1709693826 18<22des_h18>	i have a file which has data appended to it regularly. like a log. i'd like to periodically edit the data in this file, but only check the new lines which i haven't already edited. the new lines would be at the bottom of the file
T 1709693859 18<20tanath18>	maybe just `tail -n <number_of_lines_to_read> <file_path> | tac`
T 1709693881 18<22des_h18>	problem is i don't know in advance how many new lines have been appended since i last checked
T 1709693911 18<22des_h18>	so i need to go backwards until i find a line which i've already edited
T 1709693927 18<22des_h18>	and stop
T 1709694067 18<20tanath18>	you could use vim and have it remember your last position. when you open the file you're where you left off
T 1709694196 18<22des_h18>	hmm or i could just write the last position i checked in another file and retrieve it later. then use sed to print only the lines higher than that position. i think it would still improve performance somewhat
T 1709695809 18<25ormaaj18>	There should be a way to detect whether an expression is being evaluated with eval... to define an alias that hooks a function definition by only expanding in the global scope of a sourced file, you can just look at BASH_SOURCE[0], but eval doesn't modify BASH_SOURCE, so eval "$(<file)" will break the alias.
T 1709696521 18<25ormaaj18>	You can't unset or overload BASH_SOURCE. An unhackable variable :(
T 1709697491 18<29noobaroo18>	I'm really stupid and can't solve a simple math equation
T 1709697540 18<29noobaroo18>	How many minutes and seconds is a video that is 579MB and has a bitrate of 4000KB/second?
T 1709697618 18<29nightstrike18>	it's roughly 2 and a half minutes
T 1709697640 18<29nightstrike18>	579/4
T 1709697655 18<25ormaaj18>	don't you have to like extract the video from its container and get the length of the raw stream?
T 1709697667 18<29nightstrike18>	well if it's constant bitrate...
T 1709697676 18<29nightstrike18>	so like, some old codec
T 1709697695 18<25ormaaj18>	oh right that tells you nothing
T 1709697696 18<25ormaaj18>	heh
T 1709697696 18<29nightstrike18>	or if 4M is the average, it's close enough
T 1709697786 18<29noobaroo18>	I got 144.75 but it just seems incorrect, it has to be way longer than 2 minutes
T 1709697799 18<29noobaroo18>	It just doesn't seem right.
T 1709697802 18<29noobaroo18>	Thanks.
T 1709697835 18<20bent_fingers18>	does anyone really use `grep -f pattern_file`?
T 1709697848 18<29nightstrike18>	noobaroo: well maybe you use a variable bitrate, and 4M isn't the right average
T 1709697872 18<25ormaaj18>	If it's even like half of the screen is a solid blue box for the entire  video, then even the approximation will be way wrong
T 1709697880 18<29nightstrike18>	tirnanog: for my question from earlier, maybe I oversimplified... what I'm actually doing is...  cmd <<< "input string" |& grep -q Error
T 1709697892 18<29nightstrike18>	Could <<< be affecting the ability of that to work reliably?
T 1709697916 18<25ormaaj18>	no
T 1709697917 18<29nightstrike18>	noobaroo: just open it in VLC
T 1709697954 18<25ormaaj18>	don't use &| though. It sucks.
T 1709697959 18<25ormaaj18>	|&
T 1709697996 18<29nightstrike18>	why does it suck?
T 1709698009 18<25ormaaj18>	(there are no cshisms that don't suck so naturally)
T 1709698023 18<29nightstrike18>	I can't even parse that :P
T 1709698061 18<29nightstrike18>	and anyway, 2>&1 still doesn't work
T 1709698070 18<29nightstrike18>	so the problem is elsewhere
T 1709698110 18<25ormaaj18>	portability mainly. |& has completely different meaning in other shells.
T 1709698135 18<29nightstrike18>	hm...  works on the command line, not in the script
T 1709698140 18<25ormaaj18>	Also it evaluates very strangely
T 1709698186 18<29nightstrike18>	strangely?
T 1709698259 18<25ormaaj18>	cmd 2>&1 |& # won't do what you think. because it isn't like an alias for an ordinary redirection.
T 1709698435 18<29nightstrike18>	hm...  well FWIW, I reverted all my temporary kludges back to my original script, and now it works.  So there must have been something screwed up externally.
T 1709698450 18<29nightstrike18>	I think that means it's time for bed.
T 1709698637 18<29nightstrike18>	ok, so one last thing.. I got stuck on this for days and then forgot about it...  I need to match a line of an output stream, and then remove the matching line, the one after, and the two previous.  I got `sed -e 'N;/match/!P;D'` to discard the matched line and one prior, but I can't get two prior and can't get the one after
T 1709698722 18<29nightstrike18>	I guess I can ask again in #sed
T 1709700600 18<29nightstrike18>	lololol... this abomination works...   `cat x | (mapfile -t; for ((i=0; i<${#MAPFILE[@]}; i++)); do if [[ "${MAPFILE[$i]}" == *"match"* ]]; then unset "MAPFILE[$((i-2))]" "MAPFILE[$((i-1))]" "MAPFILE[$i]" "MAPFILE[$((i+1))]"; fi; done; for i in "${MAPFILE[@]}"; do echo "$i"; done)`
T 1709700638 18<29nightstrike18>	who said you can't shove that square peg through a concrete wall? :P
T 1709700887 18<25ormaaj18>	except uuoc
T 1709700900 18<29nightstrike18>	what's that?
T 1709700901 18<25ormaaj18>	!uuoc
T 1709700901 18<29greybot18>	Useless Use Of Cat (cat foo | grep bar). See https://mywiki.wooledge.org/BashFAQ/119 and http://www.iki.fi/era/unix/award.html#cat
T 1709700915 18<29nightstrike18>	lol, that's what you point out from that horror?
T 1709700925 18<29nightstrike18>	cat is a standin for some other command I'm running
T 1709700953 18<25ormaaj18>	it's not really that wrong
T 1709700961 18<29nightstrike18>	dude, it's awful
T 1709700964 18<25ormaaj18>	I'd use a read loop instead since you   only really want one line at a time
T 1709700986 18<29nightstrike18>	and it's all because `grep -v -C` doesn't DTRT
T 1709701012 18<25ormaaj18>	there are other details I guess
T 1709701033 18<27larryv18>	could probably be a pretty straightforward awk script
T 1709701034 18<25ormaaj18>	array[$((foo))] is pointless for indexed arrays
T 1709701047 18<29nightstrike18>	larryv: if I knew awk
T 1709701086 18<29nightstrike18>	ormaaj: what do you mean?
T 1709701106 18<25ormaaj18>	the index is implicitly evaluated as a math expression
T 1709701111 18<25ormaaj18>	unless the array is associative
T 1709701126 18<29nightstrike18>	you mean I can do `unset "MAPFILE[i-1]" ?
T 1709701132 18<25ormaaj18>	yes
T 1709701150 18<29nightstrike18>	...you sure?
T 1709701154 18<25ormaaj18>	quite
T 1709701157 18<29nightstrike18>	ok, I'll try it
T 1709701210 18<29nightstrike18>	well, you're right... but I just lost my ssh connection
T 1709701229 18<29nightstrike18>	stupid vpn time limit
T 1709701270 18<29nightstrike18>	even MAPFILE[i] doesn't need $i
T 1709701271 18<29nightstrike18>	nice
T 1709701296 18<25ormaaj18>	MAPFILE[i] is more correct. They aren't quite equivalent.
T 1709701386 18<25ormaaj18>	MAPFILE is hideous. just pick a name
T 1709701417 18<29nightstrike18>	lol
T 1709701430 18<29nightstrike18>	The whole thing is hideous :)
T 1709701455 18*	27JAA picks 'a'.
T 1709701457 18<29nightstrike18>	and sadly, while it works in my small test, doesn't even work in the real deal
T 1709701490 18<29nightstrike18>	JAA: I worked with a guy that wrote...   `int one_thousand_milliseconds_in_seconds = 1;`
T 1709701499 18<27JAA18>	:-)
T 1709701530 18<29nightstrike18>	this was on like a $50m project with many layers of QA. That takes balls.
T 1709701551 18<27JAA18>	Nice
T 1709701633 18<29nightstrike18>	I think he was essentially giving the finger to QA
T 1709701649 18<29nightstrike18>	ah ha!  in my real code, I forgot to swap "match" with the actual match text :)
T 1709701779 18<25ormaaj18>	mapfile -t a <"$x"; typeset -i i; for i in "${!a[@]}"; do [[ $i == *match* ]] && i+=i-2 command unset -v -- 'a[i++]'{,,,,}; done
T 1709701840 18<29nightstrike18>	whoa
T 1709701844 18<27JAA18>	Probably `[[ ${a[i]} == *match* ]]`
T 1709701858 18<25ormaaj18>	that
T 1709701865 18<29nightstrike18>	that looks like magic
T 1709701879 18<29nightstrike18>	what's this {,,,,} notation?
T 1709701890 18<27JAA18>	Very neat trick on the `unset`, yeah.
T 1709701911 18<29nightstrike18>	I know of {1..5} for generating a sequence...
T 1709701945 18<27JAA18>	It just generates 'a[i++]' five times.
T 1709701962 18<27JAA18>	You might only want four, not sure.
T 1709701980 18<29nightstrike18>	should be 4, yeah
T 1709702003 18<27JAA18>	The effect is that it unsets ${a[i++]} five times, and the post-increment takes care of $i.
T 1709702048 18<27JAA18>	So it's equivalent to `unset -v -- 'a[i]' 'a[i+1]' 'a[i+2]' 'a[i+3]' 'a[i+4]'; ((i+=5))` more or less.
T 1709702056 18<29nightstrike18>	i+=i-2..  that seems a little suspect, no?
T 1709702070 18<27JAA18>	Yeah, that should be i+=-2.
T 1709702079 18<27JAA18>	Or i=i-2.
T 1709702087 18<29nightstrike18>	ok, got it...
T 1709702116 18<29nightstrike18>	well that's certainly better than what I wrote.  I still maintain that grep -v -C should work :)
T 1709702129 18<29nightstrike18>	thanks ormaaj , mind if I use your solution?
T 1709702213 18<29nightstrike18>	I guess that's the point of posting in an irc channel :)
T 1709702576 18<25ormaaj18>	+# shopt -s lastpipe; set +m; printf '%s\n' {0..4} match {6..10} | mapfile -t a; typeset -i i; for i in "${!a[@]}"; do [[ ${a[i]} == *match* ]] && i+=-2 command unset -v -- 'a[i++]'{,,,}; done; printf '%s ' "${a[@]}"; echo
T 1709702579 18<25shbot18>	ormaaj: 0 1 2 7 8 9 10
T 1709702584 18<29nightstrike18>	hm.. your code is a lot slower, unfortunately
T 1709702612 18<25ormaaj18>	It should be faster :o
T 1709702619 18<29nightstrike18>	Maybe I typed it wrong
T 1709702642 18<29nightstrike18>	maybe it's hung
T 1709702651 18<25ormaaj18>	if it's slower it's probably bash doing some stupid backflips to export i to command
T 1709702696 18<29nightstrike18>	there's about 140k lines of input text.  Mine finished in maybe ten seconds.  Yours is going on a minute now.
T 1709702722 18<29nightstrike18>	but again, I could have typed it wrong.  it's after midnight for me.
T 1709702732 18<29nightstrike18>	yup
T 1709702733 18<29nightstrike18>	s.bash: line 129: [i++]: bad array subscript
T 1709702735 18<25ormaaj18>	the first one I wrote has some bugs
T 1709702739 18<29nightstrike18>	I must have screwed that up
T 1709702746 18<25ormaaj18>	use the one I sent to shbot
T 1709702750 18<29nightstrike18>	ok
T 1709702863 18<29nightstrike18>	hm... the bugs you fixed are ones that I also fixed...  i+=-2, the LHS of the ==, the three ,,, isntead of 4
T 1709702910 18<25ormaaj18>	wouldn't be too surprised if it does something weird with a huge input either
T 1709702962 18<25ormaaj18>	It would be faster to read one line at a time, unset the preveious too elements, seek ahead a line, and continue
T 1709703064 18<29nightstrike18>	It would be faster to use sed :P
T 1709703071 18<25ormaaj18>	yes
T 1709703079 18<29nightstrike18>	I just don't know how
T 1709703090 18<29nightstrike18>	and both times I asked in #sed got crickets
T 1709703103 18<25ormaaj18>	well with sed you have to use labels and junk. I wouldn't bother.
T 1709703160 18<25ormaaj18>	that's the only way to look ahead more than one line
T 1709703163 18<29nightstrike18>	hm... yeah, it's the i++ that's causing bash to choke
T 1709703199 18<25ormaaj18>	bash sux
T 1709703210 18<20bent_fingers18>	nobody uses grep -f pattern-file
T 1709703215 18<25ormaaj18>	you should figure out where and report a bug :{
T 1709703225 18<29nightstrike18>	hah, they won't accept the bug report
T 1709703229 18<29nightstrike18>	this is bash 4.1.2
T 1709703232 18<20bent_fingers18>	do you think they'll remove the feature if i file a bug?
T 1709703237 18<25ormaaj18>	ah yeah. bug highly likely
T 1709703243 18<25ormaaj18>	probably a bug I reported
T 1709703248 18<25ormaaj18>	years ago
T 1709703258 18<29nightstrike18>	I sadly have to support RHEL6 for another 8 months, so I gotta live with old bash for now
T 1709703268 18<27larryv18>	bent_fingers: no.
T 1709703283 18<25ormaaj18>	41# shopt -s lastpipe; set +m; printf '%s\n' {0..4} match {6..10} | mapfile -t a; typeset -i i; for i in "${!a[@]}"; do [[ ${a[i]} == *match* ]] && i+=-2 command unset -v -- 'a[i++]'{,,,}; done; printf '%s ' "${a[@]}"; echo
T 1709703302 18<25ormaaj18>	is there a 41??
T 1709703310 18<25ormaaj18>	# triggers
T 1709703311 18<25shbot18>	ormaaj: Available triggers: +# bash-devel; 1# bash-1.14; 2# bash-2.05b; 32# bash-3.2; 3# bash-3.2; 42# bash-4.2; 43# bash-4.3; 44# bash-4.4; 4# bash-4.4; 50# bash-5.0; 51# bash-5.1; 52# bash-5.2; 5# bash-5.2; # bash-5.2; d# dash-0.5.9; sh# dash-0.5.9; k# ksh 93u+ 2012-08-01; m# mksh R59 2021/01/24; b# bourne; j# bourne(w/job);
T 1709703321 18<25ormaaj18>	42# shopt -s lastpipe; set +m; printf '%s\n' {0..4} match {6..10} | mapfile -t a; typeset -i i; for i in "${!a[@]}"; do [[ ${a[i]} == *match* ]] && i+=-2 command unset -v -- 'a[i++]'{,,,}; done; printf '%s ' "${a[@]}"; echo
T 1709703323 18<25shbot18>	ormaaj: bash: [i++]: bad array subscript
T 1709703323 18<25shbot18>	ormaaj: bash: [i++]: bad array subscript
T 1709703323 18<25shbot18>	ormaaj: 2 3 4 match 6 7 8 9 10
T 1709703336 18<29nightstrike18>	yeah that's what I get, bad array subscript
T 1709703340 18<25ormaaj18>	fine piece of shit bash is.
T 1709703361 18<29nightstrike18>	42 specifies the version?
T 1709703368 18<25ormaaj18>	something like that
T 1709703377 18<29nightstrike18>	well that's a friendly bot!
T 1709703414 18<29nightstrike18>	GNU bash, version 4.1.2(2)-release (x86_64-redhat-linux-gnu)
T 1709703427 18<29nightstrike18>	CentOS release 6.10 (Final)
T 1709703451 18<25ormaaj18>	mapfile must have been very new
T 1709703461 18<25ormaaj18>	i think it came out only shortly  before
T 1709703462 18<29nightstrike18>	it's 4+ only
T 1709703467 18<29nightstrike18>	yeah
T 1709703747 18<25ormaaj18>	oh wait lastpipe wouldn't have been available then either
T 1709703799 18<25ormaaj18>	42# printf '%s\n' {0..4} match {6..10} | { mapfile -t a; typeset -i i; for i in "${!a[@]}"; do [[ ${a[i]} == *match* ]] || continue; i+=-2 command unset -v -- 'a[i++]'{,,,}; done; printf '%s ' "${a[@]}"; echo; }
T 1709703801 18<25shbot18>	ormaaj: bash: [i++]: bad array subscript
T 1709703801 18<25shbot18>	ormaaj: bash: [i++]: bad array subscript
T 1709703801 18<25shbot18>	ormaaj: 2 3 4 match 6 7 8 9 10
T 1709703808 18<25ormaaj18>	:o
T 1709703817 18<27JAA18>	Huh, it unsets 0 and 1?
T 1709703848 18<27JAA18>	Oh, a match on the first line would be fun, too.
T 1709703859 18<25ormaaj18>	42# printf '%s\n' {0..4} match {6..10} | { mapfile -t a; typeset -i i; for i in "${!a[@]}"; do [[ ${a[i]} == *match* ]] || continue; (( i-=2 )); unset -v -- 'a[i++]'{,,,}; done; printf '%s ' "${a[@]}"; echo; }
T 1709703861 18<25shbot18>	ormaaj: 0 1 2 7 8 9 10
T 1709703889 18<25ormaaj18>	hm rite
T 1709703912 18<29nightstrike18>	JAA: for my purpose, it is guaranteed to not match on the first line
T 1709703932 18<27JAA18>	A match on the last line might also make it sad, or matches on consecutive lines, or matches two lines apart.
T 1709704019 18<22des_h18>	i have a log file with unix timestamps prefixing each line. i want to generate a new file where i convert the timestamps to a human format. i can retrieve the timestamps with either awk or sed, but how do i call the external `date` utility to perform the conversation and substitute the new value in place so that I output a modified line? in sed with some kind of bash command substitution it would be like `s/timestamp/$(convert timestamp)/`
T 1709704093 18<27JAA18>	I'd probably do it in gawk.
T 1709704098 18<29nightstrike18>	The program is outputting..  "attempted command X\nError processing command\nError was NOTFOUND\nprogram failed on 'attempted command X'"
T 1709704130 18<29nightstrike18>	There are many possible errors, I'm only trying to silence specifically the NOTFOUND error, so I'm guaranteed to get those four lines of text all at once
T 1709704137 18<29nightstrike18>	but I don't want to silence any other errors
T 1709704155 18<29nightstrike18>	(and I can't modify the source program to be less annoying)
T 1709704167 18<27JAA18>	Ah, fun.
T 1709704238 18<29nightstrike18>	des_h: we're having fun with mapfile right now. You can do the same!! (no really, don't)
T 1709704245 18<29nightstrike18>	(but you could)
T 1709704275 18<27JAA18>	lol
T 1709704281 18<25ormaaj18>	42# printf '%s\n' 0 match 2 3 4 match match {7..10} | { mapfile -t a; typeset -i i; for i in "${!a[@]}"; do [[ '((i -= 2) < 0 && i = 0), 1' -ne 0 ${a[i]} == *match* ]] || continue; unset -v -- 'a[i++]'{,,,}; done; printf '%s ' "${a[@]}"; echo; }
T 1709704283 18<25shbot18>	ormaaj: bash: syntax error in conditional expression
T 1709704283 18<25shbot18>	ormaaj: bash: syntax error near `${a[i]}'
T 1709704289 18<27JAA18>	If in Bash, I'd just do a `read` loop + `printf`.
T 1709704318 18<25ormaaj18>	ugh wat
T 1709704324 18<25ormaaj18>	+# printf '%s\n' 0 match 2 3 4 match match {7..10} | { mapfile -t a; typeset -i i; for i in "${!a[@]}"; do [[ '((i -= 2) < 0 && i = 0), 1' -ne 0 ${a[i]} == *match* ]] || continue; unset -v -- 'a[i++]'{,,,}; done; printf '%s ' "${a[@]}"; echo; }
T 1709704326 18<25shbot18>	ormaaj: bash: syntax error in conditional expression
T 1709704326 18<25shbot18>	ormaaj: bash: syntax error near `${a[i]}'
T 1709704330 18<27JAA18>	wut is that string?
T 1709704339 18<25ormaaj18>	oh
T 1709704346 18<25ormaaj18>	+# printf '%s\n' 0 match 2 3 4 match match {7..10} | { mapfile -t a; typeset -i i; for i in "${!a[@]}"; do [[ '((i -= 2) < 0 && i = 0), 1' -ne 0 && ${a[i]} == *match* ]] || continue; unset -v -- 'a[i++]'{,,,}; done; printf '%s ' "${a[@]}"; echo; }
T 1709704349 18<25shbot18>	ormaaj: bash: [[: ((i -= 2) < 0 && i = 0), 1: attempted assignment to non-variable (error token is "= 0), 1")
T 1709704349 18<25shbot18>	ormaaj: bash: [[: ((i -= 2) < 0 && i = 0), 1: attempted assignment to non-variable (error token is "= 0), 1")
T 1709704349 18<25shbot18>	ormaaj: etc... ( http://paste.wooledge.org/29296 )
T 1709704372 18<25fireonlive18>	# exit
T 1709704373 18<25shbot18>	fireonlive: logout
T 1709704373 18<25shbot18>	fireonlive: (shell exited with 0)
T 1709704381 18<25ormaaj18>	mh I'm not testing wraparound either. Screw you if you need that.
T 1709704537 18<29nightstrike18>	ormaaj: what's the reason for { mapfile...} vs (mapfile...) ?
T 1709704568 18<25ormaaj18>	{ doesn't create a subshell
T 1709704573 18<29nightstrike18>	ah, ok
T 1709704622 18<25ormaaj18>	I don't know what the problem with that last one is
T 1709704625 18<27JAA18>	But really, what is that string in the comparison?
T 1709704643 18<29nightstrike18>	I'm still trying to get the first one working
T 1709704645 18<27JAA18>	Doesn't that need to be a `$((...))` or something?
T 1709704665 18<29nightstrike18>	ormaaj> 42# printf '%s\n' {0..4} match {6..10} | { mapfile -t a; typeset -i i; for i in "${!a[@]}"; do [[ ${a[i]} == *match* ]] || continue; i+=-2 command unset -v -- 'a[i++]'{,,,}; done; printf '%s ' "${a[@]}"; echo; }
T 1709704666 18<29nightstrike18>	that one
T 1709704715 18<25ormaaj18>	wow that is a bug
T 1709704737 18<25ormaaj18>	I can't do anything without finding a bug
T 1709704759 18<27JAA18>	lol
T 1709704770 18<27JAA18>	:-)
T 1709704859 18<25ormaaj18>	no shell accepts that expression
T 1709704865 18<25ormaaj18>	I don't understand what's wrong with it\
T 1709704886 18<25ormaaj18>	+# let '(i -= 2) < 0 && i = 0'
T 1709704888 18<25shbot18>	ormaaj: bash: let: (i -= 2) < 0 && i = 0: attempted assignment to non-variable (error token is "= 0")
T 1709704896 18<25ormaaj18>	looks correct to me
T 1709704917 18<25ormaaj18>	k# let '(i -= 2) < 0 && i = 0'
T 1709704919 18<25shbot18>	ormaaj: ksh: let: (i -= 2) < 0 && i = 0: assignment requires lvalue
T 1709704925 18<25ormaaj18>	there is a fucking lvalue
T 1709704940 18<27larryv18>	&& has higher precedence than =
T 1709704955 18<25ormaaj18>	>:(
T 1709705062 18<25ormaaj18>	41# printf '%s\n' 0 match 2 3 4 match match {7..10} | { mapfile -t a; typeset -i i; for i in "${!a[@]}"; do [[ '(i -= 2) < 0 && (i = 0), 1' -ne 0 && ${a[i]} == *match* ]] || continue; unset -v -- 'a[i++]'{,,,}; done; printf '%s ' "${a[@]}"; echo; }
T 1709705074 18<25ormaaj18>	42# printf '%s\n' 0 match 2 3 4 match match {7..10} | { mapfile -t a; typeset -i i; for i in "${!a[@]}"; do [[ '(i -= 2) < 0 && (i = 0), 1' -ne 0 && ${a[i]} == *match* ]] || continue; unset -v -- 'a[i++]'{,,,}; done; printf '%s ' "${a[@]}"; echo; }
T 1709705076 18<25shbot18>	ormaaj: 0 9 10
T 1709705079 18<25ormaaj18>	yay!
T 1709705081 18<25ormaaj18>	>:(
T 1709705104 18<27larryv18>	lolol
T 1709705631 18<29nightstrike18>	ormaaj: what was the ultimate fix for "bad subscript" with older bash?
T 1709705791 19*	Now talking on 22#bash
T 1709705791 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709705791 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709705846 18<29nightstrike18>	but what individual change made that go away? there were quite a few changes you were working with
T 1709705849 18<25ormaaj18>	which is odd, because an empty arithmetic expression is valid and equals zero. And those expressions were not empty
T 1709705871 18<25ormaaj18>	that last one looks like it works
T 1709705919 18<29nightstrike18>	I was trying to keep it simpler since I didn't need those extra cases
T 1709705923 18<29nightstrike18>	but I'll try it all the same
T 1709706040 18<29nightstrike18>	it doesn't
T 1709706299 18<29nightstrike18>	oh, hm..
T 1709706307 18<29nightstrike18>	it's almsot working
T 1709706351 18<29nightstrike18>	hey, it worked
T 1709706370 18<29nightstrike18>	both your one from before the extra requirements and the one you ended with
T 1709706407 18<29nightstrike18>	I had accidentally switched terminals to one that was using an older input program (the thing providing this garbage output), and its formatting was significantly different
T 1709706523 18<29nightstrike18>	it's still kinda slow, but it wokrs
T 1709706813 18<29nightstrike18>	ormaaj: ty for all the help. I'm gonna run with this.
T 1709706832 18<29nightstrike18>	Time to head to bed.   goodnight all
T 1709707318 18<25ormaaj18>	How are you supposed to get the max index of an array anyway?
T 1709707504 18<25ormaaj18>	# typeset -a a=([10]=); typeset -n r=a[-1]; echo "${!r}"
T 1709707507 18<25shbot18>	ormaaj: a[-1]
T 1709707510 18<25ormaaj18>	k# typeset -a a=([10]=); typeset -n r=a[-1]; echo "${!r}"
T 1709707512 18<25shbot18>	ormaaj: a[10]
T 1709707514 18<25ormaaj18>	fuck you bash.
T 1709707548 18<27JAA18>	Is iteration over keys guaranteed to be in order?
T 1709707555 18<25ormaaj18>	yes
T 1709707581 18<25ormaaj18>	I mean like, if you expand "${!a[@]}",  that will be in order
T 1709707611 18<27JAA18>	Yeah
T 1709707616 18<27JAA18>	Hmm
T 1709707651 18<25ormaaj18>	so b=("${!a[@]}"); echo "${b[-1]}"; will do it, but damn. All because Chet doesn't know how a freaking list should work.
T 1709707653 18<27JAA18>	And you can't do something like ${!a[-1]}.
T 1709707664 18<27JAA18>	Heh
T 1709707670 18<27JAA18>	Yeah, Bash arrays are weird.
T 1709710608 18<24xmb18>	if arr is without holes , ${#arr[@]} will return its next elem
T 1709710620 18<24xmb18>	0 1 2 , = 3
T 1709710634 18<27JAA18>	Yeah, but the discussion above was about sparse arrays.
T 1709710642 18<24xmb18>	ah k
T 1709710890 18<28emanuele618>	ack
T 1709712593 18<29andre144k18>	hello, how to "pgrep -f" for process "foo" or "bar" ?
T 1709712620 18<29andre144k18>	so when both is running once i get two process ids
T 1709712759 18<22pj18>	# ar=(); ar[1]=a ar[5]=b; ari=("${!ar[@]}"); echo "${ari[-1]}"
T 1709712761 18<25shbot18>	pj: 5
T 1709712773 18<22pj18>	JAA: This is the best way I can think of ^^^^^
T 1709712799 18<29andre144k18>	hopefully not for me ^^
T 1709712804 18<27JAA18>	Yeah
T 1709712817 18<22pj18>	basically copying the indexes into another array
T 1709712825 18<22pj18>	and then accessing the last element of that array
T 1709712873 18<22pj18>	oh, I see ormaaj came up with that earlier.
T 1709715092 18<24xmb18>	andre $( pgrep -f foo ; pgrep -f bar )
T 1709715125 18<24xmb18>	since it says only one pattern
T 1709715636 18<28emanuele618>	you can use  pgrep -f 'foo|bar'   i think
T 1709715676 18<28emanuele618>	yes
T 1709715746 18<29andre144k18>	thx
T 1709715748 18<27JAA18>	It's an ERE according to the man page.
T 1709715754 18<28emanuele618>	>:(
T 1709715781 18<27JAA18>	I completely missed it at first as it's tucked away near the bottom for some reason.
T 1709715857 18<28emanuele618>	did you know that "JAA" is a regular expression? :o
T 1709715872 18<27JAA18>	Whoa
T 1709715891 18<28emanuele618>	# printf 'Hello, %s\n' JAA emanuele6 | grep JAA
T 1709715892 18<25shbot18>	emanuele6: Hello, JAA
T 1709715921 18<27JAA18>	Amazing!
T 1709715933 18<28emanuele618>	JAAmazing!
T 1709715941 18<27JAA18>	:-)
T 1709718283 18<28nphard18>	is it posible a loop with two different values? cut -f1, cut -f2
T 1709718350 18<24xmb18>	u can save to two data structures
T 1709718351 18<28nphard18>	a yes with a variable perhaps?
T 1709718369 18<24xmb18>	whats the cut output look like
T 1709718406 18<28nphard18>	let's say the loop it's only for two iterations, how to tell the second time has to use 'cut -f2'?
T 1709718429 18<24xmb18>	show cut output plz ?
T 1709718441 18<28nphard18>	alright
T 1709718450 18<28nphard18>	it's kinda simple
T 1709718505 18<28nphard18>	https://dpaste.com/BLMFQKH44
T 1709718535 18<24xmb18>	u load -f1 into an arr , and -f2 to another
T 1709718547 18<24xmb18>	then u use those diff arrs for values
T 1709718658 18<28nphard18>	an array?
T 1709718689 18<20osse18>	while read -r num1 num2 num3; do blabla "$num1" "$num2" "$num3"; done
T 1709718702 18<20osse18>	no cut needed
T 1709718752 18<28nphard18>	osse: I need the columns
T 1709718773 18<28nphard18>	wow, so many ways, arrays, 'read -r'
T 1709718782 18<24xmb18>	v1=( 1 1 1 ) v2=( 2 2 2 ) v3=( 3 3 3 ) i=-1 ; while (( ++i <= ${#a[@]} )) ; do declare -n d1=a[i] d2=b[i] ; printf %s\\n "$i : $d1 / $d2" ; exit ; done
T 1709718799 18<28nphard18>	darn1!
T 1709718812 18<28nphard18>	that felt like a punch in the face.
T 1709718817 18<20osse18>	If the number of columns in known I would add num1, num2 and num3 to as many different arrays and process the arrays after the loop is done
T 1709718965 18<28nphard18>	alright, this is interesting, i'll be back to put all this into practice.
T 1709718965 18<24xmb18>	# v1=( 1 1 1 ) v2=( 2 2 2 ) v3=( 3 3 3 ) i=-1 ; while (( ++i <= ${#a[@]} )) ; do declare -n d1=v1[i] d2=v2[i] ; printf %s\\n "$i : $d1 / $d2" ; exit ; done
T 1709718968 18<25shbot18>	xmb: 0 : 1 / 2
T 1709718968 18<25shbot18>	xmb: logout
T 1709718968 18<25shbot18>	xmb: (shell exited with 0)
T 1709718970 18<28nphard18>	thanks all.
T 1709718978 18<24xmb18>	that one works
T 1709719024 18<28emanuele618>	# printf '1\t2\t3\na\tb\tc\nX\tY\tZ\n'
T 1709719026 18<25shbot18>	emanuele6: 1       2       3
T 1709719026 18<25shbot18>	emanuele6: a       b       c
T 1709719026 18<25shbot18>	emanuele6: X       Y       Z
T 1709719031 18<28emanuele618>	# printf '1\t2\t3\na\tb\tc\nX\tY\tZ\n' | jq -rnR '[ inputs / "\t" ] | transpose[] | join("\t")'
T 1709719033 18<25shbot18>	emanuele6: 1       a       X
T 1709719033 18<25shbot18>	emanuele6: 2       b       Y
T 1709719033 18<25shbot18>	emanuele6: 3       c       Z
T 1709719034 18<28nphard18>	xmb: but, declaring the variables with each column can become unwieldy with large numbers of files and unknown data fields.
T 1709719063 18<28nphard18>	xmb: does your solution need to put manually the data into the arrays manually for each file?
T 1709719075 18<24xmb18>	# v1=( 1 1 1 ) v2=( 2 2 2 ) v3=( 3 3 3 ) i=-1 ; while (( ++i <= ${#a[@]} )) ; do  printf %s\\n "$i : ${v1[i]} / ${v2[i]}" ; exit ; done
T 1709719077 18<25shbot18>	xmb: 0 : 1 / 2
T 1709719077 18<25shbot18>	xmb: logout
T 1709719077 18<25shbot18>	xmb: (shell exited with 0)
T 1709719096 18<24xmb18>	nphard it depends only on ur request
T 1709719103 18<28nphard18>	ths --> v1=( 1 1 1 ) v2=( 2 2 2 ) v3=( 3 3 3 )
T 1709719128 18<28nphard18>	*this
T 1709719147 18<28nphard18>	xmb: that's why I was using 'cut -fN'
T 1709719166 18<27Soliton18>	cut is very rarely useful.
T 1709719175 18<27Soliton18>	what is the goal?
T 1709719178 18<28nphard18>	pre-populating the arrays seems like hell of an extra work!!
T 1709719208 18<28nphard18>	Soliton: somthing like this --> https://dpaste.com/BLMFQKH44
T 1709719236 18<27Soliton18>	that is the input or output you want or what?
T 1709719255 18<28nphard18>	I was gonna use 'for in' but then realized is not that simple to change the values of '-fN' in the middle of the loop.
T 1709719279 18<28nphard18>	Soliton: 'cut -f1 file_with_cols'
T 1709719294 18<27Soliton18>	alright so there is no goal. nevermind.
T 1709719309 18<24xmb18>	awk ' { print $1 } '
T 1709719315 18<24xmb18>	this ur cut tries ?
T 1709719323 18<24xmb18>	print first col , then second
T 1709719325 18<28nphard18>	Soliton: separate the columns is the goal.
T 1709719330 18<24xmb18>	$1 only first
T 1709719345 18<28nphard18>	Soliton: in a loop
T 1709719345 18<27Soliton18>	and what does separate the columns mean?
T 1709719361 18<28nphard18>	filaA, fileB, fileC.
T 1709719367 18<27Soliton18>	!faq1
T 1709719367 18<29greybot18>	https://mywiki.wooledge.org/BashFAQ/001 -- How can I read a file (data stream, variable) line-by-line (and/or field-by-field)?
T 1709719432 18<28nphard18>	xmb: use it directly with the files? --> awk ' { print $1 } ' file_with_colums
T 1709719443 18<27Soliton18>	so far no idea how cut would do anything useful.
T 1709719463 18<28nphard18>	Soliton: that's why I am asking.
T 1709719479 18<27Soliton18>	but you're asking about cut and we have no idea what the actual goal is.
T 1709719481 18<28nphard18>	if I had the solution I would no be asking.
T 1709719494 18<24xmb18>	awk to print eleme
T 1709719502 18<28nphard18>	xmb: thanks, i'll try that
T 1709719508 18<24xmb18>	cut my tries failed , so awk
T 1709719517 18<24xmb18>	the point was , hold ..
T 1709719521 18<28nphard18>	xmb: can it be use in a loop?
T 1709719533 18<24geirha18>	while IFS=$'\t' read -r f1 f2 f3 ; do a+=( "$f1" ) b+=( "$f2" ) c+=( "$f3" ) ; done < file_with_cols
T 1709719539 18<24geirha18>	now you have three arrays
T 1709719554 18<28nphard18>	geirha: dope
T 1709719593 18<27Soliton18>	always amazes me a bit why people make it so hard to help them.
T 1709719594 18<28nphard18>	Soliton: why isn't 'cut' reccomended? Manually it was working quite well.
T 1709719595 18<24xmb18>	# dat=$'1 2 3\n1 2 3\n1 2 3' v1=( $( awk ' { print $2 } ' <<<"$dat" ) ) v2=( $( awk ' { print $2 } ' <<<"$dat" ) ) ; declare -p v2 v1
T 1709719597 18<25shbot18>	xmb: declare -a v2=([0]="2" [1]="2" [2]="2")
T 1709719597 18<25shbot18>	xmb: declare -a v1=([0]="2" [1]="2" [2]="2")
T 1709719603 18<24xmb18>	oo
T 1709719603 18<27Soliton18>	for what?
T 1709719614 18<24xmb18>	# dat=$'1 2 3\n1 2 3\n1 2 3' v1=( $( awk ' { print $1 } ' <<<"$dat" ) ) v2=( $( awk ' { print $2 } ' <<<"$dat" ) ) ; declare -p v2 v1
T 1709719615 18<25shbot18>	xmb: declare -a v2=([0]="2" [1]="2" [2]="2")
T 1709719615 18<25shbot18>	xmb: declare -a v1=([0]="1" [1]="1" [2]="1")
T 1709719622 18<27Soliton18>	if you want to do exactly what cut does then use it. you almost never do though.
T 1709719637 18<24geirha18>	don't do v1=( $(anything )   that's just broken
T 1709719640 18<24xmb18>	in this u make dat=.. away and both <<<"$dat" and replace em with ur file/s
T 1709719652 18<24xmb18>	awk ' code ' files
T 1709719713 18<27Soliton18>	i don't understand why you can't explain a goal. like "i have tab delimited input and i want to iterate it column by column" or whatever.
T 1709719730 18<24xmb18>	# printf $'1 2 3\n1 2 3\n1 2 3\n' >f1 ; v1=( $( awk ' { print $1 } ' f1 ) ) v2=( $( awk ' { print $2 } ' f1 ) ) ; declare -p v2 v1
T 1709719731 18<27Soliton18>	afaict it's just a big guessing game so far.
T 1709719733 18<25shbot18>	xmb: declare -a v2=([0]="2" [1]="2" [2]="2")
T 1709719733 18<25shbot18>	xmb: declare -a v1=([0]="1" [1]="1" [2]="1")
T 1709719742 18<29djph18>	Soliton: there's a bashphorism about that.
T 1709719839 18<27Soliton18>	(the only input shown so far wasn't tab delimited, btw.)
T 1709719875 18<24geirha18>	I'm just assuming the tabs got expanded into spaces either through copy/pasting or the pastebin itself
T 1709719903 18<24geirha18>	given that cut -f2 apparently works on the real data
T 1709719919 18<24xmb18>	the pastebin web looks like tabs
T 1709719954 18<27Soliton18>	i wonder how something not containing tabs looks like tabs.
T 1709719956 18<24xmb18>	# printf $'1\t2\t3\n1\t2\t3\n1\t2\t3\n' >f1 ; v1=( $( awk ' { print $1 } ' f1 ) ) v2=( $( awk ' { print $2 } ' f1 ) ) ; declare -p v2 v1
T 1709719958 18<25shbot18>	xmb: declare -a v2=([0]="2" [1]="2" [2]="2")
T 1709719958 18<25shbot18>	xmb: declare -a v1=([0]="1" [1]="1" [2]="1")
T 1709719986 18<24xmb18>	soli , there is much space between 1 and 2 and 3
T 1709719997 18<24xmb18>	im his web link , andro chrome client
T 1709720000 18<27Soliton18>	3 spaces in fact, yes. no tab in sight.
T 1709720005 18<24geirha18>	anyway, running cut or awk for each column is wasteful and you risk ending up with broken data. Especially bad when you use $() instead of reading it line by line
T 1709720006 18<24xmb18>	k
T 1709720043 18<24xmb18>	the $( is only format safe-format , he used 1 2 3 thats simple
T 1709720094 18<24geirha18>	That's obviously dummy data
T 1709720133 18<24xmb18>	ye well
T 1709720142 18<28emanuele618>	we yell
T 1709720149 18<24geirha18>	Consider what happens if you read column1 into array v1, then some process comes along and updates the tsv file, then you read column2 into array v2. Now v1 and v2 do not correspond to each other. Better to read the file once
T 1709720162 18<27Soliton18>	!using > nphard
T 1709720162 18<29greybot18>	nphard: "How can I do X using Y?" NEVER ask a question of that form. Y may not be the best way to do X. All you should ask is, "How do I do X?"
T 1709720209 18<24xmb18>	dude deliver code that uses [[ updated_file ]] then
T 1709720233 18<24geirha18>	wat?
T 1709720328 18<24xmb18>	erm i tried simple on topic
T 1709720362 18<24xmb18>	file read once , ye
T 1709720418 18<24xmb18>	# printf $'1\t2\t3\n1\t2\t3\n1\t2\t3\n' >f1 ; f=$( < f1 ) v1=( $( awk ' { print $1 } ' <<<"$f" ) ) v2=( $( awk ' { print $2 } ' <<<"$f" ) ) ; declare -p v2 v1
T 1709720420 18<25shbot18>	xmb: declare -a v2=([0]="2" [1]="2" [2]="2")
T 1709720420 18<25shbot18>	xmb: declare -a v1=([0]="1" [1]="1" [2]="1")
T 1709720479 18<27Soliton18>	!pf 50
T 1709720479 18<29greybot18>	https://mywiki.wooledge.org/BashPitfalls#pf50 -- Don't do this! -- hosts=( $(aws ‚Ä¶) )
T 1709720550 18<27Soliton18>	why do you write code like that? do you think you're actually helping anyone?
T 1709721173 18<29netmonk18>	is there a good ressource explaining bash name expension regular expression
T 1709721175 18<29netmonk18>	?
T 1709721207 18<28llua18>	eh
T 1709721230 18<28emanuele618>	bash is a regular expression
T 1709721258 18<29netmonk18>	for instance, i do ls *foobar* which expand to 12_foobar and 12_foobar_1 but i would like to exclude the second one
T 1709721268 18<27Soliton18>	!glob
T 1709721268 18<29greybot18>	Globs are shell patterns that can be used for matching strings or expanding pathnames: [[ $name = Bob* ]]; rm -- *.txt; see http://mywiki.wooledge.org/glob
T 1709721277 18<27Soliton18>	!extblog
T 1709721281 18<27Soliton18>	!extglob
T 1709721281 18<29greybot18>	"Extended globs" (shopt -s extglob) allow you to say things like "all files that do not end in .jpg". See http://mywiki.wooledge.org/glob#extglob
T 1709721300 18<27Soliton18>	those are not regular expressions.
T 1709721338 18<29netmonk18>	ok i understand, is it possible just using blob to exlude 12_foobar_1 ?
T 1709721365 18<28llua18>	see the second link
T 1709721366 18<27Soliton18>	if you want the file to end with foobar then just don't put a * at the end.
T 1709721409 18<27Soliton18>	# touch 12_foobar 12_foobar_1; printf %s\\n *foobar
T 1709721411 18<25shbot18>	Soliton: 12_foobar
T 1709721462 18<29nvz18>	if you just want to exclude one file in particular you prob need to read the results of expansion and test
T 1709721478 18<27Soliton18>	or use an extglob.
T 1709721497 18<29netmonk18>	ok in this case yes, but this is not my exact current case. ls *foobar* -> 12_foobar_009_1 and 12_foobar_009 and 11_foobar_010_1 and 11_foobar_010
T 1709721514 18<29netmonk18>	i just want to keep the one not ending with _1
T 1709721527 18<27Soliton18>	# touch 12_foobar 12_foobar_1; printf %s\\n *foobar!(_1)
T 1709721529 18<25shbot18>	Soliton: 12_foobar
T 1709721543 18<27Soliton18>	(shbot has extglob enabled by default.)
T 1709721676 18<29netmonk18>	ok
T 1709721719 18<27Soliton18>	ah, you actually have more stuff in between.
T 1709721728 18<27Soliton18>	# touch 12_foobar_009_1 12_foobar_009 11_foobar_010_1 11_foobar_010; printf %s\\n *foobar!(*_1)
T 1709721729 18<25shbot18>	Soliton: 11_foobar_010
T 1709721729 18<25shbot18>	Soliton: 12_foobar_009
T 1709721732 18<29netmonk18>	and next issue, this doesnt work when the blob is an argument of a bash function
T 1709721792 18<27Soliton18>	# touch 12_foobar_009_1 12_foobar_009 11_foobar_010_1 11_foobar_010; f() { printf %s\\n "$@"; }; f *foobar!(*_1)
T 1709721794 18<25shbot18>	Soliton: 11_foobar_010
T 1709721794 18<25shbot18>	Soliton: 12_foobar_009
T 1709721802 18<27Soliton18>	not sure what you mean.
T 1709721836 18<27Soliton18>	you need to enable extglob (shopt -s extglob) in your shell to use extended globs.
T 1709721872 18<29netmonk18>	got a syntax error near token (
T 1709721878 18<27Soliton18>	you need to enable extglob (shopt -s extglob) in your shell to use extended globs.
T 1709721932 18<29netmonk18>	ok, this was the issue sorry im slow reader :)
T 1709721935 18<29netmonk18>	thanks solitonm
T 1709721942 18<29netmonk18>	s/nm/n/
T 1709721943 18<27Soliton18>	you're welcome.
T 1709721959 18<29nvz18>	that is a regular expression
T 1709722000 18<27Soliton18>	# [[ foo =~ *foobar!(*_1) ]]; echo $?
T 1709722001 18<25shbot18>	Soliton: 2
T 1709722017 18<27Soliton18>	nope, not a valid regular expression.
T 1709722039 18<29nvz18>	no i mean the search and replace
T 1709722095 18<29nvz18>	where they mispelled your nick
T 1709722487 18<29netmonk18>	that's right
T 1709722507 18<29netmonk18>	an old habit from #unix@ircnet to correct mispell by regexo
T 1709722553 18<28emanuele618>	+# [[ foo =~ *foobar!(*_1) ]]
T 1709722555 18<25shbot18>	emanuele6: bash: [[: invalid regular expression `*foobar!(*_1)': Invalid preceding regular expression
T 1709722564 18<28emanuele618>	nope; not a valid regular expression. :D
T 1709722629 18<28emanuele618>	because invalid preceding regular expression before *foobar!(*_1)
T 1709722662 18<28emanuele618>	no, actually it just prints the entire pattern for every error
T 1709722683 18<28emanuele618>	anyway, it prints the regex error from lib c in bash devel
T 1709722689 18<19Artfaith18>	Is it possible to change type of variable from array to string without any intermediary variable?
T 1709722715 18<19Artfaith18>	# declare a=( 0 1 ); declare a="${a[0]}"; declare -p a;
T 1709722717 18<25shbot18>	Artfaith: declare -a a=([0]="0" [1]="1")
T 1709722722 18<19Artfaith18>	# declare a=( 0 1 ); declare a="${a[1]}"; declare -p a;
T 1709722724 18<25shbot18>	Artfaith: declare -a a=([0]="1" [1]="1")
T 1709722782 18<19Artfaith18>	# declare a=( 0 1 ); declare _a="${a[1]}"; unset a; declare a="$_a"; declare -p a;
T 1709722784 18<25shbot18>	Artfaith: declare -- a="1"
T 1709722829 18<28emanuele618>	# eval 'unset -v a; a='"${a[1]@Q}"
T 1709722831 18<25shbot18>	emanuele6: no output
T 1709722861 18<19Artfaith18>	emanuele6, thank you, but is there any normal way?
T 1709722926 18<28emanuele618>	using declare with an assignment is not going remove attributes. to remove attributes you use  declare +a  (where a is the attribute letter). it is only legal to use +a on unset variables.
T 1709722963 18<28nphard18>	geirha: while IFS=$'\t' read -r f1 f2 f3 ; do a+=( "$f1" ) b+=( "$f2" ) c+=( "$f3" ) ; done < file_with_cols <--- this command, when reading back the variable 'echo $a' it only prints one character, not the actual column.
T 1709723003 18<27Soliton18>	!faq 5
T 1709723003 18<29greybot18>	https://mywiki.wooledge.org/BashFAQ/005 -- How can I use array variables?
T 1709723007 18<28emanuele618>	nphard:   printf %s\\n "${a[@]}"    not   echo $a
T 1709723057 18<28emanuele618>	note that if there are empty fields  IFS=$'\t'   will not work as you expect; empty fields are skipped
T 1709723080 18<28emanuele618>	a\t\tb   is the same as  a\tb\t    and  \t\tx   is the same as  x\t\t
T 1709723262 18<28nphard18>	interesting, had to clear the variable first after typing so many randomn commands.
T 1709723327 18<25ormaaj18>	I skip empty fields. Go to strawberry fields
T 1709723354 18<28nphard18>	mm.. this is quite interesting. So the columns have been split without any loop or awk or 'cut'.
T 1709723377 18<28nphard18>	somewhat wild.
T 1709723442 18<25ormaaj18>	woh
T 1709723470 18*	28nphard staring into the distance in state of shock
T 1709723478 18<25imi18>	hi, is there a better (quicker) way to check if given variable is an integer number than grep?
T 1709723513 18<28emanuele618>	!faq number
T 1709723513 18<29greybot18>	https://mywiki.wooledge.org/BashFAQ/018 -- How can I use numbers with leading zeros in a loop, e.g. 01, 02?
T 1709723518 18<28emanuele618>	hmm, not that
T 1709723553 18<28emanuele618>	anyway, you can use    case $x in ''|*[!0123456789]*) echo no;; *) echo yes; esac
T 1709723573 18<28emanuele618>	if it is empty, or contains a character that is not 0123456789 you could say it is not a number
T 1709723578 18<25imi18>	when I have leading zeroes I prefix it with 1 and then subtract 100. now the leading zeroes are gone
T 1709723593 18<19Artfaith18>	emanuele6, to clarify, remove attributes from unset variable?
T 1709723596 18<25imi18>	ok thanks
T 1709723603 18<19Artfaith18>	What is the reason to remove an attribute from anything unset?
T 1709723620 18<19Artfaith18>	Like, in case of local variable?
T 1709723634 18<28emanuele618>	you can only remove +a and +A from unset variables; if they have a value you cannot remove those attributes
T 1709723665 18<28nphard18>	emanuele6: so... when to use these? --> a\t\tb , a\tb\t , \t\tx , x\t\t
T 1709723666 18<28emanuele618>	other attributes e.g. l, x, u, i, can be removed whenever.
T 1709723666 18<19Artfaith18>	Other attributes can be remove but these two?
T 1709723682 18<19Artfaith18>	I see...
T 1709723689 18<19Artfaith18>	Thank you, emanuele6!
T 1709723713 18<28emanuele618>	# printf 'a\t\tb\n\ta\tb\n'
T 1709723714 18<25shbot18>	emanuele6: a               b
T 1709723715 18<25shbot18>	emanuele6:         a       b
T 1709723756 18<28emanuele618>	# printf 'a\t\tb\n\ta\tb\n' | while IFS=$'\t' read -r f1 f2 f3; do printf 'f1=%q f2=%q f3=%q\n' "$f1" "$f2" "$f3"; done
T 1709723758 18<25shbot18>	emanuele6: f1=a f2=b f3=''
T 1709723758 18<25shbot18>	emanuele6: f1=a f2=b f3=''
T 1709723786 18<28emanuele618>	nphard: i was saying that for   IFS=$'\t' read -r f1 f2 f3    those sets of two lines are the same
T 1709723815 18<28emanuele618>	if you have an hole in one of the columns
T 1709723840 18<28nphard18>	ah, yes, sometimes there'll be holes.
T 1709723861 18<25imi18>	emanuele6: what about negative numbers?
T 1709723880 18<28emanuele618>	you can use   case ${x#-} in ...
T 1709723889 18<25imi18>	ok thanks
T 1709723897 18<28emanuele618>	that way if there is a - at the start, and it still matches, it is allowed
T 1709723924 18<28emanuele618>	#- removes a - from the start of $x; so it checks the patterns on the value of $x with - removed
T 1709723976 18<25ormaaj18>	x<<1,x>>1
T 1709723986 18<28emanuele618>	!faq valid
T 1709723986 18<29greybot18>	https://mywiki.wooledge.org/BashFAQ/054 -- How can I tell whether a variable contains a valid number?
T 1709723994 18<28emanuele618>	that was the faq i was looking for :D
T 1709724017 18<25ormaaj18>	><
T 1709724020 18<28emanuele618>	ormaaj: x<<=1,x>>=1 ?
T 1709724031 18<25ormaaj18>	ya!
T 1709724194 18<28emanuele618>	nphard: then you cannot use  IFS=$'\t' read -r f1 f2 f3    you could use   while read -r; do a+=( "${REPLY%%$'\t'*}" ) REPLY=${REPLY#*$'\t'} b+=( "${REPLY%%$'\t'*}" ) REPLY=${REPLY#*$'\t'} c+=( "$REPLY" ); done
T 1709724274 18<28emanuele618>	# printf 'a\t\tb\n\ta\tb\n' | while read -r; do f1=${REPLY%%$'\t'*} REPLY=${REPLY#*$'\t'} f2=${REPLY%%$'\t'*} REPLY=${REPLY#*$'\t'} f3=$REPLY; printf 'f1=%q f2=%q f3=%q\n' "$f1" "$f2" "$f3"; done
T 1709724276 18<25shbot18>	emanuele6: f1=a f2='' f3=b
T 1709724276 18<25shbot18>	emanuele6: f1='' f2=a f3=b
T 1709724778 18<25ormaaj18>	shifty eyes <<
T 1709724800 18<25ormaaj18>	shifty numbers
T 1709724849 18<25ormaaj18>	there should be rotate operators :(
T 1709725054 18<28emanuele618>	x<<=1,x&=!!(x^x>>1)
T 1709725084 18<28emanuele618>	err |=
T 1709725108 18<28emanuele618>	hmm, i am not sure
T 1709725142 18<28emanuele618>	is bash's >> signed? if it is signed, it does not work
T 1709725158 18<28emanuele618>	# echo "$(( -2 >> 1 ))"
T 1709725159 18<25shbot18>	emanuele6: -1
T 1709725162 18<28emanuele618>	:\
T 1709725316 18<28emanuele618>	need to assume 64bit and use  x&(1<<63)     x=x<<1|!!(x&1<<63)
T 1709725334 18<25OMGOMG18>	emanuele6: what was that supposed to demonstrate?
T 1709725352 18<28emanuele618>	that -2 >> 1  is signed?
T 1709725408 18<25OMGOMG18>	what would the unsigned equivalent look like
T 1709725412 18<28emanuele618>	-2 is    1111111111111111111111111111111111111111111111111111111111111110
T 1709725426 18<28emanuele618>	if it is signed >>1 results in   1111111111111111111111111111111111111111111111111111111111111111
T 1709725430 18<28emanuele618>	so -1
T 1709725443 18<28emanuele618>	if it is not signed, it results in   0111111111111111111111111111111111111111111111111111111111111111
T 1709725459 18<28emanuele618>	that is 9223372036854775807
T 1709725470 18<25OMGOMG18>	ok
T 1709725473 18<25OMGOMG18>	thanks
T 1709725509 18<28emanuele618>	signed >> duplicates the top bit, so it adds a 0 if the top bit is 0, otherwise it adds a 1 if the top bit is 1
T 1709725518 18<28emanuele618>	while unsigned >> always adds 0s
T 1709725612 18<28nphard18>	darn! bash makes you think harder every step :/
T 1709725645 18<25OMGOMG18>	do you often encounter unsigned >> ?
T 1709725799 18<28emanuele618>	?
T 1709726060 18<24ano18>	what's the best way to strip trailing char?
T 1709726096 18<28emanuele618>	%%+([chars])  ?
T 1709726211 18<24ano18>	what about portable way, ${#... ${...%%[chars] loop?
T 1709726515 18<24ano18>	# char=/; var=/path/to//////////////; until (( "${#var}" == "${var_len=0}" )); do var_len=${#var}; var=${var%%${char}}; done; echo $var
T 1709726517 18<25shbot18>	ano: /path/to
T 1709726574 18<28emanuele618>	so busybox has (( but not +()?
T 1709726593 18<28emanuele618>	"$char" not $char
T 1709726656 18<28emanuele618>	also   ""  in  (( or $((  is a big no no in most shells
T 1709726657 18<24ano18>	hmm no it doesn't
T 1709726675 18<28emanuele618>	d# echo "$(( "${#PWD}" * 2 ))"
T 1709726676 18<25shbot18>	emanuele6: dash: 1: arithmetic expression: expecting primary: " "5" * 2 "
T 1709726717 18<28emanuele618>	anyway, if you want to remove just one characters; easiest way is probably  var=${var%"${var##*[!/]}"
T 1709726728 18<28emanuele618>	missing a }
T 1709727278 18<28emanuele618>	it would actually even work if you have multiple characters you want to remove now that i think about it
T 1709728181 19*	Now talking on 22#bash
T 1709728181 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709728181 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709728196 18<27Soliton18>	you can make up whatever syntax you want with a magic alias.
T 1709728199 18<24geirha18>	magic alias should handle that particular case ,yes
T 1709728225 18<29oskie18>	nice!
T 1709728227 18<28emanuele618>	how?
T 1709728303 18<27Soliton18>	you put a # before the syntax, get it from history and do whatever you want.
T 1709728348 18<24geirha18>	see the echo-literally example at the end of that page
T 1709728364 18<28emanuele618>	i was thinking of something like that with BASH_COMMAND, but i was not sure that is what was meant
T 1709728381 18<28emanuele618>	that would only make it work if it is the only command you run on that line
T 1709728409 18<24geirha18>	yes
T 1709728482 18<28emanuele618>	err, not bash_command, the other one
T 1709728560 18<25kurahaupo18>	ormaaj: sudo generally unsets everything
T 1709728583 18<28emanuele618>	hmm, there is only BASH_EXECUTION_STRING for bash-c; so it would have to read history
T 1709728642 18<28emanuele618>	i thought there was a variable like BASH_COMMAND that included the entire line
T 1709728665 18<28emanuele618>	i remember using it for something, but i cannot find it
T 1709729052 18<25ormaaj18>	ksh -c 'integer x="1"; while sleep .1; do printf %0.64.2d\\r "$(( (x<<=1), (x^=(x==-0)) ))"; done'
T 1709729234 18<25ormaaj18>	i don't like that i used , D:
T 1709729478 18<28emanuele618>	that one goes  0100000000000000000000000000000000000000000000000000000000000000 => -1000000000000000000000000000000000000000000000000000000000000000 => 0000000000000000000000000000000000000000000000000000000000000001
T 1709729529 18<28emanuele618>	you need %u instead of %d
T 1709729564 18<28emanuele618>	x^xx==-0  can just be  x^=!!x
T 1709729582 18<28emanuele618>	that can be | instead of ^
T 1709729593 18<25ormaaj18>	oh!
T 1709729611 18<28emanuele618>	err, no
T 1709729638 18<28emanuele618>	x|=!x just one !
T 1709729651 18<25ormaaj18>	i think it's the wrong width. %0.-65.2 keeps it constant
T 1709729664 18<28emanuele618>	%0.64.2u
T 1709729682 18<28emanuele618>	d adds a - in front if the top bit is set, u does not
T 1709729684 18<25ormaaj18>	oh the unsigned one ah
T 1709729709 18<28emanuele618>	ksh -c 'integer x="1"; while sleep .1; do printf %0.64.2u\\r "$(( x<<=1, x^=!x ))"; done'
T 1709729740 18<28emanuele618>	or  x|=!x   instead of  x^=!x
T 1709729753 18<25ormaaj18>	:D!
T 1709729817 18<28emanuele618>	it looks nicer with x=0
T 1709729839 18<28emanuele618>	anyway this only works for the purpose of this animation; it does not actually rotate
T 1709729928 18<25ormaaj18>	and it's two steps
T 1709729946 18<28emanuele618>	x=x<<1|!!(x&1<<63)   is one step
T 1709729960 18<25ormaaj18>	:o
T 1709729995 18<28emanuele618>	ksh -c 'integer x=2#1011101; while sleep .1; do printf %0.64.2u\\r "$(( x=x<<1|!!(x&1<<63) ))"; done'
T 1709730062 18<28emanuele618>	oh, ksh has unsigned :D
T 1709730076 18<28emanuele618>	maybe you can use my other approach that does not hardcode 63
T 1709730146 18<28emanuele618>	em   ksh:  x<<=1,x|=!(x^x>>1) : invalid floating point operation
T 1709730211 18<25ormaaj18>	oh that's weird. When you pick a type for x it should just stay integer
T 1709730229 18<28emanuele618>	i used  integer -u
T 1709730256 18<28emanuele618>	it works until it has to wrap around; then it prints that warning
T 1709730289 18<25ormaaj18>	2>/dev/null >:(
T 1709730301 18<28emanuele618>	well, but it is fatal
T 1709730306 18<25ormaaj18>	D:
T 1709730317 18<28emanuele618>	with   typeset -iu x=2#1011101   it looks like it makes the number 32 bit
T 1709730339 18<25ormaaj18>	yeah it needs -l for long
T 1709730359 18<28emanuele618>	oh, hmm, 32bit convention
T 1709730389 18<25ormaaj18>	typeset is arch-dependent. integer always picks the largest type
T 1709730482 18<28emanuele618>	hmm
T 1709730507 18<28emanuele618>	-1<<1  turns the number negative
T 1709730515 18<28emanuele618>	it is not supposed to do that if it is unsigned
T 1709730541 18<25ormaaj18>	k is for krap
T 1709730582 18<28emanuele618>	not sure what -u is supposed to do if it does not change the behaviour of << and >>
T 1709730589 18<28emanuele618>	maybe it is just for print -v
T 1709730616 18<28emanuele618>	or to tell ksh how to convert the number to a string when you use $var
T 1709730636 18<28emanuele618>	it does not make operators unsigned
T 1709730638 18<25ormaaj18>	oh. yeah print -v could be buggy. print -C is sometimes better.
T 1709730660 18<25ormaaj18>	Also if you export to a command it does an implicit conversion to string first
T 1709730687 18<28emanuele618>	with -lu it works the same as integer;  with -ilu  it triggers the floating point warning similarly to  integer -u
T 1709730741 18<28emanuele618>	maybe -lu is interpreted as uppercase
T 1709730771 18<28emanuele618>	and -ilu / unsigned long is bugged
T 1709730879 18<25ormaaj18>	oh also it's `typeset -i[base]`. The thing after -i is the radix. `typeset -Z[width]` zero fills to constant width
T 1709730905 18<25ormaaj18>	so you can actually get rid of the printf format with the right type setting
T 1709730921 18<25ormaaj18>	or, should
T 1709730968 18<25ormaaj18>	typeset has optional option args D:
T 1709731095 18<25ormaaj18>	sheesh mcdutchie changed 1k+ lines every day this week
T 1709731100 18*	25ormaaj rebuilds
T 1709731129 18<25ormaaj18>	it's mostly the mamfiles
T 1709731565 18<28emanuele618>	the correct version of the formula i had in mind is   x=x<<1|!!(x<<1>>1^x)
T 1709731619 18<28emanuele618>	but it does not work there is now way to have unsigned >>1
T 1709731627 18<28emanuele618>	s/now/no/
T 1709731731 18*	25ormaaj c[_]
T 1709732244 18<28emanuele618>	creatememfd 3 x foreground ' '{gcc,-std=c2x,-includetime.h,-includestdio.h,-w,-xc,-,-o/dev/fd/3} <<<'main(){struct timespec t={0,1e8};unsigned long x=0b1011101;while(nanosleep(&t,0)!=-1){printf("%.64lb\r",(x=x<<1|!!(x<<1>>1^x)));fflush(stdout);}}' '' /dev/fd/3
T 1709732314 18<29oskie18>	I must say, that Magic Aliases trick was truly awesome. Thanks geirha.
T 1709732355 18<25ormaaj18>	groan magic alias
T 1709732396 18<25ormaaj18>	C is for cookie
T 1709732435 18<25ormaaj18>	works
T 1709732903 18<29oskie18>	when you run  bash -c "foo"  bash will not load .bash_profile/.bashrc etc. If you add -i it will do. But then it also expects to be run from a pty. Is there a way to have bash load all the usual init files but still not run in a terminal?
T 1709732962 18<20osse18>	perhaps bash -c "source ~/.bashrc; foo" ?
T 1709732996 18<29oskie18>	yeah, I will give it a try.
T 1709733099 18<29oskie18>	to run aliases, bash still wants -i
T 1709733123 18<29oskie18>	ooh. shopt -s expand_aliases
T 1709733186 18<24geirha18>	that will need to be on a line by itself due to weirdness in how bash parses aliases
T 1709733200 18<24geirha18>	but you can set it with -O   bash -O expand_aliases -c '...'
T 1709733272 18<29oskie18>	bash -O expand_aliases -c 'alias ll="ls -l"; ll'   <- I expected this to work, but it gave me "ll: command not found"
T 1709733308 18<25ormaaj18>	if you expected that then aliases probably aren't your thing.
T 1709733350 18<28emanuele618>	bash -O expand_aliases -c 'alias ll="ls -l"'$'\n''ll'    or   bash -O expand_aliases -c 'alias ll="ls -l"; eval ll'
T 1709733377 18<29oskie18>	ah. the newline! thanks
T 1709733396 18<25ormaaj18>	happy til the next unexpected thing
T 1709733403 18<28emanuele618>	ll needs to be read after the alias is already defined, if it is on the same line as the definition, it does not work because bash already read it and didn't expand it
T 1709733461 18<29oskie18>	ormaaj: can't disagree with you there :)
T 1709733498 18<25ormaaj18>	bash must have two different alias things to go along with its to source reading functions
T 1709733522 18<25ormaaj18>	because aliases appear to work the same in a sourced file
T 1709733543 18<20osse18>	bash 'll() { ls -l "$@"; }; ll'
T 1709733548 18<20osse18>	# bash -c 'll() { ls -l "$@"; }; ll'
T 1709733550 18<25shbot18>	osse: total 0
T 1709734682 18<24ano18>	# printf %s\\n all files contained main\(\) {} are c files > f.txt; file -i f.txt
T 1709734684 18<25shbot18>	ano: f.txt: text/x-c; charset=us-ascii
T 1709734724 18<24ano18>	just me or file utility kinda unusable?
T 1709734926 18<25Soni18>	selckin: in the name
T 1709734957 18<20osse18>	ano: if you adhere to the GNU coding standard it works
T 1709734972 18<20osse18>	# printf %s\\n all files contained 'main ()' {} are c files > f.txt; file -i f.txt
T 1709734974 18<25shbot18>	osse: f.txt: text/plain; charset=us-ascii
T 1709735026 18<27Guest1118>	Hola
T 1709735052 18<25ormaaj18>	why do I get unexpected end of file AFTER calling this function. That like never happens. https://bpa.st/raw/VZXQ
T 1709735062 18<25ormaaj18>	unmagical
T 1709735128 18<25ormaaj18>	like bash parsed the function wrong and tries to run the mis-parsed code
T 1709735241 18<25ormaaj18>	also wtf it's running the expanded code twice!
T 1709735258 18<25ormaaj18>	that also never happens
T 1709736264 18<25ormaaj18>	I think it wants a semicolon at the end of every line
T 1709736272 18<25ormaaj18>	I have never seen "unexpected token newline"
T 1709736290 18<25ormaaj18>	https://bpa.st/raw/ZJWA
T 1709736343 18<25ormaaj18>	but there's no way to inject one there
T 1709737082 18<28emanuele618>	i remember seeing unexpected token newline
T 1709737085 18<28emanuele618>	# eval for
T 1709737087 18<25shbot18>	emanuele6: bash: syntax error near unexpected token `newline'
T 1709737126 18<28emanuele618>	for, select and case if there is a newline before the variable
T 1709737506 18<28emanuele618>	also a newline after <, <<, >, >>, <<<, etc
T 1709737513 18<28emanuele618>	# eval \<\<
T 1709737515 18<25shbot18>	emanuele6: bash: syntax error near unexpected token `newline'
T 1709741069 18<25kurahaupo18>	ormaaj: why does your alias 'f' end with '<'
T 1709742099 18<25ormaaj18>	kurahaupo: turns `name()` into `function thing { return <()`. It kills the ()
T 1709742256 18<25ormaaj18>	i'm trying to write an alias the turns a function into a noop, and only function definitions in the global scope of a file.
T 1709742291 18<25ormaaj18>	while skipping the corresponding function calls
T 1709742297 18<28emanuele618>	that is not possible; < at the end of the alias and ( would be separate tokens; it cannot be equivalent to <(
T 1709742316 18<25ormaaj18>	it is possible, because it works. :)
T 1709742341 18<25ormaaj18>	bash seems to merge them
T 1709742497 18<25ormaaj18>	the code doesn't even really have to evaluate properly because a return is being injected first, so as long as it parses it should work.
T 1709742589 18<28emanuele618>	it works?
T 1709742603 18<28emanuele618>	# alias f='echo <'; f (:)
T 1709742605 18<25shbot18>	emanuele6: bash: syntax error near unexpected token `:'
T 1709742608 18<28emanuele618>	# alias f='echo <'; f(:)
T 1709742610 18<25ormaaj18>	`function name` is a lot better for hacking with than `name()`... that () is a pain in the arse.
T 1709742611 18<25shbot18>	emanuele6: bash: syntax error near unexpected token `:'
T 1709742619 18<28emanuele618>	right eval
T 1709742622 18<28emanuele618>	# alias f='echo <'; eval 'f (:)'
T 1709742623 18<25shbot18>	emanuele6: bash: syntax error near unexpected token `('
T 1709742624 18<28emanuele618>	# alias f='echo <'; eval 'f(:)'
T 1709742625 18<25shbot18>	emanuele6: /dev/fd/63
T 1709742627 18<28emanuele618>	wow
T 1709742636 18<28emanuele618>	oh, because ( is a meta character :o
T 1709742649 18<25ormaaj18>	yes :)
T 1709742654 18<28emanuele618>	# alias f='echo <'; eval 'f<< lol cat'
T 1709742656 18<25shbot18>	emanuele6: cat
T 1709742672 18<28emanuele618>	# alias f='<'; eval 'f<< lol cat'
T 1709742673 18<25shbot18>	emanuele6: lol
T 1709742694 18<28emanuele618>	wow
T 1709742699 18<28emanuele618>	does posix require that?
T 1709742713 18*	25ormaaj tames cthulhu ~~(~.~)~~
T 1709742723 18<28emanuele618>	# alias f='echo $'; eval 'f(ls)'
T 1709742724 18<25shbot18>	emanuele6: bash: syntax error near unexpected token `('
T 1709742727 18<25ormaaj18>	it likes me because I clean its box.
T 1709742733 18<28emanuele618>	hmm, it only works for <
T 1709742751 18<25ormaaj18>	yeah no clue about posix. Posix doesn't require much when it comes to aliases
T 1709742778 18<28emanuele618>	# alias f='echo $('; eval 'f(1+2))'
T 1709742779 18<25shbot18>	emanuele6: 3
T 1709742783 18<28emanuele618>	d# alias f='echo $('; eval 'f(1+2))'
T 1709742785 18<25shbot18>	emanuele6: dash: 1: eval: 1+2: not found
T 1709742856 18<28emanuele618>	bash is probably doing some parser hack to support <( and $(( that unintentionally make alias x='... meta'; xmeta  work
T 1709742947 18<25ormaaj18>	bash does intentionally do some extra effort to make aliases work where they wouldn't normally by allowing it to re-parse an overall command including words that have already been substituted.
T 1709743033 18<25ormaaj18>	so a word that was categorized by the lexer one way can change
T 1709743325 18<28emanuele618>	you mean that $(ALIAS) gets expanded twice? well, that is probably never helpful
T 1709743349 18<28emanuele618>	# alias echo='echo hi'; printf %s\\n "$(echo hello)"
T 1709743356 18<25shbot18>	emanuele6: hi hello
T 1709743357 18<28emanuele618>	# alias echo='echo hi'; eval 'printf %s\\n "$(echo hello)"'
T 1709743364 18<25shbot18>	emanuele6: hi hello
T 1709743366 18<25ormaaj18>	There is some kind of double-expansion  going on in my code. I haven't figured out why.
T 1709743368 18<28emanuele618>	wot
T 1709743382 18<28emanuele618>	why does that not print hi hi hello?
T 1709743394 18<28emanuele618>	# alias echo='echo hi'; eval 'a(){ printf %s\\n "$(echo hello)";};a'
T 1709743400 18<25shbot18>	emanuele6: hi hello
T 1709743417 18<25ormaaj18>	no $() doesn't because that should only be parsed once
T 1709743429 18<28emanuele618>	no, it is parsed every time
T 1709743456 18<25ormaaj18>	I don't think  so
T 1709743457 18<28emanuele618>	it just needs to be valid when the command is read; but the expansion code reparses everything in words every time
T 1709743489 18<28emanuele618>	# alias echo='echo hi'; eval 'a(){ printf %s\\n "$(echo hello)";};alias echo=echo\ boo; a'
T 1709743497 18<25shbot18>	emanuele6: boo hello
T 1709743497 18<25shbot18>	emanuele6: c[?7l[2J[0mSeaBIOS (version 1.15.0-1)
T 1709743497 18<25shbot18>	emanuele6: etc... ( http://paste.wooledge.org/29311 )
T 1709743502 18<28emanuele618>	wtf
T 1709743532 18<28emanuele618>	anyway, you can see it prints   boo hello   instead of  hi hello  there because the alias is reparsed
T 1709743547 18<28emanuele618>	err, i mean the word is reparsed
T 1709743555 18<24ano18>	looks like a qemu boot.log
T 1709743573 18<28emanuele618>	ah, i think i remember now; i posted how it works in #shell-lang some months ago
T 1709743614 18<28emanuele618>	   "$(ALIAS)"   has to be valid with ALIAS expanded when the command is read, but bash saves the word in the simple command with the alias unexpanded iirc
T 1709743624 18<28emanuele618>	and then the expansion code re-expands it every time
T 1709743645 18<28emanuele618>	# alias echo='echo hi'; eval 'a () { x=$(echo) ;}'; typeset -pf a
T 1709743652 18<25shbot18>	emanuele6: a ()
T 1709743652 18<25shbot18>	emanuele6: {
T 1709743652 18<25shbot18>	emanuele6: etc... ( http://paste.wooledge.org/29312 )
T 1709743656 18<28emanuele618>	# alias echo='echo hi'; eval 'a () { x=$(echo) ;}'; typeset -pf a | paste -s -
T 1709743663 18<25shbot18>	emanuele6: a ()    {           x=$(echo)   }
T 1709743671 18<28emanuele618>	see, it is not expanded
T 1709743679 18<28emanuele618>	# alias echo='echo ('; eval 'a () { x=$(echo) ;}'; typeset -pf a
T 1709743686 18<25shbot18>	emanuele6: a ()
T 1709743686 18<25shbot18>	emanuele6: {
T 1709743686 18<25shbot18>	emanuele6: etc... ( http://paste.wooledge.org/29313 )
T 1709743701 18<28emanuele618>	it is actually never expanded
T 1709743718 18<28emanuele618>	only at runtime, so you cannot use a magic alias in a $()
T 1709743776 18<28dumbledoor18>	When my cursor is at a space character just after a word, C-w does not work in vi mode. Is this normal? If not, how can I fix this?
T 1709743938 18<25ormaaj18>	heh did you win pony?
T 1709743968 18*	25ormaaj kicks qemu
T 1709744025 18<28emanuele618>	shbot does not have a floppy
T 1709744057 18<28emanuele618>	hmm. not actually it does, but it is not bootable :o
T 1709744064 18<25ormaaj18>	don't copy that floppy
T 1709744112 18<28emanuele618>	# ls /dev
T 1709744113 18<25shbot18>	emanuele6: console  full  random  stdin   tty    urandom
T 1709744113 18<25shbot18>	emanuele6: fd       null  stderr  stdout  ttyS0  zero
T 1709744121 18<28emanuele618>	hmm
T 1709744221 18<28emanuele618>	hmm, is that ^W thing a bug?
T 1709744307 18<28dumbledoor18>	does it happen on your end too emanuele?
T 1709744323 18<28emanuele618>	well, it is bound to vi-unix-word-rubout instead of unix-word-rubout so that is one difference
T 1709744337 18<28emanuele618>	i just tried it, and yes
T 1709744353 18<28emanuele618>	i don't use vi mode; i don't like it, and every time i use it i find a bug
T 1709744377 18<28emanuele618>	https://lists.gnu.org/archive/html/bug-bash/2023-04/msg00023.html
T 1709744477 18<28emanuele618>	it may be a posix mandated thing
T 1709744495 18<28dumbledoor18>	i see. thanks.
T 1709744534 18<24ano18>	# set -o posix; alias echo='echo hi'; eval 'a () { x=$(echo) ;}'; typeset -pf a | paste -s -
T 1709744536 18<25shbot18>	ano: a ()    {           x=$(echo hi)        }
T 1709744587 18<28emanuele618>	if i have     a hi bzz    and i move my cursor before hi; ^W does nothing, but if i put it after the space it deletes the space, and then if i press it again, it deletes hi
T 1709744592 18<28emanuele618>	so probably it is a bug
T 1709744618 18<28emanuele618>	anyway, that is different from standard emacs mode ^W that would delete both space and hi in one go
T 1709744657 18<28emanuele618>	well, if you want to make ^W work like in emacs mode, you can just rebind ^W to  unix-word-rubout  instead of  vi-unix-word-rubout  probably
T 1709744679 18<28emanuele618>	# set -o posix; alias echo='echo hi'; eval 'a () { x=$(echo hello) ;}'; a
T 1709744681 18<25shbot18>	emanuele6: no output
T 1709744689 18<28emanuele618>	# set -o posix; alias echo='echo hi'; eval 'a () { printf %s\\n "$(echo hello)" ;}'; a
T 1709744691 18<25shbot18>	emanuele6: hi hello
T 1709744703 18<28emanuele618>	hmm, but still, it does not double expand
T 1709744713 18<28emanuele618>	# set -o posix; alias echo='echo hi'; eval 'a () { printf %s\\n "$(echo hello)" ;}'; set +o posix; a
T 1709744719 18<25shbot18>	emanuele6: hi hi hello
T 1709744721 18<28emanuele618>	now it does :D
T 1709744800 18<28emanuele618>	so in POSIX mode, aliases in words expand when the word is read, and not when the expansion code re-parses the code; and, in standard mode, aliases in words are only expanded at runtime when the expansion code re-parses the code
T 1709744847 18<28emanuele618>	so if you want to use a magic alias in $() you can enable POSIX mode to declare the function and then turn off POSIX mode, and change the alias :D
T 1709744917 18<28emanuele618>	# set -o posix; alias A='if [[ $a = b ]]; then echo hi'; eval 'a () { printf %s\\n "$(A; fi)" ;}'; set +o posix; unalias A; A () { :;}; a
T 1709744918 18<25shbot18>	emanuele6: no output
T 1709744932 18<28emanuele618>	hmm
T 1709744934 18<28emanuele618>	oh, right
T 1709744944 18<28emanuele618>	hmm
T 1709745097 18<28emanuele618>	ah, what i was trying to do is
T 1709745137 18<28emanuele618>	# alias A=; eval 'a () { printf %s\\n "$(A fi)" ;}'; a; alias A=echo; a
T 1709745140 18<25shbot18>	emanuele6: bash: command substitution: line 1: syntax error near unexpected token `fi'
T 1709745140 18<25shbot18>	emanuele6: bash: command substitution: line 1: `A fi'
T 1709745140 18<25shbot18>	emanuele6: etc... ( http://paste.wooledge.org/29315 )
T 1709745146 18<28emanuele618>	which you can do in standard mode
T 1709745170 18<28emanuele618>	anyway, if that is the interaction between aliases in words and POSIX mode, you can probably do something interesting with it
T 1709745248 18<24cheater18>	hi all
T 1709745254 18<24cheater18>	any clue how to get this to split on tabs? while IFS=$'\t' read a; do echo "$a"; done < <(echo $'aaa\tbbb\tc\tddd')
T 1709745283 18<28emanuele618>	sounds like you want -d $'\t' not IFS=$'\t'
T 1709745299 18<24cheater18>	hmm what does IFS do? i thought it meant input field separator
T 1709745311 18<28emanuele618>	yes, the input field separator
T 1709745332 18<24cheater18>	so aren't those input fields
T 1709745333 18<28emanuele618>	you want to delimit records with tab there, not fields
T 1709745340 18<24cheater18>	what are fields then?
T 1709745357 18<28emanuele618>	fields are what are in records (a.k.a. rows)
T 1709745408 18<28emanuele618>	# printf '%sX%sY' HELLO HI BEE BZZ
T 1709745410 18<25shbot18>	emanuele6: HELLOXHIYBEEXBZZY
T 1709745470 18<28emanuele618>	# printf '%sX%sY' HELLO HI BEE BZZ | { i=1; while IFS=X read -rdY f1 f2; do printf 'record 1:\tfield1=%q\tfield2=%q' "$f1" "$f2"; done
T 1709745476 18<25shbot18>	emanuele6: Missing terminating quote, bracket or keyword
T 1709745477 18<28emanuele618>	oops
T 1709745490 18<28emanuele618>	# printf '%sX%sY' HELLO HI BEE BZZ | { i=1; while IFS=X read -rdY f1 f2; do printf 'record 1:\tfield1=%q\tfield2=%q\n' "$f1" "$f2"; done }
T 1709745492 18<25shbot18>	emanuele6: record 1:       field1=HELLO    field2=HI
T 1709745492 18<25shbot18>	emanuele6: record 1:       field1=BEE      field2=BZZ
T 1709745519 18<24cheater18>	# printf '%sX%sY' HELLO HI BEE BZZ
T 1709745520 18<25shbot18>	cheater: HELLOXHIYBEEXBZZY
T 1709745571 18<28emanuele618>	# printf '%sX%sY' HELLO HI BEE BZZ | awk -vOFS=\\t -FX -vRS=Y '{ print "record " NR, "field1=" $1, "field2=" $2 }'
T 1709745573 18<25shbot18>	emanuele6: record 1        field1=HELLO    field2=HI
T 1709745573 18<25shbot18>	emanuele6: record 2        field1=BEE      field2=BZZ
T 1709745595 18<28emanuele618>	i forgot to add i++ in the bash version, whoops
T 1709745615 18<28emanuele618>	# printf '%sX%sY' HELLO HI BEE BZZ | { i=0; while IFS=X read -rdY f1 f2; do printf 'record %s:\tfield1=%q\tfield2=%q\n' "$(( ++i ))" "$f1" "$f2"; done }
T 1709745617 18<25shbot18>	emanuele6: record 1:       field1=HELLO    field2=HI
T 1709745617 18<25shbot18>	emanuele6: record 2:       field1=BEE      field2=BZZ
T 1709745668 18<28emanuele618>	HELLOXHIYBEEXBZZY  is separated into two records by Y:   HELLOXHI BEEXBZZ
T 1709745703 18<28emanuele618>	and then echo record is separated into fields by X; "HELLO" "HI" for HELLOXHI  and  "BEE" "BZZ" for BEEXBZZ
T 1709745816 18<24ano18>	# IFS=$'\t' read -rd '' -a array < <(printf 'foo\tbar\tbaz'); printf {%s} "${array[@]}"
T 1709745817 18<25shbot18>	ano: {foo}{bar}{baz}
T 1709745891 18<28emanuele618>	s/echo/each/
T 1709745970 18<28emanuele618>	# IFS=$'\t' read -rd '' -a array < <(printf 'fo\tbar\tbaz'); printf {%s} "${array[@]}"
T 1709745971 18<25shbot18>	emanuele6: {fo}{bar}{baz}
T 1709745981 18<28emanuele618>	now that command has only ano
T 1709745985 18<25ormaaj18>	k works
T 1709745986 18<25ormaaj18>	https://bpa.st/raw/3VVQ
T 1709746123 18<24ano18>	# IFS= readarray -td $'\t' array < <(printf 'foo\tbar\tbaz'); printf {%s} "${array[@]}"
T 1709746124 18<25shbot18>	ano: {foo}{bar}{baz}
T 1709746133 18<28emanuele618>	twoo
T 1709746146 18<28emanuele618>	someo
T 1709746272 18<24cheater18>	emanuele6: ahhhhhhhhh
T 1709746273 18<24cheater18>	i se
T 1709746275 18<24cheater18>	e
T 1709746278 18<24cheater18>	thank you very much
T 1709746327 18<24cheater18>	that makes a lot more sense
T 1709746330 18<24cheater18>	hey, what's the absolute smallest way of saying, when you're in a loop, "don't run this line the first time around, but run it any other time"?
T 1709746402 18<24ano18>	what kind of loop?
T 1709746582 18<24cheater18>	any
T 1709746607 18<24cheater18>	the idea is to have something that's going to be useful anywhere
T 1709746705 18<24cheater18>	the idea i had was i=0; ... loop ... (( $i++ > 0)) && do_something; ...
T 1709746717 18<24cheater18>	but maybe there's some tricky syntax that's even tinier
T 1709746783 18<24kishar18>	The c-style loop syntax is more commonly written as  for ((i = 0; i > 10; i++)); do something; done
T 1709746839 18<24ano18>	cheater: (( i++ )) && do_something
T 1709746840 18<28emanuele618>	i don't think it is ever written like that
T 1709746899 18<24cheater18>	ano: thanks. that's a little smaller
T 1709746908 18<24cheater18>	kishar: i'm not asking about c-style loop syntax.
T 1709746912 18<28emanuele618>	&& does not make any sense
T 1709746928 18<24cheater18>	of course it does
T 1709746929 18<28emanuele618>	that never runs anything if i starts at 0
T 1709746937 18<24cheater18>	oh really?
T 1709746943 18<24cheater18>	why would it start at 0?
T 1709746944 18<28emanuele618>	oh, i misread the qeustion
T 1709746949 18<24cheater18>	right
T 1709746964 18<28emanuele618>	i guess i++ works
T 1709746973 18<24cheater18>	kishar: i'm asking, if you have a larger loop that does a bunch of stuff, then if you have one command that you only want to start running on the 2nd iteration and after, what do you do
T 1709746992 18<24cheater18>	kishar: i don't want *the whole body of the loop* to start running on the 2nd iteration. that would be stupid.
T 1709746996 18<28emanuele618>	if (( i )); then do_something; else i=1; fi  would be better
T 1709747003 18<24kishar18>	couldn't you put an if [[ i=0 ]]; then do_nothing; else ...
T 1709747005 18<28emanuele618>	kishar: i<10
T 1709747017 18<24kishar18>	emanuele6: you're right, typo.
T 1709747018 18<28emanuele618>	and now [[ i=0 ]] is always true
T 1709747032 18<28emanuele618>	same for [[ $i=0 ]]
T 1709747052 18<28emanuele618>	[[ $i = 0 ]] is how to do do it
T 1709747056 18<24kishar18>	well, I meant putting that conditional nested inside your "do something" meat of it
T 1709747057 18<28emanuele618>	do do
T 1709747068 18<24Guest123518>	For reasons I cannot fathom, this bash function which helps me manage my iptables rule set is taking forever to run.  Can anyone here please suggest ways I might optimize its performance?  https://gist.github.com/hesco/524cfb563ad69e76a6118c962fbd169d#file-00100-iptables_start-sh
T 1709747081 18<24cheater18>	emanuele6: i'm asking about the absolutely smallest way of doing this.
T 1709747085 18<24cheater18>	not the most readable one.
T 1709747109 18<24ano18>	!check https://gist.github.com/hesco/524cfb563ad69e76a6118c962fbd169d/raw/a5ffd8206ed107b9ab1d47d377bf2b6215edc049/00100--iptables_start.sh
T 1709747111 18<28checkbot18>	ano: Line 13: Double quote to prevent globbing and word splitting. Line 15: Double quote to prevent globbing and word splitting. Line 20: Double quote to prevent globbing and word splitting. See https://shellcheck.net/?id=cb47111 for all 6 issues.
T 1709747158 18<28emanuele618>	cheater: and ((i++)) only works  18446744073709551616  times.
T 1709747158 18<24kishar18>	cheater: Personally, I abhor obfuscated code, to the point of using --long-options to help self-document.
T 1709747168 18<24cheater18>	emanuele6: holy fuck wow
T 1709747190 18<28emanuele618>	if (( i )); then do_something; else i=1; fi  works forever
T 1709747194 18<24cheater18>	kishar: i'm trying to figure out an idiom.
T 1709747196 18<28emanuele618>	that is how cool it is
T 1709747201 18<24cheater18>	emanuele6: that's stupid lmao
T 1709747216 18<28emanuele618>	what is stupid?
T 1709747264 18<24ano18>	hmm what happens with (( i++ )) || continue after 18446744073709551616 times?
T 1709747281 18<28emanuele618>	ano: it is 0 that time
T 1709747283 18<28emanuele618>	then 1 again
T 1709747289 18<24ano18>	declare -i i=18446744073709551616; (( i++ )); echo $? $i
T 1709747295 18<24ano18>	# declare -i i=18446744073709551616; (( i++ )); echo $? $i
T 1709747296 18<25shbot18>	ano: 1 1
T 1709747302 18<24ano18>	# declare -i i=18446744073709551615; (( i++ )); echo $? $i
T 1709747303 18<25shbot18>	ano: 0 0
T 1709747315 18<28emanuele618>	if you want obfuscated, even  ((i=1,$i)) &&   is better than ((i++)) &&
T 1709747348 18<28emanuele618>	# declare -i i=18446744073709551615; (( i++ )); echo $? $i; (( i++ )); echo $? $i; (( i++ )); echo $? $i;
T 1709747350 18<25shbot18>	emanuele6: 0 0
T 1709747350 18<25shbot18>	emanuele6: 1 1
T 1709747350 18<25shbot18>	emanuele6: 0 2
T 1709747357 18<28emanuele618>	# declare -i i=18446744073709551614; (( i++ )); echo $? $i; (( i++ )); echo $? $i; (( i++ )); echo $? $i;
T 1709747359 18<25shbot18>	emanuele6: 0 -1
T 1709747359 18<25shbot18>	emanuele6: 0 0
T 1709747359 18<25shbot18>	emanuele6: 1 1
T 1709747426 18<28emanuele618>	it is false for the 1st line, for the 18446744073709551616th line; for the 36893488147419103232nd time, for the 55340232221128654848th time, for the 73786976294838206464th time, and so on
T 1709747458 18<28emanuele618>	hmm, actually
T 1709747473 18<28emanuele618>	it is false for the 1st line, for the 18446744073709551617th line; for the 36893488147419103233rd time, for the 55340232221128654849th time, for the 73786976294838206465th time, and so on
T 1709747498 18<28emanuele618>	1+2**(64*k)   from k=0 to inf
T 1709747516 18<28emanuele618>	hmm
T 1709747518 18<28emanuele618>	wrong
T 1709747529 18<24Guest123518>	thanks ano, will take a closer look at that.
T 1709747538 18<24Guest123518>	!check https://gist.github.com/hesco/524cfb563ad69e76a6118c962fbd169d#file-00100-iptables_start-sh
T 1709747539 18<28checkbot18>	Guest1235: Line 13: read without -r will mangle backslashes. Line 18: Instead of 'let expr', prefer (( expr )). Line 50: Double quote to prevent globbing and word splitting. See https://shellcheck.net/?id=cb47539 for all 12 issues.
T 1709747554 18<28emanuele618>	checkbot: also thank you
T 1709747554 18<28checkbot18>	emanuele6: You're welcome! \(=^.^= )/
T 1709747761 18<24Guest123518>	I'm making extensive use of the $() subshell construct, but shellcheck.net keeps advising me: "Double quote to prevent globbing and word splitting".  Is that really relevant here?  And does that mean: ??? foo-$("some_command $arg1 $arg2") ???
T 1709747799 18<24Guest123518>	rather: foo=$("some_command $arg1 $arg2")
T 1709747895 18<19Artfaith18>	Guest1235, I believe it tells it for the command inside.
T 1709747998 18<19Artfaith18>	# a() { printf "'%s'," "$@"; }; arg1='1 2'; arg2='3 4'; b=$( a $arg1 $arg2; ); declare -p b;
T 1709747999 18<25shbot18>	Artfaith: declare -- b="'1','2','3','4',"
T 1709748018 18<19Artfaith18>	# a() { printf "'%s'," "$@"; }; arg1='1 2'; arg2='3 4'; b=$( a "$arg1" "$arg2"; ); declare -p b;
T 1709748020 18<25shbot18>	Artfaith: declare -- b="'1 2','3 4',"
T 1709748070 18<24ano18>	Guest1235: https://www.shellcheck.net/wiki/SC2086 also u can get more info about errs via SCNNNN links, it has has some $() quoting examples
T 1709748112 18<24ano18>	emanuele6: (( i ? i : i++ )) will be ok too, right?
T 1709748168 18<28emanuele618>	but ((i=1,$i)) is shorter
T 1709748216 18<24ano18>	curious which one will be more resource expensive
T 1709748261 18<28emanuele618>	:'s cost money
T 1709748408 18<19Artfaith18>	ano, I would suggest BPF programs in such case then.
T 1709748411 18<28emanuele618>	((x?x:x++)) is way faster
T 1709748414 18<19Artfaith18>	1. https://ebpf.io/
T 1709748420 18<28emanuele618>	$x in bash is slow af
T 1709748424 18<19Artfaith18>	Related: https://github.com/bpftrace/bpftrace/blob/master/man/adoc/bpftrace.adoc#examples
T 1709748440 18<28emanuele618>	:\
T 1709748665 18<28emanuele618>	i tried  ((x&=1,x++)) but that is also slower
T 1709748706 18<28emanuele618>	i think part of the reason why x?x:x++  is faster other than not using $x is that it avoids assignments
T 1709748735 18<19Artfaith18>	emanuele6, how do you check? `time`? BPFs? What is it?
T 1709748741 18<28emanuele618>	then with that logic, you can use  x||x=1   which can be even faster
T 1709748766 18<28emanuele618>	Artfaith: before i tell you, i want you to tell me how to check with that link you just posted
T 1709748809 18<19Artfaith18>	A few moments then. I am in train.
T 1709748879 18<24ano18>	emanuele6: (( i || (i=1) )) ? it's always true
T 1709748934 18<28emanuele618>	err, sorry, i meant  i&&i=1
T 1709748941 18<28emanuele618>	err
T 1709748951 18<28emanuele618>	i meant   x||x++
T 1709748958 18<28emanuele618>	that is what i had in my test
T 1709749083 18<28emanuele618>	that is ~5% faster
T 1709749091 18<28emanuele618>	than x?x:x++
T 1709749910 18<28emanuele618>	and ((x?x:x++)) is ~20-25% faster than ((x=1,$x))   ((i||i++)) on average is a little under 30% faster
T 1709750327 18<28emanuele618>	those percentages are not very accurate; i am just timing  ((x?x:x++))  vs  ((x=1,$x))  in my test loop and computing a percentage
T 1709750383 18<28emanuele618>	really, we should expect that  ((x||x++))  is ~200% faster than  ((x?x:x++))  since it recalls x only once instead of two times
T 1709750400 18<24ano18>	did some tests too, ((i||i++)) looks like a best way to go
T 1709750535 18<28emanuele618>	you could also just   (( i )) || { i=1; continue;}
T 1709750737 18<24ano18>	looks the same as ((i||i++)) || continue
T 1709750758 18<28emanuele618>	i yes, because it recalls i only once
T 1709750775 18<28emanuele618>	if the first i is non-zero, it does not have to run anything else
T 1709750896 18<28emanuele618>	i?i:i++   is slower, because if the first i is non-zero, it has to recall i again to return it
T 1709750921 18<28emanuele618>	if you use   i?1:i++   it is probably going to be faster
T 1709751006 18<24ano18>	what do u mean? it's slower
T 1709751016 18<28emanuele618>	no, it takes pretty much the same time
T 1709751043 18<28emanuele618>	so it is ?: that is causing it to be slower; not the fact that x is being recalled two times
T 1709751073 18<24ano18>	still slower + ~40ms on 100500 iterations
T 1709751078 18<24ano18>	*for
T 1709751105 18<28emanuele618>	that is nothing...
T 1709751245 18<24ano18>	nothing here, nothing here, and now there's something
T 1709751281 18<24ano18>	s/something/bloathing/
T 1709751598 18<28emanuele618>	40ms is an unsignificant amount,  you cannot possibly measure a difference that small
T 1709751694 18<28emanuele618>	if you run the commands other times, the result will change
T 1709751713 18<24ano18>	curious if elektron etc full of "insignificant" amounts
T 1709751741 18<28emanuele618>	that does not make any sense
T 1709751746 18<25kurahaupo18>	emanuele6: ano just did measure it
T 1709751770 18<28emanuele618>	wow,
T 1709751820 18<25kurahaupo18>	40ms is slow enough that (if repeated) a human will hear distinct clicks rather than a continuous hum
T 1709751869 18<27JAA18>	That's a massive difference when it comes to benchmarking. Once you get into the microseconds, it gets trickier. But statistics say you just need more samples then.
T 1709751886 18<28emanuele618>	kurahaupo: did you measute it repeatedly? i was not able to
T 1709751905 18<28emanuele618>	you said that ano did measure it
T 1709751911 18<25kurahaupo18>	Why so me?
T 1709751927 18<28emanuele618>	because you said it was done
T 1709751969 18<25kurahaupo18>	Because ano said it was done. It's certainly not impossible to measure, I've often measured times much shorter than that.
T 1709752018 18<28emanuele618>	you three are not making any sense at all
T 1709752043 18<28emanuele618>	we are measuring something that takes less than a microsecond to run, with multiple iterations
T 1709752049 18<27JAA18>	I've measured differences in the dozens of nanoseconds before. Low-level Python stuff, for example.
T 1709752058 18<27JAA18>	You just need many samples to filter out the noise.
T 1709752059 18*	25kurahaupo casts a spell of discombobulation on emanuele6
T 1709752086 18<28emanuele618>	if you think that you can get a measurement that does not fluctuate by at least +- 200ms with 100500 iterations of that (()) thing, please show me how you do it
T 1709752122 18<24ano18>	https://clbin.com/JcdLl
T 1709752142 18<28emanuele618>	 $()
T 1709752144 18<28emanuele618>	that is a syscall
T 1709752147 18<25kurahaupo18>	emanuele6: bind a CPU & memory to a cgroup
T 1709752181 18<28emanuele618>	you are not showing any result, you are telling me to waste my time with your stupid idea
T 1709752184 18<27JAA18>	Can you give the concrete 'that (()) thing' including input? There were so many suggestions above that I'm not even sure what you're comparing right now.
T 1709752209 18<28emanuele618>	this is   ((x?1:x++))  vs   ((x?x:x++))
T 1709752224 18<27JAA18>	With which initial value for x?
T 1709752271 18<27JAA18>	And are we talking about applying that in sequence 100k times or trying that from the same initial value 100k times?
T 1709752271 18<28emanuele618>	it does not matter
T 1709752281 18<25kurahaupo18>	JAA: it hardly matters; it can be zero for at most one cycle
T 1709752299 18<28llua18>	how did we get to this point of optimization within bash
T 1709752310 18<27JAA18>	Wouldn't the second one recall x again on the first branch?
T 1709752319 18<28emanuele618>	yes.
T 1709752337 18<27JAA18>	So we're trying to show that that's slower for x = 0?
T 1709752365 18<28emanuele618>	x=0 is the initial value for the test, but it does not matter obviously
T 1709752374 18<25kurahaupo18>	The numeric evaluator has pretty much zero optimisations; looking up variables is unreasonably expensive
T 1709752388 18<27JAA18>	That's why I ask about
T 1709752389 18<27JAA18>	> applying that in sequence 100k times or trying that from the same initial value 100k times
T 1709752390 18<28emanuele618>	kurahaupo: wow....
T 1709752396 18<28emanuele618>	you are saying so much nonsense
T 1709752400 18<27JAA18>	In the former, yes, the initial value is basically irrelevant.
T 1709752407 18<27JAA18>	In the latter, it gets reset every time.
T 1709752408 18<28emanuele618>	ano is saying that the one with ?1  is slower; not ?x
T 1709752459 18<28emanuele618>	JAA: ?
T 1709752475 18<25kurahaupo18>	ano: could you please clarify which expressions you were comparing?
T 1709752500 18<28emanuele618>	because apparently you are not even following the conversation
T 1709752517 18<28emanuele618>	JAA: the second one returns x if x is not 0, otherwise it returns 0, and sets x to 1
T 1709752525 18<27JAA18>	emanuele6: The former is `x=0; for i in {1..100000}; do ((x?1:x++)); done`. The latter is `for i in {1..100000}; do x=0; ((x?1:x++)); done` (though you need to exclude the `x=0` assignment from the time measurement).
T 1709752547 18<24ano18>	yeah i compared ((i?i:i++)) vs ((i||i++)) there is 40ms diff, didn't try ((x?1:x++)), sorry bad eyes
T 1709752550 18<25kurahaupo18>	I thought it was comparing ((x||x++)) with ((x?1:x++))
T 1709752558 18<28emanuele618>	you should not reset x=0...
T 1709752575 18<27JAA18>	That was my question the whole time, whether it should be reset or not!
T 1709752581 18<27JAA18>	They're two different benchmarks.
T 1709752603 18<28emanuele618>	then ano just said something nonsensical from the start
T 1709752611 18<25kurahaupo18>	# echo $(( 2 ?: 3))
T 1709752612 18<25shbot18>	kurahaupo: bash: 2 ?: 3: expression expected (error token is ": 3")
T 1709752613 18<27JAA18>	One averages over different values of x, the other specifically evaluates the first branch only.
T 1709752621 18<25kurahaupo18>	Dang
T 1709752640 18<25kurahaupo18>	# echo $(( 2 || 3))
T 1709752641 18<25shbot18>	kurahaupo: 1
T 1709752645 18<24ano18>	emanuele6: sorry, "i" looks like a "1" via my eyes/fonts
T 1709752660 18<28emanuele618>	ano: elektron xD xD xD
T 1709752662 18<28emanuele618>	dXxxdXDX
T 1709752765 18<28emanuele618>	how about you do something interesting like   bind a CPU & memory to a cgroup   and getting a stable time measurement for   ((x?x:x++))  vs  ((x?1:x++)) ?
T 1709752779 18<28emanuele618>	actually doing something interesting for once
T 1709752961 18<24ano18>	what's the point to compare ((x?x:x++)) and ((x?1:x++))? need compare ((i||i++)) vs ((x?1:x++))
T 1709752982 18<24ano18>	((x||x++)) vs ((x?1:x++))
T 1709752991 18<28emanuele618>	<emanuele6> if you use   i?1:i++   it is probably going to be faster
T 1709752993 18<28emanuele618>	<ano> what do u mean? it's slower
T 1709753033 18<28emanuele618>	elektronz
T 1709753224 18<24ano18>	hmm looks the same
T 1709753304 18<28emanuele618>	:o <emanuele6> no, it takes pretty much the same time
T 1709753540 18<24ano18>	((x?1:x++)) + ~3ms slower, ((x||x++)) still better (at least in my env)
T 1709754804 18<25ormaaj18>	A recent ksh change made :, true, and false in loop invariants basically noops. So should be at least as good as ! ! in bash without the syntax hack.
T 1709754831 18<25ormaaj18>	(It was probably already way faster than bash sadly)
T 1709754837 18<28emanuele618>	does ksh not have $_ ?
T 1709754848 18<25ormaaj18>	It does but it doesn't work like bash
T 1709754859 18<28emanuele618>	it has nothing like bash's $_?
T 1709754884 18<25ormaaj18>	_ is similar in certain contexts but isn't set after every simple command. It requires a new line.
T 1709754897 18<25ormaaj18>	in mksh it only works in interactive mode
T 1709754911 18<28emanuele618>	yeah, also in dash
T 1709754936 18<28emanuele618>	hmm, no
T 1709754978 18<28emanuele618>	in dash it only works in interactive mode, but it works like bash's
T 1709754980 18<19Artfaith18>	emanuele6, you sure know what kprobes is I believe. I am still on train, but I recalled why I mentioned BPF or Berkley Packet Filter with a tool BCC, or toolset to manipulate Kernel live via kprobes (used for Kernel debugging and tracing by probing or inserting breakpoints to certain call stack of a third party program) to collect data you want at times when needed. I found the script I used a few
T 1709754982 18<19Artfaith18>	years ago for shell pipe watch I used to collect data from one program to another by PID with `strace` disabled, and it also included times in nanoseconds: https://dpaste.org/PyXr3 . Here is a CPU profiler from bookmarks using the same approach https://github.com/iovisor/bcc/blob/master/tools/profile.py . The function which is used for time is
T 1709754984 18<19Artfaith18>	https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md#3-bpf_ktime_get_ns . Please check the following: https://opensource.com/article/17/11/bccbpf-performance , https://lwn.net/Articles/132196/ , and there various solutions to visualize the data not in TUI like histograms but also graphs like https://www.parca.dev/docs/concepts
T 1709755017 18<28emanuele618>	is that a chatbot? :o
T 1709755029 18<19Artfaith18>	...
T 1709755040 18<19Artfaith18>	I regret speaking with you.
T 1709755045 18<25ormaaj18>	lol
T 1709755048 18<28bprompt18>	hehe
T 1709755056 18<28emanuele618>	i don't know what a kprobes is
T 1709755069 18<25ormaaj18>	it's a kernel debugging thing
T 1709755082 18<19Artfaith18>	It's fucking 6th time you literally put into me into your disgusting shit, emanuele6..
T 1709755084 18<28emanuele618>	that sounds like a name for kernel debugging thing, yes
T 1709755098 18<28llua18>	zzz
T 1709755114 18<28emanuele618>	i have never heard of that honestly
T 1709755125 18<25ormaaj18>	person has issues
T 1709755176 18<25ormaaj18>	now they'll be back except with their new sockpuppet account
T 1709755182 18<25ormaaj18>	just wait
T 1709755244 18<24ano18>	did anyone compare modern ksh implementations, which one is faster?
T 1709755276 18<28emanuele618>	we are talking about ksh93, not pdksh forks like openbsd ksh, mksh, pdksh, netbsd ksh, etc
T 1709755296 18<28emanuele618>	anyway the core is the same
T 1709755328 18<28emanuele618>	there is much reason why one of them would be faster than the other, mksh has more features i guess
T 1709755408 18<24ano18>	https://github.com/ksh93/ksh this one?
T 1709755437 18<28emanuele618>	that one is the maintained for of ksh93, yeah
T 1709755453 18<28emanuele618>	shbot has a different fork
T 1709755480 18<28emanuele618>	s/is much/is not much/
T 1709755562 18<28llua18>	when even the dialect has dialects.
T 1709755569 18<25ormaaj18>	that's the one. u+m is a fork of u. There's also v- which is unmaintained, has extra features, some missing ones, and a lot more bugs. There's also a 3rd fork, 2020, which is unmaintained and pretty much no point in using that one unless you plan to develop it further.
T 1709755610 18<28emanuele618>	shbot has 2020
T 1709755623 18<25ormaaj18>	wat? geirha updated it?
T 1709755636 18<28emanuele618>	k# typeset -p .sh.version
T 1709755638 18<25shbot18>	emanuele6: .sh.version='Version AJM 93u+ 2012-08-01'
T 1709755643 18<28emanuele618>	hmm, nevermind
T 1709755644 18<25ormaaj18>	nah that is not 2020
T 1709755655 18<25ormaaj18>	just an old random version
T 1709755671 18<28emanuele618>	it works similarly to 2020 which is the version i have installed on my pc, so i thought it was 2020
T 1709755790 18<25ormaaj18>	at this point backporting the important stuff from v- to u+m is probably the way to go considering there's been about 1.5k commits worth of divergence.
T 1709755855 18<28emanuele618>	when i timed  : $x  vs  : "$x"  in different shells yesterday, i noticed that ksh93 2020 is slower than bash quite a bit
T 1709755934 18<20bent_fingers18>	because ksh93 is out of coffee
T 1709755952 18<28emanuele618>	should've been written in java
T 1709755966 18<25ormaaj18>	because its creators are retired
T 1709755996 18<25ormaaj18>	possibly also tired, but they might have coffee.
T 1709756052 18<25ormaaj18>	some of that AST stuff was written in java. I forgot what it was.
T 1709756095 18<25ormaaj18>	maybe it wasn't included but a few things by the same group that did ast and uwin
T 1709756158 18<28emanuele618>	i just tried u+m and it is marginally faster than bash; 2020 is very slow ~3 times slower than bash
T 1709756184 18<28emanuele618>	also ksh93 is like bash  : $x   is faster than  : "$x"   but not by as much
T 1709756209 18<25ormaaj18>	that is very strange
T 1709756221 18<25ormaaj18>	quoted should be faster
T 1709756283 18<28emanuele618>	no, that is not what i expected, and it is measurably slower than unquoted (when no field splitting/pathname expansion/elision occurs)
T 1709756324 18<25ormaaj18>	you can't disable field splitting
T 1709756326 18<24jamiejackson18>	i'm redirecting both stdout and stderr from a command but i still see output in the terminal. why might this be? https://gist.github.com/jamiejackson/c5031958d7b89bfa1b4b944e57d6acf6
T 1709756327 18<28emanuele618>	because i know bash replaces all the quoted parts with  \v\a\l\u\e   to then re-remove the \s after the pathname expansion step
T 1709756347 18<25ormaaj18>	ah well that's clumbsy. certainly if it does it that way
T 1709756356 18<28emanuele618>	that is how the implementation works all the time, and it is very costly if $x is long; in the test it was a string of 4096 .s
T 1709756363 18<28emanuele618>	in most shells "$x" is faster, but not in bash
T 1709756415 18<28emanuele618>	jamiejackson: you are only redirecting the stderr of the sed command
T 1709756430 18<28emanuele618>	try   (jenkins-plugin-cli --list   | grep -v ':'   | sed 's/ /:/') > /tmp/plugins.lock.txt   2> /tmp/error1
T 1709756452 18<25ormaaj18>	I do know that the ksh implementation supposedly has some similar limitations. There are a few unfixable bugs caused by metadata being passed through expansion-stages in-band with an escaping scheme.
T 1709756507 18<28emanuele618>	in u+m  : "$X"  and  : $X  take pretty much the same time, unquoted is very marginally faster; in busybox, dash, and bash the difference is more substantial
T 1709756537 18<24jamiejackson18>	you're a genius, emanuele6. i learned something new about chained commands.
T 1709756584 18<20bent_fingers18>	indeed he is
T 1709756602 18<20bent_fingers18>	jamiejackson: please consider supporting his cause: https://www.givesendgo.com/GBH2M
T 1709756758 18<28llua18>	please don't do that
T 1709756769 18<24yuesbeez18>	ormaaj: hi just following up from yesterday. sudo -- bash +o monitor -O lastpipe -c '{ printf %s "$2" | { shift; { BASH_ENV=/proc/self/fd/${fd} exec -- "$@"; } {fd}<&0 <&"$tty"-; } {tty}<&0' bash 'cd /server && source blahblah; unset -v fd BASH_ENV {fd}<&-' bash gives me bash: -c: line 2: syntax error: unexpected end of file. also my end goal is to have an interactive shell so should i omit the arg1 and arg2?
T 1709756807 18<28emanuele618>	ormaaj: if you missed it yesterday, the timing setup is  (printf '%.0s: $X\n' {1..20000}) > testscript1   (printf '%.0s: "$X"\n' {1..20000}) > testscript2    printf -v X %.1s .{1..4096}    time X=$X "$sh" testscript1
T 1709756853 18<25ormaaj18>	-.-
T 1709756866 18<28emanuele618>	err,   (echo {; printf '%.0s: $X\n' {1..20000}; echo }) > testscript    actually
T 1709757842 19*	Now talking on 22#bash
T 1709757842 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709757842 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709757859 18<28emanuele618>	but it looks like it is not used for anything; maybe it used to do something in the past, now it does nothing afaict
T 1709757915 18<28emanuele618>	it has existed since the beginning of the git repo
T 1709758034 18<28emanuele618>	it looks like it never did anything
T 1709758064 18<28emanuele618>	it is a static variable in shell.c and it is not used for anything, so it just does nothing i guess
T 1709758139 18<28emanuele618>	maybe some old debugger/testsuite that they were using passes --debug when the program is being tested/debugged
T 1709758148 18<28emanuele618>	so they just accept it and ignore it
T 1709758670 18<25ormaaj18>	I wish there was something like `set -v` except that prints after alias expansion
T 1709758720 18<25ormaaj18>	you have to guess what's going on in commands that don't normally output anything for set -x... like function definitions in this case
T 1709759890 18<25ormaaj18>	I think that might be some thing that triggers bashdb
T 1709759974 18<25ormaaj18>	portage blocks installing it with bash 5.3 for some reason. I doubt anybody has tested it
T 1709760008 18<25ormaaj18>	but then it also tries to use it to display debug info for something or other and fails obviously, which just generates a bunch of errors.
T 1709760028 18<25ormaaj18>	not an actual problem afaict, just annoying.
T 1709762446 18<27xx18>	is a symlink a regular file for the purposes of "-f FILE        True if file exists and is a regular file."
T 1709762460 18<27xx18>	my testing says it is but it feels strange
T 1709762708 18<27Earnestly18>	xx: -f file follows the symlink
T 1709762764 18<27Earnestly18>	(In general symlinks are supposed to be transparent unless you specifically check if something is a symlink)
T 1709763030 18<27xx18>	probably for the best
T 1709763031 18<27xx18>	thanks
T 1709763337 18<20bent_fingers18>	!indirect
T 1709763356 18<20bent_fingers18>	!indirection
T 1709763356 18<29greybot18>	Bash is one of the few languages that causes a brain glitch in most people's heads making them want to put data in variable names. Don't do that. You probably want associative arrays or functions instead.
T 1709763753 18<20bent_fingers18>	If i want to declare my variables at the top (for easier reading) then process options, is this a sane way to do it? https://termbin.com/jvsz
T 1709763776 18<20bent_fingers18>	the issue is processing $1
T 1709763801 18<20bent_fingers18>	i want $1 to be a pattern if it's not an option
T 1709763813 18<20bent_fingers18>	and options start with `-`
T 1709763845 18<20bent_fingers18>	the only other thing i can think of is to place `pattern="$1"` after the options processing
T 1709763920 18<20bent_fingers18>	it works, but it looks a little ugly to me
T 1709764208 18<20bent_fingers18>	nevermind, i'll move the variables under option processing
T 1709774324 19*	Now talking on 22#bash
T 1709774324 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709774324 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709777052 18<19`]18>	tar exited with code 130 - police of which country is concerned?
T 1709777092 18<19`]18>	Oh, nevermind. It wasn't tar
T 1709781292 18<25kurahaupo18>	ormaaj: apropos "post-alias set -v", I wish that bash -x would print (at least the name of) function definitions as they're encountered, and the values assigned using "let a=b" and ((a=b)) and typeset -i a=b.
T 1709784480 18<20bent_fingers18>	ormaaj: interesting
T 1709784701 18<20bent_fingers18>	ormaaj: i have a script that prints "I like cookies" on the screen. perhaps i could show you how to do it one day
T 1709786353 19*	Now talking on 22#bash
T 1709786353 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709786353 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709787188 19*	Now talking on 22#bash
T 1709787188 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709787188 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709790361 19*	Now talking on 22#bash
T 1709790361 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709790361 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709790453 18<25ormaaj18>	you could do it with a debug trap. That will itself slow things down measurably.
T 1709790780 18<25ormaaj18>	If you've optimized your algorithms and their rendering in shell is good - which you can normally determine without much measurement - then it comes down to bash being slow. It's worse to contort good code to comply with weird bash performance characteristics than just leave it alone.
T 1709790797 18<26lockywolf18>	How do I encode a newline in a string?
T 1709790829 18<26lockywolf18>	found
T 1709808329 19*	Now talking on 22#bash
T 1709808329 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709808329 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709808445 18<25ormaaj18>	I use dbus-send :o
T 1709810810 19*	Now talking on 22#bash
T 1709810810 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709810810 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709811088 18<25marcopolo118>	 How do you put functions in bashrc ? You just reference your script and give it an alias?
T 1709811590 19*	Now talking on 22#bash
T 1709811590 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709811590 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709811660 18<25marcopolo118>	Like i want to execute a python script from bash terminal using an alia
T 1709812215 18<27Earnestly18>	marcopolo1: The shell is made for executing commands
T 1709812244 18<27Earnestly18>	marcopolo1: I'm not sure what is difficult for you here, maybe show real examples
T 1709813197 18<19randomhero18>	that'd require him to not be trolling, which is a stretch
T 1709815372 18<26FreeBDSM18>	hi. I have a bunch of small files in 1 dir. `cat /dir/* >> joined` says argument list too long, how to solve this task properly? I feel like xargs should be applicable here somehow, but I don't get how
T 1709815468 18<24depesz18>	FreeBDSM: find /dir/ -maxdepth 1 -type f -exec cat {} + >> joined
T 1709815475 18<24depesz18>	should work. mostly
T 1709815497 18<27mindhunter18>	depesz: do you not need the \; at the end?
T 1709815502 18<24depesz18>	NO
T 1709815509 18<24depesz18>	+, not \;. totally different thging
T 1709815518 18<27mindhunter18>	Ah
T 1709815597 18<24depesz18>	mindhunter: compare time find /etc/ -type f -exec cat {} + &>/dev/null vs. time find /etc/ -type f -exec cat {} \; &>/dev/null
T 1709815618 18<26FreeBDSM18>	depesz, thanks!
T 1709815663 18<26FreeBDSM18>	I thought that would somehow sub-optimal as it'd probably call cat once per each file, but that's exactly what xargs here is for
T 1709815694 18<28selckin18>	+ does multiple files in batches ; is one per file
T 1709815723 18<24depesz18>	xargs could still be helpful, if you needed the files to be concatenated in order.
T 1709816699 18<27JorgeBorges18>	hey
T 1709816851 18<28nphard18>	JorgeBorges: look type this into a terminal --> echo  {0000..0050} | tr ' ' '\n' | sed 's/^/<a href="/g'
T 1709816933 18<27JorgeBorges18>	the message has been probably cut off
T 1709816951 18<28nphard18>	JorgeBorges: no, that's the first part
T 1709816957 18<27JorgeBorges18>	it displays <a href="0000 0001 0002..."
T 1709816978 18<28nphard18>	JorgeBorges: are you running linux?
T 1709816980 18<24depesz18>	nphard: simpler: printf '<a href="%s\n' {0000..0050}
T 1709816982 18<27JorgeBorges18>	yes
T 1709817348 19*	Now talking on 22#bash
T 1709817348 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709817348 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709817364 18<24depesz18>	scripts?
T 1709817401 18<27JorgeBorges18>	hm?
T 1709817430 18<24depesz18>	you asked about ... "such scripts". what do you mean? the one liner with seq|sed ? or my approach with printf ?
T 1709817440 18<24depesz18>	neither of these would qualify as scripts, tbh.
T 1709817451 18<28nphard18>	JorgeBorges: I have an improved one
T 1709817498 18<28nphard18>	{0000..0050} | tr ' ' '\n' | sed 's/\(^.*$\)/<a href="\1"/g'
T 1709817502 18<27JorgeBorges18>	errata: how many hours daily you code in bash to be able to write such very simple one liners by hand?
T 1709817701 18<24depesz18>	i write bash for ~ 1 hour a day. but i think the more important fact is that I do it for many years. otoh, realisically - read man pages/help pages to printf, sed, tr, nl, bash, and you will learn how to do it. most importantly - try. play with stuff.
T 1709817715 18<28nphard18>	JorgeBorges: it's only a quick example
T 1709817743 18<24depesz18>	nphard: you don't need grouping in sed, also g flag is not needed.
T 1709817779 18<24depesz18>	| sed 's/.*/<a href="&"/' - will do the sed thing as well :)
T 1709817935 18<28nphard18>	depesz: aahh!! I was looking for that one, but I was doing it wrong 's/^.*$/href=&/'
T 1709817935 18<27Earnestly18>	FreeBDSM: {} + supplies all arguments to -exec such that it fits in ARG_MAX and then splits over that. ; calls -exec once per argument
T 1709817976 18<28nphard18>	JorgeBorges: true, reading man pages/info is quite important.
T 1709818019 18<27Earnestly18>	FreeBDSM: And as an aside, the {} in '{} +' is not the same as the {} in ;
T 1709818133 18<25marcopolo118>	Whats the difference between piping and stdout
T 1709818139 18<27Earnestly18>	(That is, with -exec ; the {} is optional and used as placeholder. With -exec {} + the '{} +' represents the entire "terminator" for -exec, and is required in that specific order. Why they didn't just use +, I'm not sure
T 1709819427 18<26FreeBDSM18>	now I need to clean up all files in that dir except files with names from a list [2,3,86,88,90], I can't think of any solution better than a for file loop
T 1709819523 18<25kurahaupo18>	Earnestly: in principle it should be possible to have find support putting {} anywhere, not just at the end: find ‚Ä¶ -exec mv {} /dir/1/ + -o -exec mv {} /dir/2/ +
T 1709820022 18<24iconoclast_hero18>	I'm trying to take the error output from ssh regarding host id changing and pipe it to a script that will take the indicated ssh-keygen line and run it for me automatically...  e.g., `$ ssh whatever 2>&1|revokessh`
T 1709820056 18<26FreeBDSM18>	so I need some kind of combination of `xargs` or `find ... -exec` and some regexmatch
T 1709820100 18<24iconoclast_hero18>	and I read the output with a while read loop and put the line ` ssh-keygen -f "/home/user/.ssh/known_hosts" -R "[ssh.address.com]:0000 ` in an array and try to run the array as a command.
T 1709820106 18<26FreeBDSM18>	IDs of correct interfaces are all lower that 100, filenames match IDs, so a fast and dirty solution would be to rm all files with names 100 and higher
T 1709820124 18<24iconoclast_hero18>	which errors out on `Cannot stat "/home/user/.ssh/known_hosts": No such file or directory`
T 1709820148 18<26FreeBDSM18>	can I use expansion like `rm {100..500000}`?
T 1709820152 18<24iconoclast_hero18>	and I'm guessing because it is looking for '"/home/user/.ssh/known_hosts"' not '/home/user/.ssh/known_hosts'
T 1709820224 18<24iconoclast_hero18>	and that I have to parse that line and execute e.g., ssh-keygen -f  "$file" "$address"
T 1709820226 18<24iconoclast_hero18>	correct?
T 1709820346 18<26FreeBDSM18>	`rm {100..500000}` generally works, but only for smaller ranges, with such a range I get error 'argument list too long'
T 1709820634 18<26FreeBDSM18>	ah, so `ls -1 | egrep -v "^(1,2,3,99)$" | xargs rm`
T 1709820699 18<24iconoclast_hero18>	also, using eval didn't work either.
T 1709820786 18<24depesz18>	FreeBDSM: I don't think this egrep does what you want it do.
T 1709820810 18<24depesz18>	check seq 1 100 | egrep "^(1,2,3,99)$"
T 1709820818 18<26FreeBDSM18>	depesz, my mistake: commas instead of pipes
T 1709820822 18<26FreeBDSM18>	1|2|3|99
T 1709820837 18<26FreeBDSM18>	but the problem is that I still get argument list too long error
T 1709820842 18<26FreeBDSM18>	what the hell
T 1709820856 18<26FreeBDSM18>	is it because I actually use `xargs sudo rm`?
T 1709820866 18<24depesz18>	FreeBDSM: with xargs? add -n 100, or something.
T 1709820908 18<26FreeBDSM18>	depesz, ha, it worked! thanks!
T 1709821234 18<29phy172918>	!ls
T 1709821234 18<29greybot18>	DO NOT USE the output of ls in scripts. Its output format is neither portable nor reliable. Use globs instead. See https://mywiki.wooledge.org/ParsingLs
T 1709823726 18<19cousteau18>	Hi
T 1709823747 18<19cousteau18>	`seq` is not POSIX nor required to exist, right?
T 1709823770 18<27colo18>	right.
T 1709823839 18<19cousteau18>	Asking because the shbot right now has an "Easter egg" implementation of seq that doesn't do the expected thing instead of just telling you politely not to use seq
T 1709823886 18<19cousteau18>	(It might be nicer if the bot just told you that seq command is not found, just saying...)
T 1709823946 18<29phy172918>	But not as fun
T 1709823951 18<29phy172918>	which is fun too
T 1709824029 18<27JanC18>	even POSIX things are only required if you care about 100% POSIX compatibility...
T 1709825025 18<25ormaaj18>	lol it would not.
T 1709825034 18<25ormaaj18>	# botsmack
T 1709825035 18<25shbot18>	Segmentation fault
T 1709825286 18<25ormaaj18>	hm i wonder if there's unicode tally marks. It could do tallies!
T 1709825355 18<24depesz18>	ùç∑ùç∏
T 1709825399 18<25ormaaj18>	best counting system
T 1709825410 18<24depesz18>	https://github.com/garabik/unicode is great piece of software for such things.
T 1709825438 18<28emanuele618>	i agree, i use it often
T 1709825459 18<25ormaaj18>	mh
T 1709825479 18<25ormaaj18>	i don't like how you can't control what kind of input you're giving or what field it's searching in
T 1709825488 18<28emanuele618>	:o
T 1709825505 18<28emanuele618>	you can
T 1709825550 18<24ano18>	# enable seq; seq 1 3
T 1709825552 18<25shbot18>	ano: 1
T 1709825552 18<25shbot18>	ano: 2
T 1709825552 18<25shbot18>	ano: 3
T 1709825557 18<25ormaaj18>	hm
T 1709825578 18<28emanuele618>	-x hexadecimal codepoint, -d decimal codepoint, -o octal codepoint, -b binary codepoint, -r regular expression search names, -s string search names
T 1709825625 18<25ormaaj18>	:o
T 1709825647 18<24depesz18>	unicode --help helps :)
T 1709825664 18<28emanuele618>	i also have a manual page for unicode
T 1709825689 18<25ormaaj18>	oh that's input. There's a --format for output
T 1709825699 18<25ormaaj18>	which is not in the manual D:
T 1709825716 18<24depesz18>	specification of output should be added to manual/help, true.
T 1709825759 18<24depesz18>	you can find output format spec docs in https://github.com/garabik/unicode/blob/master/README#L83
T 1709825792 18<22CrtxReavr18>	Here's a fun font test: touch $(echo -ne '\ufdfd')
T 1709825954 18<24ano18>	looks like a rectangle
T 1709825997 18<24ano18>	imho there are to many rectangles in unicode
T 1709826020 18<25ormaaj18>	# tŒøu—Åh $(–µ—ÅhŒø -n–µ '\ufdfd'); l—ï -–∞
T 1709826021 18<25shbot18>	ormaaj: bash: $'\320\265\321\201h\316\277': command not found
T 1709826021 18<25shbot18>	ormaaj: bash: $'t\316\277u\321\201h': command not found
T 1709826021 18<25shbot18>	ormaaj: bash: $'l\321\225': command not found
T 1709826027 18<25ormaaj18>	not working.
T 1709826153 18<25ormaaj18>	# export LC_CTYPE=en_US.UTF-8; tŒøu—Åh $(–µ—ÅhŒø -n–µ '\ufdfd'); l—ï -–∞
T 1709826155 18<25shbot18>	ormaaj: bash: –µ—ÅhŒø: command not found
T 1709826155 18<25shbot18>	ormaaj: bash: tŒøu—Åh: command not found
T 1709826155 18<25shbot18>	ormaaj: bash: l—ï: command not found
T 1709826195 18<24ano18>	# : > $(–µ—ÅhŒø -n–µ '\ufdfd'); l—ï -–∞
T 1709826197 18<25shbot18>	ano: bash: $'\320\265\321\201h\316\277': command not found
T 1709826197 18<25shbot18>	ano: bash: $(–µ—ÅhŒø -n–µ '\ufdfd'): ambiguous redirect
T 1709826197 18<25shbot18>	ano: bash: $'l\321\225': command not found
T 1709826240 18<28emanuele618>	lmao   unicode --brexit
T 1709826662 18<25ormaaj18>	I am not trusted with +s for some reason D:
T 1709826680 18<28emanuele618>	a good reason?
T 1709826686 18<25ormaaj18>	probably!
T 1709826700 18<25ormaaj18>	i mean no, stupid reason.
T 1709826720 18*	25ormaaj want colors and backwards text
T 1709826743 18<24ano18>	>$'l\321\225': command not found /why it breaks interpreter?
T 1709826762 18<25ormaaj18>	magic
T 1709826948 18<28emanuele618>	it is not breaking anything; those commands don't exist, as the error message says
T 1709826990 18<28emanuele618>	now we know that ano has a font with unicode characters because they don't see rectangles :o
T 1709827001 18<28emanuele618>	cover blown
T 1709827181 18<24ano18>	if it doesn't break anything then where (ls -a) output?
T 1709827212 18<25ormaaj18>	must be broken or smth.
T 1709827554 18<24ano18>	oh ic, tmux doesn't stick w/ unicode ranges(?) on next-word, emacs does
T 1709827561 18<28emanuele618>	it's not ls, it's $'l\321\225'
T 1709827622 18<28emanuele618>	what you see as s, is actually a lower case cyrillic dze
T 1709827738 18<24ano18>	y figured out already emacs jumping around words strictly instead tmux copy-mode, in emacs u will end on char from diff range/group (?) instead end of word on forward-word, bash cmd homograph attack
T 1709827832 18<28emanuele618>	elektron xD
T 1709828045 18<25kurahaupo18>	FreeBDSM: printf %s\\0 !([1-3]|99) | xargs -r0 rm -vf
T 1709828069 18<24OnlineCop18>	Without using getopt/getopts (I need custom handling), would I want to match single-character options like `-h` in a case statement like: `case "$1" in -*([a-gi-z])h*([a-z]) ) show_help;; ...;; esac` ? Or is there a shorter/simpler way to check that 'h' is somewhere in there?
T 1709828196 18<25kurahaupo18>	OnlineCop: what's wrong with *h* ?
T 1709828213 18<24OnlineCop18>	So `-*h* )` ?
T 1709828223 18<29phy172918>	(Assuming there are no options that take args)
T 1709828244 18<24OnlineCop18>	Some of the other options take additional args.
T 1709828261 18<25kurahaupo18>	I would walk through the args and action "help" when I see -h*)
T 1709828290 18<29phy172918>	Then you need to be a bit fancier if you want to support the POSIX guidelines
T 1709828315 18<25kurahaupo18>	There's no point rejecting -hh
T 1709828332 18<29phy172918>	There is a point in supporting -uusername_with_h
T 1709828341 18<25kurahaupo18>	Exactly
T 1709828343 18<24OnlineCop18>	I want to avoid `--choose` from triggering on `-*h*`, so thought that a regex that would match `-[a-gi-z]*h[a-z]*` would be safest...
T 1709828367 18<25kurahaupo18>	What about --hold)
T 1709828384 18<25ormaaj18>	It's always silly when it starts with "without using x, ..."
T 1709828397 18<24OnlineCop18>	Would `-*([a-g-z])h*([a-z]) )` be safe enough?
T 1709828410 18<29phy172918>	Maybe check if it's a long opt first and have those go down a different code path
T 1709828412 18<25kurahaupo18>	OnlineCop: why the extra complication?
T 1709828439 18<29phy172918>	Then pop letters off the front until you don't recognize one or one takes an argument
T 1709828445 18<25kurahaupo18>	OnlineCop: it doesn't save you anything over -*h*
T 1709828467 18<25kurahaupo18>	(they're both equally wrong, mind you)
T 1709828468 18<27Earnestly18>	kurahaupo: Yeah, I agree. That's probably what was originally intended as well
T 1709828469 18<24OnlineCop18>	Doesn't `-*h*` allow `--h` though?
T 1709828510 18<24OnlineCop18>	I typically check for `-` options before `--` options, but if I add all my `--*` cases first, then having `-*h*` at the end might work.
T 1709828539 18<25kurahaupo18>	OnlineCop: you're going about this wrong. You still need to cope with "-f file" AND "-ffile"
T 1709828594 18<25kurahaupo18>	Or "-m whole" and "-mwhole"
T 1709828597 18<27Earnestly18>	Well, you don't /have/ to. If you document the grammar as -f file then people who use -ffile can keep the pieces
T 1709828617 18<25kurahaupo18>	But it's unfriendly not to
T 1709828630 18<27Earnestly18>	Although it's not very difficult to support both I guess
T 1709828636 18<24OnlineCop18>	kurahaupo: This doesn't currently have short options that take arguments, but I don't mind moving the `-` option handling after all the `--` ones.
T 1709828648 18<27Earnestly18>	I mean you pop off the -f so whatever's left must be the argument
T 1709828687 18<27Earnestly18>	I've seen a generally successful strat being to manually parse --longs into -shorts and then handing the whole thing to getopts, being careful to preserve order
T 1709828692 18<25kurahaupo18>	Just have  ¬´ --?*) die 64 "invalid option $1" ;; ¬ª before any short options
T 1709828715 18<25kurahaupo18>	But why not simply pop off each option as you go?
T 1709828755 18<27Earnestly18>	(That won't support [=optionals] though)
T 1709828786 18<24OnlineCop18>	I haven't written it out far enough to find a singular `-` (not followed by another `-`) and then build/pop the options from the remaining letters. This is all still pretty new to me, so Best Practices is not always easy to find.
T 1709828880 18<25kurahaupo18>	It looks like: for ((;$#;)) do case $1 in ‚Ä¶ -h|--help ) yeehar! ;; ‚Ä¶ -[abchvx]?*) set X "${1:0:2}" -"${1:2}" "${@:2}" ;; ‚Ä¶ *) break ; esac ; shift ; find
T 1709828918 18<25kurahaupo18>	Where -a -b -c -h -v and -x are the single letter options that don't take args
T 1709828920 18<28emanuele618>	find
T 1709828999 18<25kurahaupo18>	Oh, last before *) break is -*) die 64 "Invalid option $1"
T 1709829041 18<25kurahaupo18>	Note that "set X ‚Ä¶" compensates for the next "shift"
T 1709829113 18<24OnlineCop18>	I don't appear to have `die` ...
T 1709829263 18<27Earnestly18>	!die
T 1709829264 18<29greybot18>	command -v foo >/dev/null || die "please install the foo command" # Using a custom 'die' function from http://mywiki.wooledge.org/BashFAQ/101
T 1709831888 18<20bent_fingers18>	Guest1235: async dns?
T 1709832291 18<28apteryx18>	hello!  in the nx-libs project Makefile, one of the recipe does '. replace.sh' (source a replace.sh shell script).  This fails with: sh: .: replace.sh: file not found, although the file does exist.  I'm puzzled; what could be the reason?
T 1709832354 18<28emanuele618>	apteryx: . foo  searchs  foo  in PATH as if you just ran   foo   as a command
T 1709832386 18<28emanuele618>	if replace.sh is in the current directory, that means that you don't have . in PATH, which is normal
T 1709832406 18<28emanuele618>	to source replace.sh in the current directory you should use     . ./replace.sh
T 1709832452 18<28emanuele618>	it is the same in bash, but bash, as an extension, if it does not find  foo  in PATH, will try to source  ./foo
T 1709832463 18<28emanuele618>	not all other shells do it
T 1709832487 18<28apteryx18>	I see!  I think I'm using Bash as sh (its POSIX compatibility mode)
T 1709832498 18<28apteryx18>	thanks for the kind and thorough explanation
T 1709832554 18<28emanuele618>	it is recommended to use  . ./replace.sh   even when using bash in standard mode, because if it finds for some reason  replace.sh  in e.g.  /usr/local/bin/replace.sh    for some reason, it will source that instead of ./replace.sh
T 1709832574 18<28emanuele618>	you are welcome
T 1709833122 18<28apteryx18>	I've reported the issue here: https://github.com/ArcticaProject/nx-libs/issues/1071
T 1709833501 18<24ano18>	what's wrong with posix ver numeration (POSIX.1 -> POSIX.1b -> POSIX.1c > POSIX.2 -> POSIX.1-2001 -> ...) ?
T 1709833562 18<28llua18>	ask them
T 1709833719 18<24ano18>	are posix man pages outdated e.g. (man 7 regex) >regex - POSIX.2 regular expressions, or regex spec unchanged since POSIX.2?
T 1709833769 18<24ano18>	ugh it's >Linux man-pages, looks like there is no(?) posix man page for regex
T 1709836410 18<28nphard18>	is this legal? echo $(foo $(foo))
T 1709836435 18<29phy172918>	No, the shell police will arrest you shortly
T 1709836439 18<29phy172918>	!echo$(
T 1709836440 18<29greybot18>	$(echo ...) and echo $(...) are both pointless. Drop the echo and $(), just write ...: rm "$(echo myfile)" -> rm myfile --- echo "$(df -h)" -> df -h; http://www.iki.fi/era/unix/award.html#echo
T 1709836471 18<29phy172918>	If you just mean can you nest $( in $(, yes
T 1709836592 18<28nphard18>	mm.. nevermind this worked : mkdir $( somecomand )
T 1709836821 18<24ano18>	!chk mkdir $( somecomand )
T 1709836837 18<24ano18>	!check mkdir $( somecomand )
T 1709836837 18<28checkbot18>	ano: Line 1: Quote this to prevent word splitting. See https://shellcheck.net/?id=cb36837
T 1709836848 18<24ano18>	nphard: ^
T 1709836911 18<24ano18>	!-- > nphard
T 1709836911 18<29greybot18>	nphard: The special option -- means "end of options" to every POSIX command except echo and test, and to many other commands. E.g. ¬´mv -- *.png /somedir¬ª (in case one of the filenames begins with "-"). See http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html#tag_12_02 and http://wiki.bash-hackers.org/dict/terms/end_of_options
T 1709837349 18<28nphard18>	like this? mkdir -- "$( somecomand )"
T 1709837390 18<24ano18>	y
T 1709838686 18<24lavaball18>	last line of file into variable. better way then x=$(tail -n1 file)?
T 1709838696 18<24lavaball18>	than
T 1709838784 18<28emanuele618>	that looks good
T 1709838793 18<29phy172918>	<sarcasm>  while IFS= read -r x; do :; done <file   It's pure shell  </sarcasm>
T 1709838899 18<28emanuele618>	<sarcasm> yeah, that is better                                       </sarcasm>
T 1709839230 18<24lavaball18>	thanks guys                        <(don't quit your day job)
T 1709839759 18<24lavaball18>	read is the best thing to search for in the man page. you get to see all the sights before you read the actual function.
T 1709840626 18<28nphard18>	I had a brilliant idea! make some tutorial for bash with Scratch interface!!
T 1709840638 18<28nphard18>	for learning purposes.
T 1709840658 18<20arraybolt318>	Scrash
T 1709840664 18<28emanuele618>	good idea
T 1709840667 18<20arraybolt318>	Scratcsh
T 1709840683 18<20arraybolt318>	Batch
T 1709840687 18<20arraybolt318>	trying to think of names for it
T 1709840701 18<24Milos18>	If I have a command like journalctl | cut [ ... ] | less +F, how do I make CTRL+C only apply to less?
T 1709840706 18<28nphard18>	this is how it'd look --> https://en.wikipedia.org/wiki/Scratch_(programming_language)#/media/File:Scratch_Beginner_Scripts.png
T 1709840742 18<28emanuele618>	‚ö°sh
T 1709840757 18<24Milos18>	With less +F, it won't let me scroll when it's in follow mode, so I have to CTRL+C to get out of follow mode (unless there's another way)? however as you know, CTRL+C is a global thing and applies to everything in the pipe...
T 1709840814 18<28emanuele618>	^X disables follow mode in less
T 1709840819 18<24ano18>	>Waiting for data... (^X or interrupt to abort)
T 1709840848 18<24Milos18>	emanuele6, d'oh. I just saw that
T 1709840851 18<24Milos18>	!!!!!!
T 1709840855 18<28emanuele618>	it seems it does not say it when you use less +F
T 1709840867 18<24Milos18>	it does say it
T 1709840873 18<24Milos18>	apparently I just never noticed
T 1709840874 18<28emanuele618>	it's F (shift+f) to turn it back on if you don't know
T 1709840877 18<24Milos18>	yup
T 1709840904 18<24Milos18>	the problem with CTRL+X is if I do it too frequently I'll start CTRL+Xing things I'm supposed to CTRL+C
T 1709840908 18<24Milos18>	:|
T 1709840925 18<24Milos18>	so - for education, is it possible to do what I originally requested?
T 1709840954 18<24Milos18>	I assume something to do with traps, can traps be used per piped command?
T 1709840976 18<28emanuele618>	i am not sure what you want is, because if you kill less, cut and journalctl will die the next time they try to print something
T 1709840988 18<24Milos18>	why didn't they just make F enable/disable follow mode, would be so much easier
T 1709841001 18<24Milos18>	emanuele6, CTRL+C doesn't kill less, it stops the live follow
T 1709841018 18<24Milos18>	I am just used to doing that, have always been doing it that way
T 1709841021 18<28emanuele618>	hm
T 1709841027 18<24Milos18>	today I learned I could CTRL+X but I'd rather not because muscle memory
T 1709841043 18<24Milos18>	would have been great if you could just F to toggle :|
T 1709841124 18<28emanuele618>	i see
T 1709841268 18<28emanuele618>	well, one way you could do it is if you start the pipeline with  { less +F & fg ;} < <(journalctl | cut [ ... ])
T 1709841273 18<28emanuele618>	but that is a bit silly
T 1709841317 18<28emanuele618>	probably the best general solution is finding the pid of the program, and then running  kill -sINT 123  in another terminal
T 1709841331 18<24Milos18>	damn
T 1709841371 18<24Milos18>	how come you can't less +F <(stuff to send it)?
T 1709841389 18<27cluelessperson18>	How do you log all the upcoming output of a script to a log file from within the script?
T 1709841390 18<28emanuele618>	or stop the process the pipeline with ^Z and figure out the pid with jobs
T 1709841452 18<27cluelessperson18>	I've gotten close with,¬† `set -x; echo &>¬† >(tee test.log); echo "Hello there!"`¬† but that has some weird buffering problem with tee I'm not sure how to solve?
T 1709841460 18<28emanuele618>	Milos: ^C sends INT to the entire process group of the foreground process;  less +F & fg  makes less run in a separate group, so that is why the other processes don't get killed
T 1709841472 18<24Milos18>	ah!
T 1709841498 18<24Milos18>	and what is the significance of { } there?
T 1709841515 18<28emanuele618>	it is just to group   less +F   and   fg
T 1709841537 18<28emanuele618>	to make the   < <(journalctl | cut ...)  redirection apply to both
T 1709841563 18<24Milos18>	cluelessperson, I don't know much but if you have a buffering issue you could use stdbuf -oL to make it line-buffered
T 1709841571 18<24Milos18>	in front of the command that is buffering
T 1709841609 18<24Milos18>	emanuele6, I don't think I've sene that get used before, it looks interesting
T 1709841613 18<24Milos18>	s/sene/seen/
T 1709841633 18<24Milos18>	I thought grouping/subshells was done with $()
T 1709841643 18<28emanuele618>	well, it is something that only makes sense for your interactive manual process management
T 1709841661 18<24Milos18>	out of curiosity could the command you wrote be rewritten without { }?
T 1709841665 18<28emanuele618>	hmm, no; $() runs a command, and then expands to its output
T 1709841676 18<24Milos18>	where can I read more about { }?
T 1709841679 18<28emanuele618>	Milos: I guess, yeah
T 1709841686 18<24Milos18>	is it the same as func() { } ?
T 1709841737 18<28emanuele618>	you would do   exec {fd}< <(journalctl | cut [ ... ]); less +F <&"$fd"- & exec {fd}<&-; fg
T 1709841744 18<28emanuele618>	{ } saves having to cleanup manually
T 1709841754 18<28emanuele618>	it is the same as the { } in func() { } yeah
T 1709841765 18<24Milos18>	wow, that looks so intense :D
T 1709841773 18<24geirha18>	syntax for a function is  name() compound-command.  A command grouping, { ...; }, happens to be the most commonly used one for functions
T 1709841805 18<28emanuele618>	in case you didn't know; you can write    guess () if [ "$1" = 100 ]; then echo you win!; else echo no; fi   :o
T 1709841810 18<27cluelessperson18>	hm, I'm stuck
T 1709841821 18<24Milos18>	yeah, I suppose like in C-like languages you can do if(condition) return; without needing to do if(condition) { return; } if the brevity is appropriate
T 1709841838 18<24Milos18>	so {} just groups stuff
T 1709841915 18<24geirha18>	yes
T 1709841916 18<28emanuele618>	and also kind of like in C; if you have   int x = 2; { int x = 3; func(x) /* this calls func(3) */ ;} func(x) /* this calls func(2) */    you don't have to restore x after the block
T 1709841932 18<28bprompt18>	Milos: other languages allow the same like Perl, however I prefer enclosing with {} for readability, so I know where one ends and another starts
T 1709841952 18<28emanuele618>	likewise if you have   { ...; } < foo   you don't have to restore/cleanup stdin manually to its original value after exiting }
T 1709841977 18<28bprompt18>	Milos: likewise in Python, you don't have to use ";", however I do
T 1709841983 18<24Milos18>	emanuele6, I didn't realise C scoped like that
T 1709842019 18<28emanuele618>	edubashion
T 1709842042 18<24ano18>	# guess () if [[ "$1" = 100 ]] then { echo you win!; } else { echo no; } fi; guess 100
T 1709842044 18<25shbot18>	ano: you win!
T 1709842049 18<24Milos18>	bprompt, PEP8 has entered the chat...
T 1709842088 18<24geirha18>	Woah, you guessed right on the first try. Well done!
T 1709842103 18<24Milos18>	emanuele6, honestly had no idea this applied to C! https://stackoverflow.com/a/1677799
T 1709842109 18<24Milos18>	I feel like I've never noticed it before
T 1709842158 18<28emanuele618>	in C++, if you declare variables with destructors, destructors get called automatically on those variables when you exit }
T 1709842185 18<28emanuele618>	{} in C/C++ (also in bash for redirections) is pretty much like try-with-resources in java, or with in python
T 1709842301 18<24chives18>	Is this a bash or linux question?  If I'm basically starting a shell just to run a screen command, but sometimes I cant access the terminal(i guess that is the name?) anymore and sometimes have to detach from that running session i guess maybe is the name... is there a way to have the terminal logout?  I can only have so many terminals before i get kind of locked out so was wondering there may be a
T 1709842303 18<24chives18>	better way
T 1709842390 18<24Milos18>	emanuele6, got it, thanks a lot for explaining all this in detail :D learned a lot
T 1709842441 18<24chives18>	I guess its prob more a linux question will ask there
T 1709842451 18<24Milos18>	emanuele6, also on that note, I had to add stdbuf -oL before 'cut' to make the command I want work, because otherwise it just doesn't. Do you know why this is needed in this case, but not in regular uses of cut?
T 1709842470 18<24Milos18>	just doesn't => less gets no text
T 1709842493 18<24geirha18>	!faq buffer
T 1709842493 18<29greybot18>	https://mywiki.wooledge.org/BashFAQ/009 -- What is buffering?  Or, why does my command line produce no output: tail -f logfile | grep 'foo bar' | awk ...
T 1709842514 18<28emanuele618>	that is something you usually have to do when you want to see immediately the output of a program that is not writing to a terminal
T 1709842554 18<24Milos18>	geirha, thanks - looking now
T 1709842555 18<28emanuele618>	when not writing to a terminal (in this case cut is writing to a pipe, that less reads and shows on the terminal), programs write more lazily
T 1709842627 18<24Milos18>	for reference, I am actually doing `journalctl -f -u some_service -u some_other_service | cut [ ... ] | less +F, so that my tmux scrollback doesn't end up consuming 2GB RAM after running journalctl -f for weeks with lots of logs output being displayed. I wanted a solution where I could view the output live but also scroll backwards if needed, without consuming scrollback history. so I guess now less is the p
T 1709842628 18<24Milos18>	rogram that's slowly eating memory, but I can easily kill and restart it without needing to restart my entire tmux session
T 1709842665 18<24Milos18>	so I think because I am using journalctl -f, it messes with buffering and requires me to do stdbuf -oL before cut
T 1709842692 18<28nphard18>	that's the price for storing logs in binary format I guess
T 1709842697 18<28bprompt18>	chives: "to run a screen command"? so, you want to run some application, and the application opens a terminal every time, right?   so if you run that app hmm 20 times, you get 20 terminals, is that it?
T 1709842723 18<24geirha18>	no, it's just that cut detects that stdout is not a tty (it's a pipe), so it starts buffering
T 1709842737 18<24Milos18>	oh
T 1709842824 18<24Milos18>	geirha, how does it know if it's a tty or not?
T 1709842827 18<24geirha18>	and it's not really explicitly doing it, but implicitly through using libc functions like printf(3), so you'll find a lot of commands do these unless they explicitly work around it
T 1709842831 18<24Milos18>	I'm slowly reading through that webpage
T 1709842838 18<24geirha18>	man 3 isatty
T 1709842843 18<24chives18>	bprompt: well kind of i think, im running mosh then screen then weechat, but mosh is great for restarting sessions, but if you reboot or close the terminal local side its forever unable to be logged back in to
T 1709842860 18<24Milos18>	geirha, so the dev purposely puts in this efficiency improvement and without it, no buffering would occur?
T 1709842870 18<24Milos18>	i.e. if you do not put in extra work to buffer, it would 'just work'?
T 1709842874 18<24Milos18>	but be slower?
T 1709842884 18<24chives18>	so thats one reason i use screen i can just restart it in the new session but now i have an extra session that takes up a port i only have so many of
T 1709842885 18<24geirha18>	no, it's extra work to not buffer
T 1709842897 18<24Milos18>	well if they are calling isatty() isn't that more work?
T 1709842919 18<28emanuele618>	the standard C library (stdio.h) decides how to buffer automatically for you, if you use puts(), printf() etc functions
T 1709842934 18<28emanuele618>	it decides based on the file type of stdout
T 1709842944 18<24Milos18>	what is stdout's file type or how can I check it?
T 1709842964 18<24chives18>	so was thinking if i had a special session that started screen, when screen terminated itd close the mosh session out and free up that port
T 1709842971 18<28emanuele618>	for cmd in   cmd | ...    stdout is the pipe that connects it with ...
T 1709843007 18<24Milos18>	right - but you said earlier it was dynamically checked based on the file type, so how is that part done?
T 1709843008 18<24geirha18>	in C,  if (isatty(1)) ...    in bash:  if [[¬†-t 1 ]] ; then
T 1709843014 18<24Milos18>	ah, so it's isatty
T 1709843038 18<28emanuele618>	# if [[ -p /dev/stdout ]]; then echo stdout is pipe >&2; elif [[ -t 1 ]]; then echo stdout is tty >&2; else echo stdout is something else >&2; fi
T 1709843039 18<25shbot18>	emanuele6: stdout is tty
T 1709843044 18<28emanuele618>	# if [[ -p /dev/stdout ]]; then echo stdout is pipe >&2; elif [[ -t 1 ]]; then echo stdout is tty >&2; else echo stdout is something else >&2; fi | cat
T 1709843046 18<25shbot18>	emanuele6: stdout is pipe
T 1709843049 18<28emanuele618>	# if [[ -p /dev/stdout ]]; then echo stdout is pipe >&2; elif [[ -t 1 ]]; then echo stdout is tty >&2; else echo stdout is something else >&2; fi > foobar
T 1709843051 18<25shbot18>	emanuele6: stdout is something else
T 1709843070 18<28emanuele618>	there are definitely way for a program to check the type of its stdout
T 1709843078 18<28emanuele618>	s/ay/ays
T 1709843093 18<24Milos18>	this is super interesting
T 1709843104 18<24Milos18>	ok so the default case then, if you were to just write a program, and use it in a pipe, and do no checks, does it buffer or not buffer?
T 1709843127 18<24Milos18>	depends on the functions used (puts etc?)
T 1709843132 18<24Milos18>	is that the answer>?
T 1709843161 18<28emanuele618>	most C programs use the stdio.h functions to print, if they do, you will get buffering because there is code in the standard C library that does it
T 1709843166 18<28bprompt18>	chives: not acquainted with "mosh", I don't use it, hmmm but you could try asking at #ubuntu :)
T 1709843203 18<24geirha18>	if you use any of stdio.h functions for output, it will do the automatic buffering. If you use the write(2) system call directly, the write will be immediate
T 1709843210 18<28emanuele618>	if the program does some direct write syscalls, or print in some other different way, it will not buffer, or it may buffer in a different way that is not disableable by  stdbuf -oL
T 1709843270 18<24Milos18>	got it - so geirha that's why you said it's more work not to buffer, if you used the standard libraries which most stuff probably does, then you have to explicitly flush buffers or whatever to disable it
T 1709843276 18<28emanuele618>	there is also code in the C standard library that understand that a program is run with   stdbuf -oL   and uses line (L) buffering instead of the default in that case; so if the program is using some other library for output buffering, stdbuf will not have any effect
T 1709843287 18<24chives18>	bprompt: why ubuntu? is that that devs? someone had said something about it in irc somewhere because i was having some serious lag trying to type and correct text and it helps
T 1709843310 18<24Milos18>	emanuele6, and the difference between line-buffered and buffer flushed after each char is just efficiency, nothing breaks?
T 1709843328 18<24Milos18>	(not talking about standard library buffering which is greater than a single line)
T 1709843333 18<24geirha18>	Milos: yes, either use write(2) directly, or call fflush(3) after doing a printf or similar
T 1709843336 18<28emanuele618>	in simple cases, pretty much yes
T 1709843370 18<24Milos18>	got it
T 1709843376 18<28emanuele618>	-o0 is no buffering at all; -oL is flush up to the last newline if there are newline in the buffer or the buffer is full
T 1709843394 18<28emanuele618>	default is typically -o4096 iirc; so flush after the buffer is full, and the buffer is 4096 bytes
T 1709843398 18<28bprompt18>	chives: it'd be likely someone either runs it and uses it at #ubuntu
T 1709843404 18<24Milos18>	so I could do -o0 but it would just be silly since you need the whole line before you see it, or at least it makes more sense to have the whole line
T 1709843428 18<24Milos18>	good to know about the default buffer size!
T 1709843472 18<24Milos18>	the only time I consciously needed to flush the buffer is when I made an animation on the terminal when stuff was loading, so I had to make it erase the line and rewrite the line and then flush the buffer
T 1709843478 18<28emanuele618>	except that the default for terminals is -oL since there is probably a human at the terminal that wants to see the output immediately
T 1709843486 18<24chives18>	oh ok will try and see im guessing its not a mosh question more of a terminal setting type question but
T 1709843528 18<24Milos18>	or I could have just started python with PYTHONUNBUFFERED :D
T 1709843532 18<28emanuele618>	yeah, there you need to flush because it is buffering with -oL so it won't actually print anything until you print a newline
T 1709843537 18<24Milos18>	yup
T 1709843579 18<24Milos18>	so the fact that it's line-buffered, that is handled by printf() or whatever python's print() statements maps to on the C level?
T 1709843626 18<28emanuele618>	no, the default is 8192 actually, not 4096
T 1709843635 18<24Milos18>	:O
T 1709843637 18<28emanuele618>	gcc -include stdio.h -xc -E -<<< BUFSIZ | tail    shows 8192 for me at least
T 1709843643 18<28emanuele618>	that is the default
T 1709843654 18<27cluelessperson18>	chives¬†¬† I was on scrollback,¬† but you can configure the session to exit once it finishes with `exit`
T 1709843681 18<28emanuele618>	Milos: not necessarily C, but yeah, it is handled by the program itself, or its libraries, not by the file or the kernel
T 1709843776 18<24chives18>	cluelessperson: oh ok so start with a .sh file and finish with exit?
T 1709843850 18<24Milos18>	hm... probably a question for another channel, but I am wondering if C's write() is buffered, because I assume python's sys.stdout.write() calls C's write(), and if I was doing the animation I talked about earlier, then if it's not buffered I wouldn't need to flush, but I did, so it must be buffering
T 1709843892 18<28emanuele618>	no, write is a direct system call to the kernel, and it will write immediately; also note that C write() is not defined in stdio.h; it is a unix standard function
T 1709843904 18<24Milos18>	ah
T 1709843983 18<28emanuele618>	important to note that if you have    printf("hello %d", i); write(STDOUT_FILENO, "! hi", 4); putchar('\n');   that will probably print out of order
T 1709844021 18<28emanuele618>	important to not mix stdio.h and write; or at least always flush before calling write on a fd that you are using with stdio.h
T 1709844040 18<28emanuele618>	that likely prints   ! hihello, 123<newline>
T 1709844055 18<28emanuele618>	same would happen in python
T 1709844066 18<24Milos18>	I did not expect to go down such a deep rabbit hole on this - just shows how much I have no idea about
T 1709844084 18<24Milos18>	that's really fascinating
T 1709844180 18<27cluelessperson18>	chives¬†¬† I would suggest searching google for more answers around running a process in the background after logout,¬† but you can just do `command & disown`,¬† but it can be tiresome/tedious to reconnect and maange them if you don't cause for them to close themselves properly.
T 1709844218 18<27cluelessperson18>	Can someone suggest a better way for me to do this?¬†¬†¬† `exec &> >(tee output.log)`
T 1709844240 18<27cluelessperson18>	it almost does exactly what I want, but seems to hang waiting for the user to hit enter?
T 1709844251 18<27cluelessperson18>	I think it's a line buffering thing, but I'm not sure how to figure that out.
T 1709844485 18<24geirha18>	if you don't wait for the process substitution to end before exiting the script, then you risk it flushing the last data it has after the script has exited, and after the next interactive prompt ir printed, overwriting/interleaving it
T 1709844693 18<27cluelessperson18>	geirha¬† How do I wait for ... *googles*
T 1709844991 18<24geirha18>	wait "$!"  if it's the only background job in the script. Otherwise, you'll need to use a named pipe instead of a procsub
T 1709844998 18<28emanuele618>	you save the pid of the process substitution after creating it with   exec ... >(...); procpid=$!    and then either before exiting or with a trap EXIT, you call   wait -- "$procpid"  at the end
T 1709845397 18<28emanuele618>	Milos: i think   sys.stdout.write()  does not call write directly; it is more similar to C's fwrite() function which is buffered
T 1709845463 18<28emanuele618>	perhaps you were thinking of  os.write(os.STDOUT_FILENO, "foo")   which actually calls write directly
T 1709845508 18<25ormaaj18>	aw I thought emanuele was mad, but the !'s were someone else
T 1709845520 18<24lavaball18>	can i have a { printf print printf  } >> output file? like the while read ... { } < inputfile just in reverse?
T 1709845531 18<28emanuele618>	hmm, looks like os.STDOUT_FILENO doesn't exist; you have to hardcode 1
T 1709845564 18<24lavaball18>	i think { } 1 >> outputfile   right?
T 1709845590 18<28emanuele618>	and you must pass a bytes to os.write, not a string; so  b'foo'   or bytes(mystr)
T 1709845604 18<28emanuele618>	or mystr.encode() however you prefer encoding your strings
T 1709845620 18<25ormaaj18>	13:47      emanuele6 ‚îÇ it seems it does not say it you useless F! F! Turn it back on if you don't know!
T 1709845635 18<28emanuele618>	$ python3 -c 'import os; i=123; print(f"hello {i}", end=""); os.write(1, b"! hi"); print("")'
T 1709845637 18<28emanuele618>	! hihello 123
T 1709845648 18<28emanuele618>	$ python3 -c 'import sys; i=123;print(f"hello {i}", end="",flush=False); sys.stdout.write("! hi"); print("")'
T 1709845650 18<28emanuele618>	hello 123! hi
T 1709845679 18<28emanuele618>	:O
T 1709845691 18<25ormaaj18>	:D
T 1709845742 18<25ormaaj18>	Usually it's the python read people complain about being magical
T 1709845758 18<25ormaaj18>	readlines or whatever
T 1709845781 18<25ormaaj18>	write could be too
T 1709845829 18<28emanuele618>	err, the second command was supposed to be just   python3 -c 'import sys; i=123; print(f"hello {i}", end=""); sys.stdout.write("! hi"); print("")'
T 1709845842 18<28emanuele618>	same result either way
T 1709846239 18<25finsternis18>	I have a script like this https://sprunge.us/TuHcOD  and want to do something like this:  ./myscript.sh | grep "foo" >> file.txt      But then I have to ctrl-c since it's waiting for input, that I don't want to pass. If I type the keystroke ctrl-c, file.txt is empty but if instead I do   kill -s SIGINT $(pgrep myscript)  then file.txt contains the matched string. Why?
T 1709846386 18<28emanuele618>	^C is not how you enter nothing; to do that you either press enter, or press ^D (pressing ^D will make the read command fail)
T 1709846600 18<25finsternis18>	emanuele6: and is it possible to automatically send ^D to the script? I mean to simulate it
T 1709846626 18<25finsternis18>	maybe expect script?
T 1709846779 18<25ormaaj18>	print(' '.join(bracex.expand("foo{1..5}{a,b}")))
T 1709846779 18<25ormaaj18>	foo1a foo1b foo2a foo2b foo3a foo3b foo4a foo4b foo5a foo5b
T 1709846863 18<25ormaaj18>	if only it globbed too
T 1709846974 18<29nvz18>	yeah its a shame its not like open source software you could add features to :P
T 1709849060 18<27Earnestly18>	ormaaj: Add Glob.glob()
T 1709849542 18<24lavaball18>	oh,without the 1. just { } >> outputfle.
T 1709849644 18<24lavaball18>	is it bad practice to read the first line of a file with read -r firstline < filename ? i feel like i should close it or something.
T 1709849796 18<27larryv18>	there's nothing wrong with that, and there's no need to "close" anything
T 1709849805 18<20twkm18>	that will close it, after the read completes.
T 1709849818 18<24lavaball18>	okay. thanks a bunch.
T 1709849829 18<20twkm18>	i.e., you didn't open it long-term (that's possible too).
T 1709849978 18<24lavaball18>	is it better practice to have a do you wanna question set a variable, which is then checked during output, or should i put the do you wanna question in between the output and forgo the variable?
T 1709850135 18<25ormaaj18>	kind of depends on context I'd say.
T 1709850228 18<25ormaaj18>	like, I would do something different depending on what the variable is for and what kind of check is most convenient. Not really a universal best practice.
T 1709850492 18<24lavaball18>	https://bpa.st/JXMA the persist=1 thing the bottom. gets checked at line 98.
T 1709850493 18<28checkbot18>	lavaball: I think the problem is on line 98. This expression is constant. Did you forget the $ on a variable? See 54 issues on https://shellcheck.net/?id=cb50493
T 1709850516 18<24lavaball18>	what?
T 1709850531 18<27larryv18>	you got checkbot'd
T 1709850539 18<25ormaaj18>	I always get checkbot'd
T 1709850561 18<25ormaaj18>	checkbot: thank you
T 1709850561 18<28checkbot18>	ormaaj: You're welcome! \(=^.^= )/
T 1709850565 18<25OMGOMG18>	almost as bad as getting yellow mustarded
T 1709850587 18<28emanuele618>	checkbot always checkbots my tcl scripts :(
T 1709850603 18<24lavaball18>	the checkbot is right though.
T 1709851022 18<25ormaaj18>	it looks a lot more complicated than it is because of all the printfs... maybe consolidating some of those would be more readable.
T 1709851042 18<24lavaball18>	how?
T 1709851060 18<24lavaball18>	does printf " ... \ ... \ .... " work?
T 1709851079 18<24lavaball18>	or should i just printf " .. \n ... \n ... \n ..."
T 1709851120 18<25ormaaj18>	oh there's a bunch of ways. can use heredocs and loops where it makes sense. shell printf implicitly loops over the format string for any number of args so you can do `printf '%s\n' 'line 1' 'line 2' 'line 3'`
T 1709851132 18<24lavaball18>	oh, right heredocs! i read about those.
T 1709851150 18<24lavaball18>	okay, the loop thing i don't understand.
T 1709851151 18<27Earnestly18>	# printf '[%s]' {a..f}
T 1709851153 18<25shbot18>	Earnestly: [a][b][c][d][e][f]
T 1709851184 18<24lavaball18>	but how does that help me here?
T 1709851218 18<25ormaaj18>	you can put some of those variables into arrays too
T 1709851243 18<27Earnestly18>	lavaball: I looked at your paste and would personally use heredocs
T 1709851249 18<25ormaaj18>	also lots of missing quotes... should go through all the shellcheck things where it says to add quotes and add them
T 1709851305 18<24lavaball18>	i've been told if i'm 100% sure there aren't space it's okay.
T 1709851321 18<25ormaaj18>	not really no
T 1709851332 18<24lavaball18>	!heredocs
T 1709851332 18<29greybot18>	Here documents. cat <<EOF followed by several lines of text, followed by the literal string EOF on a new line, NOT indented. The portion between the EOFs is passed to the command as standard input. If 'EOF' is 'quoted', substitutions WON'T be done; otherwise they are. See <<- for the indented variety.
T 1709851353 18<24lavaball18>	i was hoping for a link.
T 1709851363 18<27larryv18>	lavaball: half of these unquoted variables are user input
T 1709851374 18<25ormaaj18>	not quoting is incorrect except in special circumstances.
T 1709851386 18<27larryv18>	(i say half only because it's clearly a lot of them and i'm not about to count.)
T 1709851421 18<27larryv18>	also spaces are hardly the only thing to worry about
T 1709851438 18<24lavaball18>	what else is  there?
T 1709851473 18<25ormaaj18>	# x=/*; echo $x
T 1709851474 18<25shbot18>	ormaaj: /bin /dev /etc /init /lib /lib64 /proc /root /tmp /usr /var
T 1709851531 18<24lavaball18>	i mean i'm sure you are right, but if i have anything in there that needs quotes the resulting text files are kaputt anyway.
T 1709851554 18<25ormaaj18>	huh?
T 1709851564 18<27larryv18>	ormaaj: fishing for excuses to not quote. typical
T 1709851585 18<25ormaaj18>	!qefs
T 1709851585 18<29greybot18>	"$Quote" "$Every" "$Fucking" "$Substitution"
T 1709851613 18<25ormaaj18>	good advice greybot!
T 1709851616 18<25ormaaj18>	!yw
T 1709851616 18<29greybot18>	You're welcome, human.
T 1709851977 18<25ormaaj18>	!quotes
T 1709851977 18<29greybot18>	https://mywiki.wooledge.org/Quotes
T 1709852009 18<25ormaaj18>	mh I should peek to see if that page is as bad as UsingFind
T 1709852070 18<25ormaaj18>	Nope, better than UsingFind.
T 1709852087 18<27larryv18>	lavaball: heredoc example https://paste.wooledge.org/29349
T 1709852180 18<25ormaaj18>	that first paragraph is so well written. probably knows their stuff.
T 1709852215 18<28emanuele618>	it is missing a comma :o
T 1709852221 18<24lavaball18>	larryv, that is really kind of you. much appreciated.
T 1709852231 18<25ormaaj18>	O.O
T 1709852274 18<24lavaball18>	and you did the variable:+ thing!!!!!
T 1709852285 18<24lavaball18>	i thought nobody ever needs that like ever when i read about it.
T 1709852310 18<28lmat18>	I'm running   watch -n .5 tail -n 40 logfile;  When I see something remarkable in the log, I want to stop running tail and examine the output, but watch clears the screen when it leaves (rmcup?). How do I get watch to leave the screen as it was when I quit the command?
T 1709852314 18<25ormaaj18>	nah all the good scripts use a billion of those
T 1709852376 18<25ormaaj18>	no tail -f?
T 1709852429 18<25ormaaj18>	just don't use watch
T 1709852455 18<25ormaaj18>	use a loop and some tput if tail -f isn't good enough
T 1709852703 18<25ormaaj18>	if you actually need the polling too then pick your favorite filesystem event tool and use that, probably in a loop, with tput to rewind the cursor and clear the printed region. That would be about the most intricate way for a shell script.
T 1709852819 18<28lmat18>	ormaaj: tail -f isn't working because the file is on a sshfs to a sftp server. It's not updating often enough.
T 1709852831 18<25ormaaj18>	ah fun
T 1709852852 18<25ormaaj18>	that'll break all the other inotify things just the same.
T 1709852856 18<28lmat18>	It looks like    watch -n .5 tail -n 40 logfile && tail -n 40 logfile; isn't too bad.
T 1709852862 18<28lmat18>	ormaaj: Yeah, I haven't even tried inotify xD
T 1709852873 18<22loganlee18>	watch command seems awesome!
T 1709852879 18<28lmat18>	loganlee: It is.
T 1709852886 18<22loganlee18>	lmat, XD
T 1709852887 18<25ormaaj18>	but tail -f has a polling mode for when inotify isn't available
T 1709852888 18<28lmat18>	loganlee: ls is really cool, too... ;-)
T 1709852893 18<22loganlee18>	lmat, :D
T 1709852941 18<25ormaaj18>	best to switch to a proper filesystem
T 1709852947 18<25ormaaj18>	<.<
T 1709853071 18<25ormaaj18>	sshfs has some fancy mount options as well maybe there is some way to get modification events
T 1709853114 18<25ormaaj18>	sftp doesn't really have anything to facilitate that, not sure how that would work.
T 1709853161 18<28emanuele618>	i use watch to look at my cpu temperature
T 1709853171 18<28emanuele618>	with  watch acpi -t
T 1709853177 18<25ormaaj18>	:D
T 1709853181 18<28emanuele618>	also nice for other things
T 1709853773 18<25ormaaj18>	I don't know which sensors this board exposes through acpi but clearly either neither of them are the cpu, or they are measuring the heatsink temp or something.
T 1709854210 18<25ormaaj18>	(ins)root 18 (1568975) 0 ~ # sensors -- acpitz-\* coretemp-\* | grep ¬∞ | head -n 3
T 1709854210 18<25ormaaj18>	temp1:        +27.8¬∞C
T 1709854210 18<25ormaaj18>	temp2:        +29.8¬∞C
T 1709854211 18<25ormaaj18>	Package id 0:  +58.0¬∞C  (high = +82.0¬∞C, crit = +100.0¬∞C)
T 1709854225 18<25ormaaj18>	coretemp is always the most accurate if it's an intel chip
T 1709859326 18<20bent_fingers18>	`cat /dev/urandom` doesn't seem to be a viable screensaver
T 1709859358 18<20bent_fingers18>	it causes the cpu fans to kick into high gear
T 1709859371 18<20bent_fingers18>	any way to limit it's cpu consumption?
T 1709859375 18<20bent_fingers18>	its
T 1709859417 18<25OMGOMG18>	sleep occasionally
T 1709859436 18<25hleneto18>	nice cat /dev/urandom.
T 1709859567 18<27JAA18>	Use `pv --rate-limit`
T 1709859591 18<27JAA18>	Or something with a similar effect.
T 1709859769 18<25finsternis18>	could you please explain why when I execute this https://sprunge.us/6VNGh1  script with just  ./myscript.sh  it works, prints the last string "hello ${first_name}" and the  first_name variable is correctly initialized with the input I type, whereas if I execute with:  ./myscript | grep "foo" >> file.txt   it prints nothing, even if I pass the input string as well
T 1709859926 18<27larryv18>	finsternis: because all the output, including the prompt, gets filtered through grep into file.txt
T 1709859986 18<25finsternis18>	larryv: and is there a way to avoid this behaviour?
T 1709860019 18<29fb`18>	if you want to see the output on your terminal _and_ log to file.txt, you using something like `./script | tee -a file.txt`
T 1709860066 18<27larryv18>	finsternis: what do you expect to see printed to the terminal, exactly
T 1709860088 18<29fb`18>	grep can before or after the first pipe depending on what you want written to the file
T 1709860137 18<25finsternis18>	larryv: hello finsternis     if I type "finsternis" whan it's asking me to enter the first name
T 1709860186 18<27larryv18>	so you want the prompt and "hello [name]" to print to the terminal. in that case, what text do you want to end up in the file?
T 1709860187 18<25finsternis18>	to the file.txt it should write the matched string, so "foobar whatever hello world"
T 1709860277 18<27larryv18>	what if the name matches
T 1709860385 18<25finsternis18>	I thought grep would have worked only on the strings echoed before the input typed
T 1709860403 18<25ormaaj18>	bent_fingers: There's this new kind of monitor called an LCD. No burn in!
T 1709860412 18<27larryv18>	finsternis: it filters everything you print to stdout. which in your case is everything
T 1709860416 18<25ormaaj18>	should upgrade
T 1709860449 18<27larryv18>	finsternis: is some of this text should always go to the terminal and not to stdout, then you should specify which text that is
T 1709860451 18<27larryv18>	*if some
T 1709860487 18<25finsternis18>	larryv: it's not a problem if it matches also the name
T 1709860489 18<25ormaaj18>	actually that's a lie but that only happens if you have like a "smart billboard" that's displaying the same graphic 24/7 for years.
T 1709860576 18<27larryv18>	finsternis: it's weird that you don't seen to have a concrete idea of which output you want to go into the filtered file and which you don't
T 1709860590 18<25finsternis18>	in file.txt it already redirects what I want, the problem is that it doesn't execute the last command, that is  echo "hello ${first_name}"  so it doesn't print anything to stdout
T 1709860624 18<27larryv18>	it absolutely does execute that command. its output is filtered out by grep unless the name matches the pattern
T 1709860646 18<27larryv18>	again, it doesn't print to stdout because you are redirecting stdout into grep.
T 1709860742 18<25finsternis18>	larryv: doesn't seem to be right what you said..I tried to pass in input "foo", so that even name is matched, but I got nothing printed to stdout as well
T 1709860758 18<27larryv18>	it. is. going. through. grep
T 1709860761 18<27larryv18>	check file.txt
T 1709860767 18<25finsternis18>	only to the file
T 1709860778 18<25finsternis18>	yes, it's in the file now
T 1709860780 18<27larryv18>	yeah. because you redirected the output to the file.
T 1709860787 18<25finsternis18>	"hello foo"  too
T 1709860808 18<27larryv18>	this seems to be what you want https://paste.wooledge.org/29356
T 1709861005 18<25finsternis18>	larryv: yes, thanks
T 1709861009 18<19stability18>	if i use  ${rsyncprotonosparse:+--sparse} in a shell command then i can do rsyncprotonosparse=t mycommand, or just to mycommand, to control whether --sparse is included.  however, the sense is the opposite of what i want.  i tried ${rsyncprotonosparse:---sparse} but it does not have the opposite sense.
T 1709861075 18<19stability18>	is there a construct or a trick to getting the opposite sense, in which i can do rsyncprotonosparse=t mycommand to get no --sparse and mycommand to get --sparse?
T 1709861307 18<27larryv18>	not really. check for [[ -z $whatever ]] and construct the command as desired
T 1709861352 18<27larryv18>	e.g., args=(); if [[ -z $whatever ]]; then args+=(--sparse); fi; cmd "${args[@]}"
T 1709934726 19*	Now talking on 22#bash
T 1709934726 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709934726 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709935197 18<25ormaaj18>	I tried to make elgetpositionals in execline https://bpa.st/raw/V24A
T 1709935224 18<25ormaaj18>	I can't get it to handle whitespace D:<
T 1709935250 18<25ormaaj18>	I typed it into a bash shell so this is a bash question.
T 1709935252 18<27JAA18>	ormaash when?
T 1709935268 18<25ormaaj18>	:D
T 1709935304 18<25ormaaj18>	when I clone myself. clone will write it.
T 1709935354 18<27JAA18>	:-)
T 1709935463 19*	Now talking on 22#bash
T 1709935463 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709935463 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709935633 19*	Now talking on 22#bash
T 1709935633 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709935633 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709935661 18<25ormaaj18>	I think the whole approach is wrong. I'll have to do something like make rewrite each argument as a block and encode them that way
T 1709935678 18<28emanuele618>	it should be something like    multisubstitute { define _x x define _y y } multisubstitute { define x $_x define y $_y define z $_x$_x define w $_y$_y } cmd $x $y $z $w
T 1709936054 19*	Now talking on 22#bash
T 1709936054 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709936054 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709936056 18<25ormaaj18>	yeah I didn't use backtick -E, it waits to expand that
T 1709936141 18<25ormaaj18>	it's the sed injecting the escape that cannot work properly
T 1709936158 18<28emanuele618>	i understand what it is doing now
T 1709966630 19*	Now talking on 22#bash
T 1709966630 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709966630 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709968315 18<25Lynx-18>	ano thank you for your input earlier concerning truncation
T 1709969040 19*	Now talking on 22#bash
T 1709969040 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709969040 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709971806 18<24Aryan18>	Hi!
T 1709971826 18<24Aryan18>	why escape characters get removed in 2 and 3 ? https://paste.rs/5Kb3J.txt
T 1709971830 18<22evaloop18>	hola
T 1709971980 18<26lopid18>	perhaps you need read -r
T 1709972038 18<24Aryan18>	let me see
T 1709972123 18<24Aryan18>	thank you
T 1709975301 19*	Now talking on 22#bash
T 1709975301 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709975301 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709975561 19*	Now talking on 22#bash
T 1709975561 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709975561 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709978956 19*	Now talking on 22#bash
T 1709978956 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709978956 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709980395 19*	Now talking on 22#bash
T 1709980395 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709980395 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709985712 18<26hozgento18>	I am not sure why i am getting this error: https://bpa.st/6LBA
T 1709985849 18<26hozgento18>	is it the correct way to pass the parameters inside a function?
T 1709986048 18<26hozgento18>	and it worked fine if i copy&paste the args from the printed error and pass them to qemu-system-x86_64
T 1709986332 18<26hozgento18>	s/if/when
T 1709986657 18<24geirha18>	!faq complex
T 1709986658 18<29greybot18>	https://mywiki.wooledge.org/BashFAQ/050 -- I'm trying to put a command in a variable, but the complex cases always fail!
T 1709986672 18<24geirha18>	correct way is to use an array
T 1709986693 18<24geirha18>	qemu_args=(
T 1709986696 18<24geirha18>	  --enable-kvm
T 1709986700 18<24geirha18>	  --boot "$boot"
T 1709986706 18<24geirha18>	)
T 1709986721 18<25ormaaj18>	^
T 1709986724 18<24geirha18>	qemu-system-x86_64 "${qemu_args[@]}" "$@"
T 1709986736 18<25ormaaj18>	sorry :)
T 1709986856 18<24geirha18>	as a bonus, you can have comments within the array assignment, so it's easy to comment in/out options
T 1709987166 18<26hozgento18>	geirha: qemu-system-x86_64: -drive file=/home/x/vms/artix.img,format=raw: invalid option
T 1709987201 18<26hozgento18>	now it doesn't pass any args to qmeu-system-x86_64
T 1709987204 18<24geirha18>	sounds like you put the option and option argument into the same argument
T 1709987233 18<24geirha18>	maybe you typoed the variable name?
T 1709987255 18<26hozgento18>	https://bpa.st/ZTIQ
T 1709987278 18<24geirha18>	!check
T 1709987279 18<28checkbot18>	geirha: Looks good to me
T 1709987374 18<24geirha18>	looks correct. Run it with xtrace enabled to see what's going on;  set -x
T 1709987375 18<24geirha18>	!-x
T 1709987375 18<29greybot18>	set -x (or ''bash -x myscript'') makes bash output the exact command that it will run after parsing and expansion. You can put ''set -x'' just before the code you want to debug (turn off with ''set +x''). To add more information, change PS4 first: eg. PS4='+($?) $BASH_SOURCE:$FUNCNAME:$LINENO:'
T 1709987470 FiSHLiM plugin unloaded
T 1709988023 19*	Now talking on 22#bash
T 1709988023 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709988023 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709988032 18<24geirha18>	and depending on how this is meant to be used, you may want to validate that img_path contains a value that is safe to be embedded inside that -drive argument
T 1709988057 18<24geirha18>	e.g. if it contains comma, it may fail, or do something unintentional
T 1709988167 18<26hozgento18>	geirha: i think it works now, thank you so much
T 1709988196 18<24geirha18>	If you want to learn why your earlier attempts fail, I recommend reading https://mywiki.wooledge.org/Arguments
T 1709988243 18<26hozgento18>	ah thanks, will definitely read that
T 1709988269 18<26hozgento18>	re: e.g. if it contains comma, it may fail, or do something unintentional
T 1709988317 18<26hozgento18>	in this case what would be the solution ?
T 1709988343 18<28aesthetics18>	one should make a book from that wiki, and sell it
T 1709988364 18<25danza18>	probably already done
T 1709988374 18<26hozgento18>	because i think it has this problem now: DISPLAY="sdl,grab-mod=rctrl" the qemu works fine now but it seems like it doesn't recognize the display arg
T 1709988545 18<24geirha18>	if [[ $img_path = *[![:alnum:]/._-]* ]] ; then printf >&2 'image path should only consist of alphanumerics, slash, dot, underscore and hyphen: %s\n' "$img_path" ; exit 1 ; fi   # is one way. Just checking against a whitelist or characters
T 1709988592 18<24geirha18>	hozgento: Well, another issue with your code is the use of uppercase variable names. It's best avoided
T 1709988596 18<24geirha18>	!varcap
T 1709988596 18<29greybot18>	By convention, environment variables (PATH, EDITOR, SHELL, ...) and internal shell variables (BASH_VERSION, RANDOM, ...) are fully capitalized. All other variable names should be lowercase. Since variable names are case-sensitive, this convention avoids accidentally overriding environmental and internal variables. https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap08.html
T 1709988628 18<24geirha18>	DISPLAY happens to be an environment variable that tells X programs where they can find the X server, and you've overridden it with "garbage"
T 1709988710 18<26hozgento18>	ah interesting, thank you. i think i read it somewhere that the global vars should be in uppercase. total derp
T 1709988721 18<24geirha18>	!crap
T 1709988721 18<29greybot18>	The overwhelming majority of bash scripts, code, tutorials, and guides on the Internet are crap. Sturgeon was an optimist.
T 1709988745 18<26hozgento18>	lol agree
T 1709989119 18<24cheater18>	i'm doing some data recovery. i'm using grep -oba to find a string in a block device. i'm looking for the string "Profile = {". I know a file with this string exists on that block device (i just mounted it and checked). I know i'm selecting the right block device. however, grep isn't finding it. why isn't grep finding it?
T 1709989195 18<24cheater18>	and, can i use something other than grep?
T 1709989196 18<25ormaaj18>	grep isn't good for searching through binary garbage
T 1709989234 18<24cheater18>	i'm open to suggestions
T 1709989311 18<24cheater18>	the command i'm using is literally just `grep -oba 'Profile = {' /dev/nvme0n1p8 | tee -a found.log`
T 1709989335 18<25ormaaj18>	is it unencrypted and uncompressed
T 1709989342 18<25ormaaj18>	what filesystem
T 1709989344 18<25ormaaj18>	raid?
T 1709989349 18<25ormaaj18>	too many factors
T 1709989386 18<24cheater18>	none of that.
T 1709989394 18<24cheater18>	and the block device is fully healthy. i'm just trying to recover a file that was truncated by a program that crashed because the programmers are lamers
T 1709989399 18<24cheater18>	it's ext4
T 1709989413 18<25ormaaj18>	mount the device read-only
T 1709989419 18<26hozgento18>	geirha: works now as expected here is the full script: https://bpa.st/OEJA, thanks!
T 1709989427 18<24cheater18>	it's unmounted
T 1709989429 18<24cheater18>	it doesn't matter
T 1709989434 18<24cheater18>	it finds other strings, but not this one
T 1709989455 18<25ormaaj18>	trying to fish that out of a raw block device is insane
T 1709989638 18<24cheater18>	ok i don't think you know what you're talking about
T 1709989654 18<24cheater18>	maybe just don't talk if you're going to come up with bs like that thank you
T 1709989668 18<25ormaaj18>	lol
T 1709989701 18<25ormaaj18>	i'm not the idiot grepping through a block device for a random string
T 1709989895 18<28emanuele618>	lol  sudo grep -oba grep /dev/sda
T 1709990059 18<28emanuele618>	i tried   sudo grep -coba creatememfd /dev/sda   but i had to stop it because it was taking too long
T 1709990079 18<28emanuele618>	anyway many many thousands :o
T 1709990137 18<24cheater18>	it takes 15 minutes to scan the whole drive
T 1709990139 18<24cheater18>	so what?
T 1709990142 18<24cheater18>	that's not the fucking problem
T 1709990336 18<24cheater18>	there we fucking go, it actually found something. what do you know
T 1709990345 18<24cheater18>	wonder why it didn't previously
T 1709990356 18<25ormaaj18>	grep would likely tell them whether it's there. I'd use LC_CTYPE=C and probably just look for the offset. Wouldn't attempt to actually get the data back that way
T 1709990518 18<24cheater18>	actually i'm doing this to get the data back while read i; do skip="$(python3 -c "print($i//1024)")"; dd if=/dev/nvme0n1p8 of="$i".found bs=1K count=102 skip="$skip"; done < <(cat ../found.log | grep 'Profile = {' | cut -f1 -d:)
T 1709990559 18<25ormaaj18>	good grief
T 1709990590 18<28emanuele618>	you don't need to use CTYPE=C; -ob is enough
T 1709990607 18<24cheater18>	hell yea i found the data
T 1709990609 18<24cheater18>	it's great
T 1709990614 18<28emanuele618>	hell ye
T 1709990785 18<25ormaaj18>	maybe grep is better than bash. I don't trust random gnu tools to decode strings properly
T 1709990922 18<24cheater18>	there's nothing to "decode" here.
T 1709990926 18<24cheater18>	it's just ascii.
T 1709990943 18<28emanuele618>	i trust GNU grep grep -Paboe "$thing"\\x00   to give me the right offsets to hax:D
T 1709991048 18<25ormaaj18>	yeah they like to decode things whether you like it or not is the problem
T 1709991215 19*	Now talking on 22#bash
T 1709991215 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709991215 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709991237 18<28emanuele618>	-b will always give you a byte offset, not a character offset
T 1709991256 18<25ormaaj18>	ah
T 1709991389 18<25ormaaj18>	well it might give you a byte offset, i'm more concerned about the searching than getting back a wrong offset
T 1709991415 18<24cheater18>	you don't need to use -P
T 1709991432 18<24cheater18>	not for what i'm doing
T 1709991518 18<28emanuele618>	if the pattern is ascii, there is no way it can match it incorrectly
T 1709991638 18<25ormaaj18>	really? does it switch to searching bytes if the pattern looks like ascii?
T 1709991680 18<28emanuele618>	but also if it is utf-8 i think; because a utf-8 sequence always starts with 110xxxx 1110xxxx 11110xxx 111110xx or 1111110x followed by one or more 10xxxxxx   so if there is a valid utf-8 sequence it can always match it, because it would error at the first byte
T 1709991723 18<28emanuele618>	you would probably only need to set LC_ALL=C if you want to match something like -P '\x80\x80\x81'
T 1709991754 18<28emanuele618>	ormaaj: what do you mean?
T 1709991828 18<25ormaaj18>	what do you mean error at the first byte? :o
T 1709991842 18<28emanuele618>	actually \x80 \x80 is a bad example; i think it could even work if you don't set LC_ALL=C
T 1709991916 18<28emanuele618>	ormaaj: to look a character string, you use a function that given a string, tells you how long the next character is, and what its codepoint is
T 1709991927 18<28emanuele618>	s/look/loop/
T 1709992008 18<28emanuele618>	if you have an invalid utf-8 byte followed by a valid utf-8 sequence, it will still match it correctly, because it will recognise the invalid as one invalid byte, followed by the utf-8 sequence, there is nothing that makes it not work
T 1709992096 18<28emanuele618>	e.g. if you have  \xc3\xa8\x20\x73\x61\x62\x61\x74\x6f\x0a    grep will scan the string looking for '√® s'
T 1709992102 18<28emanuele618>	err
T 1709992117 18<28emanuele618>	e.g. if you have  \x80\xc3\xa8\x20\x73\x61\x62\x61\x74\x6f\x0a    and grep is scanning the string looking for '√® s'
T 1709992160 18<28emanuele618>	the first character is \x80 that is an invalid with value 0x80, of length one byte; it is not '√®', so grep keeps looking
T 1709992202 18<28emanuele618>	now it has    \xc3\xa8\x20\x73\x61\x62\x61\x74\x6f\x0a    (because it shifted 1 byte), and the next character is  \xc3\xa8  that is √®, and is long two bytes
T 1709992260 18<28emanuele618>	then it shifts 2, it has \x20\x73\x61\x62\x61\x74\x6f\x0a, and the first character is \x20 that is ' ' one byte, then the next character is \x73 that is 's' so you have a match
T 1709992336 18<28emanuele618>	an invalid byte in the file can never corrupt a following valid utf-8 sequence, or ascii character, because an invalid utf-8 can never contain a byte that could be part of a following valid utf-8 sequence
T 1709992478 18<25ormaaj18>	110xxxxx
T 1709992550 18<28emanuele618>	if you have  abc   and  ab is a invalid seqeunce, e.g. \xf8\xbc  that is invalid because \xf8 can only introduce a five byte utf-8 sequence  it is never possible that bc is valid because \xbc can never start a valid utf-8 sequence and it is not an ascii value
T 1709992598 18<28emanuele618>	you can always figure a utf-8 sequence is invalid before it overlaps a valid utf-8 sequence
T 1709992690 18<28emanuele618>	so whatever literal string you search it should always be fine even if you don't use C locale. the only reason you might want to do that is if you want . in  'a.\{12\}b'   to match 12 bytes and not 12 characters/invalid bytes
T 1709992773 18<28emanuele618>	hmm, actually, i think the BRE engine skips invalids, i don't remember, so .{12} may not work in any locale if you want 12 arbitrary bytes that could be >7f, anyway, for substrings, it is fine
T 1709993006 18<25ormaaj18>	heh yeah i never use the bre really
T 1709993022 18<22axet18>	hello! can I get linux CPU load average past minute / 5 mins? sesms proc/loadavg only show tasks not CPU
T 1709993424 18<28emanuele618>	i remember that sed does something weird with invalid sequences and ., but maybe it is sed specific; iirc sed has its own engine
T 1709993464 18<25ormaaj18>	if the top bit is zero it's one byte?
T 1709993501 18<28emanuele618>	if the top bit is zero, it is an ascii value (0x00-0x7f) so it is a one-byte character, yeah
T 1709993526 18<28emanuele618>	# sed 's/./a/g' <<< $'f\x80\xf9\xbc√®' | od -An -c
T 1709993529 18<25shbot18>	emanuele6:    a   a   a   a   a   a  \n
T 1709993540 18<28emanuele618>	oh, in C locale, it does not do the weird thing
T 1709993548 18<28emanuele618>	# LC_ALL=en_US.utf-8 sed 's/./a/g' <<< $'f\x80\xf9\xbc√®' | od -An -c
T 1709993551 18<25shbot18>	emanuele6:    a 200 371 274   a  \n
T 1709993557 18<28emanuele618>	# LC_ALL=en_US.utf-8 sed 's/../a/g' <<< $'f\x80\xf9\xbc√®' | od -An -c
T 1709993559 18<25shbot18>	emanuele6:    f 200 371 274 303 250  \n
T 1709993625 18<28emanuele618>	yeah, so . only matches valid characters, there it does not match f√® or $'f\x80' because $'\x80' is an invalid, and invalids are not skipped, they just cannot match .
T 1709993629 18<28emanuele618>	# LC_ALL=en_US.utf-8 sed 's/.\x80/a/g' <<< $'f\x80\xf9\xbc√®' | od -An -c
T 1709993631 18<25shbot18>	emanuele6:    a 371 274 303 250  \n
T 1709993638 18<28emanuele618>	it cannot match \x80 either
T 1709993668 18<28emanuele618>	GNU sed has \xXX (at least i know it has \x00)
T 1709993693 18<28emanuele618>	# LC_ALL=en_US.utf-8 grep -o '..' <<< $'f\x80\xf9\xbc√®' | od -An -c
T 1709993695 18<25shbot18>	emanuele6: no output
T 1709993711 18<28emanuele618>	it is the same in grep . will not match an invalid
T 1709993716 18<28emanuele618>	# grep -o '..' <<< $'f\x80\xf9\xbc√®' | od -An -c
T 1709993718 18<25shbot18>	emanuele6:    f 200  \n 371 274  \n 303 250  \n
T 1709993752 18<28emanuele618>	but in C locale, it does match it; so you can use   LC_ALL=C grep -ob 'a.{12}b'   to match a and b with 12 bytes in-between, yeah
T 1709993762 18<28emanuele618>	# grep -o '..' <<< $'f\x80\xf9\xbc√®x' | od -An -c
T 1709993764 18<25shbot18>	emanuele6:    f 200  \n 371 274  \n 303 250  \n
T 1709993782 18<28emanuele618>	oops, forgot LC_ALL=
T 1709993792 18<28emanuele618>	# LC_ALL=en_US.utf-8 grep -o '..' <<< $'f\x80\xf9\xbc√®x' | od -An -c
T 1709993793 18<25shbot18>	emanuele6:  303 250   x  \n
T 1709993813 18<28emanuele618>	# LC_ALL=en_US.utf-8 grep -o $'.\x80' <<< $'f\x80\xf9\xbc√®' | od -An -c
T 1709993815 18<25shbot18>	emanuele6:    B   i   n   a   r   y       f   i   l   e       (   s   t   a
T 1709993815 18<25shbot18>	emanuele6:    n   d   a   r   d       i   n   p   u   t   )       m   a   t
T 1709993815 18<25shbot18>	emanuele6:    c   h   e   s  \n
T 1709993826 18<28emanuele618>	# LC_ALL=en_US.utf-8 grep -ao $'.\x80' <<< $'f\x80\xf9\xbc√®' | od -An -c
T 1709993828 18<25shbot18>	emanuele6:    f 200  \n
T 1709993842 18<28emanuele618>	if you use $'.\x80' \x80 will match the invalid \x80
T 1709993856 18<28emanuele618>	# LC_ALL=en_US.utf-8 grep -a $'.\x80.' <<< $'f\x80√®' | od -An -c
T 1709993858 18<25shbot18>	emanuele6:    f 200 303 250  \n
T 1709993869 18<28emanuele618>	also in the middle of the string
T 1709993904 18<28emanuele618>	. matches any "valid" character then; not any "character" :)
T 1709993928 18<28emanuele618>	# LC_ALL=en_US.utf-8 sed $'s/.\x80/a/g' <<< $'f\x80\xf9\xbc√®' | od -An -c
T 1709993929 18<25shbot18>	emanuele6:    a 371 274 303 250  \n
T 1709993948 18<28emanuele618>	in GNU sed it works if you use $'\x80', but not if you use \x80 :o
T 1709993996 18<28emanuele618>	oh, maybe the GNU sed on shbot does not have \xXX support; on my PC it works with GNU sed 4.9
T 1709994141 18<28emanuele618>	it's the same with PCRE
T 1709994161 18<28emanuele618>	and ERE; . only matches valid characters
T 1709994247 18<28emanuele618>	in perl; a\x80b matches a.b just fine
T 1709994253 18<28emanuele618>	$ perl -E 'say "a\x80b" =~ /a.b/'
T 1709994255 18<28emanuele618>	1
T 1709994436 18<28emanuele618>	s/matched/is matched by/
T 1709994606 18<27mingdao18>	emanuele6: You abuse the hell out of this bot!
T 1709994631 18<27mingdao18>	Maybe /query shbot or something to keep from polluting the channel.  :^)
T 1709994908 18<28emanuele618>	mingdao: heh? you think that makes sense?
T 1709994962 18<28emanuele618>	i can just use my terminal if i want to see what a command does; i use shbot to show it to the channel.
T 1709995168 18<27mingdao18>	Aren't you special.  :^)
T 1709995628 18<19randomhero18>	bbbbbbbbbbbbbbbutthurt
T 1709995665 18<19randomhero18>	should have old quake multi-kill sound bites playing when he shows things using the shbot :-)
T 1709996379 18<22FakuVe18>	Hi there , I am in a quick need. Does anyone know how to sort an associative array by its keys alphabetically
T 1709997214 18<24ano18>	FakuVe: bash assoc arrays unsorted by design, there is no way to sort them
T 1709997517 18<22FakuVe18>	There has to be a way , algorithmicaly
T 1709997832 18<24ano18>	# declare -A assoc=([charlie]=x-ray [alfa]=zulu [bravo]=yankee); while IFS= read -rd '' key; do printf {%s} "$key"; done < <(printf %s\\0 "${!assoc[@]}" | sort -z)
T 1709997833 18<25shbot18>	ano: {alfa}{bravo}{charlie}
T 1709998036 18<22FakuVe18>	Ok
T 1709998047 18<22FakuVe18>	So you do it at the creation of the array
T 1709998123 18<24ano18>	FakuVe: nope, that's how read sorted via unportable (sort -z) assoc array keys one by one
T 1709998144 18<22FakuVe18>	Sorry for my hard understanding
T 1709998214 18<24ano18>	FakuVe: what are u trying to achieve, can u show some real example?
T 1709998228 18<22FakuVe18>	I need thisone to be sorted by keys
T 1709998230 18<22FakuVe18>	https://termbin.com/iebmy
T 1709998251 18<22FakuVe18>	Basically thats why I am using an associative array, so I can operate correctly with this kind of operations
T 1709998301 18<24ano18>	!check https://termbin.com/iebmy > FakuVe
T 1709998302 18<28checkbot18>	ano: Looks good to me
T 1709998324 18<24ano18>	!check https://termbin.com/iebmy
T 1709998325 18<28checkbot18>	ano: Line 1: Quote the parameter to -name so the shell won't interpret it. Line 1: Use ./*glob* or -- *glob* so names with dashes won't become options. Line 12: Double quote to prevent globbing and word splitting. See https://shellcheck.net/?id=cb98325 for all 6 issues.
T 1709998372 18<22FakuVe18>	buf
T 1709998566 18<22FakuVe18>	Ok I get
T 1709998584 18<22FakuVe18>	I get it . I will modify it for this globbing , basically quote all of them variables
T 1709998587 18<22FakuVe18>	But
T 1709998596 18<22FakuVe18>	Is there a way to sort this?
T 1709998605 18<22FakuVe18>	by their keys?
T 1709998633 18<24ano18>	>bash assoc arrays unsorted by design, there is no way to sort them
T 1709998708 18<22FakuVe18>	There has to be a way
T 1709998715 18<22FakuVe18>	Algorithmically
T 1709998723 18<22FakuVe18>	Or creating a new array
T 1709998725 18<22FakuVe18>	ordered
T 1709998759 18<22FakuVe18>	I see this
T 1709998761 18<22FakuVe18>	https://www.reddit.com/r/bash/comments/5wma5k/is_there_a_way_to_sort_an_associative_array_by/
T 1709998763 18<22FakuVe18>	Is not working for me
T 1709998773 18<22FakuVe18>	Is messing with the order in a different way
T 1709999096 18<25Lynx-18>	ano I understand that there is some saving by employing a file descriptor with file held open rather than >> inside while loop. Is there a similar kind of saving in respect of reading from a file inside a while loop? I am thinking specifically of reading from rx_bytes and tx_bytes "/sys/class/net/${dl_if}/statistics/tx_bytes"
T 1709999179 18<25Lynx-18>	And thanks for your input yesterday regarding the file descriptor / truncation issue. I managed to shave a few percent in CPU run time by switching to buffered reads and using file descriptor.
T 1709999324 18<24ano18>	FakuVe: if u mean KnowsBash solution, it doesn't sort assoc array itself but put sorted assoc array keys in new indexed array, u can then iterate over that "${sorted[@]}" indexed array
T 1709999502 18<22FakuVe18>	yeah I have discovered it
T 1709999525 18<22FakuVe18>	printf "%s\n" "${!colors[@]}" | sort -t = -k 1
T 1709999529 18<22FakuVe18>	oops sorry
T 1709999534 18<22FakuVe18>	mapfile -t sorted_links_to_paths < <(printf "%s\n" "${!links_to_paths[@]}" | sort -t = -k 1)
T 1709999549 18<22FakuVe18>	Then you need to iterate through this array , and use the associativbe array accordingly
T 1709999583 18<22phogg18>	that's the normal way to sort a hash in any language
T 1709999692 18<22FakuVe18>	good to know hehe
T 1710000528 18<24ano18>	Lynx-: /sys is sysfs is pseudo fs, doubt there is a way to keep it open and continuously read somehow, afaik such files should be reopened every time per read
T 1710000862 18<22FakuVe18>	That is amazing mio brother
T 1710001915 18<29nvz18>	Lynx-: yes sysfs is different than a normal filesystem in that it allows userland access to kernel space data, when you read from userland the kernel is creating a buffer and transferring kernel space data into userspace and I'm not intimately familiar but I believe its more a one-shot thing done when openeing and reading, so if you want to poll, you need to continually reopen the file
T 1710001949 18<29nvz18>	Lynx-: however if you're programming around it, you can likely use a library designed for sysfs rather than accessing it through the filesystem like its a normal file
T 1710002059 18<25Lynx-18>	don't suppose any of you know about file recovery in ubifs?
T 1710002062 18<29nvz18>	Lynx-: these sorts of memory-backed "filesystems" are essentially created on the fly and don't have a similar persistent state like normal files
T 1710002114 18<25Lynx-18>	I wrote over file in error and wondering if I can recover it. I have the UBI mtdblock file
T 1710007285 18<25ormaaj18>	!m
T 1710007285 18<29greybot18>	üêÑ
T 1710007549 18<28emanuele618>	!o
T 1710007549 18<29greybot18>	üêÆ
T 1710007629 18<28emanuele618>	√†
T 1710009283 22*	26ChanServ gives channel operator status to 18geirha
T 1710009287 22*	26geirha sets ban on 18docmax*!*docmax@*$##fix_your_connection
T 1710009287 22*	26geirha removes ban on 18golu*!*golu@*$##fix_your_connection
T 1710009287 22*	26geirha removes channel operator status from 18geirha
T 1710009495 18<20bent_fingers18>	# echo -e "\x00" | sed 's/\x00/+/'
T 1710009497 18<25shbot18>	bent_fingers: +
T 1710010168 18<20no_gravity18>	Any downside to mapping "grep" to "grep -P"? I think I would always want PCRE. Or am I missing something?
T 1710010196 18<20bent_fingers18>	youre choice
T 1710010210 18<20bent_fingers18>	you mean with an alias?
T 1710010276 18<20no_gravity18>	Yup
T 1710010288 18<20bent_fingers18>	then it's fine
T 1710010307 18<20no_gravity18>	For ls for example I use: alias ls='ls -Alhv --color --time-style=long-iso --group-directories-first'
T 1710010329 18<20twkm18>	you might be surprised if you copy&paste suggestions without translating a bre to pcre.
T 1710010338 18<20no_gravity18>	True
T 1710010347 18<26lopid18>	might as well use pcregrep or pcre2grep
T 1710010363 18<20bent_fingers18>	the man page says treating null data `-z` is experimental with grep -P
T 1710010368 18<20no_gravity18>	lopid: Any benefit of doing that?
T 1710010396 18<26lopid18>	grep -P, "this option is experimental"
T 1710010422 18<26lopid18>	little doubt the proper one has better support
T 1710010481 18<24geirha18>	I vote for "grepp"
T 1710010503 18<20no_gravity18>	How about "preg"?
T 1710010664 18<24geirha18>	gre√û
T 1710010703 18<27JAA18>	PCRE is also significantly slower than the other options in grep. And you wouldn't be able to override it directly, you'd have to use `\grep -F` to bypass the alias.
T 1710010784 18<27JAA18>	From the now-deprecated `fgrep` and `egrep`, it should be `pgrep`, but that's another thing already. :-/
T 1710010867 18<20no_gravity18>	# time for i in {1..1000}; do echo $RANDOM | grep 123; done
T 1710010874 18<25shbot18>	no_gravity: no output within the time limit
T 1710010882 18<20no_gravity18>	2.068s here
T 1710010889 18<20no_gravity18>	# time for i in {1..1000}; do echo $RANDOM | grep -P 123; done
T 1710010896 18<25shbot18>	no_gravity: 12347
T 1710010908 18<20no_gravity18>	2.133s here
T 1710010909 18<27JAA18>	That's going to be dominated by the loop and forking and grep startup.
T 1710010930 18<20no_gravity18>	# time for i in {1..100}; do echo $RANDOM | grep 123; done
T 1710010937 18<25shbot18>	no_gravity: no output within the time limit
T 1710010944 18<20no_gravity18>	# time for i in {1..100}; do echo $RANDOM | grep -P 123; done
T 1710010950 18<25shbot18>	no_gravity: no output within the time limit
T 1710010963 18<20no_gravity18>	shbot can't do 100 greps?
T 1710010967 18<27JAA18>	Try something like `time seq 10000000 | grep -P 123 | cat >/dev/null`. (The `cat` is needed at least with GNU grep.)
T 1710011012 18<20no_gravity18>	JAA: 0.276s
T 1710011021 18<27JAA18>	-P takes about 4 times as long as -F here.
T 1710011027 18<20no_gravity18>	0.081s without the P
T 1710011030 18<20no_gravity18>	Yeah
T 1710011030 18<28emanuele618>	cat is needed for what?
T 1710011036 18<27JAA18>	No option and -E are between.
T 1710011056 18<28emanuele618>	cat just makes it run slower for me
T 1710011072 18<20no_gravity18>	But 10M greps in 0.3s is still fast.
T 1710011075 18<27JAA18>	emanuele6: For an accurate time measurement. It appears that GNU grep has some optimisation when you redirect to /dev/null, so you get a much faster time than it would actually take in a real setting.
T 1710011116 18<20no_gravity18>	Real setting: time seq 10000000 | grep -P 123 | wc
T 1710011121 18<20no_gravity18>	0.279s
T 1710011129 18<20no_gravity18>	0.081s without the P
T 1710011139 18<20no_gravity18>	So the /dev/null seems to have no impact.
T 1710011149 18<28emanuele618>	 $ printf %s\\n '' 'foo' | strace -qqewrite -efd=1 grep foo >/dev/null
T 1710011153 18<28emanuele618>	nothing at all
T 1710011155 18<28emanuele618>	vov
T 1710011197 18<20no_gravity18>	time seq 10000000 | grep -P '^1.*2$' | wc
T 1710011199 18<27JAA18>	I wonder if it just activates -q quietly.
T 1710011206 18<20no_gravity18>	0.308s
T 1710011213 18<20no_gravity18>	Holy cow that thing is fast.
T 1710011264 18<27JAA18>	The /dev/null thing matters more when your processing takes a while. 0.3 s is probably too short to see much of a difference.
T 1710011266 18<28emanuele618>	JAA: -q would change the behaviour of the command, it probably just consumes the input after the first match though
T 1710011282 18<27JAA18>	Ah, yeah.
T 1710011295 18<27JAA18>	`exec cat` :-)
T 1710011327 18<28emanuele618>	to save writes, you run a program that writes after every read with no buffering? :o
T 1710011416 18<27JAA18>	`time seq 100000000 | grep 1 >/dev/null` = 0.8 seconds, `time seq 100000000 | grep 1 | cat >/dev/null` = 4.3 seconds
T 1710011425 18<27JAA18>	That's more like it.
T 1710011442 18<27JAA18>	I've seen an order of magnitude before, too.
T 1710011503 18<20no_gravity18>	Ok, thanks for the infos! Cu!
T 1710011538 18<28emanuele618>	time seq 100000000 | grep 1 >/dev/null = 1.2s   time seq 100000000 | grep 1 | cat >/dev/null = 6.2s
T 1710011554 18<28emanuele618>	time seq 100000000 | grep -q 1 = 0.007s :)
T 1710011648 18<27JAA18>	:-)
T 1710012277 18<28emanuele618>	cat does not optimise >/dev/null
T 1710012281 18<28emanuele618>	:\
T 1710012334 18<28emanuele618>	i guess you can use  sed -n ''  as more efficient  cat >/dev/null
T 1710012365 18<29phy172918>	!uuoc
T 1710012365 18<29greybot18>	Useless Use Of Cat (cat foo | grep bar). See https://mywiki.wooledge.org/BashFAQ/119 and http://www.iki.fi/era/unix/award.html#cat
T 1710012424 18<28emanuele618>	or  grep ^  :o
T 1710013741 18<20bent_fingers18>	emanuele6: cat is needed to reverse tac
T 1710013865 18<28emanuele618>	need a positive to cancel a negative as they say
T 1710022914 18<24cart18>	Is there a tool that adds a specific string to a specific line of a text file and shifts the rest of the strings down one line?
T 1710022971 18<27xx18>	sed?
T 1710022979 18<27koollman18>	yes, sed could do that. the syntax is not really intuitive, but it works
T 1710023087 18<27koollman18>	cart: (echo foo; echo bar; echo baz; echo quux) | sed '3i hello'
T 1710023137 18<27koollman18>	(works also with a instead of i, to add after rather than before)
T 1710023171 18<27JAA18>	I'd probably do it with AWK if only because my brain refuses to understand sed's syntax beyond simple substitute.
T 1710023185 18<24cart18>	koollman: Ok wait what does that do? add echo foo \n echo bax \n echo quux \n  ?
T 1710023205 18<20bent_fingers18>	there's no way to change the default regextype of `find` so that it only has to be set once for all instances?
T 1710023207 18<24cart18>	koollman: Ohh nvm I just ran it
T 1710023227 18<20bent_fingers18>	cart: sed
T 1710023325 18<20bent_fingers18>	i suppose i could use fd
T 1710023405 18<24cart18>	koollman: Ok so how do I use sed on a file?
T 1710023422 18<28bprompt18>	cart:    3i, for before line 3, and 3a for after it
T 1710023464 18<20bent_fingers18>	sed 'do stuff' file
T 1710023465 18<27JAA18>	# printf '%s\n' foo bar >file; sed '2i ohai'; paste - - - <file
T 1710023472 18<25shbot18>	JAA: no output within the time limit
T 1710023478 18<27JAA18>	‡≤†_‡≤†
T 1710023496 18<27JAA18>	Oh
T 1710023497 18<20bent_fingers18>	cart: https://www.grymoire.com/Unix/Sed.html#uh-0
T 1710023501 18<28bprompt18>	heheh
T 1710023503 18<27JAA18>	# printf '%s\n' foo bar >file; sed -i '2i ohai' file; paste - - - <file
T 1710023506 18<25shbot18>	JAA: foo     ohai    bar
T 1710023508 18<20bent_fingers18>	cart: https://www.pement.org/sed/sedfaq.html
T 1710023516 18<27JAA18>	It would help to use sed correctly.
T 1710023527 18<28emanuele618>	( Õ°¬∞ Õú ñ Õ°¬∞)
T 1710023543 18<20bent_fingers18>	haha
T 1710023559 18<28bprompt18>	cart:  pretty much that command, just simply append the filename
T 1710023593 18<27JAA18>	And, in the command I showed, -i for inplace editing, although you'll probably want to specify a backup suffix.
T 1710023595 18<27koollman18>	as show by others, -i to modify the file, and you can even use -i.bak to also create a backup named file.bak (often a good idea)
T 1710023604 18<27JAA18>	Heh
T 1710023619 18<27koollman18>	and don't do stuff like sed < file > file ... because then you have lost your file content :)
T 1710023647 18<20bent_fingers18>	is the ability for `.` to match a null in regex generally favorable over not matching a null?
T 1710023658 18<27JAA18>	What's a 'null'?
T 1710023665 18<27larryv18>	NUL, presumably
T 1710023670 18<27JAA18>	Ah, yeah
T 1710023671 18<20bent_fingers18>	so many regex types, dunno which to use
T 1710023679 18<20houseparty18>	sed
T 1710023682 18<28emanuele618>	vim regexps are best
T 1710023691 18<27JAA18>	I like PCRE-ish.
T 1710023693 18<28emanuele618>	it has funny sequences like \@<=
T 1710023696 18<20bent_fingers18>	the gnu docs use the locution "null character"
T 1710023700 18<28bprompt18>	yeap, Perl is Da Bomb
T 1710023703 18<20houseparty18>	She sed he wears short shorts
T 1710023711 18<27koollman18>	bent_fingers: 'it depends'
T 1710023715 18<28emanuele618>	that is (?<=) but you use it backwards
T 1710023730 18<27JAA18>	Lookarounds are awesome.
T 1710023741 18<27JAA18>	My favourite are nested negative lookarounds. :-)
T 1710023746 18<20bent_fingers18>	i know they are
T 1710023747 18<28emanuele618>	\(abc\)\@<=  for  (?<=abc)
T 1710023760 18<27JAA18>	Too many backslashes >:-(
T 1710023799 18<24cart18>	Basically something like     printf '%s\n' libparted/arch/linux.c >file; sed -i '3i #include <sys/sysmacros.h>' file; paste - - - <file
T 1710023801 18<28emanuele618>	\v([[)@<=
T 1710023808 18<28emanuele618>	too few backslashes?
T 1710023815 18<24cart18>	I want it to replace the file -> libparted/arch/linux.c
T 1710023823 18<25vanfanel6418>	I noticed that bash allows redefining fuctions, with no warning or anything:
T 1710023824 18<25vanfanel6418>	# foo() { echo ABC; }; foo; foo() { echo DEF; }; foo;
T 1710023826 18<25shbot18>	vanfanel64: ABC
T 1710023826 18<25shbot18>	vanfanel64: DEF
T 1710023839 18<27larryv18>	cart: the paste command was just for demonstration
T 1710023841 18<25vanfanel6418>	Is there a way to make it warn?
T 1710023843 18<28emanuele618>	i meant  \v(abc)@<=
T 1710023850 18<25vanfanel6418>	When a function exists
T 1710023870 18<28emanuele618>	you cannot make bash warn you about function redefinition
T 1710023885 18<25vanfanel6418>	@< looks like a duck and the = is like a comic-like visualizing of sound (quaking)
T 1710023907 18<28emanuele618>	that is precisely why vim regexps are the best kind of regexps
T 1710023916 18<20bent_fingers18>	anyhow, gnu find doesn't have sed or pcre regex types
T 1710023933 18<25vanfanel6418>	emanuele6, that and Perl's regex support is unmatched
T 1710023944 18<27JAA18>	This should match leap years: ^(?!(?![2468][048]|[13579][26])\d{2}00)\d{2}([02468][048]|[13579][26])$
T 1710023946 18<27larryv18>	bent_fingers: i would just use whatever the default is so i don't have to specify it every time, unless it literally is not suitable for the job
T 1710023957 18<20bent_fingers18>	actually, my version does have sed regextype, but it's not documented https://www.gnu.org/software/findutils/manual/html_node/find_html/Regular-Expressions.html
T 1710023977 18<20bent_fingers18>	larryv: the default requires too many backslashes
T 1710023988 18<27larryv18>	get over it
T 1710023989 18<20bent_fingers18>	too ugly for me
T 1710024017 18<25vanfanel6418>	So is it possible to make bash complain about function redefinitions?
T 1710024025 18<27Earnestly18>	vanfanel64: dynamic function redefinition is one of its rare strengths
T 1710024030 18<28emanuele618>	there is no option to do that
T 1710024034 18<27JAA18>	I use `... | perl -pe 's/x/y/' | ...` sometimes for 'sed but with good regexes'.
T 1710024080 18<28emanuele618>	sed, but the last character of the pattern space is newline
T 1710024106 18<25vanfanel6418>	Earnestly, I agree that it is a strench/good thing normally, but sometimes I want to know if I writing a function that might alreay exist, like when sourcing a bash file full of functions, like typo or forgot there was a foo in there
T 1710024158 18<28emanuele618>	so stronk
T 1710024187 18<27Earnestly18>	vanfanel64: I don't think that's a reasonable requirement because the same could apply to overriding any command, from PATH or otherwise, which a shell is intended to do. You could check if a function exists every time you define one, but that /is/ a stench
T 1710024204 18<25vanfanel6418>	emanuele6, stronk, as in getting stuck in the head?
T 1710024239 18<28emanuele618>	stronk is strength as an adjective
T 1710024258 18<25vanfanel6418>	Earnestly, comamnds and functions are separate things, with some similar attributes (like $@/$*, $1, $2... args)
T 1710024262 18<27Earnestly18>	vanfanel64: They are not
T 1710024272 18<25vanfanel6418>	huh
T 1710024277 18<25vanfanel6418>	they are not the same
T 1710024300 18<25vanfanel6418>	a command is a whole program, a function is a shell-wise reusable piece of code
T 1710024336 18<25vanfanel6418>	s/piece/chunk/
T 1710024347 18<28emanuele618>	stroink is a C function that extracts pigs from strings
T 1710024388 18<27Earnestly18>	vanfanel64: They are the same thing; you're applying programming language logic to a shell and trying to treat it like one which always leads to trouble
T 1710024408 18<25vanfanel6418>	emanuele6, does it handle wild hogs too?
T 1710024422 18<27Earnestly18>	vanfanel64: Especially when users think they can turn scripts into "libraries"
T 1710024433 18<28emanuele618>	in sh, a command is a statement
T 1710024479 18<25vanfanel6418>	Earnestly, you are mainly right, though I only wanted to know if a function was already defined
T 1710024493 18<28emanuele618>	this everrepeating programming language troll is so boring because the definition of command is made up to fit whatever you want to say
T 1710024502 18<27Earnestly18>	vanfanel64: The only practical difference, which is unfortunate, is when trying to use functions in bernstein chains that expect an exec(3), but then it might be worth turning your function into a ./script and calling it without modification
T 1710024503 18<25vanfanel6418>	emanuele6, ah, I mistakenly took command as program
T 1710024527 18<27Earnestly18>	vanfanel64: You can only test before defining it
T 1710024561 18<28emanuele618>	vanfanel64: it is fine to call programs command, but Earnestly is pretending as usual that it means something else, and that you are wrong, etc, etc, to say the same thing they always say
T 1710024703 18<27Earnestly18>	vanfanel64: (A command is a program)
T 1710024849 18<25vanfanel6418>	Ah, there IS a way!
T 1710024853 18<25vanfanel6418>	# foo() { echo ABC; }; foo; readonly -f foo; foo() { echo DEF; }; foo
T 1710024855 18<25shbot18>	vanfanel64: ABC
T 1710024855 18<25shbot18>	vanfanel64: bash: foo: readonly function
T 1710024855 18<25shbot18>	vanfanel64: ABC
T 1710024880 18<25vanfanel6418>	I would only use this in very limited situations, granted, but it is good to know
T 1710024897 18<28emanuele618>	i didn't know that :o
T 1710024917 18<28emanuele618>	i guess that is a little different, you have to specify the functions you don't want to redefine
T 1710024926 18<27Earnestly18>	vanfanel64: I thought you wanted to check if a function was already defined? I suppose you could use the exit status of readonly -f if it doesn't
T 1710024995 18<27Earnestly18>	it doesn't/it isn't already defined
T 1710025023 18<25vanfanel6418>	Earnestly, I was wondering if there was a way to make bash warn about redefinition attempts, and this effectively does that
T 1710025057 18<27Earnestly18>	In a roundabout way, yeah
T 1710025094 18<27Earnestly18>	vanfanel64: It also prevents you from actually redefining it if you decided to do so later on in the script
T 1710025160 18<27Earnestly18>	vanfanel64: As in, bash has type -t which can print 'function' if it is so
T 1710025745 18<25ormaaj18>	remember tacgnol the evil longcat
T 1710026476 19*	Now talking on 22#bash
T 1710026476 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1710026476 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1710026480 18<28emanuele618>	some tools have \< to match start of word boundary, \> for end of word boundary, and \b for either \< or \> boundaries
T 1710026503 18<28emanuele618>	less only has \b, so you need to remember to use that in less :/
T 1710026565 19*	Now talking on 22#bash
T 1710026565 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1710026565 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1710026588 18<28emanuele618>	it does not work in other standard tools though
T 1710026604 18<28emanuele618>	hleneto: hmm, maybe i am thinking of another tool; i remember there is one in which you must use \b
T 1710026628 18<28emanuele618>	it is less! \< does not work in my less
T 1710026635 18<28emanuele618>	are you sure you are using less?
T 1710026857 19*	Now talking on 22#bash
T 1710026857 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1710026857 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1710027100 19*	Now talking on 22#bash
T 1710027100 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1710027100 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1710027160 18<28emanuele618>	oh, it is not a patch, less can be built with different regex engines
T 1710027221 18<25hleneto18>	emanuele6, that explains it then.
T 1710027242 18<28emanuele618>	the archlinux package uses pcre2 instead of the default which would use glibc regular expressions :/
T 1710027382 18<28emanuele618>	debian is using gnu regexps
T 1710027396 18<20bent_fingers18>	any trick to omit binaries from the results of find?
T 1710027408 18<28emanuele618>	archlinux packages are lame :/
T 1710027420 18<20bent_fingers18>	we told you to switch to gentoo
T 1710027424 18<20bent_fingers18>	but you're stubborn
T 1710027440 18<28emanuele618>	they chose to randomly make one of the standard tools use a different regex flavour \:
T 1710027469 18<28emanuele618>	bent_fingers: you mean like programs?
T 1710027518 18<20bent_fingers18>	the ones that yield this in `file` --> ELF 64-bit LSB executable
T 1710027539 18<28emanuele618>	oh, hmm
T 1710027549 18<20bent_fingers18>	programs, yes
T 1710027562 18<27Earnestly18>	bent_fingers: Check if the file contains a NUL byte
T 1710027567 18<20bent_fingers18>	aren't scripts programs? well, that's besides the point
T 1710027585 18<27Earnestly18>	The presence of a NUL is what defines a binary
T 1710027601 18<20bent_fingers18>	ok, thanks
T 1710027618 18<28emanuele618>	bent_fingers: you could call file for each file with    -exec sh -c 'case $(file -b "$1") in ELF*) false; esac' _ {} \;
T 1710027642 18<28emanuele618>	like    find .... -exec sh -c 'case $(file -b "$1") in ELF*) false; esac' _ {} \; -print   for example
T 1710027649 18<28emanuele618>	# type file
T 1710027650 18<27Earnestly18>	bent_fingers: Keep in mind that it'll include tar files, etc. But that's the heuristic tools use (like gnu grep). Ideally you'd just handle them in the same pipeline
T 1710027652 18<25shbot18>	emanuele6: file is /bin/file
T 1710027668 18<28emanuele618>	# find /bin -exec sh -c 'case $(file -b "$1") in ELF*) false; esac' _ {} \; -print | paste -s -
T 1710027674 18<25shbot18>	emanuele6: no output within the time limit
T 1710027684 18<28emanuele618>	hmm
T 1710027718 18<28emanuele618>	# find -L /bin -type f -exec sh -c 'case $(file -b "$1") in ELF*) false; esac' _ {} \; -print
T 1710027724 18<25shbot18>	emanuele6: /bin/gawk
T 1710027724 18<25shbot18>	emanuele6: /bin/rev
T 1710027724 18<25shbot18>	emanuele6: /bin/bunzip2
T 1710027749 18<28emanuele618>	those are the only non elfs in /bin on shbot :o
T 1710027760 18<27Earnestly18>	Alternatively you could use fine-free-file which has -00 and --mime-type (and -b) and just parse that output
T 1710027761 18<28emanuele618>	since when shbot has bunzip2??
T 1710027775 18<28emanuele618>	and why does gawk have a wrapper?
T 1710027856 18<28emanuele618>	# type gunzip
T 1710027857 18<25shbot18>	emanuele6: gunzip is /bin/gunzip
T 1710027872 18<28emanuele618>	wow, i completely missed that shbot had decompression stuff
T 1710027883 18<28emanuele618>	a world of new possibilities has opened up
T 1710027930 18<28emanuele618>	i don't know what the /bin/gawk is; it is not on shbot-initramfs
T 1710027941 18<28emanuele618>	# cat /bin/gawk
T 1710027946 18<25shbot18>	emanuele6: ELF>ÔøΩÔøΩ@Pr
T 1710027946 18<25shbot18>	emanuele6: @8   @@@@ÔøΩÔøΩ888
T 1710027946 18<25shbot18>	emanuele6: etc... ( http://paste.wooledge.org/29392 )
T 1710027956 18<28emanuele618>	huh?
T 1710027962 18<28emanuele618>	# file -b /bin/gawk
T 1710027963 18<25shbot18>	emanuele6: symbolic link to gawk5
T 1710027981 18<28emanuele618>	oh, oops
T 1710028001 18<28emanuele618>	# find /bin -type f -exec sh -c 'case $(file -b -- "$1") in ELF*) false; esac' _ {} \; -print
T 1710028008 18<25shbot18>	emanuele6: /bin/rev
T 1710028008 18<25shbot18>	emanuele6: /bin/bunzip2
T 1710028034 18<28emanuele618>	# find /usr/bin -type f -exec sh -c 'case $(file -b -- "$1") in ELF*) false; esac' _ {} \; -print | paste - - -
T 1710028037 18<25shbot18>	emanuele6: /usr/bin/jq     /usr/bin/loadables      /usr/bin/bashlib
T 1710028037 18<25shbot18>	emanuele6: /usr/bin/ls
T 1710028046 18<24geirha18>	hum, no idea why bunzip2 was added
T 1710028085 18<28emanuele618>	on shbot-initramfs gunzip is a script that calls gzip, but, on shbot, it is an elf
T 1710028104 18<28emanuele618>	# file /bin/gunzip
T 1710028106 18<25shbot18>	emanuele6: /bin/gunzip: POSIX shell script, ASCII text executable
T 1710028111 18<28emanuele618>	hmm, nevermind
T 1710028118 18<28emanuele618>	why does the file command not print it then?
T 1710028198 18<28emanuele618>	# ls -dl /bin/gunzip
T 1710028200 18<25shbot18>	emanuele6: -rwxrwxr-x 1 root root 33 Mar 13  2021 /bin/gunzip
T 1710028293 18<28emanuele618>	maybe it times out
T 1710028350 18<28emanuele618>	yeah, that is why it didn't print anything when i used paste -s - earlier
T 1710028395 18<20bent_fingers18>	to organize my scripts into sections I could put a label "Variables" over the grouping of variables, "Functions" over the grouping of functions, but what how can i categorize the last part of my script where i actually run the stuff?
T 1710028397 18<20bent_fingers18>	code?
T 1710028520 18<28emanuele618>	the big brain idea is to declare a main function and put in under function, and then just call   main "$@"   at the bottom
T 1710028533 18<28emanuele618>	so you don't have to come up with a name for a new section!
T 1710028556 18<20bent_fingers18>	oh yeah, i've seen that
T 1710028764 18<28emanuele618>	yay!
T 1710028794 18<28emanuele618>	with bzip2 the 13kB loadable i was able to create last time is just 693 B!
T 1710028801 18<25OMGOMG18>	isn't it pretty obvious already what's variables and what's functions
T 1710028854 18<28emanuele618>	what if you declare a variable in a function?
T 1710028872 18<28emanuele618>	is there a nested ## Variables comment?
T 1710028962 18<28emanuele618>	693bytes is still far too big though :/
T 1710029007 18<28emanuele618>	maybe if i make strings shorter in the builtin it improves
T 1710029230 18<20bent_fingers18>	another script done
T 1710029286 18<20bent_fingers18>	OMGOMG: sure, but i find my eyes alighting on the target more readily with sections
T 1710029301 18<20bent_fingers18>	i don't use syntax highlighting cuz i'm colorblind
T 1710029668 18<28emanuele618>	it definitely helps, but it is still 588B
T 1710029773 18<28emanuele618>	removing sections helped, 541B
T 1710029829 18<28emanuele618>	539
T 1710030054 18<28emanuele618>	hmm, i got it to 510B; then i removed even more stuff (to the point that the builtin is named "", and if use help "", it will crash bash), and it became 531B D:
T 1710031100 19*	Now talking on 22#bash
T 1710031100 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1710031100 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1710031109 18<28emanuele618>	i have noticed that if i remove stuff from the end of the elf it keeps wroking
T 1710031145 18<28emanuele618>	i am blindly trimming random stuff from the end of the elf until it does not work anymore :D
T 1710031184 18<28aesthetics18>	... that colorscheme is actually quite nice
T 1710031190 18*	28aesthetics stfu
T 1710031304 18<28emanuele618>	lmao 258 bytes with gzip!
T 1710031606 18<28emanuele618>	# x=H4sIALEB7WUAA+3ZsRLBQBAG4E0kQhQxGjoeQUljNFQaKh0zVBqGqHkMr+A5NB7BCyh0GoVG5NgdyY3JSGv+r/DbvVvJaW/T6XVNwyCRoRZ9KqI257gW7TXIDj9dyr/2WpSg+D3VXFaVVW5reaV4Rucc9UXeR8syxVPmzJTPy3EOzv7USjFnRNKM1EJ6cn6i7bvJvYvd31MCtacUvp1T0xZGK3+5nvhSyrqcQ/4fT+sb+u8AAAAAAAAAAAAAAAAAAPwJucse8sXt7RHMVS64tnn9yHWW6x3XLtd5zgJnhdPhPPF+uYeta3Oy/x68n2+mO8bvZs2hZx/cJ157F5EIIAAA ksh -c 'typeset -b y;print -nv x>f';enable -f./f ''
T 1710031607 18<25shbot18>	emanuele6: bash: enable: cannot open shared object ./f: ./f: invalid ELF header
T 1710031620 18<28emanuele618>	the bash on shbot does not like that i truncated the elf :/
T 1710031667 18<28emanuele618>	oh, i am stupid; i need to decompress it
T 1710031847 18<25kurahaupo18>	bent_fingers: depending on how you define "word boundary", you can match "beginning of line or non-word character" immediately before a "word character"; e.g. sed 's#\(^\|[[:space:]]\)\([[:alnum:]][_[:alnum:]]*\)#\1matched(\2)#g'
T 1710031928 19*	Now talking on 22#bash
T 1710031928 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1710031928 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1710032555 18<20bent_fingers18>	aesthetics: i made a coloblind scheme; actually my main problem is `micro` doesn't support tree-sitter or language-server yet
T 1710032664 18<20bent_fingers18>	kurahaupo: good to know
T 1710033024 18<28emanuele618>	:D
T 1710033069 18<28emanuele618>	i had to increase the split_msg_max_length setting in weechat, because i didn't have any space left to write any code
T 1710033075 18<28emanuele618>	# ksh<<<'typeset -b x=H4sIALEB7WUAA+3ZsRLBQBAG4E0kQhQxGjoeQUljNFQaKh0zVBqGqHkMr+A5NB7BCyh0GoVG5NgdyY3JSGv+r/DbvVvJaW/T6XVNwyCRoRZ9KqI257gW7TXIDj9dyr/2WpSg+D3VXFaVVW5reaV4Rucc9UXeR8syxVPmzJTPy3EOzv7USjFnRNKM1EJ6cn6i7bvJvYvd31MCtacUvp1T0xZGK3+5nvhSyrqcQ/4fT+sb+u8AAAAAAAAAAAAAAAAAAPwJucse8sXt7RHMVS64tnn9yHWW6x3XLtd5zgJnhdPhPPF+uYeta3Oy/x68n2+mO8bvZs2hZx/cJ157F5EIIAAA;printf %B x'|gunzip>f;enable -f./f '';enable '';printf hi;'';printf \ hello;'';printf \ -
T 1710033076 18<25shbot18>	emanuele6: hi hello - hello - - -
T 1710033094 18<28emanuele618>	it is a loadable named '' that calls fork() :D
T 1710033119 18<28emanuele618>	that is the first ever loadable builtin uploaded to shbot via an irc message i think
T 1710033315 18<28emanuele618>	thank you for including gzip and bzip2 in shbot! without them, it would have been impossible
T 1710033577 18<20bent_fingers18>	smh
T 1710033577 18<27JAA18>	# type zstd
T 1710033579 18<25shbot18>	JAA: bash: type: zstd: not found
T 1710033581 18<27JAA18>	Lame
T 1710033616 18<20bent_fingers18>	shbot dislikes facebook
T 1710033623 18<28aesthetics18>	emanuele6: what were you "blindly trimming" ? does it means ELFs have some "useless" garbage at the bottom of the file ?
T 1710033695 18<28emanuele618>	stuff bash does not use when loading the shared elf as loadable, not necessarily useless...
T 1710033714 18<28aesthetics18>	oh ok!
T 1710033735 18<28emanuele618>	anyway shared elfs are huge, they are not just code and an elf header like regular elfs
T 1710033816 18<20bent_fingers18>	regular elfs help make toys
T 1710033849 18<28emanuele618>	shared elf share their toys to avoid having to make new ones
T 1710033913 18<27JAA18>	Wouldn't that be a sharing elf?
T 1710033934 18<28emanuele618>	those don't exist!
T 1710034416 18<28emanuele618>	# PS1=;ksh<<<'typeset -b x=H4sIALEB7WUAA+3ZsRLBQBAG4E0kQhQxGjoeQUljNFQaKh0zVBqGqHkMr+A5NB7BCyh0GoVG5NgdyY3JSGv+r/DbvVvJaW/T6XVNwyCRoRZ9KqI257gW7TXIDj9dyr/2WpSg+D3VXFaVVW5reaV4Rucc9UXeR8syxVPmzJTPy3EOzv7USjFnRNKM1EJ6cn6i7bvJvYvd31MCtacUvp1T0xZGK3+5nvhSyrqcQ/4fT+sb+u8AAAAAAAAAAAAAAAAAAPwJucse8sXt7RHMVS64tnn9yHWW6x3XLtd5zgJnhdPhPPF+uYeta3Oy/x68n2+mO8bvZs2hZx/cJ157F5EIIAAA;printf %B x'|gunzip>f;enable -f./f '';enable '';printf 1;eval "'' "{1..5}\;;printf 0
T 1710034423 18<25shbot18>	emanuele6: 100000000000000000000000000000000
T 1710034434 18<28emanuele618>	that is 2**(2**5) in binary!
T 1710034610 18<25ormaaj18>	:o
T 1710035115 18<20arraybolt318>	emanuele6: so wait, the maximum IRC message length is enforced by the client, not the server?
T 1710035135 18<20arraybolt318>	I figured sending messages that big would be impossible.
T 1710035178 18<28emanuele618>	the stuff to upload the file fits in 512, but then only  enable -f ./<space> fits after that
T 1710035214 18<28emanuele618>	the server has a limit, but if you send more than the server limit, your message will blindly get truncated
T 1710035235 18<28emanuele618>	s/blindly/silently/
T 1710035250 18<28emanuele618>	and you have no way of telling that since you don't receive your own messages
T 1710035303 18<20arraybolt318>	maybe shbot needs a way of stitching together multiple messages...
T 1710035308 18<28emanuele618>	so all clients will generally split your message into multiple messages of up to 512bytes each to prevent your longer messages from being truncated
T 1710035340 18<28emanuele618>	arraybolt3: then what? an http that lets me upload the file directly?
T 1710035343 18<28emanuele618>	lol
T 1710035364 18<20arraybolt318>	#u https://example.org/my-script.sh
T 1710035371 18<20arraybolt318>	something like that :P
T 1710035377 18<28emanuele618>	even in the server's maximum message length is more than 512 bytes
T 1710035394 18<28emanuele618>	s/http/& api/
T 1710035436 18<20arraybolt318>	# ping -c1 8.8.8.8
T 1710035437 18<25shbot18>	arraybolt3: bash: ping: command not found
T 1710035453 18<20arraybolt318>	if only the VMs had network access things would be easy... but that has way too many risks
T 1710035457 18<28emanuele618>	# cat </dev/tcp/localhost/1234
T 1710035459 18<25shbot18>	emanuele6: bash: localhost: System error
T 1710035459 18<25shbot18>	emanuele6: bash: /dev/tcp/localhost/1234: Invalid argument
T 1710035468 18<28emanuele618>	no tcp/ip or ip at all
T 1710035476 18<20arraybolt318>	but yeah, some way of telling the bot to fetch a file and plug it in would be cool
T 1710035494 18<28emanuele618>	s/cool/lame/
T 1710035512 18<20arraybolt318>	s/s\/cool\/lame\/s\/cool\/really cool\//
T 1710035524 18<20arraybolt318>	#BotchedSed
T 1710035533 18<20arraybolt318>	I was trying to do something cool there but it failed
T 1710035567 18<28emanuele618>	it's almost correct
T 1710035574 18<28emanuele618>	impressive
T 1710035587 18<20arraybolt318>	s/s\/cool\/lame\//s\/cool\/really cool\//
T 1710035591 18<20arraybolt318>	that's correct I think
T 1710035606 18<27larryv18>	just use a different separator
T 1710035612 18<28emanuele618>	# sed 's/s\/cool\/lame\//s\/cool\/really cool\//' <<<'s/cool/lame/'
T 1710035614 18<25shbot18>	emanuele6: s/cool/really cool/
T 1710035614 18<20arraybolt318>	well yeah but what's the fun in that?
T 1710036085 18<27JAA18>	emanuele6: I think Libera's ircd supports echo-message, actually.
T 1710036190 18<28emanuele618>	test
T 1710036213 18<28emanuele618>	i am not sure what you mean, and i do not know what that is
T 1710036229 18<28emanuele618>	i can see that nothing is being sent back to me
T 1710036233 18<27JAA18>	IRCv3 capability where the server sends back to you every message you sent.
T 1710036241 18<27JAA18>	But the client also needs to support it to do something with it.
T 1710036254 18<28emanuele618>	it is not sending anything
T 1710036263 18<27JAA18>	It can be used to implement a 'message delivered' thing where you know the message made it to the network.
T 1710036266 18<28emanuele618>	maybe you need to register to it to use it
T 1710036277 18<27JAA18>	Yes, you need to enable the capability, as with most IRCv3 things.
T 1710036367 18<28emanuele618>	https://ircv3.net/specs/extensions/echo-message
T 1710036383 18<28emanuele618>	yes, this will let the client tell you if your message has been truncated
T 1710036421 18<27JAA18>	Can confirm, it works on Libera.
T 1710037447 18<25ormaaj18>	If you have a shorter nick you get to post longer messages
T 1710037495 18<25ormaaj18>	so JAA gets 3 extra chars!
T 1710037962 18<27JAA18>	Even more!
T 1710037967 18<27JAA18>	It's the entire user mask that counts.
T 1710037986 18<27JAA18>	jaa!~jaa@user/jaa vs emanuele6!~emanuele6@user/emanuele6
T 1710038060 18<27JAA18>	I love that 'shbot' has the same length as '#bash'. So if something works in query, it also works here.
T 1710038086 18<22mute18>	mildly interesting
T 1710038127 18<22mute18>	hm whats shortest domain i've got
T 1710038260 18<22mute18>	well i could save one char there but this one is wayyy cooler
T 1710038263 18<27JAA18>	Maybe you could in theory use a TLD as the PTR. So a three-letter TLD for six-digit dollars and a single-char nick with identd to get the shortest possible 'x!x@tld'.
T 1710038308 18<27JAA18>	But maybe it requires that it's at least a second-level domain, then it'd be a char longer.
T 1710038331 18<27JAA18>	Getting one of those one-letter domains on a ccTLD might be even more expensive though than a gTLD. :-)
T 1710038342 18<20twkm18>	1x two letter .com, 3x three letter .com, lost 1x one letter .cc (after paying for it for years they said that i was violating their tos).
T 1710038380 18<22mute18>	i think that's probably worth $185k
T 1710038455 18<22mute18>	best i got is san.aq. i remember asking internic for r.com but they said it was not allowed. must've been after x.com got theirs
T 1710038772 18<25ormaaj18>	A few got grandfathered in
T 1710038779 18<25ormaaj18>	x.com x.org
T 1710038812 18<25ormaaj18>	q.com is another
T 1710038886 18<22mute18>	the heck, q.com says 1999
T 1710039139 18<25ormaaj18>	I know that one because I was stuck with with their terrible DSL for ages!
T 1710039175 18<25ormaaj18>	DSL is interesting old tech. How much bandwidth can you shove down the shittiest wire possible
T 1710039223 18<25ormaaj18>	most interesting since that thing where you put your phone onto the microphone thing ^^
T 1710039344 18<22mute18>	what thing?
T 1710039366 18<22mute18>	oh the acoustic coupler
T 1710039370 18<25ormaaj18>	yeah that one
T 1710039400 18<22mute18>	i think those max at 300 baud
T 1710039474 18<25ormaaj18>	I'm sure they were awful
T 1710039513 18<22mute18>	DSL is highly dependent on distance from the central office. when they made at&t u-verse they moved the DSLAM into the neighborhood.  you can be too close to!
T 1710049342 19*	Now talking on 22#bash
T 1710049342 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1710049342 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1710051048 18<22mosasaur18>	I'm using scite as a code editor, it can fold code blocks and can comment/uncomment them. Now I need some trick to create a code block that doesn't do anything, to fold a part of code that is turned into comments. I'm currently using "if 0; then echo fi" around the code segment. Is there a better way?
T 1710051168 18<27larryv18>	if 0 doesn't do nothing, it will try to run a command named "0"
T 1710051178 18<27larryv18>	# if 0; then :; fi
T 1710051180 18<25shbot18>	larryv: bash: 0: command not found
T 1710051213 18<22mosasaur18>	larryv: yes, I think I need a 'nop'
T 1710051257 18<27larryv18>	if false
T 1710051264 18<22mosasaur18>	ah right
T 1710051319 18<22mosasaur18>	anything else I could use instead of 'if' ?
T 1710051643 18<22mosasaur18>	# if false
T 1710051650 18<25shbot18>	mosasaur: Missing terminating quote, bracket or keyword
T 1710051839 18<27larryv18>	# if false; then echo this will not run; fi
T 1710051841 18<25shbot18>	larryv: no output
T 1710051954 18<22mosasaur18>	# if true; then echo 'thanks!'; fi
T 1710051955 18<25shbot18>	mosasaur: thanks!
T 1710051979 18<22mosasaur18>	oh wait, I wanted to thank larryv
T 1710052007 18<27larryv18>	lol np
T 1710070831 18<27Earnestly18>	https://github.com/flonatel/pipexec
T 1710071075 18<24geirha18>	That looks more complicated than just using shell redirection
T 1710071104 18<24geirha18>	Also, the images are useless in dark mode
T 1710071729 18<27Earnestly18>	geirha: It would be a tad more useful with sh and possibly in cases where the command (systemd Exec or so) is not a shell without having to worry about injection so much (unless it has its own)
T 1710071774 18<27Earnestly18>	I remember MacIlroy wanted to make multi-dimentional pipelines but couldn't settle on a nice syntax to express it
T 1710071838 18<27Earnestly18>	geirha: The cyclic example, in sh I did something like: https://0x0.st/HhaB.sh - can bash do anything about this?
T 1710073179 18<28emanuele618>	missing a par of {} in the end block
T 1710074885 18<24ano18>	!0x0
T 1710074919 18<24ano18>	!0x0.st
T 1710074919 18<29greybot18>	0x0.st serves scripts with a MIME type that indicates it's a runnable program, so some web browsers can't easily show it as a plain text file; please be nice to us and use paste.debian.net instead
T 1710074935 18<28emanuele618>	# echo $[0x0]
T 1710074939 18<25shbot18>	emanuele6: 0
T 1710074940 18<28emanuele618>	# echo ${PWD[0x0]}
T 1710074942 18<25shbot18>	emanuele6: /root
T 1710075086 18<24ano18>	should be called 0x0.shit since fucked up mime types/exts and doesn't allow tor users even read pastas
T 1710075670 18<28emanuele618>	https://0x0.st/Hhav.txt
T 1710078283 18<24ano18>	# coproc fds { while IFS= read -r var; do echo "${var~~}"; done; }; echo moo >&"${fds[1]}"; while IFS= read -ru "${fds[0]}" 'arr[++i]'; do printf "${arr[i]}"; echo "${arr[i]}" >&"${fds[1]}"; ((i==10)) && break; done
T 1710078284 18<25shbot18>	ano: [1] 51
T 1710078284 18<25shbot18>	ano: MOOmooMOOmooMOOmooMOOmooMOOmoo
T 1710078293 18<24ano18>	Earnestly: ^
T 1710079131 18<28fatal18>	any idea why bashcompletion gets messed up when i use GRN='\e[0;30;32m' instead of GRN='\[\e[0;30;32m\]' for PS1="${GRN}\$${ESC} " ?
T 1710079231 18<28emanuele618>	fatal: readline will think \e [ 0 ; 3 0 ; 3 2 m occupy 10 columns
T 1710079285 18<28emanuele618>	\[ and \] represent a \1 and \2 character respectively, and tell readline that everything between \1 and \2 occupies no space, so it can position the prompt correctly
T 1710079441 18<28fatal18>	all the examples i'm looking at only use e.g. '\e[0;32m'
T 1710079465 18<28emanuele618>	well, that has never worked correctly
T 1710079495 18<28fatal18>	so more escapes is always better? it seems to work for me.
T 1710079508 18<28emanuele618>	more escapes?
T 1710079581 18<28fatal18>	like  \[ \e \] instead of just \e
T 1710079792 18<24ano18>	see (inf -n 'controlling the prompt' bash)
T 1710079803 18<28emanuele618>	escapes that are part of the prompt always need to surrounded by \[ / \] or \1 / \2 characters, or it cannot be displayed correctly
T 1710079806 18<24ano18>	s/inf/info/
T 1710079865 18<28emanuele618>	also if you have a function that prints something and you include it in the prompt with $()
T 1710080003 18<28emanuele618>	e.g.   currentunixtime(){ printf 'current \E[32mUNIX\E[m time: %(%s)T\n' -1;}     PS1='[$(currentunixtime)]$ '    that will also break the prompt
T 1710080031 18<28emanuele618>	it needs to print \1 and \2 to delimit parts with color sequences
T 1710080053 18<28emanuele618>	  currentunixtime(){ printf 'current \1\E[32m\2UNIX\1\E[m\2 time: %(%s)T\n' -1;}
T 1710080342 18<28fatal18>	ok, got it.
T 1710080517 18<28fatal18>	interesting tho since every site that i look up for bash prompt does not tell you that
T 1710080598 18<28fatal18>	...well not every.
T 1710080598 18<28emanuele618>	maybe they never tab complete, or user never use ^R, or similar  ¬Ø\_(„ÉÑ)_/¬Ø
T 1710080609 18<28emanuele618>	s/user //
T 1710080664 18<26lolok18>	why do i get files like '.bash_history-12345.tmp' randomly in my home folder sometimes?
T 1710080771 18<28xFCFFDFFFFEFFFAF18>	‚Äõ
T 1710080840 18<28emanuele618>	lolok: websearch says that is what happens when you run a fork bomb in an interactive shell
T 1710080907 18<26lolok18>	hmmm, afaik i havent been doing that, seems like something i would have noticed
T 1710080916 18<24ano18>	hmm does bash itself create such file, even when histappend enabled?
T 1710081008 18<28emanuele618>	maybe you have been killing interactive shells with SIGKILL or similar?
T 1710081051 18<26lolok18>	less than graceful reboot maybe?
T 1710081063 18<26lolok18>	if that would cause it than that would explain it
T 1710081127 18<26lolok18>	i dont usually notice until days later so im not really sure
T 1710081131 18<28emanuele618>	it is probably an intermediate file bash uses to save the history when you exit
T 1710081164 18<28emanuele618>	so if you abruptly kill it when it's in the process of saving history, that would happen
T 1710081316 18<28fatal18>	ano: haven't used that one in a while.
T 1710081354 18<26lolok18>	ok, gotta get in the habit of properly logging out before i pull the plug, see if that makes it stop happening
T 1710081955 18<28fatal18>	hm, there is no node in info bash 'controlling the prompt', this a gpt answer?
T 1710082058 18<24ano18>	fatal: >no node ?
T 1710082106 18<28fatal18>	info -n=NODENAME
T 1710082114 18<24ano18>	https://www.gnu.org/software/bash/manual/html_node/Controlling-the-Prompt.html
T 1710082386 18<24ano18>	that manual should be generated from the same texinfo
T 1710083360 18<28emanuele618>	info -n 'controlling the prompt' bash   as ano typed it works for me
T 1710083412 18<28emanuele618>	but not much interesting there
T 1710084584 18<28fatal18>	here it just says "No menu item 'bash' in node '(dir)Top'" at the bottom of the ncurses interface with `info -n 'controlling the prompt' bash`
T 1710084713 18<28fatal18>	oh, it needs package: bash-doc. nvm, then.
T 1710086969 18<19DarkenedGentlema18>	I'm looking to pipe stdout to one program but stderr to another. ex: ./prog1 | logger || echo "stderr"
T 1710086974 18<19DarkenedGentlema18>	where am i going wrong here?
T 1710087166 18<28emanuele618>	?
T 1710087335 18<26lopid18>	cmd 2> >( stderr prog ) > >( stdout prog )
T 1710087419 18<19DarkenedGentlema18>	Sorry, that's not what I'm trying to do. lol, brain today is already not working.  Better explanation.  I'm using flock on a command running from cron.  I want the stdout of that command to be sent to logger, but if flock fails I want it to echo "blah still running"
T 1710087503 18<19DarkenedGentlema18>	my basic stest is this.
T 1710087504 18<19DarkenedGentlema18>	flock -n test.flock ./testflock.sh |logger || echo "still runnnin"
T 1710087529 18<19DarkenedGentlema18>	testflock.sh is a simple sleep 5 to simulate the prog still running.
T 1710087603 18<28emanuele618>	(flock -n test.flock ./testflock.sh || echo >&2 something stderr) | logger
T 1710088489 18<19DarkenedGentlema18>	emanuele6: Thank you!  Question, can i pass the name of the prog somenow to the echo?  $0 just shows bash
T 1710088516 18<28emanuele618>	hmm, the name of what program?
T 1710088533 18<19DarkenedGentlema18>	In this case testflock.sh
T 1710088549 18<28emanuele618>	can't you just write it again?
T 1710088578 18<19DarkenedGentlema18>	Ya I could.  I was just curious if there was a simple var i was missing
T 1710088610 18<28emanuele618>	there is "$_" that is the last argument of the previous command; so in this case it would be ./testflock.sh
T 1710088619 18<28emanuele618>	but the shell has to be bash for that to work
T 1710088628 18<28emanuele618>	it does not work on sh that cron could be running
T 1710088645 18<28emanuele618>	you could create your own variable, like
T 1710088678 18<28emanuele618>	(x=./testflock.sh; flock -n test.flock -- "$x" || printf >&2 '%s: something stderr\n' "$x") | logger
T 1710088720 18<28emanuele618>	* it does not work on any sh that cron could be running
T 1710088733 18<19DarkenedGentlema18>	Thanks, I just want to keep it simple, what you provided above will work fine.
T 1710097130 18<22olspookishmagus18>	is there a way to ONLY display the lines NOT in HISTFILE?
T 1710097210 18<22olspookishmagus18>	or maybe I should parse how many lines does ~/.bash_history file have and then use that as an offset indicator?
T 1710097292 18<28bprompt18>	olspookishmagus: what are you trying to do? besides the obvious
T 1710097393 18<24geirha18>	history -a /dev/stdout
T 1710097500 18<24geirha18>	only works once though. After that it thinks it has written those lines to history
T 1710097501 18<22olspookishmagus18>	I want to view whatever commands are there in my session and to see if any of those are wort of keeping into my .bash_history file
T 1710097527 18<24geirha18>	but you can run it in a subshell
T 1710097606 18<28emanuele618>	another way is   a='\#'; history "${a@P}"
T 1710097619 18<28emanuele618>	that works as many time as you want
T 1710097624 18<22olspookishmagus18>	good idea geirha
T 1710097635 18<22olspookishmagus18>	and thank you bprompt and emanuele6 too
T 1710097647 18<28emanuele618>	no, thank you!
T 1710097657 18<22olspookishmagus18>	I wasn't expecting that
T 1710097779 18<28bprompt18>	olspookishmagus: consider it a DST day thanks from emanuele6 =)
T 1710098174 18<27Earnestly18>	ano: I wondered if a solution might be using coproc, I've rarely managed to use it for anything useful. Thanks
T 1710098325 18<24ano18>	y it's pretty limited because of 1 per proc limitation, but it can be nested i think...
T 1710101257 18<24iconoclast_hero18>	 breakout
T 1710101281 18<24iconoclast_hero18>	sorry, was searching backscroll
T 1710101332 18<24iconoclast_hero18>	i have a script with a function to `trap '{ breakout; exit 1; }' INT`
T 1710101365 18<24geirha18>	mh, you should never exit from a SIGINT trap
T 1710101463 18<27larryv18>	!sigint
T 1710101463 18<29greybot18>	How the shell handles ^C (SIGINT) and why: http://www.cons.org/cracauer/sigint.html
T 1710101503 18<20bent_fingers18>	linux console is a terminal? https://en.wikipedia.org/wiki/List_of_terminal_emulators
T 1710101581 18<24geirha18>	terminal emulator, yes
T 1710101657 18*	24iconoclast_hero is one of the "Users who have problems problems getting rid of runaway shell scripts using Control-C. Or have interactive applications that don't behave right when sending SIGINT."
T 1710101661 18<24iconoclast_hero18>	thanks
T 1710101718 18<24geirha18>	trap 'breakout ; trap - INT ; kill -INT "$$"' INT
T 1710101766 18<24iconoclast_hero18>	well, for one thing the script that I have (which someone here basically wrote) calls another script to kill all the child processes
T 1710101786 18<24iconoclast_hero18>	so that's not really a good example to do what i need to in my current instance.
T 1710101990 18<27larryv18>	you never stated what you need to do
T 1710102055 18<20bent_fingers18>	oh, the console being the framebuffer console, i get it
T 1710102523 18<24iconoclast_hero18>	well, i'm not sure where to begin.  what i have is a script that launches four parallel ffmpeg conversion jobs and there's a helper script that goes out and kills all of them, much more than what I need here.  In the particular case I'm dealing with, I'm using something called gum  (https://github.com/charmbracelet/gum) to create a list I can scroll
T 1710102538 18<24iconoclast_hero18>	and once I select an item it goes to another gum menu
T 1710102565 18<24iconoclast_hero18>	^c from the first still goes to the second, so the faq sent addresses the issue larryv
T 1710103375 18<24iconoclast_hero18>	hey, so can I ask a question here?
T 1710103399 18<24iconoclast_hero18>	in https://www.cons.org/cracauer/sigint.html it says, "And here is where the problem arises: Once they catch the signal, the system will no longer communicate the "I-exited-on-SIGINT" status to the calling program (the parent). Even if the program exits immediately in the signal handler of SIGINT. Once it catches the signal, it has to take care of communicating the signal status itself.
T 1710103399 18<24iconoclast_hero18>	Some programs don't do this. On SIGINT, they do cleanup and exit immediatly, but the calling shell isn't told about the non-normal exit and it will call the next program in the script."
T 1710103400 18<24ano18>	!ask
T 1710103400 18<29greybot18>	If you have a question, please just ask it. Don't look for topic experts. Don't ask to ask. Don't PM! Don't ask if people are awake, or in the mood to help. Just ask the question straight out, and be patient waiting for an answer. http://mywiki.wooledge.org/NetEtiquette
T 1710103408 18<24iconoclast_hero18>	rhetorical
T 1710103418 18<24iconoclast_hero18>	sorry
T 1710103457 18<27larryv18>	no questions in this channel. answers only
T 1710103465 18<24iconoclast_hero18>	is what this is saying is that gum is oneof those programs that is not taking care of communicating the signal status itself OR
T 1710103496 18<24iconoclast_hero18>	that I'm not receiving it properly once gum's caught it?
T 1710103981 18<24geirha18>	not unlikely
T 1710104010 18<24geirha18>	(that gum is mishandling it)
T 1710104193 18<24iconoclast_hero18>	so if that is the case then i should just do the immediate uncontrollable exit if that is acceptable in my case?
T 1710104249 18<27larryv18>	IUE/WUE/WCE aren't choices you can make
T 1710104289 18<27larryv18>	they're strategies for how the shell itself behaves
T 1710104295 18<27larryv18>	you can't pick one
T 1710104318 18<24iconoclast_hero18>	yeah, that seemed a bit confusing.
T 1710104381 18<24geirha18>	#!/bin/bash
T 1710104382 18<24geirha18>	gum choose one two three
T 1710104386 18<24geirha18>	printf 'Still here\n'
T 1710104412 18<27AntonioPt18>	hi everyone need a stupid help :D
T 1710104414 18<24geirha18>	test with that script. While gum is waiting for user input, hit Ctrl+C.  If you see the "Still here" message, gum is misbehaving
T 1710104428 18<24iconoclast_hero18>	thank you
T 1710104432 18<24iconoclast_hero18>	if it is, am I SOL?
T 1710104471 18<24iconoclast_hero18>	yes, it mishandles it.
T 1710104496 18<24geirha18>	you can slap  || exit   after it as a work around, but it's just moving the problem one layer further out
T 1710104511 18<24geirha18>	best option is to report a bug against gum and hope it gets fixed
T 1710104530 18<27AntonioPt18>	inxi -Sz i get multiple result not i want ex to know bits so im using inxi -Sz | grep -ioP 'bits:\s[0-9]+' and output is bits: 64 but i just want 64
T 1710104573 18<24geirha18>	I looked at gum's source code, and it doesn't set any signal handler for SIGINT as far as I can see, so it's likely one of the modules/libraries it uses that does it
T 1710104667 18<24iconoclast_hero18>	@geirha, i posted a discussion since that's the way their discord sort of points you...
T 1710104673 18<24iconoclast_hero18>	a discussion on github.
T 1710104693 18<24iconoclast_hero18>	but yes, ultimately I would file a feature request, but you would suggest that is a bug?
T 1710104766 18<24geirha18>	your use of terminology is a bit off, but I think you still get the problem described well enough
T 1710104824 18<24iconoclast_hero18>	j=$(gum choose --height 40 "${playedarr[@]}")
T 1710104858 18<24iconoclast_hero18>	j=$(gum choose --height 40 "${playedarr[@]}" || exit) doesn't seem right
T 1710104878 18<27larryv18>	i guess the only way it exits with a nonzero status is on C-c or Esc? https://github.com/charmbracelet/gum/blob/main/input/input.go#L62-L71
T 1710104880 18<24geirha18>	j=$(gum ...) || exit
T 1710104904 18<27larryv18>	or timeout
T 1710104920 18<24iconoclast_hero18>	so what is that saying then j= the result of gum or exit?
T 1710104922 18<27larryv18>	so you could do, er, what geirha just did
T 1710104943 18<27larryv18>	j is set to whatever gum puts on stdout
T 1710104962 18<24geirha18>	it's assuming gum at least returns a non-zero exit status when it exits from a SIGINT
T 1710104974 18<25ormaaj18>	# x=$(false || exit 42); echo $?
T 1710104976 18<25shbot18>	ormaaj: 42
T 1710104985 18<27larryv18>	j=$(foo || exit) is wrong because $() is a subshell, exit will only change its exit status
T 1710105029 18<24geirha18>	# f() {¬†printf 'data\n' ; exit 0 ; } ;   var=$(f) || exit ; declare -p var
T 1710105031 18<25shbot18>	geirha: bash: syntax error near unexpected token `$'{\302\240printf''
T 1710105038 18<24geirha18>	gah, bloody nbsp
T 1710105043 18<24geirha18>	# f() { printf 'data\n' ; exit 0 ; } ;   var=$(f) || exit ; declare -p var
T 1710105045 18<25shbot18>	geirha: declare -- var="data"
T 1710105052 18<24geirha18>	# f() { printf 'data\n' ; exit 42 ; } ;   var=$(f) || exit ; declare -p var
T 1710105054 18<25shbot18>	geirha: logout
T 1710105054 18<25shbot18>	geirha: (shell exited with 42)
T 1710105199 18<24iconoclast_hero18>	what i'm getting at is that exiting with the declaration of a variable is what i'm learning...more than the exact syntax.
T 1710105240 18<25ormaaj18>	what's gum?
T 1710105244 18<25ormaaj18>	abc gum?
T 1710105249 18<24iconoclast_hero18>	charm gum
T 1710105260 18<24iconoclast_hero18>	it's a go-based script thingiemajig
T 1710105273 18<24geirha18>	see the github url larryv posted 7 minutes ago
T 1710105284 18<25ormaaj18>	:o
T 1710105300 18<24iconoclast_hero18>	i saw it on one of those things google chrome puts on your android phone one day.
T 1710105441 18<27larryv18>	iconoclast_hero: unless var is readonly, the exit status of var=$(cmd) is that of cmd. so you can use that as if you weren't doing an assignment
T 1710105468 18<24iconoclast_hero18>	yeah i was just typing that out and decided that was pretty obvious
T 1710105504 18<24iconoclast_hero18>	so basically gum results in a non zero exit code if i hit ^C and then that triggers the OR exit part.
T 1710105531 18<27larryv18>	right
T 1710105544 18<24iconoclast_hero18>	and that would be the same for any $(command) expansion
T 1710105579 18<24iconoclast_hero18>	oh so much nicer than having to deal with trap today
T 1710105659 18<27larryv18>	the ^C part would not be the same
T 1710105668 18<27larryv18>	and the exit status thing is only the same for assignments
T 1710105678 18<24iconoclast_hero18>	oh right
T 1710105681 18<24iconoclast_hero18>	good point
T 1710105685 18<24iconoclast_hero18>	i overgeneralized
T 1710105882 18<24iconoclast_hero18>	what's the ! on getopts and/or handling flags?
T 1710105901 18<27larryv18>	!faq options
T 1710105901 18<29greybot18>	https://mywiki.wooledge.org/BashFAQ/035 -- How can I handle command-line options and arguments in my script easily?
T 1710106201 18<27cabalcrow18>	When I call [[ -e $result ]] from a script I get that the file doesn't exist even if it does, however if I use the same result interactively it works properly
T 1710106234 18<25ormaaj18>	weird
T 1710106252 18<28emanuele618>	that should not happen
T 1710106269 18<25ormaaj18>	pebkac
T 1710106297 18<28emanuele618>	!pebkac
T 1710106297 18<29greybot18>	Problem Exists Between Keyboard and Chair. A humorous way to describe a problem caused by the user, not the system. Similar forms: PEBCAK/PIBCAC/PEBKAM.
T 1710106334 18<24iconoclast_hero18>	what makes a case statement a better choice than a if/elif construction?
T 1710106354 18<28emanuele618>	not many things
T 1710106367 18<25ormaaj18>	does pattern matching if posix
T 1710106375 18<24iconoclast_hero18>	looks a bit more svelte
T 1710106440 18<25ormaaj18>	you can do weird fallthrough logic with it with &; and &;;
T 1710106486 18<24iconoclast_hero18>	I wouldn't presume *I* can do anything of the sort, lol.
T 1710106497 18<24geirha18>	is perhaps $result a relative path?
T 1710106527 18<24iconoclast_hero18>	thanks, i realized i have an extended if/elif script that could be a case statement.
T 1710106544 18<24iconoclast_hero18>	that does what the first example does basically.
T 1710106567 18<27cabalcrow18>	result is a relative path yes
T 1710106596 18<27cabalcrow18>	I tried adding the full path as well in the test like [[ -e /home/user/temp/$result ]]
T 1710106613 18<27cabalcrow18>	again does not work in the script, but works interactively
T 1710106622 18<24iconoclast_hero18>	i bet that means it's not expanding when you think it's expanding
T 1710106650 18<25ormaaj18>	that would expand
T 1710106732 18<24geirha18>	cabalcrow: ok, where does result come from? maybe it comes from a source with windows line-endings (\r\n AKA CRLF)?
T 1710106758 18<24geirha18>	if it is the case, xtrace output should reveal it
T 1710106759 18<24geirha18>	!-x
T 1710106759 18<29greybot18>	set -x (or ''bash -x myscript'') makes bash output the exact command that it will run after parsing and expansion. You can put ''set -x'' just before the code you want to debug (turn off with ''set +x''). To add more information, change PS4 first: eg. PS4='+($?) $BASH_SOURCE:$FUNCNAME:$LINENO:'
T 1710106791 18<24iconoclast_hero18>	what's PS4?
T 1710106848 18<24geirha18>	variable used by set -x, so you can prefix more helpful data to each line
T 1710106856 18<27larryv18>	!ps4
T 1710106856 18<29greybot18>	The value of $PS4 is printed (after expansion) before each command bash displays during an execution trace. See man bash, under PROMPTING. # http://wiki.bash-hackers.org/scripting/debuggingtips#use_shell_debug_output Try PS4='+($?) $BASH_SOURCE:$FUNCNAME:$LINENO:'
T 1710106863 18<24geirha18>	PS4=
T 1710106866 18<24geirha18>	err
T 1710106893 18<27cabalcrow18>	It doesn't come from there. That being said I found how to fail this interactively as well. Basically if I set result="aoeu\ -\>\ aoeu", & then I test via $result it fails, however if I type it out as aoeu\ -\>\ aoeu then it works
T 1710106915 18<24geirha18>	PS4='+ $BASH_SOURCE:$LINENO:' bash -xic ''   # is a common trick to see exactly what files get sourced when an interactive bash is started
T 1710106951 18<24geirha18>	cabalcrow: oh, are you parsing ls output?
T 1710106975 18<27cabalcrow18>	yeah
T 1710106995 18<24geirha18>	well ... don't do that
T 1710106996 18<27cabalcrow18>	I'm parsing eza (ls replacement) into into fzf for the colouring
T 1710107001 18<24geirha18>	!ls
T 1710107001 18<29greybot18>	DO NOT USE the output of ls in scripts. Its output format is neither portable nor reliable. Use globs instead. See https://mywiki.wooledge.org/ParsingLs
T 1710107001 18<27cabalcrow18>	& then I'm parsing it back
T 1710107021 18<27cabalcrow18>	I know globs are the better way, but I have to redo everything eza/ls is doing then
T 1710107027 18<27cabalcrow18>	for the actual choice selection in fzf
T 1710107046 18<27cabalcrow18>	so it is easier to parse back the ls/eza output instead
T 1710107056 18<27cabalcrow18>	except for this, this is the only case I can't figure out
T 1710107142 18<24geirha18>	the only case you happen to know of. I'm sure there are many more cases
T 1710107150 18<27xx18>	which printf special character do I use to encode a null byte? I'm trying to do something like `printf '%b' 'xx\0xx\0xx' | base64` but it fails when it is literal xx in there
T 1710107159 18<27xx18>	probably because it interprets \0x as something
T 1710107163 18<27xx18>	instead of it being a \0 and a x
T 1710107190 18<24geirha18>	# printf '%b' 'xx\0xx\0xx' | od -An -tx1 -c
T 1710107192 18<25shbot18>	geirha:   78  78  00  78  78  00  78  78
T 1710107192 18<25shbot18>	geirha:    x   x  \0   x   x  \0   x   x
T 1710107212 18<24geirha18>	looks like it outputs the expected bytes
T 1710107242 18<27xx18>	damn it... I thought I was using bash but it's zsh
T 1710107252 18<27xx18>	nevermind then
T 1710107254 18<27xx18>	thanks
T 1710107371 18<27cabalcrow18>	got my whole problem into 3 commands https://paste.centos.org/view/63dcd8a2
T 1710107500 18<24geirha18>	ah, well the two are different
T 1710107546 18<24geirha18>	aoeu\ -\>\ aoeu   is  "aoeu -> aoeu"
T 1710107575 18<24geirha18>	you added unecessary backslashes to the double quoted string
T 1710107659 18<24geirha18>	"aoeu\ -\>\ aoeu"  using only backslash-quoting is:  aoeu\\\ -\\\>\\\ aoeu
T 1710107664 18<27cabalcrow18>	I tried it with a single quote & it still doesn't work
T 1710107672 18<27cabalcrow18>	result='aoeu\ -\>\ aoeu'
T 1710107691 18<24geirha18>	equally broken. Adds three backslashes to the data
T 1710107696 18<24geirha18>	just like the "" version does
T 1710107722 18<28emanuele618>	result=aoeu\ -\>\ aoeu
T 1710107737 18<28emanuele618>	or result='aoeu -> aoeu' which looks neater
T 1710107803 18<24geirha18>	# printf '%s\n' 'aoeu\ -\>\ aoeu' "aoeu\ -\>\ aoeu" aoeu\\\ -\\\>\\\ aoeu
T 1710107805 18<25shbot18>	geirha: aoeu\ -\>\ aoeu
T 1710107805 18<25shbot18>	geirha: aoeu\ -\>\ aoeu
T 1710107805 18<25shbot18>	geirha: aoeu\ -\>\ aoeu
T 1710107811 18<24geirha18>	# printf '%s\n' 'aoeu -> aoeu' "aoeu -> aoeu" aoeu\ -\>\ aoeu
T 1710107813 18<25shbot18>	geirha: aoeu -> aoeu
T 1710107813 18<25shbot18>	geirha: aoeu -> aoeu
T 1710107813 18<25shbot18>	geirha: aoeu -> aoeu
T 1710109467 19*	Now talking on 22#bash
T 1710109467 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1710109467 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1710109520 18<28emanuele618>	there is a  eza_colors-explanation  man page
T 1710109531 18<28emanuele618>	compressed yeah
T 1710109605 18<28emanuele618>	i also say bold red, that is not mentioned, but that is very obviously for unix sockets
T 1710109619 18<28emanuele618>	so many colours
T 1710110020 18<27cabalcrow18>	I was specifically editing out an existing script in this case fzf-select-file
T 1710110045 18<27cabalcrow18>	it is a script for quick file selection via fzf in zsh via a keybind
T 1710110091 18<27cabalcrow18>	but I guess I will need to figure out how to manage fzf better & extract information from eza
T 1710111752 18<27xx18>	geirha: thanks for that `od -An -tx1 -c` it's really neat. Do people use that often?
T 1710111852 18<28emanuele618>	$ grep -c $'^[^\t]*\temanuele6\t.*\\<od\\>' ~/.weechat/logs/irc.libera.#bash.weechatlog
T 1710111854 18<28emanuele618>	69
T 1710111884 18<27xx18>	I don't mean `od` on its own, I mean those exact flags to od
T 1710111903 18<24geirha18>	It's the best way of doing a hexdump using POSIX tools that I know of. I usually use xxd instead, with od a solid second if xxd isn't available
T 1710111908 18<28emanuele618>	i pretty much always use od with -An
T 1710111931 18<27xx18>	I should learn xxd
T 1710111932 18<28emanuele618>	and -tx1 to print hex, -to1 to print octal, -tc to print characters, yeah
T 1710111937 18<27xx18>	because... it has xx in it
T 1710111965 18<28emanuele618>	my latest report on @bug-bash features   od -An -to1 !  https://lists.gnu.org/archive/html/bug-bash/2024-03/msg00008.html
T 1710112017 18<28emanuele618>	a system without xxd is unusable! D:
T 1710112027 18<28emanuele618>	if it does not have xxd, it probably also does not have vim
T 1710112047 18<27xx18>	I only learned recently that xxd comes from vim
T 1710112060 18<28emanuele618>	it's a button on the default toolbar
T 1710112116 18<24geirha18>	:%!xxd -g1   then you can modify it a bit, then   :%!xxd -r
T 1710112250 18<20houseparty18>	I have two variations of the same code. These are simple. Which one is better and why? I also put comments to indicate the find command is preferable: https://paste.debian.net/1310196/
T 1710112272 18<20houseparty18>	... variations of a function with different code but the output is identical
T 1710112335 18<24geirha18>	the first one, but without the || ls ... part
T 1710112353 18<20houseparty18>	And that's why I put the find with a comment as I knew that
T 1710112376 18<24geirha18>	"Oh you passed a file/directory that doesn't exist, let's just list the current working directory instead then"
T 1710112381 18<20houseparty18>	I agree. The second one is more explicit but it's redundant and more lengthy
T 1710112405 18<20houseparty18>	Yeah. So that way if you are already in the directory you want to search, you don't have to type "$PWD"
T 1710112408 18<20houseparty18>	or "."
T 1710112434 18<20houseparty18>	two key strokes saved from "[[:space:]] \".\""
T 1710112454 18<24geirha18>	and that's already the default for ls, so the || ls ... "$PWD"   is completely pointles
T 1710112473 18<20houseparty18>	Didn't think about that. So obvious.
T 1710112487 18<20houseparty18>	Why didn't I think of that. I dunno
T 1710112569 18<24geirha18>	even if it wasn't you could default to . (or $PWD) using   "${@-.}"
T 1710112604 18<20houseparty18>	I just have them to avoid typing as much but I see your point.
T 1710112656 18<20houseparty18>	The weird thing is I am actually using the file managers more because it feels easier in many cases to just drag and drop.
T 1710112681 18<28bprompt18>	ahem, isn't --color the default for "ls"?
T 1710112748 18<20houseparty18>	No... at least not in bashrc.
T 1710112753 18<24geirha18>	no. You likely have an ls alias that adds --color=auto
T 1710112755 18<20houseparty18>	Outside of it, I think ...
T 1710112761 18<24geirha18>	but --color is short for --color=always
T 1710112836 19*	Now talking on 22#bash
T 1710112836 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1710112836 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1710112868 18<24geirha18>	--color=auto makes it only output colour if stdout is a terminal. Since you're piping the output, --color=auto would cause it to not output any colours
T 1710112881 18<20houseparty18>	I noticed after too long that there is a line in bashrc on one distro that tells you you to consider having a seperate profile just for aliases
T 1710112899 18<20houseparty18>	Did not know that either
T 1710112907 18<24geirha18>	I keep all my aliases in /dev/null
T 1710112930 18<20houseparty18>	You keep them in a vacuum?
T 1710113061 19*	Now talking on 22#bash
T 1710113061 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1710113061 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1710118768 19*	Now talking on 22#bash
T 1710118768 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1710118768 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1710118792 18<20cappy18>	Is there a way to do this: frac=$(echo "scale=6; $i/64" | bc) without calling `bc` each time in an arithmetic loop?
T 1710118856 18<27larryv18>	depends what you're doing with frac
T 1710118912 18<20cappy18>	Just printing a table:  printf "i=%2d f=%s  " "$i" "$frac"
T 1710118999 18<27larryv18>	could probably just do the whole thing in one awk script
T 1710119062 18<27larryv18>	where's $i coming from
T 1710119080 18<20cappy18>	for (( i=1; i <=64; i++ )); do
T 1710119179 18<20cappy18>	Admittedly, calling `bc` (in this case 64 times) seems the wrong approach. The loop, for another could be o-o greater.
T 1710119196 18<20cappy18>	s/o-o/OoM/
T 1710119236 18<28emanuele618>	awk 'BEGIN { for (i = 1; i <= 64; ++i) printf "i=%2d f=%08.6f\n", i, i / 64 }'
T 1710119276 18<20cappy18>	emanuele6: That looks nice. Thank you!
T 1710119679 18<28emanuele618>	python3 -c 'for i in range(1, 65): print(f"i={i:02} f={i/64:6f}")'
T 1710119689 18<27larryv18>	# bc -l <<<'for (i = 1; i <= 64; ++i) { i; i/64 }' | { mapfile -t && printf 'i=%2d f=%08.6f\n' "${MAPFILE[@]}"; }
T 1710119691 18<25shbot18>	larryv: i= 1 f=0.015625
T 1710119691 18<25shbot18>	larryv: i= 2 f=0.031250
T 1710119691 18<25shbot18>	larryv: etc... ( http://paste.wooledge.org/29437 )
T 1710119693 18<27larryv18>	>:)
T 1710119716 18<28emanuele618>	the "f=" in bc!
T 1710119794 18<28emanuele618>	hmm, bc outputs 0.123    as  .123
T 1710119828 18<28emanuele618>	s/the/you could print &/
T 1710119932 18<28emanuele618>	bc <<<'scale=6; for (i = 1; i <= 64; ++i) { i; "'$'\t''f="; i/64 }'
T 1710119938 18<28emanuele618>	# bc <<<'scale=6; for (i = 1; i <= 64; ++i) { i; "'$'\t''f="; i/64 }'
T 1710119940 18<25shbot18>	emanuele6: 1
T 1710119940 18<25shbot18>	emanuele6:         f=.015625
T 1710119940 18<25shbot18>	emanuele6: etc... ( http://paste.wooledge.org/29439 )
T 1710119947 18<28emanuele618>	not as nice, but it's all bc
T 1710119994 18<20cappy18>	Impressive, guys.
T 1710120535 18<27larryv18>	# bc <<<'scale=6; for (i = 1; i <= 64; ++i) { "i="; i; "'$'\t''f="; f=i/64; if (f < 1) { "0" }; f }'
T 1710120537 18<25shbot18>	larryv: i=1
T 1710120537 18<25shbot18>	larryv:         f=0.015625
T 1710120537 18<25shbot18>	larryv: etc... ( http://paste.wooledge.org/29451 )
T 1710131041 19*	Now talking on 22#bash
T 1710131041 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1710131041 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1710133664 19*	Now talking on 22#bash
T 1710133664 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1710133664 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1710148210 18<26sphertext_18>	I'm running `socat [...] &` inside a bash script to send it to the background. however, `ps -f` then shows its PPID to be 1
T 1710148259 18<26sphertext_18>	if i run the same socat command from the shell, it ends up having a normal PPID
T 1710148296 18<26sphertext_18>	and normally processes that i start in a bash script and background them, retain the PPID of the script
T 1710148523 18<24geirha18>	sounds like the script that started socat exited then, in which case the background job gets disowned and it gets init as parent
T 1710148582 18<26sphertext_18>	ah so they get disowned if the script?
T 1710148587 18<24geirha18>	if you want socat to die along with the script, add an EXIT trap that kills the socat on exit (assuming bash)
T 1710148595 18<26sphertext_18>	yeah, if i put a `read` command afterwards, it doesn't get disowned anymore
T 1710148658 18<24geirha18>	if the script doesn't do anything other than starting socat, why even run it in the background?
T 1710148689 18<26sphertext_18>	it does other things
T 1710148924 18<26sphertext_18>	ok but here's what is confusing me. if inside [script1] i put a while loop, then in the while loop run a `bash [script2]`, and then background the while loop. i can see that [script2] has the PPID of [script1]. even tho [script1] exited
T 1710148940 18<26sphertext_18>	how come it doesn't get disowned as well?
T 1710148987 18<24geirha18>	it's not exactly script1, it's a subshell of script1.
T 1710149018 18<24geirha18>	script1 has to fork a subshell to run that while loop in, and that subshell is then the parent of script2
T 1710149044 18<26sphertext_18>	 ps reports that the command of the PPID of [script2] was me running [script1]
T 1710149060 18<24geirha18>	being a subshell it inherits argv and such of the main shell, so it looks a bit confusing in ps output
T 1710149068 18<26sphertext_18>	ah
T 1710149180 18<24geirha18>	printf 'Script pid: %s, subshell pid: %s\n' "$$" "$BASHPID"
T 1710152285 19*	Now talking on 22#bash
T 1710152285 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1710152285 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1710153904 18<19safsf18>	quieres ver videos para adultos
T 1710153921 18<19safsf18>	¬øChat por c√°mara?
T 1710153930 18<19safsf18>	¬øYo por c√°mara?
T 1710153950 18<19safsf18>	chatear por c√°mara?
T 1710153989 18<19safsf18>	Primero haga clic en este enlace > https://yourgirlsarcade.life/?u=vtgk60r&o=d7gpk40
T 1710153990 18<19safsf18>	Y completa todas las opciones y luego muestra tu tarjeta, pero no te preocupes, es totalmente gratis.
T 1710154055 18<19safsf18>	Primero haga clic en este enlace > https://yourgirlsarcade.life/?u=vtgk60r&o=d7gpk40
T 1710154055 18<19safsf18>	Y completa todas las opciones y luego muestra tu tarjeta, pero no te preocupes, es totalmente gratis.
T 1710154239 18<19safsf18>	Ven a mi telgram >> @mariyacs
T 1710154368 18<24ano18>	!ops
T 1710154369 18<29greybot18>	twkm geirha Riviera greycat isabella osse e36freak pragma- yitz mute kurahaupo ormaaj llua phy1729 soliton phogg emg
T 1710154603 18<22phogg18>	why am I on the ops list?
T 1710154623 18<29djph18>	phogg: so you can rule with an iron fist
T 1710154636 18<22phogg18>	my fist is made of tin at best
T 1710154646 18<19katia18>	mine is made of hand
T 1710154662 18<28selckin18>	you have ops
T 1710154710 18<29djph18>	phogg: fine, rule with a tin fist then :P
T 1710157291 22*	26ChanServ gives channel operator status to 18kurahaupo
T 1710157317 22*	26kurahaupo removes channel operator status from 18kurahaupo
T 1710157436 18*	25kurahaupo discovers she has god-like powers in #bash
T 1710158412 18<29nvz18>	did you type idspispopd?
T 1710158444 18<24geirha18>	iddqd you mean
T 1710158460 18<29nvz18>	oh.. damn.. been a long time.. whats the one I said then?
T 1710158486 18<24geirha18>	don't know, doesn't ring any bells for me
T 1710158505 18<24geirha18>	I only remember iddqd, idkfa and idclip
T 1710158590 18<29nvz18>	ah its no clipping
T 1710158665 18<29nvz18>	but only in the original game, idclip works in the others I guess
T 1710158735 18<24geirha18>	huh, never knew idclip had that long winding alias
T 1710158863 18<28emanuele618>	iddrinkcoffee
T 1710159371 18<29nvz18>	I was just reading up on that mud stuff last night, apparently people are drinking fungus now instead of coffee *shrug* far from the strangest thing I heard. I recall years ago watching a tv special about people shooting coffee up their bum
T 1710159704 18<28emanuele618>	reminds me of the latest brewstew episode
T 1710159835 18<29nvz18>	heh, "awkward situations"?
T 1710159869 18*	29nvz wanders off to find breakfast since it doesn't seem to be finding me
T 1710159878 18<28emanuele618>	yes
T 1710160426 18<29nvz18>	I never heard of it, I suppose I will check it out since I seem to resemble this episode :P
T 1710160816 18<24cheater18>	does bash completion still have that bug where it doesn't complete if the strings contain :
T 1710160822 18<24cheater18>	is it a bug
T 1710160836 18<24cheater18>	or is the guy who wrote this program (that uses bash completion) just holding it wrong
T 1710161069 18<29nvz18>	all I know is, after my earlier comments and this peggers can't be choosers, I'm not gonna go anywhere near a conversation about colons any time soon, so I'll leave that apparent question to someone else and run along now
T 1710161112 18<29djph18>	cheater: both?
T 1710161147 18<24cheater18>	djph: i don't know.
T 1710161150 18<24cheater18>	djph: both?
T 1710161188 18<29djph18>	cheater: a bug, and he's holding it wrong?
T 1710161217 18<24cheater18>	yes. i'm asking you which it is. since you were asking me. but i don't know. hence i asked originally.
T 1710161264 18<29djph18>	cheater: yes, why not "both" ?  (as in "it is a bug AND the user is holdig it wrong" ... ala apple)
T 1710161283 18<24cheater18>	why not just not waste my time
T 1710161286 18<29djph18>	also, didn't their glasses start cracking in half recently?
T 1710161303 18<24cheater18>	wouldn't be surprised
T 1710161310 18<24geirha18>	default completion completes words with colon at least, so it's not a bash bug at any rate
T 1710162697 18<25OMGOMG18>	geirha: like colony or colonoscopy?
T 1710163781 18<19mort18>	how would y'all iterate through lines in a file
T 1710163797 18<27Soliton18>	!faq 1
T 1710163797 18<29greybot18>	https://mywiki.wooledge.org/BashFAQ/001 -- How can I read a file (data stream, variable) line-by-line (and/or field-by-field)?
T 1710163812 18<19mort18>	if a bot answered I've ignored it
T 1710163827 18<29osc4rpt18>	hey people, i'm trying to solve the following problem: https://bpa.st/CT3A . basically i'm trying to embed the first command, which contains backticks, into an alias shortcut, that is not working. apparently you can not embed backticks or $() syntax into an alias and make it work? can you suggest anything?
T 1710163830 18<27Soliton18>	perhaps read the topic then.
T 1710163858 18<19mort18>	Soliton: how about you just stop being an asshole instead
T 1710163859 18<27Soliton18>	!aliases
T 1710163859 18<29greybot18>	Aliases suck. They don't work in scripts. They can't take arguments. They have special evil magical powers that break all expectations. See http://mywiki.wooledge.org/BashFAQ/080 for starters.
T 1710163891 18<24depesz18>	mort: that attitude will not help you. you were given an answer. it's not our problem that you decided to ignore it.
T 1710163899 18<19mort18>	I wasn't given an answer
T 1710163907 18<28llua18>	you were
T 1710163908 18<19mort18>	I was told to read the topic
T 1710163975 18<29osc4rpt18>	greybot: alright, sure :) guess would just put it into a file then
T 1710163978 18<24geirha18>	The first entry in the FAQ answers your question
T 1710163988 18<19mort18>	why didn't you just say that earlier
T 1710164002 18<19mort18>	except no, it doesn't
T 1710164009 18<19mort18>	I need to do it in-process
T 1710164031 18<19mort18>	so not the cat file | while read -r line thing
T 1710164060 18<24geirha18>	yeah, definitely don't do cat file | while read ...
T 1710164066 18<28llua18>	so you didn't read it at all
T 1710164089 18<25OMGOMG18>	!b1
T 1710164089 18<29greybot18>	bashphorism 1: the questioner's first description of the problem/question will be misleading.
T 1710164252 18<27Soliton18>	osc4rpt: perhaps remove the backslash infront of ! in case that is meant to suppress history expansion.
T 1710164312 18<27Soliton18>	osc4rpt: that command is pretty bad either way. you should not rely on wordsplitting and pathname expansion to produce the arguments you want.
T 1710164389 18<19mort18>	right you can use the < thing with while
T 1710164410 18<19mort18>	I tried that actually, `<<<"$somevariable" while read -r blah`, it didn't work so I assumed redirects didn't work with while
T 1710164424 18<19mort18>	seems like it works but only if placed after the 'done'
T 1710164458 18<24geirha18>	osc4rpt: I'm guesstimating you are trying to find the container id of a container named "consec";  instead of using grep and ruby to parse the default output, use docker container ls's --filter to grab the one you want, and then -q to only output the id
T 1710164471 18<24geirha18>	docker container ls --filter name=consec -q --no-trunc
T 1710164740 18<24depesz18>	i don't recall, how can I print source of defined function?
T 1710164752 18<24geirha18>	declare -f funcname
T 1710164760 18<24depesz18>	aaargh. -f. i tried -p. thanks.
T 1710164772 18<24geirha18>	type funcname    will also print the function
T 1710164790 18<24depesz18>	oh. nice. thanks again :)
T 1710164818 18<28emanuele618>	if you use   declare -pf   instead of just -f  it will show an error if the function is not defined
T 1710164857 18<24geirha18>	mort: redirections can appear "anywhere" for simple commands, but while is a compound command, and for compound commands, redirections must be at the very end
T 1710164866 18<19mort18>	weird
T 1710164913 18<24geirha18>	[[ ]]  is also a compound command, and it uses < and > as string comparison operators
T 1710164949 18<19mort18>	yeah but nobody uses [[ ]]
T 1710164950 18<24geirha18>	and (( )) similarly uses < and > for integer comparisons
T 1710164987 18<24geirha18>	I guess I'm nobody then
T 1710164993 18<19mort18>	probably
T 1710165002 18<27Soliton18>	the weird part is that you can put redirections anywhere in a simple command.
T 1710165432 18<25OMGOMG18>	geirha: "nobody" would also be a good nick, length-wise
T 1710165475 18<24geirha18>	also a great choice for username
T 1710165554 18<27Earnestly18>	geirha: Of which, can shbot gain nobody as a user besides root?
T 1710165685 18<24geirha18>	problem with that is that I'd need to add a sudo/su command in addition
T 1710165732 18<27Earnestly18>	I thought shbot had su
T 1710165734 18<27Earnestly18>	# hash su
T 1710165737 18<25shbot18>	Earnestly: bash: hash: su: not found
T 1710165762 18<24geirha18>	though since those aren't standard commands, we could concoct our own version that works differently than any other implementation in existance >:)
T 1710165763 18<27Earnestly18>	Oh, well yes. sudo would be nice, but su would be enough. Although it was just to demonstrate things related to it
T 1710165815 18<27Earnestly18>	iirc it was to demonstrate permissions
T 1710165817 18<28emanuele618>	# printf 'emanuele6:x:1000:1000:moo,,,:/emanuele6:/bin/bash' >> /etc/shadow; echo ~emanuele6; chown emanuele6 .bashrc; ls -ld .bashrc
T 1710165820 18<25shbot18>	emanuele6: ~emanuele6
T 1710165820 18<25shbot18>	emanuele6: chown: invalid user: 'emanuele6'
T 1710165820 18<25shbot18>	emanuele6: -rw-rw-r-- 1 root root 634 Mar 21  2021 .bashrc
T 1710165852 18<28emanuele618>	hmm, that used to work
T 1710165863 18<28emanuele618>	oh, etc passwd
T 1710165873 18<28emanuele618>	# printf 'emanuele6:x:1000:1000:moo,,,:/emanuele6:/bin/bash\n' >> /etc/passwd; echo ~emanuele6; chown emanuele6 .bashrc; ls -ld .bashrc
T 1710165875 18<25shbot18>	emanuele6: /emanuele6
T 1710165875 18<25shbot18>	emanuele6: -rw-rw-r-- 1 emanuele6 root 634 Mar 21  2021 .bashrc
T 1710165992 18<24geirha18>	wonder if a setuid loadable builtin would work
T 1710167286 18<22mosasaur18>	I've got some lines that are commented out, my editor can fold code blocks. So I am using "if false .. then" around them to turn them into a block. However, now I've found { also works, if I add a : before closing with } .  Is this better or equal to doing it with "if then"?
T 1710167397 18<24geirha18>	that doesn't sound right
T 1710167463 18<22mosasaur18>	the if then thing or the brackets?
T 1710167477 18<27Soliton18>	you're writing weird code to please your editor or what is the goal?
T 1710167485 18<22mosasaur18>	I mean it seems to work
T 1710167511 18<27Soliton18>	perhaps you mean ; instead of :
T 1710167526 18<24geirha18>	oh the lines are still commented out in these "blocks" ?
T 1710167550 18<22mosasaur18>	Soliton:  it's weird code to run ever changing delogo filters in a script for running mpv
T 1710167565 18<22mosasaur18>	geirha: yes
T 1710167591 18<27Soliton18>	so why are you talking about folding code blocks in your editor?
T 1710167600 18<24geirha18>	but if also requires at least one command between the then and fi
T 1710167653 18<22mosasaur18>	geirha: yes, that's what the : line is for, I understand it to be some kind of nop operation
T 1710167696 18<27Soliton18>	# : $(echo hi>&2)
T 1710167697 18<25shbot18>	Soliton: hi
T 1710167701 18<22mosasaur18>	Soliton: sometimes I need to go back to the old filters
T 1710167715 18<24geirha18>	does it fold C style /* */  comments? maybe you can add some of those instead;   # /*  and  # */  above and below your comments
T 1710167728 18<22mosasaur18>	Soliton: but i don't want them clogging my code
T 1710167739 18<27Soliton18>	them?
T 1710167758 18<22mosasaur18>	Soliton: multiple commented out lines
T 1710167785 18<29djph18>	then delete them?
T 1710167820 18<25ee18>	i cannot make the builtin that calls setuid fit :(
T 1710167822 18<22mosasaur18>	djph: no, they are necessary for later eps, sometimes
T 1710167840 18<29djph18>	"eps" ?
T 1710167848 18<22mosasaur18>	episodes
T 1710167907 18<27Soliton18>	perhaps put the filters into different functions.
T 1710168015 18<22mosasaur18>	geirha: thanks!  # /*  and  # */   work too! Hadn't expected C-style to work here for some reason
T 1710168075 18<22mosasaur18>	Soliton: can't do that, they only work partially, I have to edit them all the time
T 1710168109 18<24geirha18>	what about   # {   and    # }   ?
T 1710168178 18<22mosasaur18>	geirha: those work too
T 1710168202 18<22mosasaur18>	thanks a lot
T 1710168333 18<25ee18>	# ksh<<<'typeset -b x=QlpoOTFBWSZTWTjZJJ8AAT//p//90UDAgEBBUwQYQIxw3gCAQghAAMACQEIpsADsKGplNNR6hhMIDQNDQMQM1PUMYDQAADQAAAAABISqbUbSaMhoGjQD1NDIAGmkHJazSEiUlAyIpQgwSDYWQ82MQ0rEceDChQimhfkigWJ237LWPnwb2p5HASvSiyNpAmwccbV7CVQIS4WklmZjYhLM0ubi4KNOKqAd/JSANHx9e/hs2YmozfORkMshcwR+YYhK56WrGXOMLXCORyTBINt6HMo8NKwTdEOtBVHfnz02qt1biSFBDcyyqq8q0/Tk9tbuuz3/F9XyfSxrzaXxwJ4mzGdCbe6hLVj16/8XckU4UJA42SSf;printf %B x'|bunzip2>s;enable -f./s s;s;>/z;ls -l /z
T 1710168339 18<25shbot18>	ee: -rw-r--r-- 1 1000 root 0 Mar 11 14:45 /z
T 1710168415 18<24geirha18>	oh, that's what you meant by "fit"
T 1710168468 18<25ee18>	# ksh<<<'typeset -b x=QlpoOTFBWSZTWTjZJJ8AAT//p//90UDAgEBBUwQYQIxw3gCAQghAAMACQEIpsADsKGplNNR6hhMIDQNDQMQM1PUMYDQAADQAAAAABISqbUbSaMhoGjQD1NDIAGmkHJazSEiUlAyIpQgwSDYWQ82MQ0rEceDChQimhfkigWJ237LWPnwb2p5HASvSiyNpAmwccbV7CVQIS4WklmZjYhLM0ubi4KNOKqAd/JSANHx9e/hs2YmozfORkMshcwR+YYhK56WrGXOMLXCORyTBINt6HMo8NKwTdEOtBVHfnz02qt1biSFBDcyyqq8q0/Tk9tbuuz3/F9XyfSxrzaXxwJ4mzGdCbe6hLVj16/8XckU4UJA42SSf;printf %B x'|bunzip2>s;enable -f./s s;s;>/b*/[
T 1710168475 18<25shbot18>	ee: bash: /bin/[: Permission denied
T 1710168476 18<25ee18>	:D
T 1710168630 18<28emanuele618>	bunzip2 and gunzip are my new favourite shbot commands
T 1710169839 18<28emanuele618>	i just had an idea; with nullglob, you can use  > "$mypath"/@(file)   to only write to file if it already exist, and otherwise do nothing
T 1710169870 18<28emanuele618>	# foo=bar; shopt -s nullglob; echo hi >/root/@("$foo"); cat <"$foo"
T 1710169872 18<25shbot18>	emanuele6: bash: /root/@("$foo"): ambiguous redirect
T 1710169872 18<25shbot18>	emanuele6: bash: bar: No such file or directory
T 1710169878 18<28emanuele618>	# foo=bar; shopt -s nullglob; echo hi >/root/@(.mkshrc); cat <"$foo"
T 1710169880 18<25shbot18>	emanuele6: bash: bar: No such file or directory
T 1710169890 18<28emanuele618>	oops
T 1710169894 18<28emanuele618>	# foo=.mkshrc; shopt -s nullglob; echo hi >/root/@("$foo"); cat <"$foo"
T 1710169895 18<25shbot18>	emanuele6: hi
T 1710169978 18<28emanuele618>	another use is to make   foo/@("$dirname")/baz   fail if dirname contains a /
T 1710170073 18<28emanuele618>	oh, didn't someone about a alternative noclobber that works like this some week ago?
T 1710170082 18<28emanuele618>	s/about/ask &/
T 1710170131 18<28emanuele618>	2024-02-10 22:07:35 <hsv > just checking, there's no form of >> redirection that fails if the file does *not* exist?
T 1710170144 18<28emanuele618>	aw, they are not online right now
T 1710170253 18<28emanuele618>	nevermind :)
T 1710170359 18<28emanuele618>	hsv: you can use    >> @("$file")   with nullglob on!
T 1710170376 18<28emanuele618>	if you have a path, you must split it first though
T 1710170392 18<28emanuele618>	and then do   >> "$dir"/@("$file")
T 1710170845 18*	22CrtxReavr feels abused by the ksh syntax.
T 1710175937 18<25ciphrCat18>	any ideas why $ovpn_pid would be empty when this script runs? ‚Üí openvpn --daemon --config "$cfg"; ovpn_pid=$!; printf '%s\n' "OpenVPN launched under process ID: $ovpn_pid"
T 1710176205 18<22tirnanog18>	the value of $! is meaningless. it wasn't backgrounded.
T 1710176244 18<25ciphrCat18>	ah, that's it.. in other places where I use that it's because I backgrounded the process
T 1710176245 18<22tirnanog18>	if you want to continue using --daemon, you can use --writepid to write out the pid value somewhere.
T 1710176307 18<25ciphrCat18>	thanks for the tip!
T 1710179383 18<26ormooj18>	moo
T 1710179494 18<28emanuele618>	!m
T 1710179494 18<29greybot18>	üêÑ
T 1710179869 18<25fettuccine18>	moo
T 1710180067 18<26ormooj18>	:D
T 1710189908 18<27ztrawhcse18>	geirha: random q related to shbot -- how well do the old bashes build with modern compilers?
T 1710190028 18<27ztrawhcse18>	I'm especially interested in gcc 14 (upcoming) as that definitely trips up some -Werror=implicit-function-declaration and so on but I'm hoping that those changed defaults are the only actual issues...
T 1710196474 18<24geirha18>	ztrawhcse: Don't know yet. Been compiling them on an old ubuntu 18.04 system
T 1710198778 18<26ormooj18>	gentoo has a bash 2 ebuild
T 1710198825 18<26ormooj18>	i never tried it ^^
T 1710198896 18<25cedd18>	what does this line do: while IFS= read -r -d '' file
T 1710198932 18<26ormooj18>	it should read up to the next nul into file
T 1710199460 18<29nightstrike18>	if you background a shell function, does it run in a separate thread or a separate process?
T 1710199487 18<27Soliton18>	there's not really threads in shell.
T 1710199543 18<29nightstrike18>	ok, point taken.. but is global state shared?
T 1710199556 18<26ormooj18>	no
T 1710199601 18<27larryv18>	subshells do copy of a lot of state from the parent, but they are just that, copies
T 1710199612 18<26ormooj18>	yes
T 1710199638 18<29nightstrike18>	ok, ty
T 1710200064 18<27ztrawhcse18>	geirha, ormooj: I did some more investigation, it is indeed just an issue of Modern C flags. I can compile all gentoo-packaged versions of bash if I disable the Modern C checks
T 1710200101 18<27ztrawhcse18>	now I need to decide if I'm gonna write a patchset to make these old versions build nicely with gcc 14 out of the box...
T 1710200282 19*	Now talking on 22#bash
T 1710200282 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1710200282 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1710200345 18<25cedd18>	ormooj: what does the 'IFS' part do?
T 1710200359 18<27Soliton18>	!ifs
T 1710200359 18<29greybot18>	Internal Field Separator (or Input Field Separator), used to break things into words. See http://mywiki.wooledge.org/IFS and http://mywiki.wooledge.org/BashFAQ/001 and https://wiki.bash-hackers.org/syntax/words
T 1710200407 18<27Soliton18>	IFS= means that no field splitting is happening.
T 1710201344 19*	Now talking on 22#bash
T 1710201344 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1710201344 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1710201501 18<25cedd18>	Soliton: i think i dont understand bash's syntax in a while list, why is there a var set and then with no separation it goes into a read command?
T 1710201523 18<25cedd18>	for context, here is the line again: while IFS= read -r -d '' file
T 1710201554 18<25cedd18>	what is IFS even being set to there? space?
T 1710201563 18<27Soliton18>	VAR=value cmd  # means VAR is set to value in the env of cmd.
T 1710201583 18<27Soliton18>	it's set to the empty string.
T 1710201616 18<25cedd18>	btw, this is what's being piped to that line: inotifywait -qmr -e 'moved_to,create' --format '%w%f%0' --no-newline ~/test |\
T 1710201664 18<25cedd18>	its not clear to me at all what the while list is doing
T 1710201716 18<27Soliton18>	it reads file names delimited by NUL.
T 1710201835 18<27Soliton18>	# printf '%s\0' $'file\n1' $'\tfile 2  ' | while IFS= read -r -d '' file; do printf '<%s>\n' "$file"; done
T 1710201837 18<25shbot18>	Soliton: <file
T 1710201837 18<25shbot18>	Soliton: 1>
T 1710201837 18<25shbot18>	Soliton: <       file 2  >
T 1710201909 18<27Soliton18>	without IFS= it'd mangle the file names.
T 1710202516 18<27ztrawhcse18>	kurahaupo: interesting. I can't see where in the gentoo ebuild it is telling bash 2.05b to do so, and the result is a 64-bit executable...
T 1710203142 18<25kurahaupo18>	ztrawhcse: I tried building every version of Bash that I could, and if I didn't force some of them to be 32-bit, they would build but then crash at runtime. I'll have to check which ones I needed to specify
T 1710203230 18<25cedd18>	Soliton: oic, excellent demonstration, so "IFS=" is how you set IFS to null, and the "file" term in the while list is just the name the var that read outputs to from stdin in that example?
T 1710203527 18<27Soliton18>	VAR= is how you set any variable to empty. you can also use VAR='' if you like that better.
T 1710203555 18<27Soliton18>	and yes file is the argument to read that tells it what variable name to use.
T 1710203914 18<25kurahaupo18>	cedd: You can't just look at one line, you need to look at the whole block. Start with the top level syntax: ¬´ while LIST1 ; do LIST2 ; done ¬ª where LIST1 & LIST2 are each a list of commands. It keeps repeating as long as the last command in LIST1 is successful (status zero). (Note that line breaks can be used in place of semicolons; and newlines are permitted after "while" and "do".)
T 1710203915 18<25kurahaupo18>	The "read" command has status zero iff it reads a whole line from its stdin, so it repeats for every whole line in the input, assuming there is nothing else before the "do". (Please include the "do" next time you're posting such a question.)
T 1710203915 18<25kurahaupo18>	Any (simple) command may be prefaced with variable assignments that are placed into the environment of just that one command (even if it's a built in). The read command is sensitive to the IFS variable.
T 1710203915 18<25kurahaupo18>	Variable assignments take the form WORD=VALUE where VALUE stops at the first space (so IFS= is setting IFS to empty)
T 1710204216 18<25cedd18>	kurahaupo: interesting, and great explanation, so if the read command is reading a blocking file, then that while loop should continue indefinitely right?
T 1710204258 18<25cedd18>	the exmaple in question is the last example at the bottom of the inotifywait man page
T 1710204271 18<25cedd18>	the do line is just a chown command on the file var
T 1710204453 18<25kurahaupo18>	cedd: We just need the "do" on its own, not the rest of the line, because it's important to show that there are no other commands between "read" and "do".
T 1710204454 18<25kurahaupo18>	Yes if the input is a pipe or serial device it will loop indefinitely.
T 1710204566 18<25kurahaupo18>	For the sake of writing this in one line in IRC, you can write ¬´ while ‚Ä¶ ; do ¬ª
T 1710204577 18<25cedd18>	so the IFS= item in the list only gets executed once, because the read is essentially indefinite items for a blocking file
T 1710204588 18<25cedd18>	kurahaupo: yea i should have done that in hindsight
T 1710204623 18<25kurahaupo18>	The assignment to IFS happens every time the read command is attempted
T 1710204683 18<25kurahaupo18>	And it is technically part of the read command; not a separate command
T 1710204687 18<25cedd18>	oh really? wouldnt it be better to set it before the while loop then?
T 1710204694 18<25cedd18>	oh ok
T 1710204738 18<25kurahaupo18>	IFS has effects in multiple places, not just read.
T 1710204791 18<25kurahaupo18>	The point is to limit the effect of changing it to the minimum possible scope, to just the read command itself
T 1710204826 18<25cedd18>	i see, i just hate wasting any amount of cpu no matter how small lol
T 1710204909 18<25kurahaupo18>	# while IFS= read -r x ; do printf '(%s)' $x ; done <<<'abc def ghi'
T 1710204911 18<25shbot18>	kurahaupo: (abc)(def)(ghi)
T 1710204922 18<25kurahaupo18>	# while IFS= ; read -r x ; do printf '(%s)' $x ; done <<<'abc def ghi'
T 1710204924 18<25shbot18>	kurahaupo: (abc def ghi)
T 1710204935 18<25kurahaupo18>	# IFS= ; while read -r x ; do printf '(%s)' $x ; done <<<'abc def ghi'
T 1710204937 18<25shbot18>	kurahaupo: (abc def ghi)
T 1710204948 18<25kurahaupo18>	See how those outputs change?
T 1710204990 18<25kurahaupo18>	cedd: that's why it's important to constrain changes to IFS
T 1710205027 18<25cedd18>	yea i do
T 1710205052 18<25cedd18>	well if its unavoidable then its what i must do lol
T 1710205101 18<25cedd18>	and thanks again for these great explanations, super helpful!
T 1710205268 18<25kurahaupo18>	Some argue that the default value of IFS is a trip hazard and that setting it globally to empty is the lesser of two evils. I've certainly done that a few times
T 1710205355 18<26ormooj18>	I think that it is guaranteed to corrupt your data if IFS is empty unless LC_CTYPE=C is a stupid hazard.
T 1710205369 18<25cedd18>	were you not setting it globally in the 3rd iteration of that while loop?
T 1710205391 18<26ormooj18>	Fine not guaranteed, potentially can.
T 1710205522 18<25cedd18>	ormooj: which data do you think it would potentially corrupt?
T 1710205540 18<26ormooj18>	data that contains nul, the very thing you're trying to terminate on
T 1710205586 18<25cedd18>	isnt that usually only at like the end of a file?
T 1710205625 18<25cedd18>	i guess it could be anywhere though
T 1710205671 18<26ormooj18>	most shells have a special case exception for empty IFS if the current encoding is UTF-8, because a nul in an incorrect place can't possibly be valid UTF-8, but bash doesn't, so it will randomly truncate data incorrectly if your encoding is UTF-8
T 1710205740 18<26ormooj18>	in bash you have to use `LC_CTYPE=C IFS= read -rd ''`
T 1710205752 18<25kurahaupo18>	Oof!
T 1710205762 18<26ormooj18>	I don't think we even have a pitfall for that one. it's very obscure
T 1710205769 18<26ormooj18>	I didn't even know it
T 1710205787 18<26ormooj18>	it's fucking stupid
T 1710205801 18<25kurahaupo18>	(I globally have LC_CTYPE=C.UTF-8 in my login)
T 1710205810 18<26ormooj18>	same
T 1710205817 18<26ormooj18>	I know I have that bug in a ton of my code
T 1710205862 18<25kurahaupo18>	Also LC_COLLATE because it really annoys me when the output of "ls" is in some scrambled order
T 1710205881 18<26ormooj18>	yeah I do that too ^^
T 1710205911 18<25cedd18>	what is the "LC_CTYPE=C" part doing?
T 1710205939 18<25kurahaupo18>	It's an assignment, the same as IFS= is an assignment
T 1710205962 18<26ormooj18>	It forces bash to read bytes rather than try to decode the input for the purpose of splitting and finding the delimiter
T 1710205962 18<25cedd18>	i see its another bash variable it uses for various things
T 1710206010 18<25kurahaupo18>	It's used by many things besides Bash, so it's even more important to isolate
T 1710206077 18<25kurahaupo18>	Unless, like ormooj and me, you decide you never want anything other than the standard locale
T 1710206136 18<25cedd18>	locale is the language chracter set?
T 1710206144 18<25kurahaupo18>	ormooj: does LC_CTYPE=C.UTF-8 have the same effect as LC_CTYPE=C in this respect?
T 1710206173 18<25cedd18>	and am i understanding right that bash is by default reading a byte of all zeroes as null when it could be another utf-8 charaxter thats >1 byte long?
T 1710206180 18<25kurahaupo18>	cedd: locale is a collection of parameters related to language and regional conventions
T 1710206181 18<26ormooj18>	no I don't think do. any non-C locale would cause bash to goof
T 1710206208 18<26ormooj18>	Even if you don't set LC_CTYPE your LANG is probably en_US.UTF-8 or similar, which is just as bad
T 1710206225 18<26ormooj18>	er you're aussie so, whatever that one is
T 1710206246 18<25kurahaupo18>	en_AU.UTF-8
T 1710206252 18<26ormooj18>	:D
T 1710206276 18<25cedd18>	oh so locale is a variation of a given language
T 1710206303 18<25kurahaupo18>	It includes language choice and local dialect
T 1710206361 18<25kurahaupo18>	And charset (UTF-8, Latin-1, shift-JIS, whatever)
T 1710206391 18<20cappy18>	On a filename containing whitespace, why does the following not work to advance the file's modification date:
T 1710206395 18<20cappy18>	touch -m -d "$(date -R -r "$1") + 1 hours" "$1"
T 1710206438 18<25kurahaupo18>	I've always thought that "encoding" and "charset" should be separate, that UTF-8 should be part of TERM, not part of LANG, but I'm a lone wolf on that one.
T 1710206470 18<25kurahaupo18>	cappy: GNU date understands "+ n hours"
T 1710206476 18<26ormooj18>	read does way too many things
T 1710206487 18<26ormooj18>	with 1 command
T 1710206495 18<25kurahaupo18>	Indeed
T 1710206517 18<20cappy18>	kurahaupo: It works if the filename has no whitespace. Same `date`.
T 1710206543 18<25kurahaupo18>	What do you make of the latest insanity: ¬´ local -g Foo ¬ª does nothing at all!
T 1710206585 18<26ormooj18>	ha
T 1710206629 18<25kurahaupo18>	cappy: I think I prefer stat rather than date for that, but I'm not sure which one is "standard"
T 1710206763 18<20cappy18>	kurahaupo: Indeed, but despite rebuilding a backup thumb drive as exfat, believing dates are stored with timezone as is on ext4, I need to advance the mod time since we switched to Daylight Saving Time this past Sunday.
T 1710206844 18<20cappy18>	So a small `touch` script run by find(1) should do it. Tested on a temp directory, but the production directory has files with whitespace.
T 1710206909 18<25cedd18>	it crossed my mind to try to do that on some pictures i took for work, because it was to my benefit to have them taken a few days earlier lol
T 1710206980 18<20cappy18>	Routinely, I do a meld(1) to ensure that the backup thumbdrive is in sync. Meld is citing time differences now.
T 1710206993 18<25cedd18>	kurahaupo: i think youre right that they should be seprate, and maybe the world doesnt actually need a universal charset for all languages
T 1710207034 18<25cedd18>	universal encoding*
T 1710207379 18<22phogg18>	ormooj: I don't want to alarm you but you appear to have lost the stems on your As
T 1710207483 18<22phogg18>	I came here today that I made a strategic error and looked at some of the .sh files that Oracle's runInstaller program generates. It demonstrates once again that you should never trust the quality of commercial software, especially not shell scripts, and especially not Oracle.
T 1710207491 18<22phogg18>	s/today/today to say/
T 1710207516 18<22phogg18>	e.g., someone thought it was cute to use ! as the marker for a heredoc.
T 1710207565 18<25cedd18>	phogg: the original had a 1700s constitution vibe
T 1710207600 18<22phogg18>	cedd: original?
T 1710207623 18<25cedd18>	phogg: without the substitution
T 1710207657 18<22phogg18>	Now I understand
T 1710207664 18<25cedd18>	:)
T 1710207953 18<20cappy18>	kurahaupo: Get your point now. Don't need touch. Thanks.
T 1710208165 18<26ormooj18>	i'm not logged in :|
T 1710208450 18<26ormooj18>	heh i've seen ! used for heredoc markers
T 1710225221 19*	Now talking on 22#bash
T 1710225221 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1710225221 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1710225909 18<26sphertext_18>	# touch "-"; rm *
T 1710225912 18<25shbot18>	sphertext_: rm: cannot remove '*': No such file or directory
T 1710225928 18<26sphertext_18>	i think if there's a dash in the filename, rm fails?
T 1710226016 18<27JAA18>	# touch -; printf '%q ' *
T 1710226018 18<25shbot18>	JAA: \*
T 1710226225 18<27JAA18>	`touch -` is a special case. It doesn't create a file with that name.
T 1710226231 18<27JAA18>	# touch ./-; printf '%q ' *
T 1710226233 18<25shbot18>	JAA: -
T 1710226248 18<26sphertext_18>	:D
T 1710226264 18<26sphertext_18>	i actually somehow ended up with a filename "-filename" and idk how to delete it
T 1710226276 18<27JAA18>	rm ./-filename
T 1710226294 18<26sphertext_18>	oh ok
T 1710226318 18<27JAA18>	Or `rm -- -filename` probably maybe. I don't recall whether that's guaranteed to work.
T 1710226339 18<26sphertext_18>	so it's problematic if filename starts with -
T 1710226347 18<27JAA18>	It is in the POSIX guidelines, but...
T 1710226358 18<26sphertext_18>	the * expansion isn't safe
T 1710226380 18<27JAA18>	You should always know what you're doing when using globs, yes.
T 1710226380 18<26sphertext_18>	well i suppose it's safe but the program doesn't know it's a filename
T 1710226397 18<26sphertext_18>	since all it sees is an argument
T 1710226399 18<27JAA18>	You can use ./* of course.
T 1710226413 18<26sphertext_18>	hmm that seems better yeah
T 1710226420 18<27JAA18>	Or --
T 1710233867 18<24sunyibo18>	many commands I type don't end up in my history. How can I fix this?
T 1710234024 18<20osse18>	sunyibo: what is the value of $HISTIGNORE ?D
T 1710234525 18<24sunyibo18>	this command returns no value
T 1710234657 18<29djph18>	sunyibo: what command?
T 1710235538 18<24sunyibo18>	$HISTIGNORE
T 1710235582 18<29djph18>	that's a variable, not a command.
T 1710235594 18<24sunyibo18>	so where can I find the variable?
T 1710235608 18<24geirha18>	declare -p "${!HIST@}"
T 1710235620 18<24ano18>	sunyibo: HISTIGNORE isn't a cmd, it's a var, chk its value e.g. via (printf %s\\n "$HISTIGNORE") cmd, see (info -n 'bash history facilities' bash) to figure out how bash history works
T 1710235682 18<24sunyibo18>	even those commands return no value
T 1710235917 18<24ano18>	hmm geirha approach much
T 1710235943 18<24ano18>	better since will show spaces etc
T 1710235986 18<24ano18>	sunyibo: what do u mean by "commands I type don't end up in my history" ?
T 1710235993 18<24geirha18>	sounds like HISTIGNORE is unset though, so it should default to ignoring lines that start with space
T 1710236464 18<24ano18>	geirha: default? no HISTIGNORE in case of (be careful with that command if HISTFILE not set to non-default path it will trim history to default values) (bash --noprofile --norc -il <<<'declare -p "${!HIST@}"'), only HISTCMD/HISTFILE/HISTFILESIZE/HISTFILE, no value (at all) for (declare -p "${!HIST@}") very strange
T 1710236658 18<24ano18>	sunyibo: are u sure that don't see *anything* at all after (declare -p "${!HIST@}") execution?
T 1710236768 18<24ano18>	# bash --noprofile --norc -il <<<'declare -p "${!HIST@}"' 2>/dev/null | tr \\n \|
T 1710236771 18<25shbot18>	ano: no output
T 1710236790 18<24geirha18>	I mean, if HISTIGNORE is not set, the default behavior is to ignore lines that start with space
T 1710236898 18<24geirha18>	ah no, nevermind, that's having ignorespace or ignoreboth in HISTCONTROL, so not actually a default behavior
T 1710237088 18<24sunyibo18>	I've had the issue for a while and I was told it was due to bash and I should switch to zsh or something
T 1710237125 18<27Soliton18>	!faq history lines
T 1710237125 18<29greybot18>	https://mywiki.wooledge.org/BashFAQ/088 -- How can I avoid losing any history lines?
T 1710237403 18<24sunyibo18>	thanks! I'll read this when my headache is gone, I've slept enough and had two cups of coffee ;-)
T 1710237462 18<24ano18>	# bash --noprofile --norc -o history -il <<<'declare -p "${!HIST@}"' | tr \\n :
T 1710237464 18<25shbot18>	ano: declare -p "${!HIST@}"
T 1710237495 18<24ano18>	is shbot broken or something else?
T 1710237517 18<24ano18>	# bash --noprofile --norc -o history -il <<<'declare -p "${!HIST@}"'
T 1710237520 18<25shbot18>	ano: declare -p "${!HIST@}"
T 1710237520 18<25shbot18>	ano: declare -i HISTCMD="1"
T 1710237520 18<25shbot18>	ano: etc... ( http://paste.wooledge.org/29490 )
T 1710237540 18<24ano18>	# bash --noprofile --norc -o history -il <<<'declare -p "${!HIST@}"' | sed s/HIST//
T 1710237542 18<25shbot18>	ano: declare -p "${!HIST@}"
T 1710237542 18<25shbot18>	ano: declare -i CMD="1"
T 1710237556 18<24ano18>	that's strange
T 1710237809 18<24sunyibo18>	(disretely chuckling)
T 1710238108 18<24ano18>	# bash -c "bash --noprofile --norc -o history -il <<<'declare -p \"\${!HIST@}\"'" 2>/dev/null | tr \\n \|
T 1710238110 18<24geirha18>	# PS1= bash --noprofile --norc -o history -il <<<'declare -p "${!HIST@}"' | sed s/HIST//
T 1710238111 18<25shbot18>	ano: declare -i HISTCMD="1"|declare -- HISTFILE="/root/.bash_history"|declare -- HISTFILESIZE="500"|declare -- HISTSIZE="500"|
T 1710238111 18<25shbot18>	geirha: no output
T 1710238192 18<24geirha18>	# unset -v PROMPT_COMMAND ; PS1= bash --noprofile --norc -o history -il <<<'declare -p "${!HIST@}"' | sed s/HIST//
T 1710238195 18<25shbot18>	geirha: declare -p "${!HIST@}"
T 1710238195 18<25shbot18>	geirha: logout
T 1710238195 18<25shbot18>	geirha: etc... ( http://paste.wooledge.org/29496 )
T 1710238335 18<24geirha18>	A bit of a timing issue with PS1 set to immediately kill the VM second time it's evaled
T 1710240982 18<24ano18>	# coproc { cat; }; eval exec "${COPROC[0]}>&2"; echo 2 >&"${COPROC[1]}"; sleep 0.1
T 1710240984 18<25shbot18>	ano: [1] 51
T 1710241047 18<24ano18>	why there is no(?) 2 in output/stderr?
T 1710241152 18<24ano18>	(eval exec "${COPROC[0]}>&2") isn't mean that everything from ${COPROC[0]} (coproc stdout) should be redirected to terminal stderr?
T 1710241984 18<24ano18>	# coproc { echo foo; } 1>&2; sleep 1
T 1710241987 18<25shbot18>	ano: [1] 51
T 1710241987 18<25shbot18>	ano: foo
T 1710241987 18<25shbot18>	ano: [1]+  Done                    coproc COPROC { echo foo; } 1>&2
T 1710242006 18<24ano18>	# coproc { echo foo; } 1>&1; sleep 1
T 1710242008 18<25shbot18>	ano: [1] 51
T 1710242008 18<25shbot18>	ano: [1]+  Done                    coproc COPROC { echo foo; } 1>&1
T 1710242101 18<24ano18>	# exec {fd}>&1; coproc { echo foo; } 1>&${fd}; sleep 1
T 1710242104 18<25shbot18>	ano: [1] 51
T 1710242105 18<25shbot18>	ano: foo
T 1710242105 18<25shbot18>	ano: [1]+  Done                    coproc COPROC { echo foo; } >&${fd}
T 1710242744 18<22tirnanog18>	ano: by dup'ing 2 to COPROC[0], you replace - and thereby destroy - the writing end of one of the pipes. cat will still try to write that which it initially reads but will then have to contend with SIGPIPE or EPIPE.
T 1710243215 18<22tirnanog18>	er, the reading end, I mean.
T 1710243343 18<22tirnanog18>	put another way, the act of duplicating fd 2 does not amount to a demand upon bash to somehow syphon up the input from the (already existing) pipe in question then convey it to fd 2 for you.
T 1710250873 18<19DmanT18>	hi all
T 1710254906 18<20Andy_Kw18>	Hi, in ksh, what does it mean to do `alias -x TOTO="/rep1/rep2"`
T 1710256817 18<28emanuele618>	the manual says "The obsolete -x option has no effect."
T 1710256841 18<28emanuele618>	i don't know what it used to do
T 1710256972 18<29phy172918>	If it was like OpenBSD's ksh's -x   "The -x option sets (+x clears) the export attribute of an alias or, if no names are given, lists the aliases with the export attribute (exporting an alias has no effect)."
T 1710259231 19*	Now talking on 22#bash
T 1710259231 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1710259231 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1710272022 18<22CrtxReavr18>	OpenBSD's ksh?
T 1710272048 18<22CrtxReavr18>	OpenBSD probably has a ksh port, but. . . it wouldn't be OpenBSDs.
T 1710272161 18<28llua18>	yes, openbsd ksh
T 1710272276 18<20twkm18>	a pdksh evolution.
T 1710272307 18<22tirnanog18>	it most definitely is openbsd's. there are at least two ports of it too (oksh and loksh).
T 1710272448 18<22tirnanog18>	it's also their /bin/sh. it's pretty good.
T 1710273383 18<27Earnestly18>	Which BSD uses mksh then?
T 1710273401 18<27Earnestly18>	Oh, mirbsd, a bit obvious
T 1710273404 18<22tirnanog18>	yep.
T 1710275187 18<26ormooj18>	mooh
T 1710275265 18<26ormooj18>	wow mksh have that too?
T 1710275335 18<20twkm18>	mksh is also a pdksh evolution.
T 1710275372 18<26ormooj18>	yes they don't have that many feature differences
T 1710275396 18<26ormooj18>	well, ${|
T 1710279079 18<28lmat18>	How do I use a here document and use "||"
T 1710279115 18<28lmat18>	gnuplot << "EOF"\n...\nEOF || exit;  obviously doesn't work because that's the wrong end-of-here-document marker.
T 1710279169 18<28emanuele618>	lmat: gnuplot << "EOF" || exit    ....   EOF
T 1710279293 18<28emanuele618>	the lines after the line that has <<EOF (or following lines if it is continuated by \) are part of the heredoc up the the line that contains EOF
T 1710279316 18<28emanuele618>	so the correct place to put || exit  is after <<EOF
T 1710279379 18<28emanuele618>	however, if you prefer, you could wrap the gnuplot command in { } and then put the ||exit after e.g.   {\n  gnuplog <<'EOF'\n...\nEOF\n} || exit
T 1710279417 18<29phy172918>	cat <<EOF; cat <<ASDF  is valid even
T 1710279435 18<25greycat18>	<<EOF is a redirection just like </dev/null, so if you would write  foo </dev/null || exit  then you can write  foo <<EOF || exit
T 1710279487 18<28lmat18>	emanuele6: Nice, thank you!
T 1710279497 18<28lmat18>	phy1729: :'(
T 1710279527 18<28emanuele618>	in that case, lines up to EOF are part of the first heredoc, and then lines after EOF up to ASDF are part of the second heredoc
T 1710279533 18<25greycat18>	if I needed two heredocs in the same pipeline, I would put at least one of them into a function, and then call the function in the pipeline
T 1710279640 18<28emanuele618>	or use a there doc
T 1710279665 18<29phy172918>	the real question is what does   cat - <<EOF "$(cat <<ASDF)"   do?
T 1710279669 18<28emanuele618>	exec 3<<'EOF'\n...EOF     cmd <&3-; cmd <<EOF
T 1710279672 18<28emanuele618>	:^)
T 1710279701 18<26ormooj18>	phy1729 nothing interesting :(
T 1710279719 18<28emanuele618>	$(cat <<EOF)   can't work because bash only stores $(cat <<EOF)  in the word
T 1710279725 18<28emanuele618>	so it cannot find the heredoc
T 1710279787 18<26ormooj18>	I wish I could auto-number them since I use multiple heredocs so often
T 1710279803 18<29phy172918>	wait, WHY
T 1710279810 18<26ormooj18>	<<EOF$((n++))
T 1710279813 18<26ormooj18>	:D
T 1710279815 18<28emanuele618>	i think you can just use the same terminator
T 1710279876 18<28emanuele618>	you don't have to use a different one, they are read left to right
T 1710279878 18<26ormooj18>	I can do that with the heredoc command ^^
T 1710279912 18<28emanuele618>	or i guess i should say from start to end
T 1710279913 18<29phy172918>	I'm trying to think of how to break thr LTR bit. <( and $( don't work really
T 1710279921 18<28emanuele618>	because they could be read right to left
T 1710279926 18<28emanuele618>	if you have something like
T 1710279942 18<28emanuele618>	cat foobar <<EOF;\
T 1710279946 18<28emanuele618>	cat<<EOF
T 1710279953 18<28emanuele618>	that is right to left :^)
T 1710279962 18<29phy172918>	not meaninfully
T 1710280076 18<28emanuele618>	you could use an alias i think
T 1710280123 18<28emanuele618>	# alias x=$'cat <<EOF\nhi'; eval $'y="$(x\nEOF)"'; declare -p y
T 1710280125 18<25shbot18>	emanuele6: bash: hi: command not found
T 1710280125 18<25shbot18>	emanuele6: declare -- y=""
T 1710280131 18<28emanuele618>	hmm
T 1710280223 18<28emanuele618>	# alias x=$'cat <<EOF\nhi'; eval $'y="$(x\nEOF\n)"'; declare -p y
T 1710280225 18<25shbot18>	emanuele6: bash: hi: command not found
T 1710280225 18<25shbot18>	emanuele6: declare -- y=""
T 1710280271 18<28emanuele618>	it does not work; not sure why
T 1710280280 18<28emanuele618>	cat is running, probably with an empty heredoc
T 1710280306 18<28emanuele618>	weird that  EOF: command not found  is not printed
T 1710280479 18<28emanuele618>	i thought that maybe it did not work because newlines are understood as ;s in $(), but that can't be all of it because it would say   EOF: command not found   if that was the case
T 1710280752 18<28emanuele618>	hmm, with strace i can see that bash is running    cat </dev/null   : openat(AT_FDCWD, "/dev/null", O_RDONLY); dup2(3, 0); close(3); execve("/usr/bin/cat",    which is odd
T 1710280846 18<28emanuele618>	it just checked and it seems it does that for any empty heredoc, so it is not as weird; it just means that somehow it thinks that the heredoc is empty
T 1710280997 18<28emanuele618>	ah, the issue is that heredoc text cannot come from an alias
T 1710281014 18<28emanuele618>	# alias x=$'cat <<EOF'; eval $'y="$(x\nhi\nhello\nEOF)"'; declare -p y
T 1710281016 18<25shbot18>	emanuele6: declare -- y=$'hi\nhello'
T 1710281025 18<28emanuele618>	it works :D
T 1710281164 18<28emanuele618>	# eval $'f () { y="$(x\nhi\nEOF);}"'; alias x=$'cat <<EOF'; f; printf 'y=%s\t' "$y"; alias x='echo x'; f; printf 'y=%s\t' "$y"
T 1710281166 18<25shbot18>	emanuele6: bash: syntax error: unexpected end of file
T 1710281166 18<25shbot18>	emanuele6: bash: f: command not found
T 1710281166 18<25shbot18>	emanuele6: etc... ( http://paste.wooledge.org/29513 )
T 1710281188 18<28emanuele618>	huh?
T 1710281198 18<28emanuele618>	oh, i was thinking of the POSIX mode alias behaviour
T 1710281364 18<28emanuele618>	no, i just put the quotes wrong in eval; this does not work with POSIX mode aliases
T 1710281367 18<28emanuele618>	# eval $'f () { y=$(x\nhi\nEOF\n);}'; alias x=$'cat <<EOF'; f; printf 'y=%s\t' "$y"; alias x='echo x'; f; printf 'y=%s\t' "$y"
T 1710281369 18<25shbot18>	emanuele6: y=hi    bash: hi: command not found
T 1710281369 18<25shbot18>	emanuele6: bash: EOF: command not found
T 1710281369 18<25shbot18>	emanuele6: y=x
T 1710281371 18<28emanuele618>	:D
T 1710281630 18<25ormaaj18>	https://bpa.st/raw/S5QA
T 1710281638 18<25ormaaj18>	but ! is a variable!
T 1710281727 18<25ormaaj18>	and I have no clue how to escape that \0. It should be \\0 -> \0 for execline but don't know what env wants.
T 1710282072 18<25ormaaj18>	this is not so nice because I don't think there's a way to rename / move an environment variable without an importas so I was hoping env -S would work.
T 1710282087 18<28emanuele618>	!aside
T 1710282087 18<29greybot18>	"As an aside, don't use all upper-case variable names for purely internal purposes." ~twkm
T 1710282122 18<25ormaaj18>	^^
T 1710282124 18<28emanuele618>	in this case use all upper-case for environment variables :D
T 1710282163 18<28emanuele618>	!learn asidealt As an aside, use all upper-case variable names for environment variables.
T 1710282163 18<29greybot18>	OK, emanuele6
T 1710282210 18<25ormaaj18>	meh you can remove that to not highlight twkm. That's his famous quote tho
T 1710282809 18<20bent_fingers18>	i knew that
T 1710282848 18<28emanuele618>	that is why its famous
T 1710284635 18<19uuuuu18>	how come when I echo '\'asd' bash thinks the command isn't finished
T 1710284650 18<20arraybolt318>	Escaping doesn't work in single quotes.
T 1710284660 18<20arraybolt318>	# echo "\'asd"
T 1710284662 18<25shbot18>	arraybolt3: \'asd
T 1710284670 18<20arraybolt318>	# echo -e "\'asd"
T 1710284672 18<25shbot18>	arraybolt3: \'asd
T 1710284687 18<20arraybolt318>	wow
T 1710284692 18<20arraybolt318>	# echo "'asd"
T 1710284694 18<25shbot18>	arraybolt3: 'asd
T 1710284720 18<19uuuuu18>	I know, but I still want to know why I can't have '\'asd'
T 1710284724 18<20arraybolt318>	ahem. So, use `echo -e` with double quotes when you need escaping. Also, you don't have to escape a ' when using double-quotes, as I just unintentionally demonstrated by fumbling all over myself.
T 1710284775 18<20arraybolt318>	uuuuu: Breaking it down character by character, ' = start a string, \ = literal, ' = end a string, asd = something outside the string, Bash will parse this in a way you don't intend, ' = start a string.
T 1710284784 18<20arraybolt318>	By the end of it, you start a string that you don't finish.
T 1710284803 18<28emanuele618>	uuuuu: \' does not mean anything, there '\' is just a single quoted \, then you have asd, and then you start a ' that you never close
T 1710284850 18<28emanuele618>	it is the same that would happen if you used  'a'asd'  \ does not do anything special
T 1710286055 18<25kurahaupo18>	arraybolt3: "echo -e" shouldn't be recommended for anything; printf is more portable and $'‚Ä¶' is more efficient, and both are less problematic with interpolation.
T 1710287020 18<20bent_fingers18>	whenever i see 'echo -e' i grab my marker and smudge the `-e` on my screen
T 1710287788 18<28emanuele618>	bent_fingers:  i=0; while (( i < COLUMNS * LINES )); do clear; printf '%*s%s' "$((i++))" '' 'echo -e Hello, World!'; sleep .2; done; printf \\n
T 1710288439 18<25kurahaupo18>	emanuele6: s/while/for/
T 1710288641 18<25kurahaupo18>	emanuele6: Why include "*LINES"? I'd have thought i<=COLUMNS-21 (where 21 is the length of 'echo -e Hello, World!')
T 1710288903 18<20bent_fingers18>	emanuele6: hahaha
T 1710289131 18<25kurahaupo18>	s='echo -e Hello, World!' t=${s//-e/$'\e[2m-e\e[22m'} ; for (( i=0 ; i <= COLUMNS*LINES - ${#s} ; ++i )) do printf '\e[H%*s%s\e[J' "$i" '' "$t"; sleep .1; done; printf \\n
T 1710289254 18<20bent_fingers18>	Per man page: "A pipeline is a sequence of one or more commands separated by ..."
T 1710289256 18<25kurahaupo18>	We used to worry about supporting multiple terminal types with different escape codes, but everything other than IEC codes died 20+ years ago.
T 1710289265 18<20bent_fingers18>	so a single command is a pipeline?
T 1710289279 18<25kurahaupo18>	bent_fingers: grammatically speaking, yes
T 1710289310 18<29phy172918>	I'm glad the international electrical codes are still around
T 1710289313 18<25kurahaupo18>	However a singleton pipeline doesn't get an implicit subshell
T 1710289324 18<20bent_fingers18>	the definition for "list" is analogous
T 1710289331 18<20bent_fingers18>	so a single command is also a list?
T 1710289340 18<25kurahaupo18>	Correct
T 1710289356 18<29phy172918>	# help while
T 1710289358 18<25shbot18>	phy1729: while: while COMMANDS; do COMMANDS-2; done
T 1710289358 18<25shbot18>	phy1729:     Execute commands as long as a test succeeds.
T 1710289358 18<25shbot18>	phy1729: etc... ( http://paste.wooledge.org/29584 )
T 1710289366 18<29phy172918>	bah it says COMMANDS not list
T 1710289371 18<25kurahaupo18>	bent_fingers: it's about specifying what's acceptable in a given context
T 1710289388 18<20bent_fingers18>	it's been awhile since i've heard the word "singleton"
T 1710289417 18<25kurahaupo18>	Actually LIST is used in the definition of "for"
T 1710289440 18<25kurahaupo18>	# help for | grep LIST
T 1710289441 18<25shbot18>	kurahaupo: no output
T 1710289449 18<25kurahaupo18>	# help for
T 1710289452 18<25shbot18>	kurahaupo: for: for NAME [in WORDS ... ] ; do COMMANDS; done
T 1710289452 18<25shbot18>	kurahaupo:     Execute commands for each member in a list.
T 1710289452 18<25shbot18>	kurahaupo: etc... ( http://paste.wooledge.org/29585 )
T 1710289457 18<25kurahaupo18>	Gah
T 1710289463 18<25kurahaupo18>	It was used there
T 1710289495 18<25kurahaupo18>	That help line is wrong; the semicolon should be inside the []
T 1710289570 18<25kurahaupo18>	(a spurious semicolon is allowed between NAME and do, but it has no purpose there)
T 1710290101 18<28emanuele618>	# a () for ((;;)) do :;done; declare -f a | grep for
T 1710290103 18<25shbot18>	emanuele6:     for ((1; 1; 1))
T 1710290112 18<25ormaaj18>	# for((;;)){(())||print -n 'moo ';}
T 1710290120 18<25shbot18>	ormaaj: bash: print: command not found
T 1710290120 18<25shbot18>	ormaaj: bash: print: command not found
T 1710290120 18<25shbot18>	ormaaj: etc... ( http://paste.wooledge.org/29587 )
T 1710290124 18<28emanuele618>	111!
T 1710290134 18<25ormaaj18>	111
T 1710290187 18<28emanuele618>	# a () for ((    1;    1;    1)) do :;done; declare -f a | grep for
T 1710290189 18<25shbot18>	emanuele6:     for ((1; 1; 1))
T 1710290200 18<28emanuele618>	# a () for ((1    ;1    ;1    )) do :;done; declare -f a | grep for
T 1710290202 18<25shbot18>	emanuele6:     for ((1    ; 1    ; 1    ))
T 1710290232 18<25ormaaj18>	(()) = dead code
T 1710290287 18<25ormaaj18>	wow `for((;;)){(print -n 'moo ')}` is very slow.
T 1710290304 18<28emanuele618>	# a () (()); declare -f a | grep ((
T 1710290305 18<25shbot18>	emanuele6: bash: syntax error near unexpected token `('
T 1710290306 18<28emanuele618>	oops
T 1710290308 18<28emanuele618>	# a () (()); declare -f a | grep '(('
T 1710290310 18<25shbot18>	emanuele6:     (())
T 1710290342 18<28emanuele618>	(()) is not equivalent to ((1)), only ((;;)) is equivalent to ((1;1;1))
T 1710290351 18<28emanuele618>	also i guess (()) is equivalent to ((0))
T 1710290359 18<28emanuele618>	# (()); echo "$?"
T 1710290361 18<25shbot18>	emanuele6: 1
T 1710290527 18<28emanuele618>	i wonder if i can hack that 1 used for ((1;1;1))
T 1710290589 18<25ormaaj18>	 $ bash -c 'function f { typeset n=0; for((;++n<1000;)){(print -n "moo ")}; echo; }; time f' >/dev/null
T 1710290589 18<25ormaaj18>	real    0m0.835s
T 1710290612 18<25ormaaj18>	 $ ksh -c 'function f { typeset n=0; for((;++n<1000;)){(print -n "moo ")}; echo; }; time f' >/dev/null
T 1710290612 18<25ormaaj18>	real    0m00.001s
T 1710290657 18<25ormaaj18>	faster with proper integer
T 1710290716 18<28emanuele618>	also faster because ksh does not fork, while bash does
T 1710290743 18<25ormaaj18>	yeah it's real slow even for that though
T 1710290772 18<28emanuele618>	how do you have print pre-enabled in bash?
T 1710290818 18<25ormaaj18>	$ bash -c 'type print'
T 1710290818 18<25ormaaj18>	print is /usr/local/post/bin/print
T 1710290843 18<25ormaaj18>	 $ cat /usr/local/post/bin/print
T 1710290843 18<25ormaaj18>	#!/usr/bin/ksh
T 1710290843 18<25ormaaj18>	\command -- print "$@"
T 1710290849 18<25ormaaj18>	:P
T 1710290886 18<28emanuele618>	well, that would make it even slower xD
T 1710290956 18<25ormaaj18>	 $ bash -c 'enable print; function f { typeset n=0; for((;++n<1000;)){(print -n "moo ")}; echo; }; time f' >/dev/null
T 1710290956 18<25ormaaj18>	real    0m0.194s
T 1710291017 18<28emanuele618>	and with  { print -n "moo ";}   ?
T 1710291038 18<25ormaaj18>	that should be quick
T 1710291056 18<25ormaaj18>	.002
T 1710292049 18<28emanuele618>	k# bash -c 'for ((;;)) { echo hi;}'
T 1710292056 18<25shbot18>	emanuele6: hi
T 1710292056 18<25shbot18>	emanuele6: hi
T 1710292056 18<25shbot18>	emanuele6: etc... ( http://paste.wooledge.org/29606 )
T 1710292059 18<28emanuele618>	k# dd bs=1 seek=1008250 status=none count=1 <<<0 of=/bin/bash conv=notrunc; bash -c 'for ((;;)) { echo hi;}'
T 1710292060 18<25shbot18>	emanuele6: no output
T 1710292065 18<28emanuele618>	:D
T 1710292086 18<28emanuele618>	so   for((1;1;1)) is more reliable
T 1710292147 18<28emanuele618>	unless if you also hack the bit that makes (()) fail if the result is 0, instead of succeed
T 1710292234 18<28emanuele618>	k# dd bs=1 seek=1008250 status=none count=1 <<<0 of=/bin/bash conv=notrunc; bash -c 'a()for ((;;)) { echo hi;};declare -f a'|grep for
T 1710292236 18<25shbot18>	emanuele6:     for ((0; 0; 0))
T 1710292252 18<28emanuele618>	k# dd bs=1 seek=1008250 status=none count=1 <<<x of=/bin/bash conv=notrunc; bash -c 'a()for ((;;)) { echo hi;};declare -f a'|grep for
T 1710292253 18<25shbot18>	emanuele6:     for ((x; x; x))
T 1710293090 18<28emanuele618>	k# printf \\0 | dd bs=1 seek=1008250 status=none count=1 of=/bin/bash conv=notrunc; bash -c 'for ((;;)) { echo hi;}'
T 1710293091 18<25shbot18>	emanuele6: Memory fault
T 1710293100 18<28emanuele618>	huh?
T 1710293111 18<28emanuele618>	k# printf ' ' | dd bs=1 seek=1008250 status=none count=1 of=/bin/bash conv=notrunc; bash -c 'for ((;;)) { echo hi;}'
T 1710293112 18<25shbot18>	emanuele6: no output
T 1710293147 18<28emanuele618>	not sure why that error happens when i write nul
T 1710293221 18<28emanuele618>	anyway, i guess that is the reason why bash replaces blank with 1, if it left  for((;;))  blank would evaluate to false
T 1710297063 18<28emanuele618>	still, it could have done that for only the second expression instead of all three
T 1710298122 18<25ormaaj18>	that last ksh bug I ran into was a loop optimizer problem
T 1710299720 18<20arraybolt318>	So if parsing the output of ls is the easiest way to go to jail without passing go or collecting $200, what's the recommended way of sorting a list of filenames?
T 1710299739 18<20arraybolt318>	er, I mean, the recommended way to get a sorted directory listing for future use in a script?
T 1710299765 18<20arraybolt318>	(we'll assume the filenames won't contain newlines for `sort`s sake
T 1710300199 18<25ormaaj18>	# a=(/*); typeset -p a
T 1710300202 18<25shbot18>	ormaaj: declare -a a=([0]="/bin" [1]="/dev" [2]="/etc" [3]="/init" [4]="/lib" [5]="/lib64" [6]="/proc" [7]="/root" [8]="/tmp" [9]="/usr" [10]="/var")
T 1710300308 18<20arraybolt318>	awesome, thanks
T 1710300370 18<20arraybolt318>	hmm, though if you'll indulge my "right but I want a cherry on top" for a bit, is there a way to make it not include the entire relative path to the items in the specified directory? Or do I have to trim all those off myself?
T 1710300450 18<25ormaaj18>	globs always sort (by locale) so you're just getting ordinary glob results there.
T 1710300473 18<25ormaaj18>	# cd / && { a=(/*); typeset -p a; }
T 1710300475 18<25shbot18>	ormaaj: declare -a a=([0]="/bin" [1]="/dev" [2]="/etc" [3]="/init" [4]="/lib" [5]="/lib64" [6]="/proc" [7]="/root" [8]="/tmp" [9]="/usr" [10]="/var")
T 1710300477 18<25ormaaj18>	# cd / && { a=(*); typeset -p a; }
T 1710300479 18<25shbot18>	ormaaj: declare -a a=([0]="bin" [1]="dev" [2]="etc" [3]="init" [4]="lib" [5]="lib64" [6]="proc" [7]="root" [8]="tmp" [9]="usr" [10]="var")
T 1710300486 18<20arraybolt318>	Right, but observe:
T 1710300527 18<20arraybolt318>	# cd /; a=(/bin/*); IFS=$'\n'; echo "${a[*]}" | sed "s/\/bin\///"
T 1710300530 18<25shbot18>	arraybolt3: [
T 1710300530 18<25shbot18>	arraybolt3: adu
T 1710300530 18<25shbot18>	arraybolt3: etc... ( http://paste.wooledge.org/29607 )
T 1710300548 18<20arraybolt318>	I'd like to avoid the `sed` hack at the end, especially since it turns my lovely array into a string
T 1710300556 18<20arraybolt318>	and that string has many of the problems of parsing ls :P
T 1710300618 18<20arraybolt318>	I guess I could do something like...
T 1710300633 18<25ormaaj18>	# cd /bin && { a=(*); typeset -p a; }
T 1710300635 18<25shbot18>	ormaaj: declare -a a=([0]="[" [1]="adu" [2]="awk" [3]="basename" [4]="bash" [5]="bash+" [6]="bash1" [7]="bash2" [8]="bash3" [9]="bash32" [10]="bash4" [11]="bash42" [12]="bash43" [13]="bash44" [14]="bash5" [15]="bash50" [16]="bash51" [17]="bash52" [18]="bc" [19]="bsh" [20]="bunzip2" [21]="bzcat" [22]="bzip2" [23]="cal" [24]="cat" [25]="chgrp" [26]="chmod" [27]="chown" [28]="cksum" [29]="cmp" [30]="comm" [3\
T 1710300635 18<25shbot18>	ormaaj: 1]="compress" [32]="cp" [33]="csplit" [34]="cut" [35]="dash" [36]="date" [37]="dd" [38]="df" [39]="diff" [40]="dirname" [41]="du" [42]="echo" [43]="ed" [44]="env" [45]="ex" [46]="expand" [47]="expr" [48]="false" [49]="file" [50]="find" [51]="fold" [52]="fuser" [53]="gawk" [54]="gawk5" [55]="gencat" [56]="getconf" [57]="getent" [58]="grep" [59]="gunzip" [60]="gzip" [61]="head" [62]="hostname" [63]=\
T 1710300635 18<25shbot18>	ormaaj: etc... ( http://paste.wooledge.org/29612 )
T 1710300657 18<20arraybolt318>	:face_palm: how did I not think of that
T 1710300676 18<25ormaaj18>	I don't like to use CWD side-effects if possible. I would just trim it.
T 1710300714 18<20arraybolt318>	I guess for ultimate "don't parse ls" awesomeness, this might do:
T 1710300773 18<27larryv18>	# a=(/bin/*); echo "${a[*]#/bin/}"
T 1710300773 18<25ormaaj18>	# a=(/bin/*) a=("${a[@]##*/}"); printf '%s ' "${a[@]:0:10}"; echo
T 1710300775 18<25shbot18>	ormaaj: no output
T 1710300776 18<25shbot18>	larryv: [ adu awk basename bash bash+ bash1 bash2 bash3 bash32 bash4 bash42 bash43 bash44 bash5 bash50 bash51 bash52 bc bsh bunzip2 bzcat bzip2 cal cat chgrp chmod chown cksum cmp comm compress cp csplit cut dash date dd df diff dirname du echo ed env ex expand expr false file find fold fuser gawk gawk5 gencat getconf getent grep gunzip gzip head hostname iconv id join jq jsh kill ksh ldconfig link ln loc\
T 1710300776 18<25shbot18>	larryv: ale localedef logger logname ls m4 mawk mawk133 mawk134 mkdir mkfifo mknod mksh mktemp mount mv nawk newgrp nice nl nohup oawk od paste patch pathchk pax pr printf ps pwd recode renice rev rm rmdir sed seq setsid sh sleep sort split strace strings stty tabs tac tail tee test time touch tput tr true tsort tty umount uname uncompress unexpand uniq unlink uudecode uuencode wc which who xargs yes zcat
T 1710300794 18<20arraybolt318>	# cd /; a=(/bin/*); b="$(IFS=$'\0'; echo "${a[*]}" | sed -z "s/\/bin\///")"; mapfile -t$'\0' c <<< "${b}"; typeset -p c
T 1710300797 18<25shbot18>	arraybolt3: declare -a c=([0]="[/bin/adu/bin/awk/bin/basename/bin/bash/bin/bash+/bin/bash1/bin/bash2/bin/bash3/bin/bash32/bin/bash4/bin/bash42/bin/bash43/bin/bash44/bin/bash5/bin/bash50/bin/bash51/bin/bash52/bin/bc/bin/bsh/bin/bunzip2/bin/bzcat/bin/bzip2/bin/cal/bin/cat/bin/chgrp/bin/chmod/bin/chown/bin/cksum/bin/cmp/bin/comm/bin/compress/bin/cp/bin/csplit/bin/cut/bin/dash/bin/date/bin/dd/bin/df/bin/diff/bin/\
T 1710300797 18<25shbot18>	arraybolt3: dirname/bin/du/bin/echo/bin/ed/bin/env/bin/ex/bin/expand/bin/expr/bin/false/bin/file/bin/find/bin/fold/bin/fuser/bin/gawk/bin/gawk5/bin/gencat/bin/getconf/bin/getent/bin/grep/bin/gunzip/bin/gzip/bin/head/bin/hostname/bin/iconv/bin/id/bin/join/bin/jq/bin/jsh/bin/kill/bin/ksh/bin/ldconfig/bin/link/bin/ln/bin/locale/bin/localedef/bin/logger/bin/logname/bin/ls/bin/m4/bin/mawk/bin/mawk133/bin/mawk134/b\
T 1710300797 18<25shbot18>	arraybolt3: etc... ( http://paste.wooledge.org/29614 )
T 1710300804 18<20arraybolt318>	well that didn't work
T 1710300829 18<20arraybolt318>	trying to leverage NUL delimiting
T 1710300866 18<20arraybolt318>	anyway, this is overkill, CWD side-effects are perfectly acceptable in the code I'm writing.
T 1710300871 18<25ormaaj18>	# a=(/bin/*) a=("${a[@]##*/}"); printf '%s ' "${a[@]:0:20}"; echo
T 1710300872 18<25shbot18>	ormaaj: [ adu awk basename bash bash+ bash1 bash2 bash3 bash32 bash4 bash42 bash43 bash44 bash5 bash50 bash51 bash52 bc bsh
T 1710300876 18<25ormaaj18>	:o
T 1710300885 18<25ormaaj18>	it said no output before
T 1710300896 18<27larryv18>	because i cut in X(
T 1710300913 18<27larryv18>	i could have sworn shbot didn't have this problem before
T 1710301744 18<25ormaaj18>	arraybolt3: for future reference, `x=$'\0'` is the same as `x=''` is the same as `x=`. You can nether store nor expand a nul anyway so that code is broken in 10 different ways.
T 1710301767 18<20arraybolt318>	aha, good to know
T 1710301787 18<25ormaaj18>	can't read a nul with a comsub either for same reason. bash even warns if you try
T 1710301971 18<20arraybolt318>	That sort of makes a fine how-do-you-do if you're trying to deal with all possible esoteric filenames. The only right way to separate filenames that contain all 255 other bytes is to use NUL, but you can't split a NUL-separated string into an array so you have to deal with it as a string, unless you fancy replacing NULs with newlines which breaks things, and even that might not be possible if you
T 1710301973 18<20arraybolt318>	can't even specify a NUL :-/
T 1710301987 18<20arraybolt318>	I get why it would be this way - you can't sore a nul in a string in C, but... hmm.
T 1710302003 18<20arraybolt318>	Perhaps UNIX should have added one more character to the list of "illegal in filenames" characters.
T 1710302032 18<25ormaaj18>	Ideally you at most only read in file names once and do the rest with array manipulations.
T 1710302067 18<20arraybolt318>	hmm, yeah
T 1710302146 18<25ormaaj18>	you can split a nul-separated string into an array
T 1710302345 18<25ormaaj18>	# shopt -s lastpipe; set +m; mkdir -- $'/x\ny'; find / -maxdepth 1 -type d -print0 | LC_CTYPE=C mapfile -td '' a; typeset -p a
T 1710302347 18<25shbot18>	ormaaj: declare -a a=([0]="/" [1]=$'/x\ny' [2]="/proc" [3]="/var" [4]="/tmp" [5]="/usr" [6]="/bin" [7]="/lib" [8]="/etc" [9]="/root" [10]="/dev")
T 1710304673 18<22pj18>	The key is that NUL can't be used in a variable or passed as an arg or part of a command name because all of those use NUL-terminated strings internally.  NULs can, however, be part of a file's content or a stream, so it's perfectly fine to pass it as STDIN, for example.
T 1710305042 18<25ormaaj18>	mhhh
T 1710305232 18<25ormaaj18>	bash has A FEW commands that can work with nuls in data, only when reading and/or writing.
T 1710305271 18<22pj18>	right, commands that work on streams, such as readarray work fine with NULs
T 1710305344 18<22pj18>	or you can output NULs with printf, for example.
T 1710305349 18<20bent_fingers18>	# echo -e '\0' | tr '\0' '+'
T 1710305350 18<25shbot18>	bent_fingers: +
T 1710305379 18<20bent_fingers18>	something out of nothing
T 1710305387 18<20bent_fingers18>	ex nihilo
T 1710305408 18<25ormaaj18>	use %b for that though.
T 1710305421 18<22pj18>	# readarray -d '' ar < <(printf '%s\0' a b c d e f g); declare -p ar
T 1710305422 18<25shbot18>	pj: declare -a ar=([0]="a" [1]="b" [2]="c" [3]="d" [4]="e" [5]="f" [6]="g")
T 1710305519 18<22pj18>	That's sort of a dumb example, but you could use it in conjunction with something like GNU sort...
T 1710305558 18<22pj18>	# readarray -d '' ar < <(printf '%s\0' d a e b g f|sort -z); declare -p ar
T 1710305560 18<25shbot18>	pj: declare -a ar=([0]="a" [1]="b" [2]="d" [3]="e" [4]="f" [5]="g")
T 1710305633 18<22pj18>	This is a safe way of sorting an array and putting the results back in an array, so long as you have GNU sort ^^^^
T 1710305692 18<22pj18>	well as safe as you can get, there are still issues with trailing newlines.
T 1710305712 18<25ormaaj18>	nope
T 1710305788 18<22pj18>	# readarray -d '' ar < <(printf '%s\0' d $'a\n' e b g f|sort -z); declare -p ar
T 1710305790 18<25shbot18>	pj: declare -a ar=([0]=$'a\n' [1]="b" [2]="d" [3]="e" [4]="f" [5]="g")
T 1710305801 18<22pj18>	hrmmmmm, interesting
T 1710305810 18<22pj18>	I thought those would all be the same.
T 1710305812 18<25ormaaj18>	`readarray < <(printf) < <(sort)` bit nicer. Bash can directly exec those commands.
T 1710305825 18<25ormaaj18>	no double-forking
T 1710305847 18<22pj18>	oh, I didn't know you could do that.
T 1710305898 18<22pj18>	# readarray -d '' ar < <(printf '%s\0' d a e b g f) < <(sort -z); declare -p ar
T 1710305900 18<25shbot18>	pj: declare -a ar=([0]="a" [1]="b" [2]="d" [3]="e" [4]="f" [5]="g")
T 1710305906 18<22pj18>	oh, interesting
T 1710305940 18<22pj18>	how does bash know with that syntax to send the output of the printf to sort?
T 1710306003 18<25ormaaj18>	there's nothing special there
T 1710306032 18<22pj18>	Then I just can't wrap my head around it.
T 1710306034 18<25ormaaj18>	 < <() opens the pipe for reading. redirects are evaluated left-to-right
T 1710306053 18<25ormaaj18>	so the next redirect has the pipe open for reading on stdin
T 1710306077 18<22pj18>	hrmmmmm ...
T 1710306102 18<22pj18>	# < <(printf '%s\0' d a e b g f) < <(sort -z) readarray -d '' ar; declare -p ar
T 1710306103 18<25shbot18>	pj: declare -a ar=([0]="a" [1]="b" [2]="d" [3]="e" [4]="f" [5]="g")
T 1710306154 18<25ormaaj18>	here's a pipe reader I just made :D https://bpa.st/raw/CB6A
T 1710306172 18<22pj18>	hahaha, that's right redirects don't have to be at the end, they tend to just out of convention.  But by putting the redirect at the beginning you can read it as going from right to left where the output of each command redirects into the one to its left.
T 1710306223 18<22pj18>	oh wait, that doesn't read the way I thought
T 1710306224 18<22pj18>	bleh
T 1710306236 18<22pj18>	it does read that way with the redirects at the end.
T 1710306257 18<22pj18>	oh nm, I'm confused, I just need dinner
T 1710307491 18<25ormaaj18>	https://bpa.st/raw/QOCA
T 1710308285 19*	Now talking on 22#bash
T 1710308285 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1710308285 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1710340572 19*	Now talking on 22#bash
T 1710340572 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1710340572 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1710340576 18<19xiaomiao18>	tirnanog: small world ;)
T 1710340596 18<22tirnanog18>	anyway, I think I'm mistaken. grsecurity had a logging mechanism but wouldn't police the rate of forks. my memory is very fuzzy at this point.
T 1710343036 19*	Now talking on 22#bash
T 1710343036 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1710343036 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1710343092 18<27Soliton18>	$! contains the PID of the last background process. calling ssh normally does not make it a background process. -f does not change that.
T 1710343134 18<27Soliton18>	if ssh gets stopped when you background it it probably tries to read from the terminal which a background process is not allowed to do.
T 1710343199 18<27Soliton18>	perhaps you want to use the control socket feature of openssh.
T 1710343365 18<28jclsn18>	Soliton: Thanks, got it
T 1710343376 18<28jclsn18>	Had to use ssh -NL
T 1710343387 18<28jclsn18>	-f will give it another pid
T 1710343810 18<25ormaaj18>	syd would make short work of it. I didn't bother testing. highmon                 ‚îÇ08:57:05              --> ‚îÇ jpn [jpn] (Jos√© Neta) (~jpn@user/jpn) has joined #bash                                                                                                                                                                                                                        blo]
T 1710343810 18<25ormaaj18>	             
T 1710343810 18<25ormaaj18>	syd would make short work of it. I didn't bother testing. highmon                 ‚îÇ08:57:05              --> ‚îÇ jpn [jpn] (Jos√© Neta) (~jpn@user/jpn) has joined #bne        ash
T 1710343810 18<25ormaaj18>	           
T 1710344064 18<28llua18>	the cat is getting better at typing
T 1710344842 18<25ormaaj18>	er that, minus the garbage :o
T 1710345223 18<25ormaaj18>	I am using a fork of kmscon that attempts to implement mouse support but it's very crude. Doesn't really implement any of the terminal interaction things. It's just like gpm but spams whatever you've selected if you middle click.
T 1710345240 18<27Earnestly18>	chiselfuse: Not the kernel per-se, but as a structured interchange format for arbitrary byte streams. It would also mean that json could store unix filenames correctly, amoung other things, which would be important for many such config files
T 1710345296 18<22tirnanog18>	has it been implemented yet?
T 1710345326 18<25ormaaj18>	like in a way that I don't always notice. I should just disable that :(
T 1710345373 18<27Earnestly18>	ormaaj: Was that mouse impl responsible for the ++++ spam the other day?
T 1710345388 18<25ormaaj18>	maybe
T 1710345393 18<25ormaaj18>	probably not
T 1710345404 18<25ormaaj18>	maybe :O
T 1710345412 18<27Earnestly18>	Was curious as to what mad scientist thing you were doing to produce that
T 1710345511 18<28emanuele618>	mad sadie thing
T 1710345648 18<25ormaaj18>	(that's my cat. she types sometimes.)
T 1710345659 18<29alip18>	ormaaj: syd prevents subnamespaces so your trick won't work there
T 1710345688 18<25ormaaj18>	blast
T 1710345753 18<25ormaaj18>	!ormaajbomb
T 1710345753 18<29greybot18>	shopt -s lastpipe; set -o pipefail; ((())|[()(]|[)||(())|]()([|])||])
T 1710345758 18<25ormaaj18>	:S
T 1710346529 19*	Now talking on 22#bash
T 1710346529 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1710346529 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1710346633 18<22tirnanog18>	when you run bash like that, it has no idea what the positional parameters were. it's just a new born process. bash -c is one way of assigning to the positional parameters (you still have to pass them).
T 1710346750 18<24raccct18>	noteify(){bash -c 'notify-send "$1" "$2"' _ "$@"}; noteify "A" "B B" -> was the quotes my syntax error? I tried to use the _ $@ you mentioned above. I had never seen it before (the _) what does it do?
T 1710346770 18<27Soliton18>	# noteify(){bash -c 'notify-send "$1" "$2"' _ "$@"}
T 1710346772 18<25shbot18>	Soliton: bash: syntax error near unexpected token `{bash'
T 1710346782 18<22tirnanog18>	!$@ > raccct
T 1710346782 18<29greybot18>	raccct: The difference between $@ and $*: "$@" (quoted) expands to each positional parameter as its own argument: "$1" "$2" ... while "$*" expands to the single argument "$1c$2c..." where c is the first character of IFS. You almost always want "$@". The same goes for arrays: "${array[@]}" or "${array[*]}". Unquoted $* and $@ are nonsense; DO NOT use
T 1710346820 18<22tirnanog18>	but no, unquoted $@ was not the error of syntax.
T 1710346845 18<27Soliton18>	_ does nothing. it's just a string. you can use whatever else you want. the argument in that position is $0.
T 1710346903 18<22tirnanog18>	raccct: to understand why it's a syntax error, try LESS='+/Compound Commands' man bash, then study the definition of the second compound command form shown in that section.
T 1710346945 18<22tirnanog18>	it is shown as { list; }, and it is explicitly stated the command list must be separated from the braces by whitespace.
T 1710346981 18<22tirnanog18>	the semicolon must also be there, unless you have a line break prior to the closing "}".
T 1710347040 18<27Soliton18>	btw, you don't need bash -c to invoke other things. you may have to use bash -c if something forces that on you. like you want to run something inside chroot or docker or so.
T 1710347145 18<27Soliton18>	i.e. you don't call bash -c directly.
T 1710347185 18<28emanuele618>	"$BASH" -c   is better
T 1710347254 18<25ormaaj18>	why
T 1710347266 18<28emanuele618>	because
T 1710347291 18<22tirnanog18>	so you get the bash you began with, I suppose. probably still no less silly for whatever they are ultimately doing.
T 1710347292 18<28emanuele618>	it works even if PATH is unset
T 1710347316 18<24raccct18>	tirnanog, Soliton thanks! yes, the _ i meant. It fails without. but I realized I can replace it with any string. I think I need to learn more.
T 1710347341 18<25ormaaj18>	 what if PATH changed and bash should be called from the updated PATH?
T 1710347351 18<24raccct18>	noteify(){sh -c 'notify-send "$1" "$2"' _ "$@"}; noteify "A" "B B" -> works.
T 1710347353 18<28emanuele618>	if you take a bash expression as argument it is better to    if "$BASH" -c -- "$expr"; then ...; fi  then use   if eval -- "$expr"
T 1710347356 18<25ormaaj18>	I have had that happen.
T 1710347362 18<24raccct18>	noteify(){sh -c 'notify-send "$1" "$2"' "$@"}; noteify "A" "B B" -> only renders "B B"
T 1710347504 19*	Now talking on 22#bash
T 1710347504 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1710347504 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1710347554 18<25ormaaj18>	I think it's transcended fad maybe
T 1710351789 19*	Now talking on 22#bash
T 1710351789 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1710351789 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1710353088 18<20ppw18>	any ideas about this? I have no idea why that timestamp gets cut off. https://bpa.st/PYSQ
T 1710353108 18<22tirnanog18>	!faq ffmpeg
T 1710353108 18<29greybot18>	https://mywiki.wooledge.org/BashFAQ/089 -- I'm reading a file line by line and running ssh or ffmpeg, only the first line gets processed!
T 1710353255 18<20ppw18>	thank you so much, this has been driving me up the wall
T 1710354131 18<22tirnanog18>	np
T 1710354147 18<22tirnanog18>	that one comes up fairly routinely.
T 1710355501 18<19Artfaith18>	ormaaj, you say you randomize pid but the pid counter increases since it's fork bomb, or what was the attack purpose if not to consume resources?
T 1710355530 18<19Artfaith18>	I mean, considering you have set a limit to max pid number for a user.
T 1710357178 18<25ormaaj18>	Artfaith: Yeah if you're not actually root it's easy to nab the user namespace
T 1710357294 18<25ormaaj18>	but you could make it tricky to isolate your new process spam from other users
T 1710357331 18<25ormaaj18>	not THAAT tricky but might take manual intervention to stop it
T 1710360292 18<22Psi-Jack18>	Hmm. I know this is not ble.sh, but if anyone uses it, I'm curious if there's a way to get it to work with ESC+Backspace to delete words like bash normal does.
T 1710360371 18<28llua18>	!otbut
T 1710360371 18<29greybot18>	Just because you preface a question with `I know this is offtopic but...' or `#ontopicchannel isn't responding' doesn't automatically make it on topic in #bash
T 1710360416 18<22Psi-Jack18>	ble.sh is a bash script for bash. At least it's within the realm of topic.
T 1710360984 18<20twkm18>	make sure it uses read's -e option.
T 1710361243 18<19Artfaith18>	ormaaj, I'll check more about it. Thank you.
T 1710361313 18<22tirnanog18>	Psi-Jack: esc+backspace is nothing that I recognise as a default binding. are you mixing bash up with zsh there?
T 1710361330 18<22Psi-Jack18>	No, I'm not. Been using ESC+backspace in bash for years.
T 1710361367 18<22tirnanog18>	oh, I see. I had vi mode on and forgot that I'd done it.
T 1710361393 18<22Psi-Jack18>	Heh, Yeah, emacs mode ESC+backspace (in quick succession), deletes a word backwards.
T 1710361494 18<27larryv18>	Psi-Jack: https://github.com/akinomyoga/ble.sh/issues/355
T 1710361532 18<22Psi-Jack18>	Huh, good find! Thanks larryv!
T 1710361638 18<22Psi-Jack18>	Yeah, this works great! I've gone back to using bash as my normal shell versus zsh and fish, because of ble.sh and it's pretty nice. :)
T 1710365508 18<28jclsn18>	j
T 1710365679 18<28emanuele618>	clsn
T 1710365702 18<28emanuele618>	!sandwich
T 1710365811 18<27JAA18>	No sandwich? Can't have shit in Detro^H^H^H^H^H#bash...
T 1710366345 18<25Lynx-18>	Anyone see way to speed up this loop for monitoring network interface transfer rates? https://github.com/lynxthecat/cake-autorate/blob/384da1a34eaa0df9a1abed1b8e3f3b7fcc27adc9/cake-autorate.sh#L478
T 1710366418 18<25Lynx-18>	typical path for read is e.g.: rx_bytes_path="/sys/class/net/${dl_if}/statistics/tx_bytes"; tx_bytes_path="/sys/class/net/${ul_if}/statistics/tx_bytes"
T 1710366446 18<28emanuele618>	well, since you are not even using if-then-else, but instead are using &&||  you could drop the [[ -f ... ]] and it would have the exact same behaviour
T 1710366493 18<28emanuele618>	hmm, not exact, it would read from pipes while with [[ -f ... ]] it does not read from pipes if that is an issue
T 1710366595 18<28emanuele618>	${EPOCHREALTIME/./} only works if the user of the script uses a locale in which the decimal point symbol is .
T 1710366663 18<28emanuele618>	# LANG=de_DE.utf-8; echo "${EPOCHREALTIME}"; echo "${EPOCHREALTIME/./}"
T 1710366665 18<25shbot18>	emanuele6: 1710366664,257032
T 1710366665 18<25shbot18>	emanuele6: 1710366664,260289
T 1710366689 18<28emanuele618>	in germany locale it does not work for example, because it uses "," also in many other european locales
T 1710366724 18<28emanuele618>	!epochrealtimeint
T 1710366725 18<29greybot18>	the format of EPOCHREALTIME is %u%c%06u where %c is the decimal delimiter of the current locale (".", ",", ...). It can be converted to an integer using: $(( 10#${EPOCHREALTIME//[!0123456789]} ))
T 1710366808 18<25Lynx-18>	hmm hasn't come up yet
T 1710366812 18<28emanuele618>	"$((10#" is only there for paranoia that the user may use faketime or similar to run the script within one second of 1970-01-01; just  t=${EPOCHREALTIME//[!0123456789]}  would also work
T 1710366817 18<25Lynx-18>	does export LC_ALL=C affect that?
T 1710366841 18<28emanuele618>	yes, because that changes LC_NUMERIC to C, and in C locale, the delimiter is .
T 1710366868 18<25Lynx-18>	Ah, so that should save it
T 1710366887 18<25Lynx-18>	[[ -f "${rx_bytes_path}" ]] && { read -r rx_bytes < "${rx_bytes_path}"; } 2> /dev/null || rx_bytes="${prev_rx_bytes}" <-- this works for me - path set then rx_bytes set to 0
T 1710366906 18<25Lynx-18>	sorry path not set, then set to prev, path set, then set to the read
T 1710366910 18<28emanuele618>	but why not just   { read -r rx_bytes < "${rx_bytes_path}"; } 2> /dev/null || rx_bytes="${prev_rx_bytes}"   ?
T 1710366921 18<25Lynx-18>	ahh
T 1710366933 18<28emanuele618>	especially since you are already hiding stderr; for what other reason would you do that?
T 1710366951 18<25Lynx-18>	Yes, seems good
T 1710366959 18<25Lynx-18>	is there any way at all to speed up the reads?
T 1710366971 18<25Lynx-18>	ano said file descriptor doesn't work for sysfs
T 1710366988 18<28emanuele618>	what does that mean?
T 1710367003 18<25Lynx-18>	I mean there is no way to avoid file open, close in each iteration
T 1710367004 18<28emanuele618>	i don't think ano would say something like that
T 1710367022 18<28emanuele618>	well, than you mean something else
T 1710367044 18<28emanuele618>	some sysfs files are regenerated on open, so you need to reopen them
T 1710367070 18<22tirnanog18>	"done 2>/dev/null" would make a slight difference, at the obvious cost of trashing stderr throughout.
T 1710367160 18<28emanuele618>	$ cat /sys/class/net/enp0s25/mtu
T 1710367162 18<28emanuele618>	1500
T 1710367168 18<25Lynx-18>	I'll revert to: { read -r rx_bytes < "${rx_bytes_path}"; } 2> /dev/null || rx_bytes="${prev_rx_bytes}" - I see the logic since this avoids pointless test every iteration
T 1710367191 18<28emanuele618>	it's one line, you can just use   var=$(< /sys/class/net/enp0s25/mtu) || var=$something   which is way faster than read
T 1710367202 18<25Lynx-18>	oh crap no way?
T 1710367225 18<22tirnanog18>	same for main_fd, for that matter: done >&"${main_fd}" 2>/dev/null
T 1710367367 18<25Lynx-18>	# root@OpenWrt-1:~# x=(< /sys/class/net/wan/statistics/tx_bytes)
T 1710367367 18<25Lynx-18>	bash: syntax error near unexpected token `<'
T 1710367370 18<25shbot18>	Lynx-: bash: syntax error near unexpected token `('
T 1710367384 18<22tirnanog18>	$(<
T 1710367404 18<25Lynx-18>	ok got it
T 1710367425 18<25Lynx-18>	Doesn't that involve subshell?
T 1710367433 18<22tirnanog18>	no.
T 1710367469 18<25Lynx-18>	Oh, I thought stuff that involved $( ... ) involved subshell?
T 1710367493 18<25Lynx-18>	is there a name for x= $( < .... ) ? I've not seen that much
T 1710367533 18<24geirha18>	command substitution
T 1710367623 18<24geirha18>	but I don't see how it could be faster than read
T 1710367645 18<28emanuele618>	because read reads with a buffer size of 1, one syscall per byte
T 1710367648 18<25Lynx-18>	# cat /sys/class/net/wan/statistics/tx_bytes
T 1710367650 18<25shbot18>	Lynx-: cat: /sys/class/net/wan/statistics/tx_bytes: No such file or directory
T 1710367663 18<22tirnanog18>	also, shorter variable names have been known to permit bash to run measurably faster (that's not a joke).
T 1710367670 18<24geirha18>	only if stdin is not seekable
T 1710367681 18<28emanuele618>	oh, i always forget that
T 1710367698 18<28emanuele618>	so it would not be that much faster, still saves some work, but not as much
T 1710367705 18<28emanuele618>	as i thought
T 1710367874 18<25Lynx-18>	the read seems faster on my router, if I'm doing it right: https://pastebin.com/raw/sstEA32c
T 1710367918 18<25Lynx-18>	I suppose reading from /proc/net/dev would be no faster?
T 1710367929 18<25Lynx-18>	since same information is there I think
T 1710367973 18<28emanuele618>	yes, it seems slower for me too
T 1710368001 18<22tirnanog18>	I wouldn't think so. not only is there more to read, you'd have to match the appropriate rows and extract the appropriate fields. that sounds like more work to me.
T 1710368159 18<28emanuele618>	with stace you can see that read does more than double the system calls per iteration; openat+fcntl+fcntl+fcntl+fcntl+dup2+close+rt_sigprocmask+ioctl+lseek+read+dup2+fcntl+close  vs just    openat+read+read+close+rt_sigprocmask+rt_sigprocmask
T 1710368183 18<28emanuele618>	i guess read saves one read and having to seek because it finds the newline immediately
T 1710368221 18<28emanuele618>	but it is overall a lot more system calls, i think  rt_sigprocmask   is what takes up most of the time
T 1710368239 18<28emanuele618>	i am not sure why it even calls it twice, strace shows that it calls it with the same arguments
T 1710368250 18<25Lynx-18>	could it be that in the context of my while loop / background process the ( < .. ) is faster?
T 1710368280 18<25Lynx-18>	this is called circa every 400ms
T 1710370368 19*	Now talking on 22#bash
T 1710370368 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1710370368 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1710370451 18<27Earnestly18>	JAA: (Tbh, the notion that performance shouldn't be a goal, or isn't important or cannot be achieved against some other criteria are all basically copes)
T 1710379561 19*	Now talking on 22#bash
T 1710379561 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1710379561 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1710399072 18<24cheater18>	hi
T 1710399212 18<24cheater18>	so is there a good library yet for accepting command line arguments that supports all of the following? long args with = (--foo=x) and without (--foo x), short arguments (-f), collapsed and multiple short arguments (-xvvv, -x -v -v -x), taking stuff from env, taking stuff from config files (hierarchically) ?
T 1710399268 18<24cheater18>	possibly also accept argument changes after startup via a socket file or something
T 1710403391 18<24geirha18>	I'd just use a manual loop to parse options. Not too hard to also handle collapsed options
T 1710407198 19*	Now talking on 22#bash
T 1710407198 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1710407198 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1710407468 19*	Now talking on 22#bash
T 1710407468 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1710407468 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1710407754 19*	Now talking on 22#bash
T 1710407754 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1710407754 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1710408516 18<19sphertext18>	# mapfile -d '' f < <(awk 'BEGIN {exit} END {a[1]; a[2]; for (i in a) printf("%s\0", i)}'); declare -p f
T 1710408519 18<25shbot18>	sphertext: declare -a f=([0]="21")
T 1710408542 18<19sphertext18>	why isn't this splitting correctly on \0?
T 1710408709 18<22mosasaur18>	sphertext: it does here: declare -a f=([0]="1" [1]="2")
T 1710408710 18<27Soliton18>	# awk 'BEGIN {exit} END {a[1]; a[2]; for (i in a) printf("%s\0", i)}' | sed -n l
T 1710408712 18<25shbot18>	Soliton: 21$
T 1710408726 18<24geirha18>	awk doesn't handle \0 very well. Only GNU awk handles it somewhat
T 1710408753 18<24geirha18>	# mapfile -d '' f < <(gawk 'BEGIN {exit} END {a[1]; a[2]; for (i in a) printf("%s\0", i)}'); declare -p f
T 1710408755 18<25shbot18>	geirha: declare -a f=([0]="1" [1]="2")
T 1710408761 18<19sphertext18>	...
T 1710408804 18<24geirha18>	awk is designed to handle text, not binary data
T 1710408818 18<27Soliton18>	"If all of the digits are 0 (that is, representation of the NUL character), the behavior is undefined."
T 1710408857 19*	Now talking on 22#bash
T 1710408857 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1710408857 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1710409132 18<29Gurkenglas18>	`apt show foo | less & wait_pid=$!; apt install foo; kill $wait_pid` feels like I'm manually freeing memory. Is there an approach that makes foo act more like a scoped variable, so it'll automatically exit when the install completes?
T 1710409187 18<29Gurkenglas18>	s/makes foo act/makes the `apt show foo | less` act/
T 1710409363 18<27Earnestly18>	Soliton: Doesn't that only apply to printf? I don't recall anything really being said about \0 for NR
T 1710409386 18<27Earnestly18>	(Oh also for regex)
T 1710409401 18<27Earnestly18>	But since RS * isn't regex, does it apply?
T 1710409407 18<29Gurkenglas18>	uh, I just noticed the line I said is completely bogus. Of course I meant "`sudo apt install foo -y`, displaying `apt show foo | less` as a 'loading screen' until the install completes"
T 1710409475 18<27Soliton18>	Earnestly: it applies to octal backslash escapes.
T 1710409606 18<27Earnestly18>	Maybe, but I only read that it applies to regular expressions (and specifically ~ / !~ / FS / g|sub / match / split as documented)
T 1710409680 18<27Earnestly18>	(mawk handles nul separated records for what its worth)
T 1710409720 18<27Earnestly18>	Soliton: I suppose you do have a point though as RS accepts \n which would otherwise be considered undefined as it's more than one character
T 1710409885 18<27Soliton18>	under Lexical Conventions it's explained how string constants work.
T 1710409954 18<27Earnestly18>	Fair
T 1710409962 18<27Earnestly18>	How annoying though
T 1710410001 18<27Earnestly18>	I was looking again for updates and just wanted to note that xargs -P is under consideration again where at least it has been accepted to include text that states -P might be added in a future version
T 1710410146 18<27Earnestly18>	Same treatment for %q
T 1710412219 18<24geirha18>	Gurkenglas: you could use a whipttail gauge perhaps.   apt-get install -y hello | whiptail --gauge "$(apt show hello)" "$((LINES - 4))" "$((COLUMNS - 4))" 0
T 1710412255 18<24geirha18>	if you can figure out how to parse apt-get install output to figure out a percentage, you can output that to the pipe to make the gauge move
T 1710412589 18<29Gurkenglas18>	geirha: Thanks! whiptail seems overly specific, but 1. that's fair enough since it's specific for *the usecase I posed* 2. whiptail can surely be "abused" to be as general as what I was hoping for
T 1710412773 18<28selckin18>	maybe you want to script a tmux pane/window instead, if my guess of what it does is even close to right
T 1710412950 18<29Gurkenglas18>	(what I was hoping for was e.g. an application of general syntax for managing pipes and general syntax for managing which jobs will keep which scripts from ending)
T 1710414460 18<29Gurkenglas18>	hmm, whiptail --gauge eats the installation errors too. I suppose selckin was right! I *could* just run apt show foo in a new tmux pane/window and close it afterwards, though that brings us back to square one on the "feels like manually freeing memory"
T 1710414489 18<28selckin18>	it can auto close when the process exits
T 1710414530 18<29Gurkenglas18>	ohhh, by running the install in that pane/window too! makes sense, thanks
T 1710414568 18<25ormaaj18>	add random sleeps to simulate gc.
T 1710414572 18<29Gurkenglas18>	and for errors I can do 2>$(tty)
T 1710414587 18<29Gurkenglas18>	ormaaj: ??
T 1710414686 18<25ormaaj18>	you wanted it to feel like not manual memory management!
T 1710414891 18<29Gurkenglas18>	where is my trout.
T 1710414964 18<29Gurkenglas18>	(though i'll admit i don't know why GC is even a thing, instead of automatically freeing variables when they go out of scope.)
T 1710415040 18<28selckin18>	some memory need to survive in multiple scopes
T 1710415091 18<29Gurkenglas18>	can i have an example where the variable's scope should then not be the latest common ancestor of the two?
T 1710415202 18<28selckin18>	cache
T 1710415264 18<29Gurkenglas18>	i don't quite follow yet, but feel free to pass me off to some keyword-to-google or link when i sufficiently negatively-surprise you with my followingness
T 1710415370 18<29Gurkenglas18>	my guess is you are pointing at the general class of "what if we store it in an array, won't the array come to hold null pointers?", to which my response would be "when the variable goes out of its scope, the same logic that frees its memory should inform the array of the death"
T 1710415421 18<29Gurkenglas18>	s/the general class/a special case/
T 1710415466 18<28selckin18>	multiple scopes can use the same item, and then one dedices to delete/replace it
T 1710415505 18<29Gurkenglas18>	then there should be exactly one of the scopes who you talk to if you need that
T 1710415540 18<28selckin18>	who waits for all the scopes to finish with it before deleting right?
T 1710415588 18<29Gurkenglas18>	let me rephrase: then there should be exactly one of the scopes who you cause to die if you need that
T 1710415616 18<28selckin18>	you're thinking immutable or copy on use or something
T 1710415623 18<28selckin18>	anyway offtopic
T 1710415645 18<29Gurkenglas18>	(and if other scopes are not finished when the variable's scope dies, you picked the wrong scope)
T 1710415686 18<28selckin18>	or descriping ref counting a form of gc
T 1710415692 18<29Gurkenglas18>	sure, the reasons you brought forward, while they don't quite sway me, make me not baffled that they sway others.
T 1710416344 18<29Gurkenglas18>	ahahaha, even more offtopic than i thought, somehow i thought this was #linux. (((upon due consideration, i have updated my "won't arrays come to hold null pointers?" response to "yes")))
T 1710420069 22*	26ChanServ gives channel operator status to 18ormaaj
T 1710420103 22*	26ormaaj removes ban on 18*!*Angels@user
T 1710420103 22*	26ormaaj removes channel operator status from 18ormaaj
T 1710420160 22*	26ChanServ gives channel operator status to 18ormaaj
T 1710420189 22*	26ormaaj removes ban on 18*!~Angels@user/Angels
T 1710420211 22*	26ormaaj removes channel operator status from 18ormaaj
T 1710421740 18<27lovetruth18>	Hey :)
T 1710421826 18<25ormaaj18>	neigh
T 1710422153 18<24iconoclast_hero18>	is there someway to both compare two directories and make sure that the directory of interest exists?
T 1710422165 18<24iconoclast_hero18>	it seems to me that there should be some way to combine e.g.,
T 1710422166 18<24iconoclast_hero18>	[[ ! -d "$cachedir" ]] && rsync -avz "$backdir$cachedir" "$cacheroot"
T 1710422166 18<24iconoclast_hero18>	[[ $(diff "$cachedir" "$backdir$cachedir" -rq) ]] && rsync -avz "$backdir$cachedri" "$cacheroot"
T 1710422194 18<24iconoclast_hero18>	and that typo was fixed after copying.
T 1710422330 18<25ormaaj18>	do i have to know what those commands do?
T 1710422421 18<28selckin18>	iconoclast_hero: why compare? just let rsync do it ?
T 1710422452 18<25ormaaj18>	I would guess if directory of insterest doesn't exist then it doesn't match thing you're comparing it to
T 1710422474 18<24iconoclast_hero18>	that is a fair point.
T 1710422518 18<24iconoclast_hero18>	rationale: trying to habituate myself to testing if things are there, etc., before doing things in scripts.
T 1710422524 18<24iconoclast_hero18>	it is unnecessary.
T 1710422536 18<24iconoclast_hero18>	still, is it possible?
T 1710422557 18<27Soliton18>	use the exit status of diff not its output.
T 1710422634 18<24iconoclast_hero18>	how?
T 1710422647 18<24iconoclast_hero18>	i tried diff x y ; echo "$?" and nothing.
T 1710422669 18<27Soliton18>	# diff x y; echo "$?"
T 1710422671 18<25shbot18>	Soliton: diff: x: No such file or directory
T 1710422671 18<25shbot18>	Soliton: diff: y: No such file or directory
T 1710422671 18<25shbot18>	Soliton: 2
T 1710422700 18<24iconoclast_hero18>	touch x y; diff x y; echo "$?"
T 1710422704 18<24iconoclast_hero18>	# touch x y; diff x y; echo "$?"
T 1710422706 18<25shbot18>	iconoclast_hero: 0
T 1710422756 18<24iconoclast_hero18>	oh right
T 1710422765 18<24iconoclast_hero18>	# touch x y; diff x z; echo "$?"
T 1710422767 18<25shbot18>	iconoclast_hero: diff: z: No such file or directory
T 1710422767 18<25shbot18>	iconoclast_hero: 2
T 1710422792 18<24iconoclast_hero18>	i see now, thank you.
T 1710422940 18<24iconoclast_hero18>	will chown "$cacheuser:$cachegroup" do the same as chown "$cacheuser":"$cachegroup" ?
T 1710422956 18<24iconoclast_hero18>	or is the latter safer regardlesS?
T 1710422967 18<27Soliton18>	those do the same thing.
T 1710422987 18<27Soliton18>	: and ":" mean the same thing.
T 1710423143 18<24iconoclast_hero18>	can you even have a whitespace in either a username or groupname?
T 1710423183 18<27Soliton18>	depends on the OS. probably not.
T 1710423202 18<27Soliton18>	whitespace is not the only thing quotes protect from anyway.
T 1710423984 18<24ano18>	[ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789._][ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789._-]{0,7} afaik it's rule for posix login/usr name, most of modern *nix don't respect it
T 1710424020 18<24geirha18>	debian allows * in usernames iirc
T 1710424090 18<25kurahaupo18>	ano: I used to have a dot in my username on my home PC, but eventually I got tired of chown getting confused
T 1710424240 18<24ano18>	does it say >invalid user or something else?
T 1710424454 18<24geirha18>	At least GNU chown accepts both  user:group  and  user.group  with the latter being undocumented, but still valid because history, probably.
T 1710424574 18<24geirha18>	"The BSD syntax user[. group] was changed to user[: group] in this volume of POSIX.1-2017 because the <period> is a valid character in login names (as specified by the Base Definitions volume of POSIX.1-2017, login names consist of characters in the portable filename character set). " -- POSIX
T 1710425002 18<24geirha18>	sudo useradd 'My User'  # useradd: invalid user name 'My User': use --badname to ignore
T 1710425012 18<24geirha18>	sudo useradd 'My*User'  # no complaints
T 1710425014 18<24geirha18>	sudo useradd 'My/User'  # no complaints
T 1710425048 18<24geirha18>	My*User:x:1001:1001::/home/My*User:/bin/sh
T 1710425050 18<24geirha18>	My/User:x:1002:1002::/home/My/User:/bin/sh
T 1710425060 18<24geirha18>	(wcgw)
T 1710425216 18<25kurahaupo18>	geirha: how about 'my:user' ? ü§™
T 1710425228 18<25kurahaupo18>	"what could possibly go wrong"
T 1710425248 18<24geirha18>	useradd: invalid user name 'my:user': use --badname to ignore
T 1710425275 18<25kurahaupo18>	"my:user:0:0:me:/:/bin/sh"
T 1710425318 18<24geirha18>	useradd: failure while writing changes to /etc/passwd    when I added --badname
T 1710425320 18<25kurahaupo18>	useradd --badname "my:user:0:0:me:/:/bin/sh"
T 1710425329 18<25kurahaupo18>	Awww, dang
T 1710425368 18<24geirha18>	My User:x:1003:1003::/home/My User:/bin/sh
T 1710425375 18<24geirha18>	that one went through with --badname
T 1710425431 18<24geirha18>	mhhh just think of the number of scripts that will fail because they stupidly assume $HOME will never contain whitespace
T 1710425549 18<25ormaaj18>	( LC_CTYPE=C; { y=$(readlink -sn -- "/proc/self/fd/${x}") && [[ -d /proc/self/fd/${x} && ! -L $y && /proc/self/fd/${x} -ef $y ]]; find "/proc/self/fd/${x}/" ! -type d -printf '%p\0%P\0' | while IFS= read -rd '' 'a[0]' && IFS= read -rd '' 'a[1]'; do cmp -s -- "${a[0]}" "/proc/self/fd/${z}/${a[1]}" || (( $? - 1 )) || ! break; done } {x}<~ {z}</mnt/ormaaj2/vol/home/ormaaj; echo "$?" )
T 1710425628 18<25ormaaj18>	made a directory comparer. for "fun". including weird !homework rule.
T 1710425649 18<25ormaaj18>	now back to actual work
T 1710425804 18<25ormaaj18>	not sure how to filter file types by "contains stuff that can be compared"
T 1710425978 18<25ormaaj18>	:o also wonder whether it reads named pipes.
T 1710426020 18<25ormaaj18>	# cmp <(cat /dev/zero) /dev/zero
T 1710426027 18<25shbot18>	ormaaj: no output within the time limit
T 1710426033 18<25ormaaj18>	ah.
T 1710426055 18<25ormaaj18>	( LC_CTYPE=C; { y=$(readlink -sn -- "/proc/self/fd/${x}") && [[ -d /proc/self/fd/${x} && ! -L $y && /proc/self/fd/${x} -ef $y ]]; find "/proc/self/fd/${x}/" -type f -printf '%p\0%P\0' | while IFS= read -rd '' 'a[0]' && IFS= read -rd '' 'a[1]'; do cmp -s -- "${a[0]}" "/proc/self/fd/${z}/${a[1]}" || (( $? - 1 )) || ! break; done } {x}<~ {z}</mnt/ormaaj2/vol/home/ormaaj; echo "$?" )
T 1710426248 18<25ormaaj18>	# cmp <(cat /dev/zero){,}
T 1710426255 18<25shbot18>	ormaaj: no output within the time limit
T 1710426943 18<25fris18>	trying to pass a url and get the last pathname, can this be done via xargs? http://pastie.org/p/2KEicYuCplhfZOqExhJw9f
T 1710427082 18<27Soliton18>	that's shell injection.
T 1710427082 18<25OMGOMG18>	!check
T 1710427082 18<28checkbot18>	OMGOMG: Unable to read that :/
T 1710427167 18<27Soliton18>	!faq 1
T 1710427167 18<29greybot18>	https://mywiki.wooledge.org/BashFAQ/001 -- How can I read a file (data stream, variable) line-by-line (and/or field-by-field)?
T 1710427347 18<27Soliton18>	!check http://pastie.org/p/2KEicYuCplhfZOqExhJw9f/raw
T 1710427348 18<28checkbot18>	Soliton: Looks good to me
T 1710427369 18<25OMGOMG18>	checkbot: it does?
T 1710427369 18<28checkbot18>	OMGOMG: I'm a bot. Use !checkbot for info/triggers, /msg checkbot quiet for stfu, or https://shellcheck.net to check your scripts.
T 1710427396 18<25fris18>	first part works, im trying to do the filename in the xargs
T 1710427401 18<25fris18>	{}.zip part
T 1710427446 18<27Soliton18>	the whole thing is bad.
T 1710427464 18<25OMGOMG18>	fris: why not ask wp, whatever that is, for the file name instead of the url?
T 1710427490 18<27Soliton18>	do not use for to iterate lines, do not use echo|cut instead of parameter expansion. do not use xargs pretty much ever.
T 1710427506 18<25fris18>	it doesnt provide filename, im just using the path as the filename, you need to pass url
T 1710427525 18<25OMGOMG18>	and why are you deleting the first two urls?
T 1710427535 18<27Soliton18>	probably some header.
T 1710427547 18<25fris18>	1st line is the header, 2nd line is the main site, rhe rest are sub sites
T 1710427574 18<25fris18>	domain.com/subsite would be passed as url and subsite.zip would be filename
T 1710427574 18<25OMGOMG18>	Soliton: i was not asking you
T 1710427683 18<27Soliton18>	is the xargs thing just trying to do the same thing as the for loop?
T 1710427724 18<25fris18>	ya
T 1710427742 18<27Soliton18>	so fix the loop instead and forget about xargs.
T 1710427771 18<27Soliton18>	wp site list --fields=url | sed '1,2d' | while IFS= read -r url; do filename=${url##*/}; wp mu-migration export all "$filename".zip --plugins --themes --uploads --url="$url"; done
T 1710427818 18<27Soliton18>	assuming wp outputs lines.
T 1710427945 18<25fris18>	tested just echoing filename from that parameter expansion it just prints .zip for each line
T 1710427966 18<25OMGOMG18>	fris: did you try wp site list --field=blog_id
T 1710427995 18<25fris18>	ya that just does the blogid, im lookimg to export to the name
T 1710428012 18<27Soliton18>	# while IFS= read -r url; do filename=${url##*/}; declare -p filename; done <<< domain.com/subsite
T 1710428014 18<25shbot18>	Soliton: declare -- filename="subsite"
T 1710428014 18<25OMGOMG18>	right
T 1710428114 18<27Soliton18>	if your url ends in / then you have to remove that first.
T 1710428127 18<25OMGOMG18>	fris: why not then wp site list --field=blog_id,name
T 1710428165 18<25OMGOMG18>	--fields, rather
T 1710430488 18<25fris18>	any reason why that parmeter expansion prints nothing
T 1710430513 18<27Soliton18>	the url ends in /.
T 1710430564 18<27Soliton18>	if the url is not as you said and you need to cut out the 4th field or something you'd do it differently.
T 1710430755 18<25fris18>	the echo with cut works
T 1710430778 18<25fris18>	filename=$(echo "$url" | cut -d/ -f4) better way than that?
T 1710430865 18<24ano18>	!echo
T 1710430865 18<29greybot18>	echo outputs a string. echo has many portability problems, and should never be used with option flags. Consider printf instead: printf 'name: %s\n' "$name". https://wiki.bash-hackers.org/commands/builtin/echo | https://cfajohnson.com/shell/cus-faq.html#Q0b | http://www.in-ulm.de/~mascheck/various/echo+printf | https://pubs.opengroup.org/onlinepubs/9699919799/utilities/echo.html
T 1710430998 18<25fris18>	printf '%s\n' "$url" | cut -d/ -f4
T 1710431010 18<27Soliton18>	if you have no idea how your urls look: IFS=/ read -ra fields <<< "$url"; filename=${fields[3]}
T 1710431014 18<27Earnestly18>	fris: urls are fairly well defined, you may not need to use external tools to access the fields
T 1710431061 18<25fris18>	all urls are domain.com/subsite/ domain.com/anothername/ etc no extra paths
T 1710431084 18<25fris18>	so just need subsite anothername etc
T 1710431091 18<27Soliton18>	"if your url ends in / then you have to remove that first."
T 1710431160 18<27Soliton18>	# while IFS= read -r url; do filename=${url%/} filename=${filename##*/}; declare -p filename; done <<< domain.com/subsite/
T 1710431162 18<25shbot18>	Soliton: declare -- filename="subsite"
T 1710431221 18<27Earnestly18>	E.g. with sh: url=domain.com/anothername/; filename=$(set -f; IFS=/; set -- $url; printf %s "$2") # This shouldn't have the trailing separator issue afaiui
T 1710431241 18<25fris18>	i could also use basename $url ?
T 1710431246 18<27Earnestly18>	However because you wrote 4 I assume your example is wrong and you meant to include https://
T 1710431261 18<27Soliton18>	if you must use an external tool, sure.
T 1710431277 18<25fris18>	Earnestly: no i dont need https, im using the subfolder at the end for the filename.zip
T 1710431296 18<25fris18>	domain.com/subsite/ becomes subsite.zip
T 1710431309 18<27Soliton18>	the point is that your cut example does not work with that.
T 1710431312 18<27Earnestly18>	fris: Then how does field 4 of domain.com/subsite/ work? As there is no field 4 there
T 1710431330 18<25fris18>	Soliton: yes it does https://domain.com/subsite/ is the value
T 1710431340 18<27Soliton18>	hence what Earnestly said...
T 1710431364 18<25fris18>	Earnestly: has https in it
T 1710431366 18<27Earnestly18>	# url=https://domain.com/anothername/; filename=$(set -f; IFS=/; set -- $url; printf %s "$4"); declare -p filename
T 1710431367 18<25shbot18>	Earnestly: declare -- filename="anothername"
T 1710431419 18<27Soliton18>	not much point in using wordsplitting anyway.
T 1710431437 18<27Earnestly18>	(Ideal shell would be one with a split builtin, no IFS, and read has both -f and -d where -f is field separator and -d is terminator)
T 1710431463 18<27Earnestly18>	And possibly join to replace $*
T 1710431556 18<25fris18>	Earnestly: http://pastie.org/p/6L734xn8oEXdflMamMNJGs like this/
T 1710431613 18<27Earnestly18>	fris: No I would not write it like this as I would lift the split up before it sees the loop and avoid the cost of forking so much
T 1710431641 18<27Earnestly18>	fris: What is wp site list --fields=url producing that you need sed?
T 1710431649 18<27Earnestly18>	I assume a header
T 1710431666 18<25fris18>	delete first 2 lines, 1 headeer, 2nd is the main domain.com which is not needed
T 1710431723 18<27Earnestly18>	Yeah, the problem is sed 1,2d doesn't really explain that intention. It's just "remove the first two lines". Hm
T 1710431760 18<25fris18>	yes first 2 are to be excluded
T 1710431850 18<27Earnestly18>	fris: Can you do --fields=url,path?
T 1710431864 18<25fris18>	ya
T 1710431883 18<27Earnestly18>	fris: Hm, this also has --format as well
T 1710431926 18<27Earnestly18>	But it doesn't appear to print a header so I'm not sure why yours does unless the documentation I'm looking at is different from yours
T 1710431979 18<25fris18>	ahh should be just the first line then
T 1710431996 18<25fris18>	as i dont want the main domain, just sub sites
T 1710432109 18<27Earnestly18>	fris: What does --fields=url --path=/ do?
T 1710432171 18<25fris18>	path is for the path to the wordpress install --path=/ prints not a valid wp install
T 1710432188 18<27Earnestly18>	fris: Well, I don't know this command and the docs are weak. The point being is that you should produce both values you need before the read loop. E.g. read -r path url; do if ...; wp mu-migration "$path".zip ... --url="$url"
T 1710432214 18<27Earnestly18>	fris: Ah I hoped it might filter urls with / in their name, thus excluding the pathless domain
T 1710432215 18<25fris18>	ya thats why the cut cmd which gets the .zip file name
T 1710432231 18<27Earnestly18>	fris: Yes but do it once outside of the loop instead of forking cut multiple times
T 1710432231 18<25kurahaupo18>	Earnestly: ideally IFS (and shopt and set -o) would be recorded when the script is parsed, and stick. Then we wouldn't have to fluff about saving & restoring settings inside functions
T 1710432267 18<27Earnestly18>	kurahaupo: To be fair I don't recall using IFS incidently anywhere so it doesn't even matter what IFS ends up being in my scripts, but I know that only really applies to me
T 1710432346 18<27Soliton18>	the url is only available in the loop...
T 1710433387 18<27Earnestly18>	fris: So iow, generate urls | cut into url and path | read both url and path at the same time. The pipeline executes once and just filters data, then you can arrange it for your migration which has to fork
T 1710433424 18<25ormaaj18>	hm i'm using getent to test the string from the user login field. Hope it's reliable for that probably unintented purpose.
T 1710433434 18<27Earnestly18>	fris: wp site list appears to have a --format=json which can help structure this and even filter out the pathless domain all in one go
T 1710433476 18<25ormaaj18>	i could add that pattern match as a preliminary filter.
T 1710433485 18<27Earnestly18>	fris: You can then provide the url first, which is well defined to contain no whitespace and a potentially url-decoded path afterwards, which is slurped up into read's last parameter unharmed
T 1710433516 18<27Earnestly18>	wp mu-migration would be nice if it accepts url encoded paths though
T 1710433642 18<27Earnestly18>	fris: So iow: https://0x0.st/HFSS.txt
T 1710433656 18<27Soliton18>	an arbitrary path will not be "unharmed".
T 1710433657 18<27Earnestly18>	With a ; do sorry
T 1710433662 18<27Earnestly18>	Soliton: How so?
T 1710433675 18<27Soliton18>	you split into fields...
T 1710433709 18<27Earnestly18>	Soliton: 'url path\0' | IFS=' ' read -rd '' url path
T 1710433716 18<27Earnestly18>	I can't see where path would be damaged here
T 1710433752 18<27Earnestly18>	I define the fields as url space path nul, if I don't get two fields then it's undefined anyway
T 1710433785 18<27Soliton18>	in your example any trailing spaces will be gone.
T 1710433809 18<27Earnestly18>	Hm, even with -d ''?
T 1710433818 18<27Earnestly18>	That's a bit annoying
T 1710433819 18<27Soliton18>	how does that matter?
T 1710433877 18<27Earnestly18>	And that only applies to "IFS whitespace" iirc
T 1710433950 18<27Earnestly18>	So instead 'url/path\0' | IFS=/ read -rd '' url path should work, alternatively: url\0path\0 | { read -rd '' url; read -rd '' path; } if such pairing can be guaranteed. I really dislike IFS
T 1710433953 18<27Soliton18>	# printf 'url_path_\0' | { IFS=_ read -rd '' url path; declare -p path; }
T 1710433955 18<25shbot18>	Soliton: declare -- path="path"
T 1710433986 18<27Earnestly18>	So bash isn't POSIX either and trims non-whitespace chars?
T 1710434014 18<27Earnestly18>	# # printf 'url_path__\0' | { IFS=_ read -rd '' url path; declare -p path; }
T 1710434015 18<25shbot18>	Earnestly: no output
T 1710434024 18<27Earnestly18>	# printf 'url_path__\0' | { IFS=_ read -rd '' url path; declare -p path; }
T 1710434026 18<25shbot18>	Earnestly: declare -- path="path__"
T 1710434077 18<27Soliton18>	it's the IFS is not a separator but terminator thing.
T 1710434160 18<27Earnestly18>	# printf 'url path \0' | { IFS=' ' read -rd '' url path; declare -p path; }
T 1710434162 18<25shbot18>	Earnestly: declare -- path="path"
T 1710434172 18<25ormaaj18>	 $ ( LC_CTYPE=C; enable kv; printf '%s %s\0' boo moo | kv -A a -d '' -s ' '; printf '%s ' "${a[@]@k}"; echo )
T 1710434172 18<25ormaaj18>	boo moo
T 1710434187 18<27Earnestly18>	And the trouble is, you can't even suffix it with a separator for it to eat
T 1710434190 18<27Earnestly18>	# printf 'url path  \0' | { IFS=' ' read -rd '' url path; declare -p path; }
T 1710434191 18<25shbot18>	Earnestly: declare -- path="path"
T 1710434236 18<27Soliton18>	anyway, two trivial parameter expansions do what they want. if there is a need to urldecode then they can do that in shell as well.
T 1710434246 18<27Earnestly18>	Yeah, seems reasonable in light
T 1710434298 18<27Earnestly18>	Soliton: And the domain is known so the entire thing can be accurately stripped off the head, which if the result is checked for non-empty string means the nonsubdomain domain will be excluded 'for free'
T 1710434333 18<20Led_Zeppelin218>	i have 3 variables. a,b,c. How can I have them in a another variable? all="aval_$abval_$bcval_$c" is that the right way? forsome reason its not showing it
T 1710434362 18<27Soliton18>	${a}
T 1710434363 18<27Earnestly18>	Led_Zeppelin2: all=$a$b$c
T 1710434382 18<20Led_Zeppelin218>	what if I want to describe the variable? like a_val.
T 1710434395 18<27Earnestly18>	Then what Soliton wrote, use {} to guard them
T 1710434400 18<27Soliton18>	!${
T 1710434400 18<29greybot18>	Without curly braces parameter expansions refer to the longest valid variable name or shortest positional parameter. "${var}bar" expands the parameter named "var" while "$varbar" expands "varbar". "$123" references argv[1] and "${123}" references argv[123]. Braces are requried for parameters > 9, special PEs, and array expansions: ${10}, ${var##pat}, ${arr[5]}. BRACES AREN'T A SUBSTITUTE FOR QUOTES!
T 1710434459 18<27Earnestly18>	all=a_val_${a}b_val_${b}...
T 1710434685 18<25ormaaj18>	"thx it worked! IFS=_; for val in $all; do mv $val ~; done"
T 1710435152 18<20twkm18>	though you better unset IFS if that shell will be doing anything else.
T 1710435371 18<25ormaaj18>	# typeset -p LANG
T 1710435373 18<25shbot18>	ormaaj: declare -x LANG="en_US.UTF-8"
T 1710435529 18<25ormaaj18>	added a default to catch try catching encoding issues and generally be more "realistic"
T 1710435557 18<25ormaaj18>	s/catch//
T 1710435655 18<28emanuele618>	# : > $(–µ—ÅhŒø -n–µ '\ufdfd'); l—ï -–∞
T 1710435656 18<25shbot18>	emanuele6: bash: –µ—ÅhŒø: command not found
T 1710435656 18<25shbot18>	emanuele6: bash: $(–µ—ÅhŒø -n–µ '\ufdfd'): ambiguous redirect
T 1710435656 18<25shbot18>	emanuele6: bash: l—ï: command not found
T 1710435671 18<28emanuele618>	now we can trick ano better
T 1710435681 18<25ormaaj18>	:D
T 1710438521 18<29Kingsy18>	https://bpa.st/KKQA <- can someone tell me what is wrong with this script. it outputs thats the branch does noit match the pattern.. it does though....
T 1710438613 18<27Soliton18>	!check
T 1710438616 18<28checkbot18>	Soliton: Looks good to me
T 1710438641 18<27Soliton18>	maybe in some other regex dialect that matches.
T 1710438649 18<27Soliton18>	!=~
T 1710438650 18<29greybot18>	The =~ operator of [[ evaluates the left hand string against the right hand ERE (see <ere>, <regex>). After a successful match, the BASH_REMATCH array contains the matched string and subexpressions (if any). Any quoted characters in the ERE become literal. Best to put the whole ERE in a variable: [[ $string =~ $regex ]]
T 1710438658 18<27Soliton18>	!ere
T 1710438658 18<29greybot18>	Extended Regular Expressions. See http://mywiki.wooledge.org/RegularExpression or (POSIX) https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_04 or https://man7.org/linux/man-pages/man7/regex.7.html
T 1710438698 18<29Kingsy18>	hmm I don't understand.
T 1710438754 18<29Kingsy18>	so the regex is correect but its the comparison thats wrong?
T 1710438764 18<27Soliton18>	bash supports ERE so you need to write such a regex.
T 1710438879 18<29Kingsy18>	Soliton: well I did have something like this -> REGEX="^(ticket\/PH-[[:digit:]]+_[[:alnum:]-]+|release\/[[:digit:]]{2}\.[[:digit:]]{2}\.[[:digit:]]{2}|main|develop)$" <- but it still had the same issue.
T 1710438933 18<29Kingsy18>	oh I got it
T 1710438946 18<27Soliton18>	i mean PH != A
T 1710438955 18<29Kingsy18>	haha yeah typo to hell
T 1710438961 18<27Soliton18>	also you have weird \/ in there.
T 1710438983 18<29Kingsy18>	its so I can support hte / char in the branch new
T 1710438984 18<29Kingsy18>	name *
T 1710438994 18<29Kingsy18>	it needs to be escaped no?
T 1710439001 18<27Soliton18>	no
T 1710439092 18<27Soliton18>	i don't think / is special in any regex dialect i know. sometimes regex are delimited by / though and then you may need to escape the delimiter.
T 1710439099 18<29Kingsy18>	so anyway, the first regex was not valid because bash doesnt support it? and only ERE? or you need ERE for the comparison?
T 1710439151 18<27Soliton18>	it was valid but \d is unspecified.
T 1710439170 18<27Soliton18>	it might match d or a digit or whatever.
T 1710439193 18<26tearsfornations18>	does anyone want to read my testimony (Christian)? It is 1 page.
T 1710439219 18<27Soliton18>	this channel is about shell scripting.
T 1710439302 18<29Kingsy18>	Soliton: thanks so much for the info
T 1710440806 18<27xx18>	this isn't born again spiritual healing?
T 1710442956 18<20houseparty18>	Is it accurate that it is OK to use grep with globs when searching for file names - but when searching within files, you should use regexes? I found this: https://www.linuxjournal.com/content/globbing-and-regex-so-similar-so-different. I sort of felt like shellcheck was misleading me as my regex wasn't doing what I wanted - only the glob. But that
T 1710442956 18<20houseparty18>	Linux Journal article makes it sooo much easier if a person can just remember files vs file titles.
T 1710442978 18<24geirha18>	grep doesn't do globs at all
T 1710442996 18<27Soliton18>	the shell expands the globs.
T 1710443138 18<27Soliton18>	general syntax is  grep 'regex' files...  and files... can be provided by the shell expanding a glob to multiple matching files.
T 1710443157 18<20houseparty18>	Yeah, it did some scary things at some point ... started somehow executing my files. I think it was echo that did that. Echo can execute or it can run a command by expanding it in command substitution. I should have saved the code ... I hit ctrl+c before anything bad happened.
T 1710443184 18<27Soliton18>	echo does no such thing.
T 1710443188 18<22tirnanog18>	it's not accurate because it makes no sense as an axiom. grep is not a tool for matching against file names.
T 1710443208 18<22tirnanog18>	find is one example of a tool that might be suitable then.
T 1710443235 18<27Soliton18>	command substitution is another shell feature independent of echo (which might be a shell builtin).
T 1710443342 18<20houseparty18>	So, this is my code ... and it's fixed now. I did use the globstars here because I got tired of fooling with regexes ... and shellcheck only complained when I grepped outside of the context of executing the find command. This isn't anything fancy or interesting but it worked for my case. Took too long when this should have been written in like one
T 1710443343 18<20houseparty18>	minute:
T 1710443343 18<20houseparty18>	I can't find my paste bin link... there is a popular one everyone uses here.
T 1710443413 18<20houseparty18>	This worked for what I wanted. then I will lose it and spend another vast period of time finally remembering what I did: https://bpa.st/WSRA
T 1710443492 18<20houseparty18>	You can see there that I combined it with find. And when I did it, I realized it was redundant. I just wanted something that worked so I quit editing it.
T 1710443539 18<27Soliton18>	the glob is handled by find there which also supports globs.
T 1710443582 18<20houseparty18>	that is actually what ChatGPT said. You should get hired by OpenAI
T 1710443607 18<22tirnanog18>	incidentally, no -f test is required because find is only being permitted to print the pathnames of regular files to begin with. using sudo is also suspect, given you're searching your own home directory to begin with.
T 1710443612 18<27Soliton18>	who knows why you use sudo to run find on your home dir.
T 1710443616 18<20houseparty18>	I asked ChatGPT why shellcheck didn't flag it in the context of the find command and it said almost exactly what you just typed, Soliton. Impressive.
T 1710443626 18<22tirnanog18>	also, it won't handle all pathnames correctly.
T 1710443634 18<22tirnanog18>	(bet your 'AI' doesn't tell you that)
T 1710443635 18<20houseparty18>	Because if I don't use sudo, I get complaints from the find command
T 1710443651 18<20houseparty18>	I can show you them... They relate to configs for programs that run under root. I'm sure that's the reason
T 1710443668 18<20houseparty18>	The programs automatically store the files in ~/.config ... also, swap files are owned by root.
T 1710443673 18<27Soliton18>	might want to fix the premissions in your home then.
T 1710443676 18<22tirnanog18>	yes. if you have paths that cannot otherwise be traversed, that would explain it.
T 1710443705 18<20houseparty18>	*They should be. It's dangerous to have swap files owned by a regular user... they give a person access to memory space. Memory space is critical and obviously a huge part of exploits.
T 1710443720 18<22tirnanog18>	directories that cannot be traversed and/or entries that cannot be stat'ed.
T 1710443724 18<20houseparty18>	Well, I'm moving to another OS but it's good to consider so thanks
T 1710443759 18<20houseparty18>	For a second, tirnanog, I thought you were arguing with the last commenter ... you countered yourself ... Ha, I misread clearly
T 1710443845 18<27Soliton18>	also using find with -maxdepth 1 is fairly useless. you usually use find when you want to traverse a dir hierarchy.
T 1710443929 18<27Soliton18>	getting permission errors directly in $HOME sounds quite odd.
T 1710443940 18<20houseparty18>	No, so that I flat out disagree with. Searching beyond one directory for files that I knew were no further than one depth would have stalled the search ... find leaves no stone unturned but if I want EVERYTHING you would be right. You are operating under the assumption that I don't want to miss anything or that I don't know which location the swaps
T 1710443941 18<20houseparty18>	are. I did
T 1710443975 18<20houseparty18>	I actually knew what they were all called to... but I want to copy them which is the next step and I didn't want to keep monitoring the copy progress ... run copy over and over. That's why I wrote the script
T 1710444022 18<27Soliton18>	a simple for loop if you even need it does the same.
T 1710444110 18<20houseparty18>	I keep getting confused about those. They are needed for a finite list ... if we know exactly where it begins and stops... or if it's an array. I know if I have an array and there are no spaces in the names, it works ... outside of that,¬† just use a while loop so that shellcheck doesn't complain.
T 1710444268 18<20houseparty18>	Soliton: You are referring to a for loop to copy the files or instead of what I just did ... and I am glad I finished the first task.
T 1710445448 18<28nowarning18>	I want to check if value is one from the list, how can i do it in bash?
T 1710445519 18<20bent_fingers18>	what list?
T 1710445557 18<28nowarning18>	something like: mylist=("value1" "value2"); if $var in $mylist[@]... ?
T 1710445569 18<27larryv18>	use an associative array instead
T 1710445626 18<20bent_fingers18>	A "list" in bash is:
T 1710445628 18<20bent_fingers18>	"A list is a sequence of one or more pipelines separated by one of the operators ;, &, &&, or ||, and optionally terminated by one of ;, &, or <newline>."
T 1710445699 18<28nowarning18>	larryv: i'd prefer using array than associative array, i think. there is no need for key/value mapping
T 1710445736 18<27Soliton18>	then you have to look through the whole array each time instead of a single access to check.
T 1710445750 18<28nowarning18>	Soliton: you mean in a loop?
T 1710445751 18<27larryv18>	whereas if you use an associate array then you can look up the keys directly. use dummy values, they don't matter
T 1710445760 18<27larryv18>	*associative
T 1710445798 18<27larryv18>	nowarning: yes, you'd have to iterate over the whole thing (or until you find something)
T 1710445976 18<28nowarning18>	hmm I guess [[ "${mylist[*]}" =~ "$var" ]] is not the best approach?
T 1710445986 18<24ano18>	# declare -A assoc=([foo]= [bar]= [baz]=); value=bar; if [[ -v 'assoc[$value]' ]] then echo bar found; fi
T 1710445987 18<25shbot18>	ano: bar found
T 1710445995 18<27Soliton18>	it's not correct so no.
T 1710446043 18<28nowarning18>	it's working well for mylist=("foor" "bar"); [[ "${mylist[*]}" =~ foo ]] && echo OK
T 1710446062 18<28nowarning18>	i expected that it will evaluate to true, but it doesn't
T 1710446070 18<28nowarning18>	Soliton: so what's wrong with this?
T 1710446098 18<27larryv18>	lol that example is already broken
T 1710446099 18<27Soliton18>	you mash everything together and then look for a match somewhere. can't possibly work right.
T 1710446114 18<27userdocss18>	nowarning: why don't you want to use an Associative array? what's the reasoning, since it's the right answer.
T 1710446116 18<27larryv18>	you're searching for foo. there is no element "foo". there's an element "foor". yet it still works
T 1710446124 18<27larryv18>	"works"
T 1710446138 18<28nowarning18>	Soliton: yeah, indeed, that's why I expected to find the "foo" in "foor", but it didn't happen
T 1710446146 18<27larryv18>	# mylist=("foor" "bar"); [[ "${mylist[*]}" =~ foo ]] && echo OK
T 1710446147 18<25shbot18>	larryv: OK
T 1710446154 18<27larryv18>	# mylist=("fooradsfdsfdsafdsaasd" "bar"); [[ "${mylist[*]}" =~ foo ]] && echo OK
T 1710446155 18<25shbot18>	larryv: OK
T 1710446185 18<28nowarning18>	oh, ok, i had a typo, yeah, that's what i was expecting
T 1710446239 18<27Soliton18>	# mylist=("foo" "bar"); [[ "${mylist[*]}" =~ foo\ bar ]] && echo OK
T 1710446240 18<25shbot18>	Soliton: no output
T 1710446276 18<28nowarning18>	what about: mylist="foo:bar:zoo"; [[ ":$myist:" == *":foo:"* ]] && echo OK ? :)
T 1710446304 18<27Soliton18>	if no element can contain a semicolon, sure.
T 1710446304 18<22tirnanog18>	then it's no longer an array.
T 1710446326 18<27Soliton18>	still have to go through the whole string all the time.
T 1710446379 18<27Soliton18>	# mylist=("foo" "bar"); [[ "${mylist[*]}" =~ foo\ bar ]] && echo OK
T 1710446381 18<25shbot18>	Soliton: OK
T 1710446400 18<27Soliton18>	shbot is a little erratic lately.
T 1710446402 18<28nowarning18>	yeah, it doesn't have to be an array, and the ":" is invalid, so it should be fine
T 1710446503 18<28nowarning18>	wouldn't checking keys in associative array need to go throug the list of keys ?
T 1710446512 18<22tirnanog18>	no.
T 1710446523 18<27larryv18>	weird how people come in here asking for help and then go to extreme lengths to avoid using the best solution, fishing for excuses to use inappropriate data structures so they can stick to some idiom they like
T 1710446539 18<22tirnanog18>	nowarning: have you heard of a hash table, or map?
T 1710446552 18<22tirnanog18>	that's conceptually what it is.
T 1710446575 18<22tirnanog18>	the existence of a key can be determined quickly.
T 1710446575 18<28nowarning18>	larryv: nah, it's just that using map for keys only, looks a little weird and provide less readability
T 1710446592 18<22tirnanog18>	anyway, if your array is reasonably short there is also:
T 1710446594 18<22tirnanog18>	!inarray
T 1710446594 18<29greybot18>	Check whether a value is in an array: inarray() { local n=$1 h; shift; for h; do [[ $n = "$h" ]] && return; done; return 1; } # Usage: inarray "$value" "${array[@]}" Or just use an associative array if possible
T 1710446594 18<28nowarning18>	tirnanog: yeah, i know what is it, but i don't know how it's implemented in bash
T 1710446679 18<22tirnanog18>	in bash, associative arrays aren't that much different from conventional arrays. the important difference is that the keys can be strings, not merely valid integers.
T 1710446755 18<27Soliton18>	fairly common to implement a set using the keys of a map.
T 1710446824 18<28nowarning18>	tirnanog: yeah, i guess indexed array can be associative arrays under the hood too, no? it's just that index is a key, but maybe they are C arrays and size allocation is fixed, never seen the bash code
T 1710446875 18<22tirnanog18>	nowarning: yes, indeed. normal arrays are sparse in bash already.
T 1710446901 18<22tirnanog18>	# foo=(); foo[100]=1; declare -p foo
T 1710446902 18<25shbot18>	tirnanog: declare -a foo=([100]="1")
T 1710446951 18<22tirnanog18>	# foo=(a b c); unset -v 'foo[1]'; declare -p foo
T 1710446953 18<25shbot18>	tirnanog: declare -a foo=([0]="a" [2]="c")
T 1710446956 18<28nowarning18>	what's the proper way to check if key exists?
T 1710446971 18<27larryv18>	bash indexed arrays are implemented as linked lists iirc (unless you pick the alternate implementation at build time)
T 1710446973 18<28nowarning18>	"${map[key]+true}" ? :)
T 1710446982 18<22tirnanog18>	I would suggest going by value if you can. if you can't, [[ -v
T 1710447074 18<28nowarning18>	tirnanog: what's a difference?
T 1710447076 18<27larryv18>	# declare -A foo=([a]=1 [b]=1); [[ -n ${foo[a]} ]]; echo "$?"; [[ -n ${foo[z]} ]]; echo "$?"
T 1710447077 18<25shbot18>	larryv: 0
T 1710447077 18<25shbot18>	larryv: 1
T 1710447085 18<27larryv18>	(if you use nonempty dummy values)
T 1710447097 18<28nowarning18>	i'd use empty values i guess
T 1710447112 18<27faceface18>	hi
T 1710447122 18<22tirnanog18>	right. if you have empty values you don't need to think of it in terms of key existence. because of a number of bash deficiencies, I generally recommend it. that being said, here's how to use -v.
T 1710447130 18<27faceface18>	I want to add `... | tr -d '^M' | ...` to my script (Ctrl-V Ctrl-M outputs ^M on the terminal). How do I write ^M correctly inside vscode to get written to my bash script?
T 1710447168 18<22tirnanog18>	# foo=(a b c); key=1; unset -v 'foo[$key]'; [[ -v 'foo[$key]' ]] || echo "key $key no longer exists"
T 1710447170 18<25shbot18>	tirnanog: key 1 no longer exists
T 1710447181 18<22tirnanog18>	(yes, the quoting is weird)
T 1710447220 18<28nowarning18>	huh, but this is for indexed array, no?
T 1710447229 18<22tirnanog18>	works the same way for associative arrays.
T 1710447231 18<27Soliton18>	faceface: why not write \r?
T 1710447243 18<27faceface18>	hi Soliton
T 1710447251 18<28nowarning18>	tirnanog: I'm not sure I understood this: if you have empty values you don't need to think of it in terms of key existence. because of a number of bash
T 1710447267 18<22tirnanog18>	because you can take an empty value has meaning non-existence ...
T 1710447280 18<22tirnanog18>	and use dummy value like 1 otherwise.
T 1710447299 18<28nowarning18>	how does it matter here?
T 1710447317 18<22tirnanog18>	# declare -A map; map[foo]=1; map[bar]=1; [[ ${map[baz]} ]] || echo "couldn't find baz"
T 1710447318 18<25shbot18>	tirnanog: couldn't find baz
T 1710447334 18<22tirnanog18>	I'm not _actually_ testing for the existence of baz as a key there but it's ok within those constraints.
T 1710447343 18<28nowarning18>	The only difference I see is that I can't use one line to declare an associative array with empty values
T 1710447352 18<22tirnanog18>	I'm just saying, -v can be weird.
T 1710447361 18<22tirnanog18>	if you can not use it, I suggest not using it.
T 1710447408 18<28nowarning18>	interesting
T 1710447414 18<22tirnanog18>	nowarning: I'm not sure what isn't clear. the distinction is between a) testing for existence of a key b) testing for existence by instead taking into consideration the value looked up _by_ the key
T 1710447424 18<20Led_Zeppelin218>	coming from psotgresql 11 to 13. I know recovery.conf is gone now. Is there a doc I can see to prepare myself?
T 1710447424 18<22tirnanog18>	I'm simplying suggesting "b" over "a" in bash where possible.
T 1710447431 18<22tirnanog18>	because bash has a lot of pitfalls.
T 1710447432 18<28nowarning18>	tirnanog: yeah, i got you now
T 1710447434 18<27Soliton18>	i'd just use ${map[key]+true} as you said.
T 1710447447 18<22tirnanog18>	and yeah, that does also work.
T 1710447470 18<27larryv18>	!nabq > Led_Zeppelin2
T 1710447470 18<29greybot18>	Led_Zeppelin2: Not a #bash question. You might want to ask in a channel where it's actually on-topic. You can use "/msg alis list KEYWORDS" to search for suitable channels
T 1710447483 18<20Led_Zeppelin218>	ph soory
T 1710447488 18<22tirnanog18>	nowarning: as for declaring on "one line", you may. declare -A map([foo]=1 [bar]=1).
T 1710447502 18<28nowarning18>	tirnanog: yeah, but not with empty values
T 1710447514 18<22tirnanog18>	''
T 1710447519 18<22tirnanog18>	or ""
T 1710447522 18<28nowarning18>	ok :)
T 1710447528 18<27larryv18>	or nothing
T 1710447531 18<27larryv18>	# declare -A foo=([a]= [b]=); declare -p foo
T 1710447532 18<22tirnanog18>	that too!
T 1710447533 18<25shbot18>	larryv: declare -A foo=([b]="" [a]="" )
T 1710447542 18<28nowarning18>	larryv: that returns me error
T 1710447556 18<27larryv18>	uh
T 1710447558 18<22tirnanog18>	are you on macOS?
T 1710447573 18<28nowarning18>	yes
T 1710447577 18<27faceface18>	thank you Soliton
T 1710447587 18<28nowarning18>	bash: syntax error near unexpected token `(
T 1710447603 18<22tirnanog18>	you'll need a different build of bash.
T 1710447614 18<22tirnanog18>	in macOS, /bin/bash is ancient.
T 1710447619 18<22tirnanog18>	no associative array support.
T 1710447624 18<28nowarning18>	I don't use macOS bash
T 1710447638 18<22tirnanog18>	hmm. what is it then?
T 1710447642 18<27faceface18>	Final dumb question (heh)... I'm running `bash script.bash | tee -a ...` but I don't get output right away... is there a simple fix? e.g. it nees to 'cache' up some output before I see it
T 1710447648 18<28nowarning18>	GNU bash, version 5.2.26(1)-release (aarch64-apple-darwin23.2.0)
T 1710447660 18<22tirnanog18>	is that also borne out by: declare -p BASH_VERSION
T 1710447688 18<28nowarning18>	declare -- BASH_VERSION="5.2.26(1)-release"
T 1710447702 18<22tirnanog18>	can confirm.
T 1710447714 18<22tirnanog18>	oh wait.
T 1710447720 18<22tirnanog18>	no, I can't. was just a typo.
T 1710447726 18<22tirnanog18>	works fine. what is your command precisely?
T 1710447764 18<28nowarning18>	tirnanog: declare -A mapx([foo]= [bar]=)
T 1710447770 18<22tirnanog18>	you missed an =
T 1710447779 18<28nowarning18>	ohhhh
T 1710447789 18<28nowarning18>	tirnanog: thx :D
T 1710447843 18<22tirnanog18>	faceface: you'll have to consider whatever script.bash is doing.
T 1710447847 18<22tirnanog18>	!faq buffering
T 1710447847 18<29greybot18>	https://mywiki.wooledge.org/BashFAQ/009 -- What is buffering?  Or, why does my command line produce no output: tail -f logfile | grep 'foo bar' | awk ...
T 1710447854 18<22tirnanog18>	that's a general article concerning the matter.
T 1710447900 18<22tirnanog18>	something in your script is refraining from employing line-buffering, basically.
T 1710447920 18<28nowarning18>	ok, so what's really wrong with test -v? :) I'm really curious :)
T 1710447937 18<22tirnanog18>	nowarning: having to use that bizarre quoting style, for one thing.
T 1710448006 18<22tirnanog18>	or, rather, having to quote at all for it to function in the expected way.
T 1710448007 18<28nowarning18>	:P
T 1710448010 18<22tirnanog18>	it's very counter-intuitive.
T 1710448041 18<28nowarning18>	then what about the "${map[key]+ok}" style? does it look better? :D
T 1710448047 18<22tirnanog18>	the other problem with it is that the concept of setness, so to speak, can be confusing.
T 1710448074 18<22tirnanog18>	I won't comment on aeshtetics but it's correct.
T 1710448080 18<22tirnanog18>	aesthetics, even
T 1710448118 18<22tirnanog18>	[[ ${map[key]+ok} ]] will consider either the empty string or "ok" for non-emptiness, and it will only expand as "ok" if the key exists.
T 1710448165 18<22tirnanog18>	I'd probably write "set", not "ok" there but it doesn't matter what the string is, so long as it's non-empty.
T 1710448174 18<27larryv18>	!pf61 > nowarning
T 1710448174 18<29greybot18>	nowarning: https://mywiki.wooledge.org/BashPitfalls#pf61 -- Don't do this! -- [[ -v hash[$key] ]]
T 1710448204 18<22tirnanog18>	right.
T 1710448238 18<27larryv18>	maybe also breeze through #62 if you hate yourself
T 1710448244 18<22tirnanog18>	I was about to say the same.
T 1710448247 18<22tirnanog18>	truly lamentable.
T 1710448264 18<28nowarning18>	ohm
T 1710448370 18<28nowarning18>	tirnanog: [[ ${map[key]+ok} ]] will consider either the empty string or "ok" for non-emptiness -- what's happening with the empty string here?
T 1710448402 18<22tirnanog18>	[[ word ]] is the same as [[ -n word ]]. see "help test".
T 1710448415 18<28nowarning18>	ok
T 1710448431 18<22tirnanog18>	it's a check for non-emptiness. nothing more.
T 1710448460 18<28nowarning18>	so adding +ok would work as expected, the map values can be empty
T 1710448512 18<22tirnanog18>	it's not testing the value. if you're ok doing it that way, [[ ${map[key]} ]] is enough.
T 1710448620 18<29nightstrike18>	what's a good data file type to use with bash?  I was thinking json, and found quite a few ways to trivially read json in bash, but not update it
T 1710448632 18<29phy172918>	!graduated
T 1710448632 18<29greybot18>	Congratulations! You've graduated to needing to use a real language!
T 1710448633 18<22tirnanog18>	# declare -a map; map[a]=""; [[ ${map[a]+ok} ]] || [[ ${map[b]} ]]; declare -p PIPESTATUS
T 1710448635 18<25shbot18>	tirnanog: declare -a PIPESTATUS=([0]="0")
T 1710448639 18<22tirnanog18>	whoops
T 1710448642 18<22tirnanog18>	# declare -a map; map[a]=""; [[ ${map[a]+ok} ]] | [[ ${map[b]} ]]; declare -p PIPESTATUS
T 1710448643 18<25shbot18>	tirnanog: declare -a PIPESTATUS=([0]="0" [1]="1")
T 1710448658 18<29nightstrike18>	lol
T 1710448664 18<20arraybolt318>	nightstrike: key-value pairs work well for me, you can read them and split them up with `cut` pretty easily.
T 1710448709 18<22tirnanog18>	nowarning: note the difference there. ${map[a]+ok} expands as "ok" because the key exists (that its value is empty is immaterial). the other test fails not simply because "b" doesn't exist as key but because the expansion is ultimately the empty string.
T 1710448729 18<20arraybolt318>	there's a tool called `jo` in the Ubuntu archives that allows outputting JSON.
T 1710448737 18<22tirnanog18>	tl;dr: if empty values are enough to constitute non-existence to you, the latter style of test is acceptable.
T 1710448737 18<20arraybolt318>	haven't used it, have no idea if it's any good
T 1710448773 18<20arraybolt318>	https://github.com/jpmens/jo
T 1710448773 18<27larryv18>	nightstrike: hard to discussion "good data file type" without knowing what you're actually, like, doing with it.
T 1710448776 18<27larryv18>	*to discuss
T 1710448787 18<29nightstrike18>	fair point
T 1710448857 18<29nightstrike18>	arraybolt3: I was looking at jq, I didn't see jo
T 1710450133 18<27faceface18>	thanks tirnanog
T 1710450328 18<27faceface18>	tirnanog: right, I added | tr |, which I assume is buffering
T 1710450440 18<24geirha18>	more likely it's the command to the left of tr in that pipeline that buffers
T 1710450529 18<24geirha18>	ah no, looks like tr also buffers
T 1710450596 18<24geirha18>	... | stdbuf -o0 tr -d '\r' | ...   if you have (GNU) stdbuf installed
T 1710463163 18<20ibanja18>	how can I read a line from a file with a variable in it and have bash process the variable? Example: $HOME/.bashrc would become /home/someuser/.bashrc
T 1710463237 18<27larryv18>	!template > ibanja
T 1710463237 18<29greybot18>	ibanja: http://mywiki.wooledge.org/TemplateFiles
T 1710463282 18<20ibanja18>	OK... I thought it would involve the exec command. I'll have a look at templates.
T 1710463412 18<20ibanja18>	so basically I just use a place holder and replace that using sed.
T 1710463534 18<27larryv18>	consider reading the rest of the page.
T 1710463546 18<27larryv18>	the sed suggestion is the most basic approach and almost the worst one
T 1710463755 18<20ibanja18>	OK... this is new to me, so I'll have to wrap my head around it. Thanks for the help.
T 1710463927 18<27larryv18>	the easiest approach is probably the envsubst one, if you have that utility
T 1710464146 18<27larryv18>	ibanja: also, what do you want to do with the text you process? this wiki page assumes you're just going to write the processed text back out to a different file
T 1710464351 18<20ibanja18>	I want to copy a list of files to the user directory of the user who is running the script. Example: I Will copy .bashrc to $HOME/.bashrc.
T 1710466587 18<28emanuele618>	i just learned/figured-out that   env -S  can be used as an hack to make shebang work in CRLF files, because env -S will discard CR as whitespace
T 1710467440 18<28emanuele618>	1000th wordle :o
T 1710467482 18<27larryv18>	:O
T 1710469598 18<27wyclif18>	emanuele6: off-topic I know, but what is your fave Wordle app?
T 1710470451 19*	Now talking on 22#bash
T 1710470451 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1710470451 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1710470700 19*	Now talking on 22#bash
T 1710470700 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1710470700 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1710470726 18<25ormaaj18>	of top I.C. on to PIC
T 1710470747 18<25ormaaj18>	off to pee I see
T 1710477122 18<20bent_fingers18>	where are the job listings for bash programmers?
T 1710477204 18<20bent_fingers18>	where are the opportunities for those bash programmers who can confidently report on their resume five stars out of five stars for that skill level
T 1710477267 18<20bent_fingers18>	there must be somebody whose willing to pay for an echo
T 1710479006 19*	Now talking on 22#bash
T 1710479006 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1710479006 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1710480282 18<25ormaaj18>	3 star bash programmer
T 1710488641 18<24PlasmaHH18>	Hi, how can I on bash in mingw canonicalize a path? using realpath C:/ and /c/ at the start at input will be left as-is even though they refer to the same actual path...
T 1710490191 18<25ormaaj18>	PlasmaHH: Convert to a unix path first then use readlink or realpath. Alternatively, use a tool designed for that such as cygpath or winepath.
T 1710490249 18<24PlasmaHH18>	ormaaj: I can't depend on external tools that don't come with the git bash mingw installation... so that conversion needs to be done manually?
T 1710490436 18<25ormaaj18>	I would guess probably, unless there is a similar native windows tool or maybe powershell applet (if they don't count as external tool)
T 1710490442 18<25ormaaj18>	I am not familiar with that environment
T 1710490479 18<24PlasmaHH18>	powershell would also count as an external tool here as it is disabled per default in the company
T 1710490524 18<25ormaaj18>	there is a realpath bash loadable.
T 1710490534 18<25ormaaj18>	# enable realpath; type realpath
T 1710490537 18<25shbot18>	ormaaj: realpath is a shell builtin
T 1710490561 18<25ormaaj18>	I would bet it is not included.
T 1710490623 18<25ormaaj18>	highly unlikely
T 1710490635 18<24PlasmaHH18>	indeed its not included
T 1710490774 18<25ormaaj18>	how does mingw handle /proc magic symlinks? Depending on what you're doing you can sometimes get away with using /proc/self/fd/* directly.
T 1710490845 18<25ormaaj18>	bash evidently has some limited built-in abstraction for /proc/self/fd on various platforms, in some contexts.
T 1710491032 18<25ormaaj18>	e.g. instead of cannonicalizing a true path and opening it multiple times, you might open a dir fd once and use it as a substitute.
T 1710493574 18<25ormaaj18>	hm
T 1710493586 18<25ormaaj18>	 $ ls -- ~/!(+([[:graph:]]))
T 1710493586 18<25ormaaj18>	'/home/ormaaj/%y'$'\001\004\177'  '/home/ormaaj/&2)]; printf '  '/home/ormaaj/A'$'\177'  '/home/ormaaj/W'$'\f'']{'$'\177'  '/home/ormaaj/'$'\315\002\001\004\177'
T 1710500291 18<25hsv18>	Hi, any pointers how to grep for both 'x' and 'X' (different case) and have these go separately to stdout and stderr?
T 1710500397 18<25hsv18>	The overall objective is to 'tail -f' a logfile, and have 'beep -s' sound a beep only for say 'x' whereas both are output to the terminal.
T 1710501092 18<19Artfaith18>	o/
T 1710501099 18<19Artfaith18>	hsv, something like `multitail` or https://lnav.org/ ?
T 1710501192 18<19Artfaith18>	Related: https://stackoverflow.com/questions/13858912/piping-tail-output-though-grep-twice
T 1710501237 18<25hsv18>	yes i'm already using --line-buffered
T 1710501318 20*	Disconnected (20)
T 1710501475 19*	Now talking on 22#bash
T 1710501475 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1710501475 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1710501680 18<25hsv18>	it does the job :)
T 1710502059 18<27rendar18>	beep?
T 1710502086 18<25hsv18>	https://linux.die.net/man/1/beep
T 1710502463 18<28dumbledoor18>	Is there an equivalent of emacs' C-w binding for the search gutter in the less pager?
T 1710502594 18<28dumbledoor18>	The way I search options in man pages is that I enter / and ESC+k to go to the last searched item which is always like /^s+-o or /^s+--option form. So, it's easy to change the -o by just a single backspace but I want somthing to remove the entire `option` word with a binding.
T 1710505451 18<25ormaaj18>	hsv: https://bpa.st/raw/LM3A
T 1710505705 18<28emanuele618>	!coffee
T 1710505705 18<29greybot18>	c[_]
T 1710508309 18<28nowarning18>	I get SC2145 for [[ "${#map[@]}" -gt 0 ]], not sure how to refactor it..
T 1710508365 18<28nowarning18>	I can do [[ -n "${map[0]}" ]] but..
T 1710508398 18<27Soliton18>	((${#map[@]} > 0))
T 1710508412 18<22tirnanog18>	eh.
T 1710508451 18<27Soliton18>	(no clue what SC2145 is.)
T 1710508523 18<22tirnanog18>	there's nothing wrong with [[ "${#map[@]}" -gt 0 ]], in isolation. considering it in isolation is almost certainly a mistake.
T 1710508529 18<28nowarning18>	Soliton: https://www.shellcheck.net/wiki/SC2145
T 1710508559 18<27Soliton18>	no clue what SC2145 has to do with this.
T 1710508601 18<22tirnanog18>	nothing.
T 1710508689 18<28llua18>	!check map=(.); [[ "${#map[@]}" -gt 0 ]]
T 1710508689 18<28checkbot18>	llua: Looks good to me
T 1710508908 18<28nowarning18>	heh, using (( )) also shellcheck complains :)
T 1710508915 18<22tirnanog18>	read what you see, not what you think you see.
T 1710508939 18<22tirnanog18>	(as an old teacher was so very fond of saying)
T 1710509030 18<28nowarning18>	tirnanog: i wonder you meant with the isolation, because what you are saying is that this code is mostly a mistake, no? :)
T 1710509046 18<27Soliton18>	!tests
T 1710509047 18<29greybot18>	Use [[ .. ]] for testing strings or files, (( .. )) for testing numbers, and ''if ..'' for testing commands. Do *NOT* use [ .. ] in bash (only in sh). See <http://mywiki.wooledge.org/tests> and <http://wiki.bash-hackers.org/commands/classictest>. Difference between [ and [[: <http://mywiki.wooledge.org/BashFAQ/031>
T 1710509047 18<24geirha18>	!check map=(.); [[ "${map[@]}" -gt 0 ]]
T 1710509047 18<28checkbot18>	geirha: Line 1: Arrays implicitly concatenate in [[ ]]. Use a loop (or explicit * instead of @). See https://shellcheck.net/?id=cb9047
T 1710509098 18<27Soliton18>	still no SC2145
T 1710509106 18<24geirha18>	yeah, different error for that one
T 1710509107 18<22tirnanog18>	yes. not buying it.
T 1710509160 18<22tirnanog18>	nowarning: no. I'm suggesting that you don't understand the output that shellcheck is giving you, nor how it pertains to your code.
T 1710509173 18<22tirnanog18>	at the same time, I'd rather not guess how it is happening.
T 1710509202 18<22tirnanog18>	that [[ "${#map[@]}" -gt 0 ]] raises SC2145 is falsifiable.
T 1710509234 18<24geirha18>	sure it's not SC2154 (var referenced but not assigned) ?
T 1710509390 18<28nowarning18>	nope
T 1710509403 18<28nowarning18>	 SC2145:error:26:88: Argument mixes string and array. Use * or separate argument
T 1710509431 18<22tirnanog18>	and "26:88" is what?
T 1710509439 18<28nowarning18>	index in the file
T 1710509452 18<28nowarning18>	or maybe not
T 1710509453 18<22tirnanog18>	I give up.
T 1710509453 18<28nowarning18>	:)
T 1710509472 18<28nowarning18>	i don't what is it :)
T 1710509484 18<22tirnanog18>	line and col numbers, probably.
T 1710509548 18<28nowarning18>	ah, ok ok. yeah. i have one more line:col because it's bundled, yeah
T 1710509620 18<28nowarning18>	ok, i unbundled this script, now i get SC2145 and SC2154
T 1710509663 18<26squirrel18>	hello. on windows, in a .gitconfig alias, i'm trying to read one line from stdin into a variable using `read -r commit_message`, however for some reason it is not accepting an empty or blank line, instead it acts like `cat` reading multiple lines until ^Z (windows version of ^D), any idea what might be the issue here?
T 1710509721 18<22tirnanog18>	reading from your tty, probably.
T 1710509744 18<28nowarning18>	oh wow, ok, i know what is happening
T 1710509789 18<22tirnanog18>	i.e. if you open a terminal and issue "read -r commit_message", that's what will happen as STDIN is your terminal.
T 1710509818 18<22tirnanog18>	although, it should still end after having encountered a newline.
T 1710510054 18<27Soliton18>	sounds like no newline is input.
T 1710510071 18<27Soliton18>	maybe whatever terminal is used is in a weird mode.
T 1710510074 18<22tirnanog18>	or perhaps something else entirely is trying to read stdin at the point that the symptom is observed. who knows.
T 1710510122 18<22tirnanog18>	(I doubt the alias is simply "read -r commit_message")
T 1710510169 18<28nowarning18>	yeah, the problem was not with the [[ ]], but another line where I had something like echo "Foo: ${map[@]}", I replaced @ with * :)
T 1710510185 18<22tirnanog18>	we know.
T 1710510208 18<28nowarning18>	:D
T 1710510222 18<26squirrel18>	tirnanog: in the terminal, `read -r commit_message` behaves normally, it only tries to read multiple lines when running ‚Äúinside‚Äù git. the process explorer also shows that it launches `sh.exe`, i wonder if this might be something other than bash
T 1710510268 18<22tirnanog18>	as long as it's a proper sh implementation, it shouldn't matter. git for windows uses msys2. it's likely either bash or dash.
T 1710510303 18<27Soliton18>	what happens if you press enter? do you see ^M or so?
T 1710510414 18<22tirnanog18>	on the matter of sh, you might want to run "type sh" and check that it's not something that is outside the purview of the msys2 environment.
T 1710510444 18<26squirrel18>	no ^Ms or anything like that, it reads from stdin until i do ^Z on a new lne
T 1710510475 18<27Soliton18>	and then commit_message contains the input?
T 1710510492 18<26squirrel18>	yeah, multiline input
T 1710514191 18<24depesz18>	hi. in my script I need to do sometthing 30 times. so I did: for i in {1..30}; do ...; done - but shellcheck complains about unused variable.
T 1710514203 18<24depesz18>	is there any way do to the loop without variable?
T 1710514221 18<29phy172918>	_ is the idiomatic "I don't care about this" variable
T 1710514237 18<24depesz18>	oh. of course. thanks.
T 1710514432 18<20twkm18>	appeasing a linter seems silly.
T 1710514481 18<29phy172918>	In this case it's helpful for humans too because the reader knows they don't need to keep track of _. i might be used later so has to be kept in your head.
T 1710514531 18<26lopid18>	if you're in a team of people using the same linter and everyone sees the same noise
T 1710515193 18<27faceface18>	hi
T 1710515272 18<27faceface18>	several places in my script I have code like this... echo "STEP 1" |& unbuffer -p tr -d '/r' | tee -a "$log"
T 1710515297 18<27faceface18>	Could you a) slap me about the face, and b) help me work out how to put it into a python function?
T 1710515329 18<27faceface18>	Obvously, other stuff than echo feeds into it (hence the |& bit)
T 1710515358 18<29phy172918>	You just want to translate windows line endings to unix line endings without buffering?
T 1710515390 18<27faceface18>	phy1729: and tee both stderr / stdout to file
T 1710515439 18<27faceface18>	and avoid wriing the same bug-prone code several times in my script...
T 1710515491 18<27faceface18>	crap... I wrote python function.. .obvs I mean bash function!
