T 1709074261 18<27JAA18>	For -f with multiple files IIRC.
T 1709074273 18<28emanuele618>	stdbuf only works for non-statically linked programs that use glibc
T 1709074304 18<28emanuele618>	and only for things that use stdio functions to read/write; not if the program uses something else to print
T 1709074340 18<28emanuele618>	ormaaj: you can use it to change the buffering of bash (for printf/echo)
T 1709074366 18<28emanuele618>	but it generally works on most tools, at least if they are written in C, use stdio, and are not built statically
T 1709074425 18<27JAA18>	That makes sense, yeah.
T 1709074456 18<27larryv18>	clarkk: you can probably augment the awk script to get the same effect as grep -v. as an aside, single quotes would REALLY help you there.
T 1709074575 18<28emanuele618>	# type stdbuf
T 1709074576 18<25shbot18>	emanuele6: bash: type: stdbuf: not found
T 1709074589 18<28emanuele618>	hmm, shbot does not have it
T 1709074593 18<20cappy18>	http://www.pixelbeat.org/programming/stdio_buffering/
T 1709074610 18<28emanuele618>	ormaaj: try   stdbuf -o0 bash -c '{ enable fdflags; fdflags -s+direct 1; printf abcdef;} | while dd status=none count=1; do printf \\n; done' | sed '/f/q'    vs without stdbuf -o0
T 1709074637 18<25ormaaj18>	Oh heh it says gnu tee screws with the buffering itself. Funny I'm usually using tee when I want to change how things buffer
T 1709074661 18<22clarkk18>	actually, I pasted the wrong command, due to all the troubleshooting I've already done. This is it. tee won't work without stdbuf  `ping -DO 8.8.8.8 | stdbuf -oL awk -F "[][]" "/^\[/{print strftime(\"%Y-%m-%d %H:%M:%S\", \$2), \$3; next} 1" | tee -a network-ping.txt`
T 1709074760 18<25ormaaj18>	that sucks. Normally the exact time you want to control is is when you need to split some output into multiple channels, and tee is like pretty much the main way to do that
T 1709074926 18<22clarkk18>	larryv, do you mean like this, using single quotes?  ping -DO 8.8.8.8 | stdbuf -oL awk -F '[][]' '/^\[/{print strftime("%Y-%m-%d %H:%M:%S", $2), $3; next} 1' | tee -a network-ping.txt
T 1709074926 18<25ormaaj18>	:o interesting
T 1709074990 18<22clarkk18>	larryv, if I try to add in the filter, it breaks tee.  ping -DO 8.8.8.8 | stdbuf -oL awk -F '[][]' '/^\[/{if($3 !~ /bytes from /) print strftime("%Y-%m-%d %H:%M:%S", $2), $3; next} 1' | tee -a network-ping.txt
T 1709075096 18<25ormaaj18>	emanuele6: why does the direct pipe matter in that case?
T 1709075260 18<22clarkk18>	emanuele6, sorry, I didn't see your message. That returns bash: line 1: enable: fdflags: not a shell builtin
T 1709075451 18<28emanuele618>	ormaaj: with a direct pipe every write() is boxed in a packet, and every read() only reads one packet. if it were not a direct pipe, write()s would just accumulate in the pipe's buffer, and when a process read()s the pipe, the kernel will just give it as much data from the buffer as it can. so it would not show the difference
T 1709075485 18<28emanuele618>	clarkk: well, it sounds like you don't have fdflags
T 1709075553 18<22clarkk18>	emanuele6, I can't find it in the apt repo, on debian 12
T 1709075601 18<28emanuele618>	it should be the bash-builtins package if you want it
T 1709075626 18<25ormaaj18>	Many distros don't bother to include them or have bash configured to use them by default.
T 1709075636 18<28emanuele618>	another way to see the difference more explicitly without a direct pipe is  strace -qqefd=1 -ewrite stdbuf -o0 bash -c 'printf abc' >/dev/null    vs without  stdbuf -o0
T 1709075745 18<28emanuele618>	with -o0 bash (or any other compatible program) writes one character at the time, with -o10  in chunk of 10 character, with -oL up to a newline (except if the line is too long), etc
T 1709075795 18<28emanuele618>	note that i have noticed some time ago that bash printf is "bugged", and always flushes the buffer after a newline even if the buffering is not -oL, so maybe use  /bin/printf  to see how it is actually supposed to work
T 1709076214 18<25ormaaj18>	Does it have a separate effect on the read and write ends or does setting the flag on either end affect functions on both ends?
T 1709076239 18<28emanuele618>	it affects both ends
T 1709076314 18<28emanuele618>	well, really it does not actually
T 1709076331 18<25ormaaj18>	:O
T 1709076349 18<28emanuele618>	but if you set on the write end, it seems to be enough
T 1709076350 18<25ormaaj18>	!coffee
T 1709076350 18<29greybot18>	c[_]
T 1709076473 18<28emanuele618>	# enable fdflags; (sleep 1; printf x; printf y) | (fdflags -s+direct 0; sleep 2; dd count=1)
T 1709076476 18<25shbot18>	emanuele6: xy0+1 records in
T 1709076476 18<25shbot18>	emanuele6: 0+1 records out
T 1709076476 18<25shbot18>	emanuele6: 2 bytes copied, 0.00692369 s, 0.3 kB/s
T 1709076507 18<28emanuele618>	setting it on the read end does nothing; the only one that matters is the write end i think
T 1709076715 18<28emanuele618>	afaics if you set direct on a write end after there is already some data on the pipe, the pipe does not start behaving like a direct pipe until it gets emptied
T 1709077191 18<28emanuele618>	and if you have a direct pipe already, but you open a second write end to that pipe that does not have O_DIRECT, if you write with the non-direct end first, and then the direct end; the packet contains what was written by the non-direct end followed by what was written by the direct end
T 1709077243 18<28emanuele618>	if you write the other way around, the packet only contains what was written by the direct end, but the next packet will be prefixed by what was written by the non-direct end
T 1709077282 18<28emanuele618>	and if the read end reads while the pipe only contains stuff written by the non-direct end, it still returns and reads the stuff written by the non-direct end
T 1709077329 18<28emanuele618>	so probably O_DIRECT makes write() inject some magic end of packet marker in the pipe, that is why it only matters on the write end
T 1709082580 19*	Now talking on 22#bash
T 1709082580 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709082580 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709082583 18<22pj18>	okay
T 1709082622 18<28emanuele618>	the first substitution command always only expands literal code of your script, so it is always safe as long as you only expand those values before the next substitution
T 1709082692 18<22pj18>	okay, yeah this is completely out of my league, heh.
T 1709082694 18<25ormaaj18>	(where "their arguments" is the entire remainder of the script)
T 1709082766 18<28emanuele618>	like this https://0x0.st/HRj_.txt
T 1709082805 18<28emanuele618>	err,  importas -ui c c   https://0x0.st/HRjL.txt
T 1709082898 18<25ormaaj18>	:O
T 1709083232 18<25ormaaj18>	double multisubstitute cute
T 1709164962 19*	Now talking on 22#bash
T 1709164962 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709164962 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709164978 18<24bxsx18>	It would be very nice if I break the loop on the first occurrence, but I don't it, well, still not that bad..
T 1709165065 18<24bxsx18>	larryv: any real difference between setting the flag to 1 or true?
T 1709165078 18<27larryv18>	why bother with a flag? just use the loop variable
T 1709165086 18<24bxsx18>	ahhhhhh
T 1709165096 18<24bxsx18>	it's not cleared after the loop?
T 1709165114 18<27larryv18>	no
T 1709165115 18<27larryv18>	# shopt -s nullglob; f=; for f in .*; do :; done; declare -p f
T 1709165117 18<25shbot18>	larryv: declare -- f=".mkshrc"
T 1709165123 18<27larryv18>	# shopt -s nullglob; f=; for f in foo*; do :; done; declare -p f
T 1709165124 18<25shbot18>	larryv: declare -- f=""
T 1709165176 18<27larryv18>	it's not cleared before the loop either, which is why you have to do it yourself
T 1709165190 18<27larryv18>	# shopt -s nullglob; f=x; for f in foo*; do :; done; declare -p f
T 1709165191 18<25shbot18>	larryv: declare -- f="x"
T 1709165197 18<24bxsx18>	I see
T 1709165220 18<24bxsx18>	no, the nullglob makes a lot of sense
T 1709165299 18<24bxsx18>	s/no/now
T 1709165368 18<24bxsx18>	larryv: thanks
T 1709165377 18<27larryv18>	np
T 1709165458 18<24bxsx18>	I guess in the final solution it would the [[ -z $f ]] or should I use declare -p for that (I'm assuming you used that only to demo the output now?)
T 1709165496 18<27larryv18>	yeah, that was just for show. you would do something like if [[ -z $f ]]; then echo oh no; exit 1; fi
T 1709165582 20*	Disconnected (20)
T 1709165736 19*	Now talking on 22#bash
T 1709165736 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709165736 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709171987 18<19sphertext18>	i've tested the code for the mac osx -exec bug in the find utility on 10.14 and it's still broken. even tho the wiki claims it's been fixed after 10.8 https://mywiki.wooledge.org/UsingFind#Nasty_OS_X_bug
T 1709172054 18<19sphertext18>	wait no
T 1709172116 18<19sphertext18>	well i tried copy pasting the commands in a script instead of writing them by hands and i got the correct outcome
T 1709172130 18<19sphertext18>	so i made a mistake the first time
T 1709172512 18<19sphertext18>	ok i found the problem. it's unrelated to the mac osx bug
T 1709172945 18<24alguien18>	how do i terminate the pipe (only) as soon as one part fails?
T 1709172981 18<24alguien18>	i can get get the error code of the failing part with `set -o pipefail`, but it still seems to execute the rest of the pipe
T 1709173422 18<22tirnanog18>	that's how they work; they are fully asynchronous in nature. the question is: why is it a problem in your case? a program attempting to read from its end of a closed pipe will encounter EOF, whereas a program attempting to write to its end of a closed pipe will receieve SIGPIPE.
T 1709173428 18<22tirnanog18>	alguien: ^
T 1709173511 18<24alguien18>	hm, maybe it isn't a problem then, thanks
T 1709173571 18<22tirnanog18>	as a silly little example, if you run seq 1 1000000 | head -n1, it will get nowhere near writing one million lines.
T 1709173625 18*	24alguien nods
T 1709173661 18<22tirnanog18>	https://termbin.com/v4d3u
T 1709173746 18<22tirnanog18>	also, try man 7 pipe. if you don't have it: https://www.man7.org/linux/man-pages/man7/pipe.7.html
T 1709173753 18<24alguien18>	Prob was I tested with find nonexistent | echo yes, and I always got yes
T 1709173762 18<24alguien18>	but that's not equivalent to what i'm doing
T 1709173778 18<22tirnanog18>	I don't know what you expected to happen there. echo doesn't read anything.
T 1709173782 18<24alguien18>	my real RHS is read, and it will just not read anything
T 1709173789 18<22tirnanog18>	for example?
T 1709173799 18<22tirnanog18>	this sounds like !faq disappear, honestly.
T 1709173808 18<24alguien18>	!faq disappear
T 1709173808 18<29greybot18>	https://mywiki.wooledge.org/BashFAQ/024 -- I set variables in a loop that's in a pipeline. Why do they disappear after the loop terminates? Or, why can't I pipe data to read?
T 1709173824 18<24alguien18>	nah, that was an earlier topic :)
T 1709173831 18<22tirnanog18>	what then?
T 1709173849 18<22cornfeedhobo18>	can someone suggest a good way to do a non-regex search-and-replace within a file?
T 1709173851 18<24alguien18>	you answered my question
T 1709173877 18<24alguien18>	cornfeedhobo, non-interactive vi
T 1709173896 18<22tirnanog18>	perl is very good at it.
T 1709173898 18<22tirnanog18>	https://mywiki.wooledge.org/BashFAQ/021#Just_Tell_Me_What_To_Do
T 1709173905 18<22cornfeedhobo18>	na, vi is too heavy. i need it to work in build container.
T 1709173911 18<22tirnanog18>	thanks to its quotemeta (\Q) functionality.
T 1709173926 18<22cornfeedhobo18>	perl is also an option that is commonly offered, but also not well suited to portability
T 1709173932 18<22tirnanog18>	awk then.
T 1709173944 18<24alguien18>	ed is posix
T 1709173951 18<22tirnanog18>	actually, it's awkward in awk (ha).
T 1709173953 18<24alguien18>	but i think it's complicated
T 1709173966 18<22cornfeedhobo18>	yeah, awk makes it difficult
T 1709173967 18<22tirnanog18>	"non-regex" was a component of the question.
T 1709173975 18<24alguien18>	sed has a switch i think, but i don' think it's posix
T 1709173980 18<22cornfeedhobo18>	it's really this non-regex that makes it hard
T 1709173997 18<22cornfeedhobo18>	which is surprising somewhat... like why isn't there a common tool or flag for this
T 1709174008 18<22tirnanog18>	well, how about bash then. it won't be as fast, but you can do line=${line//"$literal"/...} easily enough.
T 1709174016 18<22cornfeedhobo18>	but i also haven't had to deal with this before, so there's that :p
T 1709174019 18<19sphertext18>	re: the current question.. i had this idea but idk how to take it from here. the last echo could be substituted with kill, but idk how to choose a process id
T 1709174021 18<19sphertext18>	# set -o pipefail; echo f | grep b  | { ! [[ "$?" -eq 0 ]] && echo b ; }
T 1709174023 18<25shbot18>	sphertext: no output
T 1709174025 18<22tirnanog18>	not actually a literal but treating the content of the var literally there.
T 1709174026 18<24alguien18>	cornfeedhobo, agreed
T 1709174074 18<19sphertext18>	# set -o pipefail; echo "f" | grep b | { ! [[ "$?" -eq 0 ]] && echo g ; }
T 1709174076 18<25shbot18>	sphertext: no output
T 1709174076 18<22cornfeedhobo18>	yeah, i could read in the entire file and do the replace with native bash
T 1709174083 18<19sphertext18>	dunno why it's not working
T 1709174109 18<22tirnanog18>	# printf 'foo baboon bar baboon\n' > input; needle=baboon; while read -r; do REPLY=${REPLY//"$needle"/orangutan}; printf '%s\n' "$REPLY"; done < input > output; cat output
T 1709174111 18<25shbot18>	tirnanog: foo orangutan bar orangutan
T 1709174120 18<19sphertext18>	oh the `set-o pipefail` doesn't register
T 1709174134 18<19sphertext18>	if you run `set -o pipefail` as a separate command, then it will work
T 1709174136 18<22tirnanog18>	follow it up with a conditional mv and there you go.
T 1709174138 18<22cornfeedhobo18>	yeah, that's probably what i'll do, since the files aren't ever going to be that large
T 1709174142 18<22tirnanog18>	right. perfect then.
T 1709174183 18<22cornfeedhobo18>	thanks for the sounding board. I thought I was limited in my options, but needed a sanity check
T 1709174238 18<24alguien18>	cornfeedhobo, surely you're still missing a simple utility that would be able to do that?
T 1709174264 18<24alguien18>	sphertext, what will and what doesn't?
T 1709174284 18<22tirnanog18>	sphertext: it's not clear what you even expect $? to be there. it's a brand new subshell, it will have whatever value the parent shell had before it forked.
T 1709174305 18<22tirnanog18>	# false; true | true | echo "$?"
T 1709174308 18<25shbot18>	tirnanog: 1
T 1709174309 18<19sphertext18>	how do you `set -o` ?
T 1709174315 18<19sphertext18>	in one line
T 1709174321 18<22tirnanog18>	whatever it is you think you're doing there, it probably needs rethinking.
T 1709174330 18<19sphertext18>	i think it works
T 1709174341 18<19sphertext18>	but i don't know how to `set -o pipefail` in the same line
T 1709174350 18<22tirnanog18>	no it doesn't.
T 1709174356 18<22tirnanog18>	see above.
T 1709174356 18<22cornfeedhobo18>	alguien: it sounds like one doesn't exist, other than bash itself. to be fair, i probably should have asked in ##workingset
T 1709174393 18<24alguien18>	have to add that channel to autojoins i always forget its name
T 1709174400 18<19sphertext18>	if you run `set -o pipefail` and then ` false | { ! [[ "$?" -eq 0 ]] && echo failed ; }` you will get the outcome
T 1709174403 18<22tirnanog18>	if you want to know the exit status from a given portion of a pipline, issue the pipeline *first* then use PIPESTATUS.
T 1709174404 18<24alguien18>	i always think it's #posixset
T 1709174410 18<22tirnanog18>	no you bloody won't.
T 1709174423 18<19sphertext18>	why is it printing "failed" then?
T 1709174469 18<22tirnanog18>	# true | false; declare -p PIPESTATUS
T 1709174471 18<25shbot18>	tirnanog: declare -a PIPESTATUS=([0]="0" [1]="1")
T 1709174482 18<22tirnanog18>	that's how you get the status from a particular part of a pipeline.
T 1709174545 18<19sphertext18>	i ran the command `false | { ! [[ "$?" -eq 0 ]] && echo failed ; }` on my machine and it printed `failed`, i can show you the screen shot. but i'm getting unreliable results now, idk why
T 1709174557 18<22tirnanog18>	because you're not listening. that's why.
T 1709174618 18<22tirnanog18>	as I said earlier, the value of $? will initially be whatever it was when the parent shell forked, within all of the subshells implied by the pipeline.
T 1709174644 18<19sphertext18>	so it doesn't get updated by whatever happens in the pipe?
T 1709174646 18<22tirnanog18>	so doing foo | [[ "$?" -eq .. ]] in any capacity is nonsense code. all you're doing is testing the vaue of the _parent's_ copy of $? there.
T 1709174652 18<22tirnanog18>	just don't do this. it's completely wrong.
T 1709174678 18<22tirnanog18>	the value of $? will be meaningful after the pipeline has concluded execution.
T 1709174686 18<22tirnanog18>	that's where pipefail has a clear effect.
T 1709174701 18<22tirnanog18>	but just use PIPESTATUS if you need the exit status of anything but the final component of the pipeline.
T 1709174704 18<19sphertext18>	ok so it just gets inherited from the parent shell and won't be updated until the pipe finishes
T 1709174712 18<22tirnanog18>	it's not even that.
T 1709174727 18<22tirnanog18>	you have to understand that every single portion of a pipeline implies its on subshell.
T 1709174747 18<22tirnanog18>	if you do "foo | bar", there are two subshells. if you do "foo | bar | baz" there are three subshells.
T 1709174756 18<22tirnanog18>	all of them inherit the execution environment of the parent initially.
T 1709174778 18<19sphertext18>	ok i get it
T 1709174778 18<22tirnanog18>	each will manipulate $? in its own right. but each subshell will eventually die and the changes it makes are immaterial.
T 1709174791 18<22tirnanog18>	it is how the parent shell sets $? (and PIPESTATUS) that you care about.
T 1709174808 18<19sphertext18>	so all the subshells of a pipe are spawned by the original parent shell? they're not sub-subshells
T 1709174828 18<22tirnanog18>	yes. I mean, you could make more still.
T 1709174866 18<22tirnanog18>	# echo "parent = $$; left subshell = $BASHPID" >&2 | echo "parent = $$; right subshell = $BASHPID" >&2
T 1709174868 18<25shbot18>	tirnanog: parent = 44; right subshell = 52
T 1709174868 18<25shbot18>	tirnanog: parent = 44; left subshell = 51
T 1709174875 18<22tirnanog18>	those are pid numbers.
T 1709174895 18<26lockywolf18>	sphertext: you can pipe into a subshell
T 1709174955 18<22tirnanog18>	so all you have to ask yourself is "do I need anything other than the exit status of the right-most part of the pipeline". if the answer is no, you don't need pipefail, nor PIPESTATUS. if yes, then they have a use.
T 1709175006 18<22tirnanog18>	(pipefail can also have side effects if over-used or used blithely - it's often perfectly normal to expect for the 'left-most' parts to fail)
T 1709175016 18<22tirnanog18>	feeding something through head is a great example.
T 1709175079 18<22tirnanog18>	as with anything, it depends on the exact use case, though.'
T 1709175096 18<19sphertext18>	so you need to do a check of PIPESTATUS in every element of the pipe if you want to interrupt it whenever one element fails
T 1709175113 18<19sphertext18>	also, how do you interrupt it after the test shows an element has failed?
T 1709175125 18<22tirnanog18>	well, if you genuinely consider any element failing to be an error, pipefail will do that.
T 1709175137 18<19sphertext18>	do you kill the parent shell?
T 1709175140 18<22tirnanog18>	but be careful with it. it's one of those things that may look neat at first, but it's often not appropriate.
T 1709175146 18<19sphertext18>	so that it stops executing the rest of the pipe
T 1709175165 18<22tirnanog18>	PIPESTATUS lets you just examine any of its exit status values and do as you place.
T 1709175222 18<22tirnanog18>	there is no such thing as "stop executing the rest of the pipe". disavoid yourself of this notion immediately. you can expect for programs to terminate sooner than they otherwise might have, perhaps.
T 1709175237 18<22tirnanog18>	consider the seq | head example given earlier: https://termbin.com/v4d3u
T 1709175256 18<22tirnanog18>	you can stop neither seq nor head running there, but seq does finish quite early, owing to the pipe error.
T 1709175264 18<22tirnanog18>	er, disavow, even.
T 1709175277 18<26lockywolf18>	what about   echo test0 | ( set -e ; cat - ; ls /fail ; echo test1   | (cat - ; echo test2 ; ) )
T 1709175293 18<26lockywolf18>	the pipe will terminate after ls /fail
T 1709175299 18<22tirnanog18>	if you think it's important that programs execute strictly sequentially, you shouldn't even be using a pipe.
T 1709175307 18<22tirnanog18>	because pipes are async. always.
T 1709175329 18<22tirnanog18>	but that's what makes them so amazing.
T 1709175419 18<22tirnanog18>	you don't "interrupt". you just exit the subshell in question.
T 1709175438 18<22tirnanog18>	stop reading. close your end of the pipe.
T 1709175438 18<19sphertext18>	`false | { ! [[ ${PIPESTATUS[${#PIPESTATUS[@]}-1]} -eq 0 ]] && killpipe ; }`
T 1709175447 18<19sphertext18>	so this is not possible, nor recommended?
T 1709175448 18<22tirnanog18>	no. this is complete nonsense.
T 1709175461 18<22tirnanog18>	if you don't want to consume any more data, stop reading and exit!
T 1709175485 18<22tirnanog18>	please look at the earlier paste and try to understand what's going on there.
T 1709175496 18<22tirnanog18>	seq gets a broken pipe eventually and that is _fine_
T 1709175503 18<22tirnanog18>	head closed its end of the pipe.
T 1709175521 18<22tirnanog18>	because it exited after reading one line.
T 1709175545 18<22tirnanog18>	also, man 7 pipe (please)
T 1709175609 18<22tirnanog18>	you check PIPESTATUS only when the entire pipeline is don.
T 1709175618 18<22tirnanog18>	if it is needed at all.
T 1709175755 18<22tirnanog18>	at best, a writer may be able to fill up the pipe buffer (16 x page size on Linux, by default - so 64 KiB on x86_64). at that point, if the reading end is closed, it will get a signal. that's what you see happening with seq in the paste. it never gets to actually write 1 million numbers.
T 1709175805 18<22tirnanog18>	which is a good thing, of course. it would be silly if it were allowed to go all the way to the end.
T 1709175828 18<22tirnanog18>	anyway, this is explained in pipe(7).
T 1709176122 18<22tirnanog18>	I should add: there are certain, specific cases in which cleaning up after tasks can be useful. but they should be dealt with as and when they arise. most of the time, there is no need to bring homebrew process management into it (and even then, a simple trap can be a solution).
T 1709178712 18<25ormaaj18>	sphertext: Stupid thing about bash # 3 trillion and one - it forcibly calls wait when the command of the last pipe element completes, and no sooner. Therefore PIPESTATUS is not accessible from that command AND the forced wait will block further execution until all of the subshells are waited on. So it is impossible to access statuses from any command that can read from the pipe. Bash doesn't even
T 1709178712 18<25ormaaj18>	give you their pids.
T 1709178746 18<25ormaaj18>	 $ shopt -s lastpipe; function pp { exec -- getpid -E p print -rf '%-2s %s\n' -u "$2" -- "$1" \$p; }; ${| local -; set +m; { pp 0a 3 | pp 1 4 | printf '%-2s %s\n' 0b "${ jobs -p; }" 3 "$BASHPID"; } 3>&1 4>&1; }
T 1709178746 18<25ormaaj18>	0b 3642770
T 1709178747 18<25ormaaj18>	3  3375217
T 1709178747 18<25ormaaj18>	1  3642771
T 1709178747 18<25ormaaj18>	0a 3642770
T 1709178793 18<25ormaaj18>	you can get the pid of the first element from jobs, but the ones in the middle are inaccessible.
T 1709178806 18<25ormaaj18>	basically pipelines suck.
T 1709179408 18<28emanuele618>	>:(
T 1709179624 18<25ormaaj18>	Almost like it's written by one whose Cranium Has Emptyness Throughout
T 1709180769 18*	25ormaaj is mean D:
T 1709180781 18<28emanuele618>	not by someone with an Outstanding Roasted Mixture Awesome Arabica Jar
T 1709180948 18<29cult18>	Is it possible to use ${@} properly in an alias or does it cause problems? Ideally I want to use something like alias foo='echo "${@:-bar}"' but bar is always printed with or without args
T 1709180972 18<28emanuele618>	aliases just replace text
T 1709180974 18<25ormaaj18>	it can be done
T 1709180992 18<25ormaaj18>	ha wow
T 1709181008 18<28emanuele618>	you could define a function in the alias and call that immediately; that is the usual technique for when you need to accept arguments
T 1709181063 18<28emanuele618>	'f () { something "$@"; echo hi ;}; f'    e.g. in git aliases
T 1709181064 18<29cult18>	Hmm yes I had a function initially but I was wondering why doing it this way results in the weird behaviour. I'd expect just "bar" if no args and a list of args otherwise. But "foo 1 2 3" will print "bar 1 2 3"
T 1709181138 18<28emanuele618>	i don't remember what @:- does in bash; i know it is unspecified in standard sh
T 1709181163 18<28emanuele618>	# a=(1 2 3); set -- "${@:-foo}"; echo -E set -- "${@@Q}"
T 1709181164 18<25shbot18>	emanuele6: set -- 'foo'
T 1709181168 18<28emanuele618>	# a=(); set -- "${@:-foo}"; echo -E set -- "${@@Q}"
T 1709181169 18<25shbot18>	emanuele6: set -- 'foo'
T 1709181184 18<25ormaaj18>	it's lame :(. Takes the overall result and flattens it, and expands the alternate if the resulting string is empty.
T 1709181187 18<28emanuele618>	it just always expands to foo, it ieems
T 1709181192 18<28emanuele618>	oh, oops
T 1709181201 18<28emanuele618>	# set -- 1 2 3; set -- "${@:-foo}"; echo -E set -- "${@@Q}"
T 1709181202 18<25shbot18>	emanuele6: set -- '1' '2' '3'
T 1709181206 18<28emanuele618>	# set --; set -- "${@:-foo}"; echo -E set -- "${@@Q}"
T 1709181207 18<25shbot18>	emanuele6: set -- 'foo'
T 1709181224 18<28emanuele618>	so it expands to 'foo' if there are no arguments; that is what it does
T 1709181240 18<27larryv18>	# set ''; set -- "${@:-foo}"; echo -E set -- "${@@Q}"
T 1709181241 18<25shbot18>	larryv: set -- 'foo'
T 1709181246 18<25ormaaj18>	It's really like [[ $@ ]]
T 1709181251 18<28emanuele618>	oh, it is like  ${!@}
T 1709181280 18<28emanuele618>	if the concatenation of the arguments is empty, it expands to 'foo'
T 1709181285 18<25ormaaj18>	yep
T 1709181300 18<29cult18>	It seems to do that even if there are arguments though, or is that because I'm using it in an alias?
T 1709181303 18<28emanuele618>	# IFS=; set '' a; set -- "${@:-foo}"; echo -E set -- "${@@Q}"
T 1709181305 18<25shbot18>	emanuele6: set -- '' 'a'
T 1709181309 18<28emanuele618>	# IFS=; set '' ''; set -- "${@:-foo}"; echo -E set -- "${@@Q}"
T 1709181311 18<25shbot18>	emanuele6: set -- '' ''
T 1709181319 18<29cult18>	As I said "foo 1 2 3" will output "bar 1 2 3" when I would expect just "1 2 3"
T 1709181329 18<28emanuele618>	and it is @, not *, so it is never empty if there are more than two arguments
T 1709181356 18<25ormaaj18>	Not a very useful behavior IMO
T 1709181410 18<28emanuele618>	cult: that is not what "${@:-foo}" does; if you want to expand something else if there are no arguments, you would use something like    "${1-foo}" "${@:2}"
T 1709181415 18<25ormaaj18>	(it's so unuseful it could probably be changed since nobody uses it, at least not if they know what it actually does)
T 1709181479 18<25ormaaj18>	!ormaajrotate
T 1709181479 18<29greybot18>	# f() { echo "${@:2}"; ${!1+f $(($1+1)) "${!#}" "${@:2:$#-2}"}; }; f 3 {a..c}
T 1709181481 18<25shbot18>	greybot: a b c
T 1709181481 18<25shbot18>	greybot: c a b
T 1709181481 18<25shbot18>	greybot: b c a
T 1709181735 18<28emanuele618>	cult: if you are saying you don't understand why your alias prints   bar 1 2 3    it is because the alias just replaces the text in the command
T 1709181750 18<28emanuele618>	i said it earlier
T 1709181788 18<28emanuele618>	foo 1 2 3    will run    echo "${@:-bar}" 1 2 3   because that is what is in the foo alias
T 1709181828 18<27JAA18>	Aliases are insanely stupid.
T 1709181836 18<28emanuele618>	evidently your shell does not have any non-empty arguments, so it expands bar
T 1709181845 18<28emanuele618>	JAA: no u >:(
T 1709181855 18<27larryv18>	D:
T 1709181863 18<28emanuele618>	# set --; echo "${@:-bar}" 1 2 3
T 1709181864 18<25shbot18>	emanuele6: bar 1 2 3
T 1709181868 18<28emanuele618>	# set -- foo bar; echo "${@:-bar}" 1 2 3
T 1709181870 18<25shbot18>	emanuele6: foo bar 1 2 3
T 1709181876 18<27JAA18>	:-)
T 1709181878 18<28emanuele618>	# set -- zzz yyy; echo "${@:-bar}" 1 2 3
T 1709181879 18<25shbot18>	emanuele6: zzz yyy 1 2 3
T 1709181895 18<28emanuele618>	# set -- zzz yyy; f () { echo "${@:-bar}";}; f 1 2 3
T 1709181896 18<25shbot18>	emanuele6: 1 2 3
T 1709181917 18<27JAA18>	TIL (or rather, realised) what that function trick is about though. Thanks, I hate it.
T 1709181972 18<28emanuele618>	with a function, or an alias that defines a function and calls it, the arguments are 1 2 3, but "${@:-bar}" is still wrong; you want  "${1-bar}" "${@:2}"
T 1709182014 18<28emanuele618>	JAA: if bash embraced eval, and dynamic scoping like tcl, we would have an apply builtin, and we would not need this :D
T 1709182028 18*	27JAA slaps emanuele6 around a bit with a large trout
T 1709182054 18<28emanuele618>	hmm, i thought of a cool use for "${@:-}" earlier
T 1709182078 18<28emanuele618>	it is "$*", but it ignores IFS, and always uses space
T 1709182090 18<28emanuele618>	could be useful in a pinch
T 1709182129 18<27JAA18>	Hmm, yeah
T 1709182194 18<28emanuele618>	ormaaj: now, you can't change this behaviour because we would notice muhahaha
T 1709182206 18<29cult18>	emanuele6: thank you that makes sense now!
T 1709182218 18<27JAA18>	Well, it'd still be multiple values though, not one, unless you remove the quotes.
T 1709182227 18<27JAA18>	If you have args, that is.
T 1709182256 18<28emanuele618>	if you don't have arguments, or have an empty argument "${@:-}" expands to '' which is correct
T 1709182279 18<28emanuele618>	and if you have more than one argument, the delimiter is space, so it is still correct because the result is non-empty
T 1709182298 18<27JAA18>	# set -- 1 2 3; printf '%q ' "${@:-}"
T 1709182300 18<25shbot18>	JAA: 1 2 3
T 1709182310 18<27JAA18>	That's three args, not 1\ 2\ 3.
T 1709182313 18<28emanuele618>	what the heck
T 1709182322 18<28emanuele618>	then what does it do?
T 1709182332 18<28emanuele618>	# set -- 1 2 3; printf '%q ' "${@:+baz}"
T 1709182334 18<25shbot18>	emanuele6: baz
T 1709182334 18<27JAA18>	Same as "$@", no?
T 1709182367 18<28emanuele618>	so it is the same as "$@" if [[ $@ ]] ? wow
T 1709182378 18<28emanuele618>	that does not make any sense
T 1709182412 18<27JAA18>	Seems reasonable enough to me.
T 1709182433 18<27JAA18>	Just like "${@/foo/bar}" expands to multiple words with the replacement.
T 1709182476 18<27JAA18>	It's just a bit whack to combine arrays and a default value.
T 1709182483 18<27JAA18>	Or array-ish, whatever.
T 1709182521 18<28emanuele618>	but it checks $@ as a string and returns multiple values; if ' '.join(args): yield from expand(word) else: yield from args   :/
T 1709182586 18<28emanuele618>	it does not check whether $@ is empty, it checks if the $@ is empty or the arguments concatenated by space are a non-empty string
T 1709182592 18<27JAA18>	Too bad you can't return another array like "${@:-(a b c)}". :-D
T 1709182606 18<28emanuele618>	well, because it is quoted
T 1709182686 18<27JAA18>	# set -- '' ''; printf '%q ' "${@:-}"
T 1709182688 18<25shbot18>	JAA: '' ''
T 1709182700 18<27JAA18>	# set -- ' '; printf '<%q> ' "${@:-}"
T 1709182702 18<25shbot18>	JAA: <\ >
T 1709182712 18<28emanuele618>	hmm, i don't remember if in quoted -WORD context, it is a string expansion or not
T 1709182713 18<27JAA18>	Seems to behave as expected to me.
T 1709182761 18<28emanuele618>	# a=('a b' c d); echo -E set -- "${PWD+${a[@]@Q}}"
T 1709182762 18<25shbot18>	emanuele6: set -- 'a b' 'c' 'd'
T 1709182768 18<28emanuele618>	JAA: you totally can do that
T 1709182782 18<27JAA18>	Hah
T 1709182795 18<27JAA18>	Yeah, makes sense.
T 1709182806 18<28emanuele618>	D:
T 1709182825 18<28emanuele618>	too JAA everything makes sense :o
T 1709182836 18<27JAA18>	lol
T 1709182837 18<28emanuele618>	ooo
T 1709182855 18<28emanuele618>	with a glob you normally have to choose if you want to quote the expansion or the glob
T 1709182905 18<28emanuele618>	because "${PWD-*}"  will quote the glob, so you can only use the glob if you don't quote the expansion ${PWD-*}  which is not very useful except for +
T 1709182933 18<28emanuele618>	but array expansions are special and they expand to multiple words even when the expansion is quoted, so you can do it
T 1709182967 18<27JAA18>	Hmm, right
T 1709183056 18<27JAA18>	"${PWD}"${PWD:-*}
T 1709183077 18<27JAA18>	Er, no, that makes no sense.
T 1709183081 18<28emanuele618>	that expands PWD twice
T 1709183085 18<27JAA18>	Yeah
T 1709183101 18<28emanuele618>	once quoted and the other time not quoted
T 1709183115 18<27JAA18>	Wouldn't it be nice if you could do ${PWD@Q-*}?
T 1709183204 18<28emanuele618>	nah, you can just use   ${|[[ $PWD ]] && REPLY=*;}
T 1709183219 18<27JAA18>	Naturally
T 1709183234 18<28emanuele618>	anyway that and even ${PWD+*}  are not great anyway because they will not work correctly with IFS=*
T 1709183240 18<27JAA18>	I'm not sure yet whether I love or hate those.
T 1709183523 18<28emanuele618>	s/[&][&]/||/
T 1709183644 18<27JAA18>	Does this actually work?
T 1709183648 18<27JAA18>	Does [[ set REPLY?
T 1709183654 18<28emanuele618>	no?
T 1709183670 18<28emanuele618>	the only things that set REPLY are select and read afaik
T 1709183689 18<28emanuele618>	some loadables too, i think, but i don't remember which ones
T 1709183698 18<27JAA18>	Oh, you mean as a replacement of the second part in my silly thing above, right.
T 1709183725 18<27JAA18>	So it'd expand to nothing if PWD is set and to the glob expansion if not.
T 1709183755 18<28emanuele618>	yes, but that, like ${PWD+*} is actually expanded as if it were  x=*; ... $x
T 1709183762 18<28emanuele618>	so if IFS contains * it will not work
T 1709183789 18<28emanuele618>	and there is no workaround except setting IFS to ''
T 1709183828 18<27JAA18>	Hmm
T 1709183907 18<25ormaaj18>	# shopt -s expand_aliases; eval set function f { t } \; set -- '"${@/*/&=& }"' \; alias '"${@:1:3}"' '"u=${*%%=*}"' '"t=echo \"\$@\";"' \; eval u \; f moo
T 1709183909 18<25shbot18>	ormaaj: moo
T 1709184037 18<28emanuele618>	with an apply builtin   (possible implementation   apply () { eval 'shift; '"$1";} ), you could write your gitalias as just   "apply 'something "$@"; somethingelse'"
T 1709184050 18<28emanuele618>	also it would make aliases more nicer to use
T 1709184061 18<28emanuele618>	s/more //
T 1709184100 18<28emanuele618>	aliases can be nicer than functions because they can be bypassed easily with just a \
T 1709184115 18<27JAA18>	That is true, yeah.
T 1709184206 18<28emanuele618>	hmm, i wonder
T 1709184235 18<28emanuele618>	k# alias foo='echo hi'; eval 'function zzz { foo;}'; zzz; declare -f zzz
T 1709184236 18<25shbot18>	emanuele6: hi
T 1709184236 18<25shbot18>	emanuele6: ksh: declare: not found [No such file or directory]
T 1709184242 18<28emanuele618>	k# alias foo='echo hi'; eval 'function zzz { foo;}'; zzz; typeset -f zzz
T 1709184243 18<25shbot18>	emanuele6: hi
T 1709184243 18<25shbot18>	emanuele6: function zzz { foo;}
T 1709184246 18<28emanuele618>	hehe
T 1709184300 18<28emanuele618>	ksh93 showing functiondeclaration+terminator instead of serialised code is a bit lame
T 1709184310 18<28emanuele618>	k# alias foo='echo hi'; eval 'if :; then function zzz { foo;} end'; zzz; typeset -f zzz
T 1709184312 18<25shbot18>	emanuele6: ksh: eval: syntax error: `end' unexpected
T 1709184312 18<25shbot18>	emanuele6: ksh: zzz: not found [No such file or directory]
T 1709184314 18<28emanuele618>	err
T 1709184316 18<25ormaaj18>	yea :(
T 1709184322 18<28emanuele618>	k# alias foo='echo hi'; eval 'if :; then function zzz { foo;} fi'; zzz; typeset -f zzz
T 1709184323 18<25shbot18>	emanuele6: hi
T 1709184323 18<25shbot18>	emanuele6: function zzz { foo;} fi
T 1709184363 18<28emanuele618>	it does not only mean that you get nonsense like fi or esac or ;; or } if the function is defined in a conditional; but it also means that aliases in typeset -f are not expanded
T 1709184387 18<25ormaaj18>	 $ ksh -c 'function f { :; }; typeset -fp f'
T 1709184387 18<25ormaaj18>	function f
T 1709184387 18<25ormaaj18>	{       :
T 1709184387 18<25ormaaj18>	}
T 1709184389 18<28emanuele618>	but bash's declare -f sucks too \:
T 1709184395 18<28emanuele618>	oh, wow
T 1709184401 18<28emanuele618>	k# alias foo='echo hi'; eval 'if :; then function zzz { foo;} fi'; typeset -pf zzz
T 1709184402 18<25shbot18>	emanuele6: function zzz { foo;} fi
T 1709184405 18<28emanuele618>	hmm
T 1709184420 18<28emanuele618>	oh, i thought you were running that on shbot
T 1709184695 18<25ormaaj18>	!meta ormaajrotate
T 1709184695 18<29greybot18>	ormaaj 1366207861(2013-04-17) learn # f() { echo "${@:2}"; ${!1+f $(($1+1)) "${!#}" "${@:2:$#-2}"}; }; f 3 {a..c}
T 1709184710 18<25ormaaj18>	I should get rid of the field splitting :(
T 1709185204 18<28emanuele618>	local - IFS=;set -f
T 1709185228 18<28emanuele618>	err IFS=' ' in this case, and quoting 'f'
T 1709185250 18<28emanuele618>	or "$FUNCNAME" instead of f
T 1709208830 18<29Mo18>	Hi, what is the best way to pipe a big script via ssh ? Currently I have a big string right after  ssh myserver ... with lots of escapes. Can I use a HERE document for that?
T 1709208871 18<28emanuele618>	moo
T 1709208975 18<29Mo18>	for machine in myserver;do ssh $machine "echo \"select \\\* from v\\\$version;\" \\\|sqlplus foo/foo123@foo 2>&1|grep -m2 -e \"^Version\" -e \"^Oracle\"";done
T 1709209000 18<29Mo18>	Just as an example. The complete command is far bigger.
T 1709209088 18<24Nintendo18>	If you have ssh, you also have scp, right?  (If you don't want to use scp, a little ${s@Q} might help with the escape madness.)
T 1709209141 18<28emanuele618>	hmm, is that command correct? that would not expand $version, i doubt it is supposed to be an environment variable on the repote
T 1709209149 18<28emanuele618>	# echo "echo \"select \\\* from v\\\$version;\"
T 1709209155 18<25shbot18>	emanuele6: Missing terminating quote, bracket or keyword
T 1709209156 18<28emanuele618>	# echo "echo \"select \\\* from v\\\$version;\""
T 1709209158 18<25shbot18>	emanuele6: echo "select \\* from v\$version;"
T 1709209177 18<28emanuele618>	it does not expand $version; there are an odd number of \ before $
T 1709209192 18<28emanuele618>	s/repote/remote/
T 1709209217 18<29Mo18>	I would like to have that as multi-line script without the awful escapes.
T 1709209236 18<29Mo18>	HERE doc sounds it could do it?
T 1709209268 18<28emanuele618>	is $version a sql macro or similar?
T 1709209285 18<28selckin18>	yea, pipe that to ssh cat << EOF blbla  | ssh foo
T 1709209296 18<28emanuele618>	anyway, you could use a here document; yes    ssh foo << 'EOF'
T 1709209306 18<28emanuele618>	selckin: em, 'EOF' not EOF
T 1709209329 18<28selckin18>	blalbla is also wrong
T 1709209332 18<28selckin18>	suprise
T 1709209348 18<28emanuele618>	they said they don't want to deal with awful escapes, not introduce awfuler escapes
T 1709209469 18<28emanuele618>	but if you want to expand that $version on the local, and your example was wrong, than you cannot just ssh<<'EOF'
T 1709209544 18<28emanuele618>	you could use two heredocs; one for the bash code, and one for the sql code
T 1709209637 18<28emanuele618>	ssh -- "$machine" bash <<'SH' 3<<SQL    and then in SH you use   </dev/fd/3   instead of echo |
T 1709209779 18<28emanuele618>	or <&3; or use stdin for the sql, and fd3 for the sh so you don't need any redirection  ssh -- "$machine" bash /dev/fd/3 3<<'SH' <<SQL
T 1709210689 18<25fdan18>	 sudo -H -u ec2-user nohup forever_running_process > nohup.out 2>&1 &
T 1709210689 18<25fdan18>	there is a script which we run by doing the above command
T 1709210690 18<25fdan18>	now this creates 2 processes one with sudo and a child process without sudo.
T 1709210690 18<25fdan18>	when we want to kill a process? which PID should we use. i know the way the command is started is not nice.
T 1709211227 18<27wwilliam18>	!echo
T 1709211227 18<29greybot18>	echo outputs a string. echo has many portability problems, and should never be used with option flags. Consider printf instead: printf 'name: %s\n' "$name". https://wiki.bash-hackers.org/commands/builtin/echo | https://cfajohnson.com/shell/cus-faq.html#Q0b | http://www.in-ulm.de/~mascheck/various/echo+printf | https://pubs.opengroup.org/onlinepubs/9699919799/utilities/echo.html
T 1709211744 18<25fdan18>	when we want to kill a process? which PID should we use. i know the way the command is started is not nice.
T 1709211865 18<27colo18>	eh? the PID of the process is unique...
T 1709211882 18<25fdan18>	[18:14:49] <fdan>  sudo -H -u ec2-user nohup forever_running_process > nohup.out 2>&1 &
T 1709211883 18<25fdan18>	[18:14:49] <fdan> there is a script which we run by doing the above command
T 1709211883 18<25fdan18>	[18:14:49] <fdan> now this creates 2 processes one with sudo and a child process without sudo.
T 1709211884 18<25fdan18>	[18:14:49] <fdan> when we want to kill a process? which PID should we use. i know the way the command is started is not nice.
T 1709211928 18<27colo18>	ah. I would kill the child process below sudo.
T 1709211949 18<25fdan18>	why not the sudo process?
T 1709212081 18<25fdan18>	geirha can you help me here
T 1709212098 18<27Soliton18>	you can kill the sudo process as well. you didn't really say what the goal is.
T 1709212133 18<25fdan18>	we are trying to run a process as a ec2-user
T 1709212168 18<25fdan18>	this creates 2 processes
T 1709212223 18<27Soliton18>	you're asking about kill.
T 1709212377 18<27colo18>	fdan: so you use sudo as root to switch to another user?
T 1709212425 18<25fdan18>	yes
T 1709212447 18<27colo18>	you are better off using `setpriv` for that
T 1709212454 18<27colo18>	(on Linux, at least)
T 1709212532 20*	Disconnected (20)
T 1709212551 19*	Now talking on 22#bash
T 1709212551 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709212551 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709212577 18<28emanuele618>	D:
T 1709212591 18<24geirha18>	something something systemd
T 1709213224 18<25fdan18>	if i start a process like this - sudo -H -u ec2-user nohup forever_running_process > nohup.out 2>&1 &
T 1709213225 18<25fdan18>	which process should i kill? the parent or the child process
T 1709213540 18<27colo18>	I would kill forever_running_process
T 1709213542 18<27Soliton18>	presumably you want to kill forever_running_process so the child.
T 1709213993 19*	Now talking on 22#bash
T 1709213993 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709213993 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709214149 18<25fdan18>	Soliton why not the parent process?
T 1709214162 18<25fdan18>	since we start with the Sudo, i think killing the parent would be much better right?
T 1709214320 18<25fdan18>	if we kill the parent process, will it not kill the child process too?
T 1709214502 18<27colo18>	the parent sudo will also terminate once the child exits. if you kill sudo, it will forwardthe signal to its children, and you have the ~ same effect.
T 1709214887 18<25fdan18>	we are observing an issue where the parent(sudo) process gets killed but the child process doesnt get killed or takes more time
T 1709215025 18<27colo18>	well, why do you not just kill the child process then? :)
T 1709215050 18<27JanC18>	nohup is sudo's child process...
T 1709215088 18<27colo18>	I mean the process that all this ill-fated attempt at managing a service is eventually all about
T 1709215136 18<27JanC18>	if that was an attempt at managing a service, then why use nohup?  that only makes it harder...
T 1709215222 18<27colo18>	I never implied that it was a particularly good attempt ;)
T 1709215333 18<27JanC18>	I wasn't telling that you particularly, it's fdan who should probably go read some documentation about what nohup does
T 1709215958 18<25fdan18>	Janc we wanted to have the logs
T 1709215994 18<27JanC18>	nohup has nothing to do with logs
T 1709216088 18<25fdan18>	we are running the process in background
T 1709216094 18<25fdan18>	we store the logs in nohup.out
T 1709216163 19*	Now talking on 22#bash
T 1709216163 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709216163 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709216256 18<27colo18>	have you considered to use systemd-run instead of nohup?
T 1709216385 18<27JanC18>	or just configure a service that you can start whenever you want to, especially if you need it more than once
T 1709216798 18<25fdan18>	colo not yet, since its a small service, we didnt plan
T 1709216819 18<25fdan18>	colo do we get the logs using systemd?
T 1709217927 18<27colo18>	fdan: yes, all streams of the child process are preserved in the resulting unit's journal
T 1709218625 18<26volga62918>	Hello Everyone, how to incorporate. index  with in for loop https://paste.centos.org/view/e32f5ddc
T 1709218775 18<26volga62918>	 opt_array is find out if domain already present in db
T 1709219761 18<27Soliton18>	just use the index? not sure what the issue is.
T 1709219854 18<27Soliton18>	weird code anyway so hard to tell what the goal is.
T 1709220346 18<26volga62918>	Index is domain group ID, logic is simple if domain not found in db, I am adding new entry with group ID ( index ). Issue that can't increment group ID in for loop I tried group_id=$(($idx+1)), but that only ones and not for each domain from the list
T 1709220429 18<27Soliton18>	i didn't understand much.
T 1709220465 18<27Soliton18>	# declare -A opt; while IFS=, read -r c; do opt+=([${c%%,*}]=${c#*,}); done <<< $'0,a\n1,b\n2,c'; idx=1 end=${#opt[@]}; for ((i=$idx; i<=$end; i++)); do printf "Key %s Value %s\n" "$i" "${opt[$i]}"; done
T 1709220466 18<25shbot18>	Soliton: Key 1 Value b
T 1709220466 18<25shbot18>	Soliton: Key 2 Value c
T 1709220466 18<25shbot18>	Soliton: Key 3 Value
T 1709220509 18<27Soliton18>	it's weird to set IFS and then not use it.
T 1709220536 18<27Soliton18>	the end check should be < not <=.
T 1709220577 18<26volga62918>	ok let me test
T 1709220621 18<27Soliton18>	no idea what the relationship between db and the file is or what any of the data looks like anyway.
T 1709221528 18<26volga62918>	file contain list domain,ip address which need to insert. DB contain domain,ip,attrs columns. I am pulling last entry as start index, end index is array count.
T 1709222230 18<27Soliton18>	so the index is not a number?
T 1709222284 18<27Soliton18>	this is still confusing. show an actual issue with actual data.
T 1709222310 18<26volga62918>	index is number attr column in db
T 1709222346 18<27Soliton18>	but domain is surely not a number?
T 1709222357 18<26volga62918>	yes
T 1709222360 18<26volga62918>	domain.com
T 1709222368 18<26volga62918>	as example
T 1709222369 18<27Soliton18>	so i have no idea what you're trying to do.
T 1709222433 18<27Soliton18>	declare -A is an assoc array and apparently the keys are domain names. what do you expect to do with some index number?
T 1709222440 18<29djph18>	Soliton: it's okay, neither do they!
T 1709222507 18<27Soliton18>	if your index corresponds to some line in that file then remove the assoc array and look at that line.
T 1709222539 18<26volga62918>	index is attr column in db where in script it should  increment by one  to get next attr number
T 1709222569 18<27Soliton18>	i have no idea what an attr number is.
T 1709222590 18<26volga62918>	right now last entry is 15 in db
T 1709222596 18<26volga62918>	that attr
T 1709222621 18<26volga62918>	I am pulling that number as start index
T 1709222627 18<27Soliton18>	and what does that have to do with the file?
T 1709222751 18<26volga62918>	file contain list domains to insert into db, when script located list of domains which not present in db, PSQL do insert (domain,ip,attr) value  ($domain,$ip,$i);
T 1709222803 18<26volga62918>	$i is number index incremented by one from start index
T 1709222861 18<27Soliton18>	so you just want to increment the index you got from the DB?
T 1709222870 18<26volga62918>	yes
T 1709222875 18<26volga62918>	inside the loop
T 1709222883 18<26volga62918>	to get next number
T 1709222889 18<27Soliton18>	idx=$((idx+1))
T 1709222948 18<26volga62918>	Yes, I tried that, it increment only first run through domain array
T 1709222956 18<26volga62918>	Let me try again
T 1709222977 18<27Soliton18>	so some code you didn't show does something you don't expect.
T 1709223046 18<24ano18>	# echo MOVIE - TXT FILES STARTED WITH \"MOVIE\" AREN\'T TXT FILES > f.txt; file -i f.txt
T 1709223047 18<25shbot18>	ano: f.txt: video/x-sgi-movie; charset=us-ascii
T 1709223880 18<26volga62918>	Soliton thank you for all help, script is working here the whole think https://paste.centos.org/view/77f831c9
T 1709224027 18<27Soliton18>	still weird why you set IFS. it does nothing.
T 1709224051 18<27Soliton18>	i would remove the array since it seems useless.
T 1709224081 18<27Soliton18>	i assume you're aware that you're doing sql injection and know it is safe.
T 1709224310 18<26volga62918>	yes
T 1709224328 18<26volga62918>	localhost only and by me only
T 1709224382 18<26volga62918>	yes I just set so it in this case IFS is not splitting
T 1709224397 18<26volga62918>	I will remove it
T 1709224412 18<26volga62918>	that because I tried -a array to test
T 1709224480 18<27Soliton18>	no real point in an array that you use a single time.
T 1709224498 18<27Soliton18>	just wasting time writing to and reading from the array.
T 1709224509 18<26volga62918>	correct
T 1709224636 18<27Soliton18>	btw, the way to make sure that sql injection is safe is thinking about what the data that you inject can be. it has nothing to do with your user or localhost.
T 1709225753 18<25kurahaupo18>	!pipe
T 1709225753 18<29greybot18>	(Anonymous) pipes use the | character to connect the standard output of one command to the standard input of another. Each command is executed in a subshell (but see !subshell, !lastpipe, !faq 24).
T 1709225775 18<25kurahaupo18>	!notapipe
T 1709225931 18<25kurahaupo18>	!learn notapipe "Pipe" is not a catch-all term for feeding a file into a program. On the contrary, it specifically means connecting the output of one program as the input of another program, both of which run concurrently. The word you're probably looking for is "redirect".
T 1709225931 18<29greybot18>	OK, kurahaupo
T 1709225947 18<25kurahaupo18>	!notapipe
T 1709225947 18<29greybot18>	"Pipe" is not a catch-all term for feeding a file into a program. On the contrary, it specifically means connecting the output of one program as the input of another program, both of which run concurrently. The word you're probably looking for is "redirect".
T 1709226066 18<25Inline18>	 pipe it but instead of letting the sdinput catch it redirect it
T 1709226072 18<25Inline18>	|> file
T 1709226095 18<25Inline18>	hmmm
T 1709227654 18<25kurahaupo18>	Inline: So what do you think is in "file"  after you go: echo foxfog |>file tr fgox ienl
T 1709227755 18<25kurahaupo18>	# echo foxfog |>file tr fgox ienl ; cat file
T 1709227757 18<25shbot18>	kurahaupo: inline
T 1709230358 18<25ormaaj18>	:o   10:46:05  <-- │ pgas (~pgas@user/pgas) has quit (Ping timeout: 250 seconds)
T 1709235320 18<19Guest145718>	hello, i'm new here
T 1709235335 18<19Guest145718>	is this the right place to ask for help and support for the bash terminal?
T 1709235405 18<25ormaaj18>	oh let's just say yes
T 1709235408 18<27Soliton18>	!bashis
T 1709235408 18<29greybot18>	Bash is a shell. That's a program which can do simple math, logic, I/O and run other programs. It's NOT a terminal, it's not a kernel, it doesn't manage the system's authentication or environment, it's not your OS and it's not X, KDE or Gnome.
T 1709235490 18<25ormaaj18>	bash manages my system's authentication and environment tho.
T 1709235571 18<25ormaaj18>	mh nevermind.
T 1709235882 18<19Guest145718>	greybot, oh ok, my bad, it's a shell
T 1709235888 18<19Guest145718>	run on a TERMINAL ENUMLATOR
T 1709235901 18<19Guest145718>	your right, i just need to get my terms correct
T 1709235925 18<19Guest145718>	but is this the correct place to ask for help regarding the bash shell?
T 1709235933 18<27Soliton18>	yes
T 1709235959 18<22Riviera18>	many people here use bash,
T 1709235976 18<22Riviera18>	so perhaps, yes,
T 1709235984 18<22Riviera18>	somebody might be able to help
T 1709236075 18<19Guest145718>	cool
T 1709236086 18<19Guest145718>	thank you, when i need help with the bash shell i will definately ask here
T 1709236145 18<19Guest145718>	i wanted to learn irc and come here to ask questions regarding the bash shell because i was told that i was less likely to run into "skiddies" on irc then discord, matrix, reddit, stackexchange, xmpp, and bash forums seem to be dead :(
T 1709236363 22*	26ChanServ gives channel operator status to 18llua
T 1709236369 22*	26llua removes ban on 18*!~Artfaith@user/voxel
T 1709236374 22*	26llua removes channel operator status from 18llua
T 1709254781 19*	Now talking on 22#bash
T 1709254781 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709254781 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709257045 18<22phogg18>	yargs? like this? https://www.npmjs.com/package/yargs
T 1709257227 18<28emanuele618>	zargs
T 1709257319 18<27larryv18>	zargs! https://zsh.sourceforge.io/Doc/Release/User-Contributions.html#index-zargs
T 1709259181 18<25xmoforf18>	is there a way to do this in more pure bash: find /path/to/files -type f -name "*.txt" | your_program
T 1709259210 18<28llua18>	why
T 1709259253 18<25xmoforf18>	seems better if i can avoid usinf find
T 1709259260 18<22tirnanog18>	it isn't.
T 1709259263 18<28llua18>	find is going to be faster than bash
T 1709259284 18<28emanuele618>	vroom
T 1709259288 18<22tirnanog18>	it can be done but it will be cumbersome and slow.
T 1709259392 18<26yitz18>	starglob! globstar?
T 1709259393 18<22tirnanog18>	the results of pathname expansion undergo collation, and that can really end up hurting for globstar.
T 1709259408 18<20twkm18>	plus it might exceed ARG_MAX.
T 1709259611 18<22tirnanog18>	for argument's sake: { shopt -s globstar; for f in **/*; do test -f "$f" && printf '%s\n' "$f"; done; } | your_program. it is much worse than find and not equivalent, in fact. dotglob would make it equivalent, except that bash will still sort (very slowly) and find will not.
T 1709259679 18<22tirnanog18>	rather, more like: [[ -f $f && $f == *.txt ]]
T 1709259682 18<22tirnanog18>	just use find, seriously.
T 1709259749 18<22tirnanog18>	what you have there is not even a non-standard usage of find.
T 1709259840 18<25xmoforf18>	great thank you
T 1709259849 18<25xmoforf18>	i will use find
T 1709259925 18<22tirnanog18>	even if you had wanted to sort, bash would still be the worst tool for doing so. I cannot over-emphasise how bad globstar performance is.
T 1709259953 18<22tirnanog18>	you might not notice if treading relatively few pathnames but find blows it out of the water at even moderate scale.
T 1709260359 18<20twkm18>	plus lack of newline safety.
T 1709260403 18<22tirnanog18>	heh. I was just thinking of that while finishing the washing up.
T 1709261410 18<27JAA18>	# echo {a..b}{a..b}
T 1709261411 18<25shbot18>	JAA: aa ab ba bb
T 1709261459 18<27JAA18>	Any neat tricks to revert the order of the iteration, i.e. get 'aa ba ab bb' in this case?
T 1709261622 18<28emanuele618>	yes
T 1709261624 18<28emanuele618>	# eval echo '{a..b}'{a..b}
T 1709261625 18<25shbot18>	emanuele6: aa ba ab bb
T 1709261787 18<27JAA18>	Heh, what could possibly go wrong? :-)
T 1709261884 18<27JAA18>	# echo {b..a}{b..a} | rev
T 1709261885 18<25shbot18>	JAA: bb ab ba aa
T 1709261886 18<27JAA18>	But meh
T 1709261894 18<27JAA18>	Ah yes
T 1709261895 18<27JAA18>	:-)
T 1709264041 18<25ormaaj18>	Invert your expectation about being able to do x with y surprise disappointment becomes a thing of the past. Can I do x? Lol no. With y? Ha!
T 1709264440 18*	25ormaaj looking for awesome arabica jar.
T 1709268522 18<28emanuele618>	can i do z?
T 1709268996 18<28emanuele618>	with w?
T 1709269622 18<27JAA18>	:-)
T 1709269802 18<26sphertext_18>	anyone knows if possible to use the macos CMD key in keybindings for terminal programs? for example I'd like to use CMD+` to move to the next gnu screen window. but I don't know how to definite it in the `keybinding` command
T 1709269877 18<26sphertext_18>	it's not clear what exactly bash registers when i use CMD as a modifier key
T 1709269996 18<27larryv18>	sphertext_: no, you cannot do this.
T 1709270044 18<26sphertext_18>	annoying. do ppl on windows keyboard have the same problem with their WIN key?
T 1709270062 18<27larryv18>	it's not about the keyboard, it's about the terminal emulator
T 1709270257 18<26sphertext_18>	yeah, i know the terminal emulator sends the keys to the programs, and it can also translate them to something else
T 1709270260 18<20twkm18>	your terminal might be able to send ^An when cmd+` is pressed.
T 1709270285 18<26sphertext_18>	but does CMD have a direct correspondent, like all other keys?
T 1709270297 18<20twkm18>	(or whatever your escape is set to)
T 1709270300 18<27larryv18>	Apple Terminal does not provide a means to use Command to send sequences
T 1709270302 18<20twkm18>	nope.
T 1709270389 18<26sphertext_18>	so what's the canonical key set? alpha numerical etc, alt, and an escape (usually ctrl)?
T 1709270390 18<20twkm18>	modifiers make sense to graphical programs like the terminal emulator, but not to bash.  bash typically will receive a sequence of characters, e.g., \e` rather than a single compound character.
T 1709270441 18<26sphertext_18>	hmmm
T 1709270491 18<26sphertext_18>	so i need to configure my emulator to send a sequence of characters when I press cmd+` and then use that sequence in the keybind command
T 1709270560 18<26sphertext_18>	but gnu screen allows `keybind C-k ...`, so it does allow describing the modifier
T 1709270564 18<27larryv18>	i'm like 90% sure that Apple Terminal does not support doing this, and i'm only hedging because i'm not on the latest macOS. i'm not sure how many times i have to repeat myself
T 1709270607 18<26sphertext_18>	i'm not even using apple terminal. i'm using iterm2
T 1709270624 18<27larryv18>	that would have been helpful to know from the beginning.
T 1709270660 18<27larryv18>	the point stands. whatever iTerm2 lets you do, you can do.
T 1709270669 18<26sphertext_18>	 i'm trying to understand how bash programs interface with emulators
T 1709270674 18<20twkm18>	bash doesn't change your window, screen does.  send it your escape character (default is ^A) followed by n (or space or ^N) to switch to the next window.
T 1709270765 18<22tirnanog18>	alacritty can do this.
T 1709270769 18<27larryv18>	sphertext_: this suggests that iTerm2 lets you define key mappings using Command https://iterm2.com/documentation-preferences-profiles-keys.html
T 1709270784 18<22tirnanog18>	and yes, Terminal.app almost certainly won't let you do this.
T 1709270815 18<27larryv18>	you want one of the "Send [whatever]" actions, depending on what sequence you decide to go with
T 1709270824 18<26sphertext_18>	how come in `keybinding C-n` we can specify the ctrl modifier, but not the cmd modifier?
T 1709270841 18<22tirnanog18>	because it's not based like alacritty, possibly.
T 1709270867 18<26sphertext_18>	that's a screen command
T 1709270894 18<22tirnanog18>	oh. derp. anyway, it's too removed to even know what a Cmd key is.
T 1709270901 18<27larryv18>	that's not really referring a key combination per se. it's a character
T 1709270918 18<27larryv18>	*referring to
T 1709270923 18<20twkm18>	^N means a single byte value, \x1e.  which is what pressing control+n also produces.
T 1709270960 18<26sphertext_18>	"Screen does not understand the prefix C- to mean control, although this notation is used in this manual for readability. Please use thecaret notation (^A instead of C-a) as arguments"
T 1709270967 18<20twkm18>	iterm2 likely doesn't know screen is running so whatever you map will be sent to whatever is running.
T 1709271087 18<20twkm18>	duh, not 1e, 0e.
T 1709271171 18<26sphertext_18>	why control+n produces a single byte value, but not cmd+`?
T 1709271181 18<26sphertext_18>	is it a convention?
T 1709271208 18<20twkm18>	cmd didn't exist when control characters came about.
T 1709271257 18<26sphertext_18>	control characters = byte values that are not uhmm.. for human-readable text?
T 1709271293 18<20twkm18>	they were to control devices, originally and still some these days.
T 1709271325 18<20twkm18>	and to control communications, which is almost totally gone these days.
T 1709271342 18<27larryv18>	https://en.wikipedia.org/wiki/ASCII#Control_characters
T 1709271591 18<26sphertext_18>	so i can configure my terminal emulator to send \x0e when i press cmd+` and then i would be able to bind it as C-n in the screen configuration file?
T 1709271636 18<26sphertext_18>	where is the association between C+[something] and the control byte values that screen recognises?
T 1709271654 18<22tirnanog18>	or just configure it to send \x01n so it happens directly.
T 1709271680 18<26sphertext_18>	why doesn't screen just use the byte value, instead of the intermediary C+[something] notation?
T 1709271681 18<20twkm18>	provided your escape is the default ^A (aka \x01).
T 1709271704 18<20twkm18>	because you type n's a lot but you don't want to switch windows as a result.
T 1709271762 18<26sphertext_18>	i mean why is the command `keybind C-n next` instead of `keybind \x0e next`?
T 1709271803 18<20twkm18>	50 years ago a hex notation was much less common.
T 1709271817 18<27larryv18>	arguably C-n is easier to understand. also bind accepts an octal representation
T 1709271842 18<20twkm18>	and 50 years ago octal was quite common.
T 1709271917 18<26sphertext_18>	"ASCII reserves the first 32 code points (numbers 0–31 decimal) and the last one (number 127 decimal) for control characters. "
T 1709271934 18<26sphertext_18>	this means not all C+[key] on the keyboard result in a control character?
T 1709271945 18<20twkm18>	correct.
T 1709271962 18<26sphertext_18>	how do i know which ones send a control byte value?
T 1709271970 18<26sphertext_18>	or what the byte is
T 1709272152 18<26sphertext_18>	are control sequences and extension of the control characters? they seem to be different things
T 1709272157 18<20twkm18>	the keymap defines which send what, but generally the ascii value of the letter pressed & 0x1f is the resulting control value.
T 1709272250 18<20twkm18>	symbols too but typically specific ones, e.g., control+[ produces 0x1b but control+{ likely doesn't produce anything.
T 1709272321 18<26sphertext_18>	there should be like a terminal command where you can press control+[something] and it displays the byte value registered
T 1709272324 18<22tirnanog18>	also, cat -v helps. lnext can also help to obtain the raw value (issue C-v first and see stty -a also).
T 1709272381 18<26sphertext_18>	what is lnext?
T 1709272399 18<25hleneto18>	on X, xev can tell you something.
T 1709272474 18<22tirnanog18>	you can also do this in bash: printf '0x%02x\n' "'^A" # do not enter ^A literally there, press C-a instead
T 1709272539 18<22tirnanog18>	lnext is useful if you want to enter something like C-c, which would otherwise be handled specially by the tty (again, see stty -a).
T 1709272589 18<26sphertext_18>	but is it a terminal command? i don't have this program
T 1709272616 18<22tirnanog18>	what program?
T 1709272619 18<26sphertext_18>	lnext
T 1709272624 18<22tirnanog18>	please see stty -a
T 1709272629 18<22tirnanog18>	(for the third time)
T 1709272645 18<22tirnanog18>	"lnext = ^V"
T 1709272651 18<20twkm18>	the character to type so that the next character typed is taken literally not as a control.
T 1709272654 18<22tirnanog18>	so, try C-v, then C-c, for example.
T 1709272706 18<26sphertext_18>	so those cchars in stty -a are hijacked by bash
T 1709272719 18<22tirnanog18>	it will bypass the normal handling of C-c (to send SIGINT to the foregrand process group) and you'll get the actual raw value instead.
T 1709272724 18<26sphertext_18>	i suppose they can't be used directly for binding in another program, unless you issue lnext first?
T 1709272728 18<22tirnanog18>	it has nothing to do with bash.
T 1709272750 18<22tirnanog18>	you should avoid anything shown by stty -a, yes.
T 1709272821 18<26sphertext_18>	so i can use your printf command to discover the byte value of any control+[something] (if such a byte value is sent). but make sure to issue lnext (^V) beforehand
T 1709272857 18<22tirnanog18>	you don't always need lnext, but it's handy when you do.
T 1709272882 18<26sphertext_18>	and then i can configure my emulator to send the byte value that I want for any other key press, including ones using the CMD modifier
T 1709272893 18<22tirnanog18>	yes.
T 1709272893 18<26sphertext_18>	that way i can emulate pressing control
T 1709272951 18<26sphertext_18>	so the default byte values sent by control+[something] are some kind of convention, that both my emulator and e.g screen abide by?
T 1709272976 18<26sphertext_18>	because I imagine I could also configure my emulator to issue a non-standard byte value when I press control+[something]
T 1709273003 18<22tirnanog18>	if it's sufficiently flexible, yes.
T 1709273014 18<22tirnanog18>	I think ever Terminal.app can cover that particular case.
T 1709273022 18<22tirnanog18>	(it can't handle Cmd though)
T 1709273087 18<22tirnanog18>	I can only speak for alacritty, where this works: keybindings = [ { key = "=", mods = "Command", chars = "\u0001n" } ]
T 1709273100 18<27larryv18>	could even send more than one byte.
T 1709273102 18<22tirnanog18>	having to use the \u notation is a TOML format thing.
T 1709273152 18<22tirnanog18>	that's C-a followed by n, then.
T 1709273178 18<20twkm18>	which is screen default for next window.
T 1709273506 18<22tirnanog18>	by the way, lnext means literal next and I believe it only works with the standard line discipline. brief overview here: https://en.wikipedia.org/wiki/Line_discipline. be sure to check out the first referenced link also.
T 1709273518 18<22tirnanog18>	basically, this is tty stuff.
T 1709273586 18<22tirnanog18>	(first referenced from that same wikipedia article I mean)
T 1709274015 18<26sphertext_18>	looks pretty esoteric
T 1709274356 18<22tirnanog18>	if you run cat, you can actually get a better idea of how that discipline works, without the line editing capabilities of your shell getting in the way.
T 1709274388 18<22tirnanog18>	for example, issuing ^R (C-r) does, indeed, reprint the input line, as indicated by stty -a.
T 1709274471 18<22tirnanog18>	and ^T will, indeed, give you a status readout.
T 1709274648 18<26sphertext_18>	i just wish there was a table which showed the conventional association between control+[something] and its byte value (if there is one)
T 1709274665 18<26sphertext_18>	without having to press each one of them individually to find out
T 1709274690 18<20osse18>	sphertext_: man ascii
T 1709274692 18<26sphertext_18>	I'm also trying to figure out how "control sequences" relates to all this
T 1709274695 18<20osse18>	Ctrl-X is always X - 64
T 1709274716 18<27larryv18>	or: https://en.wikipedia.org/wiki/ASCII#Control_code_chart
T 1709274806 18<26sphertext_18>	oh nice
T 1709278705 18<26sphertext_18>	"A control character is a character that, in isolation, has some control function, such as carriage return (CR). Escape sequences, by contrast, consist of one or more escape characters which change the interpretation of subsequent characters. "
T 1709278994 18<26sphertext_18>	more on control character vs. escape sequence https://en.wikipedia.org/wiki/Escape_character#Control_character
T 1709279364 18<20osse18>	this jives witrh my understanding of the concept
T 1709279425 18<26sphertext_18>	so by convention, when you press control+J, a terminal emulator will send the _control character_ for line feed (which is a byte value). separately, there is also the _escape sequence_ `\n`, which resolves to the same _control character_ for line feed.
T 1709279450 18<25ormaaj18>	I don't know what a control function is
T 1709279492 18<20osse18>	could have said "has some function" I suppose
T 1709279501 18<25ormaaj18>	carriage return does absolutely nothing in a shell script. It's an ordinary character like any other.
T 1709279539 18<26sphertext_18>	ormaaj ?
T 1709279544 18<26sphertext_18>	are you replying to someone else or
T 1709279602 18<25ormaaj18>	The quoted text. That's really true in most languages. CR normally has no function.
T 1709279704 18<25ormaaj18>	the only place it may have some context-specific meaning is in languages whose parsers interpret CRLF as a substitute for LF.
T 1709279740 18<26sphertext_18>	oh the quote is just from wikipedia
T 1709279745 18<25ormaaj18>	yes
T 1709279843 18<26sphertext_18>	don't most languages interpret <CR> as line feed?
T 1709279854 18<25ormaaj18>	no
T 1709280010 18<27JAA18>	Ancient Mac OS stuff would, I suppose.
T 1709280075 18<26sphertext_18>	I don't understand, doesn't pressing <CR> when editing a text file insert the byte value for line feed?
T 1709280079 18<27JAA18>	Don't know when they made the switch exactly, but it was a long time ago.
T 1709280089 18<20osse18>	going from os9 to x
T 1709280116 18<27JAA18>	Ah yeah, so 20-ish years ago. Sounds about right.
T 1709280122 18<28emanuele618>	to type a carriage return, you use ^V^M
T 1709280128 18<28emanuele618>	$ ^M
T 1709280130 18<28emanuele618>	bash: $'\r': command not found
T 1709280153 18<28emanuele618>	i had to press enter after ^V^M to run that
T 1709280174 18<27JAA18>	'When editing a text file' implies an editor is involved, which might indeed do such a transformation.
T 1709280182 18<26sphertext_18>	when you press Enter, what do you input exactly?
T 1709280226 18<28emanuele618>	or a line editor like readline :D but really it is handled by the terminal, so ^V^M will work even when you just run cat with the terminal as stdin
T 1709280315 18<28emanuele618>	$ HISTFILE=/dev/null strace -qqqqefd=0 -eread bash --norc --noprofile
T 1709280315 18<26sphertext_18>	in vim, when you want to create a key mapping that involves pressing the enter key, you write it as <cr>
T 1709280317 18<28emanuele618>	bash-5.2$ read(0, "\r", 1)                        = 1
T 1709280343 18<26sphertext_18>	and i've never used a text editor in which pressing the Enter key didn't move to the next line
T 1709280347 18<22pj18>	sphertext_: Enter is a control key, corresponding to ^M, but can be independently trapped by most computer languages.  What it actually does varies depending on which program you're using and it's settings.
T 1709280355 18<28emanuele618>	bash-5.2$ read(0, "\26", 1)                       = 1
T 1709280357 18<28emanuele618>	read(0, "\r", 1)                        = 1
T 1709280359 18<28emanuele618>	that is ^V^M
T 1709280393 18<28emanuele618>	that is only happening because bash is running the terminal in raw mode; so it interprets ^V^M itself
T 1709280394 18<25ormaaj18>	I don't think characters interpreted by the tty driver can be considered within the scope of the language. The shell parser never sees it
T 1709280405 18<28emanuele618>	and Return/Enter actually sends \r in this mode
T 1709280420 18<28emanuele618>	but if you try with cat in standard cooked mode, you will see that enter/return
T 1709280426 18<26sphertext_18>	are there non-graphical ASCII characters which are  not control characters?
T 1709280426 18<28emanuele618>	will send \n
T 1709280435 18<28emanuele618>	$ strace -qqqqefd=0 -eread cat
T 1709280437 18<28emanuele618>	read(0,
T 1709280439 18<28emanuele618>	"\n", 131072)                   = 1
T 1709280444 18<28emanuele618>	and ^V^M or ^V<enter> sends "\r"
T 1709280452 18<28emanuele618>	read(0, ^M"\r", 131072)                   = 1
T 1709280470 18<28emanuele618>	i had to press ^D to flush the terminal, you can also press enter, but then cat reads \r\n
T 1709280483 18<25ormaaj18>	sure that makes sense
T 1709280539 18<28emanuele618>	i mean, what does not make sense? in #bash, everything always makes sense B)
T 1709280682 18<25ormaaj18>	read corrupting data randomly for non-C encodings when IFS is empty.
T 1709280705 18<28emanuele618>	makes sense
T 1709280713 18<25ormaaj18>	nonsense
T 1709280836 18<25ormaaj18>	I think other shells special case empty IFS + nul delimiter for UTF-8. Bash really should too because the normal behavior is useless.
T 1709281953 18<22tirnanog18>	sphertext_: the space character is not a control character.
T 1709281975 18<26sphertext_18>	but I would say it's graphical
T 1709282004 18<27JAA18>	'printable'?
T 1709282021 18<27JAA18>	That's the usual term, anyway.
T 1709282072 18<26sphertext_18>	apart from space, are there other examples of non-graphical ASCII characters which are not control characters?
T 1709282078 18<27JAA18>	In which case, no, ASCII is divided into control characters and printable characters.
T 1709282090 18<26sphertext_18>	great
T 1709282096 18<27JAA18>	0x00 to 0x1F and 0x7F are control characters, 0x20 to 0x7E are printables.
T 1709282136 18<26sphertext_18>	are there control characters which are not ASCII?
T 1709282169 18<26sphertext_18>	I'm thinking of arrow keys
T 1709282170 18<22tirnanog18>	incorrect. 0x20 does not use 'ink'. it is not printable.
T 1709282177 18<26sphertext_18>	do arrow keys send a byte code, or a character, or what? is it ASCII?
T 1709282209 18<22tirnanog18>	oh, I'm probably mixing it up with graph.
T 1709282241 18<27JAA18>	0x20 is special, but yeah, it's considered printable.
T 1709282276 18<28emanuele618>	# if [[ ' ' = [[:print:]] ]] then echo yes; else echo no; fi
T 1709282278 18<27JAA18>	Arrows send an escape sequence IIRC?
T 1709282279 18<25shbot18>	emanuele6: yes
T 1709282282 18<28emanuele618>	# if [[ ' ' = [[:graph:]] ]] then echo yes; else echo no; fi
T 1709282284 18<25shbot18>	emanuele6: no
T 1709282298 18<22tirnanog18>	# [[ " " == [[:print:]] ]] | [[ " " == [[:graph:]] ]]; echo "${PIPESTATUS[*]}"
T 1709282300 18<25shbot18>	tirnanog: 0 1
T 1709282321 18<28emanuele618>	that is 1 in binary
T 1709282329 18<25ormaaj18>	The first 128 unicode code points are the characters that correspond with ascii, so, yes effectively everything has them because everything is unicode.
T 1709282375 18<28emanuele618>	i don't think →↓←↑ are escape codes
T 1709282409 18<28emanuele618>	they are utf-8 sequences, but i don't think those are considered escape sequences
T 1709282472 18<28emanuele618>	the arrow keys should send ←↓→↑ !
T 1709282500 18<27JAA18>	Can't wait to use AltGr+i to move to the right!
T 1709282511 18<28emanuele618>	exactly what i was thinking
T 1709282515 18<25ormaaj18>	hjkl
T 1709282525 18<28emanuele618>	much easier to press than arrowright or alt+f
T 1709282530 18<28emanuele618>	err ctrl+f
T 1709282555 18<28emanuele618>	ew vim mode
T 1709282560 18<28emanuele618>	vi mode
T 1709282579 18<25ormaaj18>	so good
T 1709282607 18<27JAA18>	My layout is extremely annoying. It has ←↓→ but no ↑.
T 1709282612 18<22tirnanog18>	sphertext_: run cat -v (as mentioned earlier), press the arrow keys and see what happens. or use lnext with anything that can tell you what it is (printf, od, hexdump etc).
T 1709282648 18<25ormaaj18>	My login prompt should have username completion
T 1709282651 18<28emanuele618>	JAA: it's altgr+shift+u on my keyboard layout
T 1709282662 18<27JAA18>	Ooh
T 1709282677 18<27JAA18>	That even makes perfect sense since AltGr+u is ↓.
T 1709282705 18<28emanuele618>	i always think that altgr+u is ↑ because up
T 1709282711 18<28emanuele618>	but it is the opposite :/
T 1709282760 18<27JAA18>	The shift key has a big up arrow, so it turns the arrow upwards.
T 1709282783 18<28emanuele618>	also u in vim visual mode converts to lowercase, while U converts to upper case
T 1709282788 18<28emanuele618>	also U is taller than u
T 1709282849 18<26sphertext_18>	^[[D. so from wikipedia, ^[ is an ASCII, non-graphical, control character which is used as an escape character. does this mean ^[[D is an _escape sequence_ consisting of 3 ASCII characters (one non-graphical and two graphical)?
T 1709282867 18<26sphertext_18>	^[[D is what I got when I pressed left-arrow in cat-v
T 1709282892 18<20osse18>	yes
T 1709282913 18<26sphertext_18>	i am terrified that i am starting to actually understand this
T 1709282935 18<22tirnanog18>	sphertext_: another experiment: 1) od -t x1 2) lnext, arrow key 3) enter, C-d (to signify EOF)
T 1709282949 18<22tirnanog18>	that'll mix in the byte for the linefeed but it does the job.
T 1709282993 18<22tirnanog18>	actually, shouldn't even need lnext.
T 1709283060 18<22tirnanog18>	(because od uses the bog standard line discipline, just like cat)
T 1709283219 18<22tirnanog18>	for me that prints "1b  5b  44  0a"
T 1709283222 18<26sphertext_18>	oh this is very nice
T 1709283229 18<26sphertext_18>	i used it with -t c
T 1709283303 18<22tirnanog18>	-t a is also interesting for ascii (both of those can be shortened as -c and -a).
T 1709283336 18<22tirnanog18>	you can mix formats too.
T 1709283354 18<22tirnanog18>	-t x1 -c
T 1709283401 18<26sphertext_18>	and those formats are ways to represent the underlying byte value?
T 1709283402 18<28emanuele618>	iF yOuR od SuPpOrTs -c
T 1709283444 18<22tirnanog18>	oh, it's xsi? alright.
T 1709284014 18<22tirnanog18>	sphertext_: yes.
T 1709284041 18<22tirnanog18>	the -t a ones you can look up directly in the macos ascii man page, iirc.
T 1709284074 18<22tirnanog18>	as well as the hex values, obviously.
T 1709284487 18<26sphertext_18>	weird. default behaviour in iTerm for alt+[up arrow] is ^[[1;9A while in mac's own Terminal it's ^[[A
T 1709284505 18<26sphertext_18>	tho you can definitely configure this in iTerm
T 1709284512 18<26sphertext_18>	(i didn't, that's just the default)
T 1709284532 18<26eoc18>	in posix can one remove trailing path of url to leave base url? echo ${1%/*}
T 1709284610 18<28emanuele618>	in posix, on posix, under posix, by posix
T 1709284827 18<26sphertext_18>	# url="www.website.com/foo/bar/page.html" echo ${url%%/*}
T 1709284829 18<25shbot18>	sphertext_: no output
T 1709284850 18<28emanuele618>	!faq foo=bar
T 1709284850 18<29greybot18>	https://mywiki.wooledge.org/BashFAQ/104 -- Why doesn't foo=bar echo "$foo" print bar?
T 1709284873 18<26sphertext_18>	# url="www.website.com/foo/bar/page.html"; echo ${url%%/*}
T 1709284875 18<25shbot18>	sphertext_: www.website.com
T 1709284885 18<28emanuele618>	that is the least urly url i have ever seen
T 1709284927 18<26sphertext_18>	sounds racist
T 1709284959 18<26sphertext_18>	but yeah dunno how to solve if it has a URI prefix
T 1709285142 18<26eoc18>	hah, very creative sphertext, unfortunately the urls start with http://
T 1709285169 18<26sphertext_18>	you have to do it in 2 steps then
T 1709285242 18<28emanuele618>	great out of the box, in of the posix thinking
T 1709285246 18<26eoc18>	ah okok
T 1709285941 18<22pj18>	sh# url=http://www.example.com/foo/bar/baz.html base=${url#*//} domain=${base%%/*} path=${url#*$domain} base=${url%$path}; echo "$base"
T 1709285942 18<25shbot18>	pj: http://www.example.com
T 1709285954 18<22pj18>	some creative thinking might be able to shorten that.
T 1709288012 18<22meteors18>	I am sourcing a file with variables and creating a new file with the variables expanded. I use this: `source "$FILE_A";eval "cat <<EOF > $FILE_FINAL $(<"$FILE_B") EOF"`. Is there a better way to achieve the same?
T 1709288211 18<24geirha18>	!template
T 1709288211 18<29greybot18>	http://mywiki.wooledge.org/TemplateFiles
T 1709288215 18<27Soliton18>	showing crazy code and then asking how to achieve the same but better is not very useful. explain a goal.
T 1709288303 18<24geirha18>	If you can rely on envsubst (from gettext package) being available, I'd definitely use that
T 1709288502 18<22meteors18>	I 'll try with envsbust, thanks. Sorry for the crazy code, trying to combine a file with variables with another file that I'd like the variables to be expanded. envsubst seems a good fit, ty
T 1709288736 18<24geirha18>	yeah, so then it would look something like  (set -a ; source file_a ; envsubst < file_b > final)
T 1709289174 18<22meteors18>	Yup, works fine, thanks
T 1709289234 18<26chiselfuse18>	in interactive mode, i sometimes want to run a command i have in .xinitrc, i do this by typing:   $(grep ^foo .xinitrc)    to run the command "foo bar baz" found in my .xinitrc.     the problem is that sometimes the command is appended with a comment such as "foo bar baz # comment" and i find that typing  $(grep ^foo .xinitrc)  passes the # and the comment as arguments
T 1709289239 18<26chiselfuse18>	how can i prevent this?
T 1709289319 18<27Soliton18>	if you want to execute shell code then you use eval.
T 1709289320 18<27wyclif18>	You use the awk command to filter out comments
T 1709289346 18<27wyclif18>	Like, here's an example:
T 1709289347 18<26chiselfuse18>	eval works
T 1709289348 18<27wyclif18>	'$(grep ^foo .xinitrc | awk '{sub(/#.*/, "", $0); print $0}')
T 1709289357 18<26chiselfuse18>	i had confused "eval" with "command"
T 1709289373 18<27Soliton18>	and quote properly.
T 1709289387 18<27Soliton18>	eval "$(grep ...)"
T 1709289388 18<27wyclif18>	That removes everything from `#` to the end of the line, removing the comments from the output of `grep`
T 1709289394 18<26chiselfuse18>	wyclif: this is interactive mode, even if this were a cleaner solution it would be a bit ugly to type out
T 1709289417 18<27wyclif18>	Then the modified command is executed using `$()`
T 1709289439 18<27wyclif18>	Yes, it's ugly
T 1709289457 18<27wyclif18>	you could use sed and do something like:
T 1709289460 18<27wyclif18>	`$(grep ^foo .xinitrc | sed 's/#.*//')
T 1709289466 18<27Soliton18>	that it works with unquoted $() is by accident.
T 1709289476 18<27Soliton18>	that is not how you execute code.
T 1709289501 18<27wyclif18>	ignore the opening tick, that was a typo on my part
T 1709289560 18<27Soliton18>	handling one specific syntax part is not going to make it much less by accident.
T 1709289635 18<27wyclif18>	But yes, you should use `eval`
T 1709289643 18<28selckin18>	should just make it a seperate script, and not run things you grep
T 1709289671 18<27wyclif18>	if you want to execute the command obtained from the `.xinitrc` file and handle the comments properly
T 1709289688 18<27wyclif18>	Like maybe:
T 1709289700 18<27wyclif18>	eval "$(grep ^foo .xinitrc | sed 's/#.*//')"
T 1709289728 18<24geirha18>	no point in removing the comment anymore since eval will treat it as a comment
T 1709289736 18<27Soliton18>	# $(echo 'echo "foo bar" #comment')
T 1709289737 18<25shbot18>	Soliton: "foo bar" #comment
T 1709289742 18<27Soliton18>	# eval "$(echo 'echo "foo bar" #comment')"
T 1709289744 18<25shbot18>	Soliton: foo bar
T 1709289883 18<24geirha18>	I guess it's a decent usecase for fzf    eval "$(fzf < ~/.xinitrc)"
T 1709289895 18<27wyclif18>	Yes
T 1709289921 18<27wyclif18>	Everyone should have fzf installed; it's so useful
T 1709289922 18<26chiselfuse18>	geirha: that's a pretty cool idea
T 1709289933 18<26chiselfuse18>	i think i'll write a function in my rc file
T 1709289959 18<26chiselfuse18>	hmm what should i call it
T 1709289968 18<28emanuele618>	can you write it also in my rc file?
T 1709289998 18<26chiselfuse18>	i don't think shell redirection works over network
T 1709290034 18<26chiselfuse18>	echo testing > emanuele6:.bashrc
T 1709290045 18<26chiselfuse18>	oops overwrote the entire file
T 1709290047 18<20sphertext__18>	got so many good ideas for using fzf from this https://www.youtube.com/watch?v=8SqakfCSzQk
T 1709290052 18<26chiselfuse18>	unless it didn't work to begin with
T 1709290172 18<20sphertext__18>	oops this is newer: https://www.youtube.com/watch?v=41JxYe70Xwo
T 1709290191 18<28emanuele618>	hmm, why am i getting the default prompt and  bash: testing: command not found   when i start bash?
T 1709290197 18<26chiselfuse18>	run() { eval "$(fzf < "$1")" }
T 1709290204 18<26chiselfuse18>	do you think this is good?
T 1709290212 18<28emanuele618>	you need a ; before }
T 1709290230 18<26chiselfuse18>	but it works without it, what benefit is there?
T 1709290244 18<28emanuele618>	if it works without it is not bash
T 1709290255 18<28emanuele618>	# run() { eval "$(fzf < "$1")" }
T 1709290261 18<25shbot18>	emanuele6: Missing terminating quote, bracket or keyword
T 1709290276 18<26chiselfuse18>	weird, idk how it worked without it for me
T 1709290311 18<24geirha18>	maybe you have a newline before the }
T 1709290314 18<28emanuele618>	anyway, you would preferably use  eval -- "$(fzf < "$1")"  or  eval " $(fzf < "$1")"   or it will not work correctly if the lines is longer than two characters and starts with -
T 1709290320 18<24geirha18>	run() { eval "$(fzf -q "$2" < "$1")" ; }
T 1709290324 18<24geirha18>	run .xinitrc foo
T 1709290488 18<26chiselfuse18>	emanuele6: i read the manpage for eval about the "--" and i can't understand what it's saying at all
T 1709290504 18<26chiselfuse18>	does eval take any '-' options?
T 1709290511 18<26chiselfuse18>	why would it require -- then
T 1709290528 18<27Soliton18>	# eval --help
T 1709290530 18<25shbot18>	Soliton: eval: eval [arg ...]
T 1709290530 18<25shbot18>	Soliton:     Execute arguments as a shell command.
T 1709290530 18<25shbot18>	Soliton: etc... ( http://paste.wooledge.org/29065 )
T 1709290589 18<27Soliton18>	# eval -a
T 1709290590 18<25shbot18>	Soliton: bash: eval: -a: invalid option
T 1709290590 18<25shbot18>	Soliton: eval: usage: eval [arg ...]
T 1709290616 18<28emanuele618>	if the argument is longer than two characters, and starts with -
T 1709290626 18<26chiselfuse18>	is the manpage eval(1P) relevant here? because i can't find any of this there
T 1709290646 18<27Soliton18>	!man
T 1709290647 18<29greybot18>	bash builtins and keywords do not have separate man-pages, read bash's manual instead or use the help builtin. Rule of thumb: If ''type foo'' says foo is a builtin or keyword, run ''help foo'' or ''man bash'', otherwise try man and/or info.
T 1709290665 18<26chiselfuse18>	what is eval(1P) for then?
T 1709290667 18<26chiselfuse18>	it says it's posix
T 1709290696 18<24ano18>	!posix
T 1709290696 18<29greybot18>	The POSIX standard defines what any modern unix should support. Use just POSIX external commands and options to make portable scripts. See http://shellhaters.org
T 1709290697 18<26chiselfuse18>	APPLICATION USAGE Since eval is not required to recognize the "--" end of options delimiter, in cases where the argument(s) to eval might begin with '-' it is recommended that the first argument is prefixed by a string that will not alter the commands to be executed, such as a <space> character:
T 1709290731 18<28emanuele618>	in bash you can use   eval --   however you cannot use  run() { eval "$(fzf < "$1")" }
T 1709290750 18<28emanuele618>	for a portable function you would use    run() { eval " $(fzf < "$1")" ;}
T 1709290751 18<24geirha18>	anyway, it's not like you have any commands that start with - so you wouldn't select any with fzf in the first place, but still a good idea to add the safeguard
T 1709290769 18<27Soliton18>	emanuele6: why does it need to be longer than two characters when -a already fails?
T 1709290784 18<28emanuele618>	two characters or longer!
T 1709290815 18<28emanuele618>	!cookie > Soliton
T 1709290815 18<29greybot18>	Soliton: 🍪
T 1709291797 18<20sphertext__18>	so if `control+.` is not mapped to a control character, this means I can't use it as a binding in a terminal program
T 1709294290 18<27Soliton18>	there is a good chance your terminal does not produce distinct input for it.
T 1709294348 18<27Soliton18>	in principle it can do whatever it wants of course.
T 1709295156 18<28dumbledoor18>	When I archive a file using `tar czf file`, tar creates an archive with the file nested deeply in a hierarchy of directories instead of saving it at the top level. How to deal with this?
T 1709295219 18<28dumbledoor18>	I backup my "stuffs" directory to google drive and this "stuffs" directory has both files and directories. tar works fine with directories but creates this problem when working with files.
T 1709295253 18<28dumbledoor18>	Should I just use tar and gzip for files and directories respectively?
T 1709295386 18<28dumbledoor18>	tar and gzip for directories and files*
T 1709295483 18<28dumbledoor18>	Note: I am not archiving the stuffs directory itself, because I want to make use of google drive's history feature.
T 1709295508 18<26lopid18>	cd to iot
T 1709295509 18<28APic18>	Maybe You should hardlink the File to singlefilestuffs/File and then tar czvf singlefilestuffs/File
T 1709295510 18<26lopid18>	it
T 1709295560 18<28APic18>	tar czvf singlefilearchive.tgz singlefilestuffs/File even
T 1709295574 18<28APic18>	Or just zip Your single Files    😉
T 1709295602 18<28APic18>	tar always stores Directories by Default, zip not
T 1709295644 18<28APic18>	Remember tar came from „Tape Archiver“
T 1709295648 18<28dumbledoor18>	oops
T 1709295655 18<28dumbledoor18>	you are right lopid
T 1709295675 18<28dumbledoor18>	if I cd to the directory of the file, tar archives it at the top level
T 1709295715 18<28dumbledoor18>	(that's unpredictable tho, i wonder why it works like that)
T 1709295805 18<28dumbledoor18>	(ok it's not unpredictable, i just don't know the right word)
T 1709295811 18<28dumbledoor18>	thanks
T 1709296031 18<29sixwheeledbeast18>	so you can restore it from the tape in the same place.
T 1709296258 18<28dumbledoor18>	sixwheelbeast: Does tar need an extra option to extract at the same place?
T 1709296312 18<29sixwheeledbeast18>	You could use -C to target another directory
T 1709296332 18<29sixwheeledbeast18>	or maybe cd in a subshell
T 1709296357 18<28dumbledoor18>	You mean by default it extracts at the same place? That did not work for me
T 1709296457 18<28dumbledoor18>	It created a home directory at the place instead
T 1709296521 18<27Soliton18>	tar uses the path you give it. if you give it file then it extracts file. if you give it path/to/file then it extracts path/to/file.
T 1709296547 18<27Soliton18>	if you give it an absolute path it might complain.
T 1709296736 18<28dumbledoor18>	I see. It does say tar: Removing leading '/' from member names
T 1709296799 18<25pgas18>	if you only need compression, then just use gzip or xz or the like.
T 1709297096 18<28dumbledoor18>	didn't know about xz. thanks.
T 1709297302 18<24cheater18>	https://hackaday.com/2024/02/29/the-white-house-memory-safety-appeal-is-a-security-red-herring/
T 1709297309 18<28emanuele618>	xz is the xz in .tar.xz; and gzip is the gz in .tar.gz; another popular one is bzip2, that is the bx2 in .tar.bz2
T 1709297318 18<28emanuele618>	s/bx/bz/
T 1709297335 18<24cheater18>	wasn't there another new one too
T 1709297387 18<28emanuele618>	there are many different compression tools
T 1709297410 18<28emanuele618>	gz, xz, and bz2 are probably the most populars
T 1709297432 18<24geirha18>	probably thinking of zstd
T 1709297443 18<28selckin18>	lzma lz4
T 1709297511 18<20osse18>	all of them sound like party drugs
T 1709297538 18<28emanuele618>	oh, yes, archlinux started using zstd for packages some years ago
T 1709297561 18<28emanuele618>	its extension is .zst
T 1709297579 18<24geirha18>	so idiotic
T 1709297587 18<28emanuele618>	either party drugs or party diseases
T 1709297592 18<27colo18>	heh
T 1709297661 18<28emanuele618>	archlinux packages are all compiled with -fno-plt >:(
T 1709297666 18<28emanuele618>	i cannot ltrace them
T 1709298076 19*	Now talking on 22#bash
T 1709298076 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709298076 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709299228 18<27Earnestly18>	> steelman
T 1709299237 18<27Earnestly18>	Ada had so much potential
T 1709299772 18<26chiselfuse18>	https://0x0.st/HRnb.txt
T 1709299777 18<26chiselfuse18>	does this look good?
T 1709299803 18<26chiselfuse18>	i added grep to uncomment commented lines
T 1709299845 18<26chiselfuse18>	hmm somehow uploading it completely screwed indentation
T 1709299950 18<26chiselfuse18>	https://0x0.st/HRnG.txt
T 1709300003 18<26chiselfuse18>	!check
T 1709300004 18<28checkbot18>	chiselfuse: Looks good to me
T 1709300131 18<27Earnestly18>	chiselfuse: If you're using eval you likely don't need to worry about excluding comment characters
T 1709300141 18<27Earnestly18>	As eval, being the shell, understands what they are
T 1709300181 18<27Earnestly18>	I suppose it's just for fzf's sake
T 1709300407 18<28llua18>	lines don't have to start with # to be a comment too
T 1709300468 18<27Earnestly18>	A good point, this doesn't account for line continuations
T 1709300734 18<28emanuele618>	chiselfuse: but ex is a standard program D:
T 1709300797 18<28emanuele618>	i don't understand that grep command; it outputs from the first character that is not #
T 1709300874 18<28emanuele618>	so e.g. for "# foobar", " foobar"   for " # baz", " baz"   for "## boo", " boo"  for " ## boo", " ## boo"
T 1709300899 18<28emanuele618>	you have not quoted $#
T 1709300931 18<28emanuele618>	err   for " # baz", " # baz"   is what i meant to write
T 1709300974 18<28emanuele618>	it is basically like  sed 's/^#*//'   but weirdly written with a GNU grep command
T 1709301056 18<28emanuele618>	well, not exactly, if a line only contains  ####  that grep command outputs nothing, while sed 's/^#*//' would output an empty line, but in that context it does not make much difference
T 1709301169 18<28emanuele618>	s/line only/line is empty, or only/
T 1709301464 18<26chiselfuse18>	emanuele6: what's the correct preprocessing to do in english do you think? get a line that starts with anything that isn't # or whitespace?
T 1709301487 18<26chiselfuse18>	or would there be some edge case there too
T 1709301549 18<28emanuele618>	that grep command is basically  sed 's/^#*//'  but written weirdly
T 1709301557 18<28emanuele618>	you should quote "$#"
T 1709301593 18<26chiselfuse18>	huh?
T 1709301599 18<26chiselfuse18>	emanuele6: what $# do you mean?
T 1709301609 18<28emanuele618>	the one in your code
T 1709301623 18<28emanuele618>	you have    if [ $# -ne 1 ]; then    that is wrong
T 1709301628 18<26chiselfuse18>	oh
T 1709301639 18<28emanuele618>	it should be   [ "$#" -ne 1 ]   or just   [ "$#" != 1 ]
T 1709301649 18<28emanuele618>	but quoted
T 1709301686 18<26chiselfuse18>	is there a way to match any whitespace character in grep or sed?
T 1709301701 18<28emanuele618>	and ex is a standard command  https://pubs.opengroup.org/onlinepubs/9699919799/utilities/ex.html  vi in non-visual mode
T 1709301769 18<28emanuele618>	well, yes, there is [[:space:]] to match any whitespace character defined in the current locale, and [[:blank:]] to match any horizontal whitespace defined in the current locale... you could also specify the whitespace characters manually in a [...]
T 1709301828 18<26chiselfuse18>	do you think that     grep -o '[^#]|[[:space:]].*$'    is okay?
T 1709301837 18<26chiselfuse18>	err
T 1709301843 18<28emanuele618>	how can it be ok?
T 1709301849 18<26chiselfuse18>	grep -o '[^#]|[^[[:space:]]].*$'    is okay?
T 1709301859 18<28emanuele618>	wot
T 1709301888 18<28emanuele618>	i think you mean [^#[:space:]].*$
T 1709301900 18<26chiselfuse18>	i'm trying to say "longest match starting with a character that isn't # or whitespace
T 1709301904 18<28emanuele618>	but i don't understand by what logic that makes sense
T 1709301921 18<26chiselfuse18>	"longest match starting with a character that isn't # or whitespace"
T 1709301925 18<26chiselfuse18>	how would you do it then?
T 1709301955 18<28emanuele618>	that sentence has basically exactly the same meaning as remove all the characters at the start that are whitespace or #
T 1709301965 18<26chiselfuse18>	yea
T 1709301978 18<26chiselfuse18>	what's wrong with it?
T 1709301997 18<28emanuele618>	i said earlier how to convert it?
T 1709302025 18<28emanuele618>	 sed $'s/^[# \t]*//'
T 1709302054 18<26chiselfuse18>	weird my chat log doesn't have the first time you said it
T 1709302055 18<28emanuele618>	i cannot see the value is using [[:space:]] as you are doing instead of just space and tab since using any other whitespace character in bash will result in an error
T 1709305277 19*	Now talking on 22#bash
T 1709305277 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709305277 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709312939 19*	Now talking on 22#bash
T 1709312939 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709312939 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709316253 19*	Now talking on 22#bash
T 1709316253 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709316253 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709345126 19*	Now talking on 22#bash
T 1709345126 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709345126 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709345182 18<25ormaaj18>	tirnanog: do you happen to know if profiles run sandboxed? If yes then I can't use findmnt or mountpoint so all I can really do in that case is [[ $EROOT -ef /usr/bin ]]
T 1709345217 18<25ormaaj18>	sandboxed or otherwise disallow exec like global-scope ebuild code
T 1709345279 18<22tirnanog18>	I don't, sorry. if it helps, the devmanual should explain (I think) whether a given phase is sandboxed. I think anything that isn't an ebuild phase generally isn't but you have to go to to the code to be sure.
T 1709345311 18<22tirnanog18>	or just try it.
T 1709345314 18<25ormaaj18>	ok ty. making such a simple change takes some research :|
T 1709345337 18<22tirnanog18>	yeah, I'm right about the devmanual.
T 1709345347 18<22tirnanog18>	here's an example showing that sandboxing is in effect for src_install: https://devmanual.gentoo.org/ebuild-writing/functions/src_install/index.html
T 1709345357 18<22tirnanog18>	and that it's also root at that point.
T 1709346214 18<25ormaaj18>	I was trying to install mksh-9999 earlier which needs to access a CVS repo which uses ssh, and the PORTAGE user apparently cannot access its own home directory without sandbox error, so that happens to be why I was complaining about openssh earlier.
T 1709346268 18<22tirnanog18>	ah.
T 1709346307 18<22tirnanog18>	the sandbox is a relic from a time where every phase was executed as root and we didn't have namespaces.
T 1709346313 18<22tirnanog18>	it should be put out to pasture, really.
T 1709346326 18<22tirnanog18>	it causes bugs in its own right from time to time.
T 1709346404 18<25ormaaj18>	it needs to read the known_hosts file. My previous hack of just putting the host in portage's file doesn't work anymore, because they must have changed how the sandbox works. So I need a new hack, which will probably be to abuse the KnownHostsCommand to write a hard-coded value for the host key with printf XD
T 1709346423 18<22tirnanog18>	oh dear.
T 1709350303 18<24nicolas1718>	I can use ${f#prefix} and ${f%suffix} to remove a prefix or suffix from a variable value, but is there any easy way to remove *both* a prefix and a suffix? or do I need to use a temporary variable to do # and % steps separately?
T 1709350469 18<27larryv18>	the latter
T 1709350496 18<27larryv18>	depending on what you're doing, you might be able to just reuse the same variable
T 1709356535 19*	Now talking on 22#bash
T 1709356535 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709356535 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709356629 19*	Now talking on 22#bash
T 1709356629 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709356629 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709368583 18<19zxd18>	hi, what's the history behind the need for a    comma    before  closing }   :       { echo foo  ;}
T 1709368620 18<19zxd18>	it looks for '}'  command?
T 1709369144 18<19Artfaith18>	zxd, I am sory, a comma or semicolon?
T 1709369320 18<25ormaaj18>	# {(echo moo)}
T 1709369323 18<25shbot18>	ormaaj: moo
T 1709369647 18<19zxd18>	semicolon
T 1709369818 18<19Artfaith18>	zxd, what do you mean by "history"? Why is it required in the syntax?
T 1709369983 18<28emanuele618>	# if { [[ 1 ]] } then {(echo hi)} fi
T 1709369984 18<25shbot18>	emanuele6: hi
T 1709370029 18<28emanuele618>	you "need" a semicolon for because otherwise } is just the string "}"
T 1709370032 18<28emanuele618>	# echo }
T 1709370033 18<25shbot18>	emanuele6: }
T 1709370064 18<28emanuele618>	it is the same reason why you "need" a semicolon before fi
T 1709370065 18<19Artfaith18>	And just in case, ( :; ) means a subshell.
T 1709370073 18<28emanuele618>	# if true; then echo hi fi
T 1709370079 18<25shbot18>	emanuele6: Missing terminating quote, bracket or keyword
T 1709370081 18<28emanuele618>	# echo hi fi
T 1709370082 18<25shbot18>	emanuele6: hi fi
T 1709370087 18<28emanuele618>	# if true; then echo hi; fi
T 1709370089 18<25shbot18>	emanuele6: hi
T 1709370111 18<25ormaaj18>	# [[(({})||({}))]] && echo moo moo moo
T 1709370112 18<25shbot18>	ormaaj: moo moo moo
T 1709370119 18<19Artfaith18>	# a=1; ( a=2 ); declare -p a;
T 1709370120 18<25shbot18>	Artfaith: declare -- a="1"
T 1709370189 18<28emanuele618>	# for case in case do case in esac done
T 1709370196 18<25shbot18>	emanuele6: Missing terminating quote, bracket or keyword
T 1709370196 18<28emanuele618>	err
T 1709370201 18<28emanuele618>	# for case do case in esac done
T 1709370202 18<25shbot18>	emanuele6: bash: syntax error near unexpected token `esac'
T 1709370210 18<28emanuele618>	# for case do case moo in esac done
T 1709370211 18<25shbot18>	emanuele6: no output
T 1709370213 18<28emanuele618>	:D
T 1709370364 18<28emanuele618>	# for do do if case moo in esac then for voo do case poo in esac done else case do in esac fi done
T 1709370365 18<25shbot18>	emanuele6: no output
T 1709370414 18<25ormaaj18>	# for for do select select do case case in esac done done; echo :\)
T 1709370416 18<25shbot18>	ormaaj: :)
T 1709370608 18<25ormaaj18>	I have an actual headache now. Stupid bash.
T 1709370755 18<28emanuele618>	# until case headache in esac do for for do if case moo in esac then case ormaaj in esac fi done done
T 1709370756 18<25shbot18>	emanuele6: no output
T 1709371297 18<25ormaaj18>	!smiley
T 1709371297 18<29greybot18>	m# case { { ( { ) ( <<< :-\) cat ) }
T 1709371298 18<25shbot18>	greybot: :-)
T 1709371358 18<28emanuele618>	# time TIMEFORMAT=:-\)
T 1709371359 18<25shbot18>	emanuele6: :-)
T 1709371401 18<28emanuele618>	$ strace -qqqqefd=2 -ewrite bash -c 'time TIMEFORMAT=:-\)'
T 1709371403 18<28emanuele618>	write(2, ":-)\n", 4:-)
T 1709371405 18<28emanuele618>	)                    = 4
T 1709371411 18<28emanuele618>	that is how you write to stderr without redirections in bash
T 1709371806 18<25ormaaj18>	# bash+ -c $'${| local -; eval "set -nv\nmoo" ; }' >/dev/null
T 1709371808 18<25shbot18>	ormaaj: moo
T 1709371863 18<28emanuele618>	# bash+ -c $'${| local -; eval "set -nv\:-)" ; }' >/dev/null
T 1709371865 18<25shbot18>	emanuele6: bash+: eval: line 1: syntax error near unexpected token `)'
T 1709371865 18<25shbot18>	emanuele6: bash+: eval: line 1: `set -nv\:-)'
T 1709371868 18<28emanuele618>	# bash+ -c $'${| local -; eval "set -nv\n:-)" ; }' >/dev/null
T 1709371869 18<25shbot18>	emanuele6: :-)
T 1709371869 18<25shbot18>	emanuele6: bash+: eval: line 3: syntax error near unexpected token `)'
T 1709371869 18<25shbot18>	emanuele6: bash+: eval: line 3: `:-)'
T 1709371912 18<28emanuele618>	# read -t0 -p$':-)\n'
T 1709371913 18<25shbot18>	emanuele6: no output
T 1709371922 18<28emanuele618>	:/
T 1709371927 18<25ormaaj18>	ha
T 1709371929 18<28emanuele618>	# read -rN0 -p$':-)\n'
T 1709371931 18<25shbot18>	emanuele6: no output
T 1709371935 18<28emanuele618>	D:
T 1709372347 18<28emanuele618>	time TIMEFORMAT=${str//%/%%}   is the best way to do that
T 1709372509 18<28emanuele618>	# log () { time local TIMEFORMAT=${@//%/%%};}; log hello; log 99% done
T 1709372510 18<25shbot18>	emanuele6: hello
T 1709372510 18<25shbot18>	emanuele6: 99% done
T 1709372941 18<22mosasaur18>	get on with it then
T 1709372990 18<28emanuele618>	00% done
T 1709373065 18<22mosasaur18>	# date
T 1709373066 18<25shbot18>	mosasaur: Sat Mar  2 09:51:05 UTC 2024
T 1709374004 18<25ormaaj18>	hm I forgot - are these the same? `[[ ( -L $x && -d $x ) && $x == foo || -z $moo ]]` and `[[ ( ( -L $x && -d $x ) && $x == foo ) || -z $moo ]]`
T 1709374038 18<25ormaaj18>	They look same... unless I missed a case. The operator precedence isn't actually documented.
T 1709374139 18<25ormaaj18>	Mainly concerned with whether -z moo is evaluated only if the overall previous expression is false
T 1709374541 18<24geirha18>	if they aren't the same, I've probably written a lot of bugs
T 1709374563 18<24geirha18>	removing all the parenthesis should also yield the same logic
T 1709374973 18<24geirha18>	# for a in '' T ; do for b in '' T ; do for c in '' T ; do for d in '' T ; do printf '[[ ( %s && %s ) && %s || %s ]]: ' "${a:-F}" "${b:-F}" "${c:-F}" "${d:-F}" ; if [[ ( $a && $b ) && $c || $d ]] ; then printf 'T\n' ; else printf 'F\n' ; fi ; done done done done
T 1709374975 18<25shbot18>	geirha: [[ ( F && F ) && F || F ]]: F
T 1709374975 18<25shbot18>	geirha: [[ ( F && F ) && F || T ]]: T
T 1709374975 18<25shbot18>	geirha: etc... ( http://paste.wooledge.org/29172 )
T 1709375177 18<24geirha18>	# for a in '' T ; do for b in '' T ; do for c in '' T ; do for d in '' T ; do printf '[[ ( %s && %s ) && %s || %s ]]: ' "${a:-F}" "${b:-F}" "${c:-F}" "${d:-F}" ; if [[ ( $a && $b ) && $c || $d$(printf E>&2) ]] ; then printf 'T\n' ; else printf 'F\n' ; fi ; done done done done
T 1709375179 18<25shbot18>	geirha: [[ ( F && F ) && F || F ]]: EF
T 1709375180 18<25shbot18>	geirha: [[ ( F && F ) && F || T ]]: ET
T 1709375180 18<25shbot18>	geirha: etc... ( http://paste.wooledge.org/29174 )
T 1709375741 18<25ormaaj18>	yay good same!
T 1709375744 18<25ormaaj18>	:)
T 1709378384 18<19zxd18>	if { [[ 1 ]] } then {(echo hi)} fi
T 1709378385 18<19zxd18>	-bash: syntax error near unexpected token `}'
T 1709378800 18<19zxd18>	# if { [[ 1 ]] } then {(echo hi)} fi
T 1709378801 18<25shbot18>	zxd: hi
T 1709378810 18<19zxd18>	why does it work with the bot
T 1709379034 18<28emanuele618>	because the bot has bash 5.2
T 1709379044 18<28emanuele618>	while you evidently do not
T 1709379088 18<28emanuele618>	the only difference is that since bash 5.2 { [[ 1 ]] } is allowed, while in earlier versions you had to use  { [[ 1 ]] ;}
T 1709379100 18<28emanuele618>	51# { if { [[ 1 ]] } then {(echo hi)} fi }
T 1709379101 18<25shbot18>	emanuele6: bash: syntax error near unexpected token `}'
T 1709379106 18<28emanuele618>	51# { if { [[ 1 ]];} then {(echo hi)} fi }
T 1709379107 18<25shbot18>	emanuele6: hi
T 1709379224 18<19zxd18>	and also don't need  ;   after { [[ 1 ]] }   if { [[ 1 ]] };
T 1709379444 18<19zxd18>	what's the difference between using      [[ (foo || foo) && ( foo )  ]] ||  [[ foo ]]     and      [[ (( foo || foo ) && foo ) || foo ]]
T 1709379565 18<19zxd18>	what does   [[ {} ]] && echo a   mean ? why does it work when there is no space between the {  }     and also  [[ {asdasdasdasda} ]] && echo a
T 1709380427 18<29sixwheeledbeast18>	the test [[ will be true as string length is gt 0 and then echo a
T 1709380453 18<29sixwheeledbeast18>	command grouping doesn't do much
T 1709380837 18<19zxd18>	i remember there was a trick with printf    to leave the last space off when printing an array :  printf "%s " "${array[@]}"
T 1709380843 18<19zxd18>	how to get rid of the last space
T 1709381180 18<24geirha18>	printf %s "${array[*]}"
T 1709381295 18<24geirha18>	and make sure IFS starts with a space, of course
T 1709381537 18<27Earnestly18>	zxd: IFS is useful for this, but typically in languages that lack it, the process is usually to put the separator first as a variable which is unset of the first iteration. I.e. for elem in collection {printf "%s%s", sep, elem; sep = ' '}
T 1709381558 18<27Earnestly18>	Or sep = '' whatever the language needs
T 1709381564 18<27Earnestly18>	(Initially that is)
T 1709386868 18<25Lynx-18>	Is it OK to have the output from multiple binaries piped to a single FIFO simultaneously, or will mangling occur?
T 1709387343 18<19zxd18>	51# for for do select select do case case in esac done done; echo :\)
T 1709387345 18<25shbot18>	zxd: bash: syntax error near unexpected token `done'
T 1709387345 18<27Earnestly18>	It is okay, but the order will be based on the order things write to it. I'm not sure if you can call that mangling since it's not going to just randomly disorder things
T 1709387402 18<19zxd18>	this  'for for'  loop is a 5.2 feature ?
T 1709387436 18<27Earnestly18>	for for in do; do echo "$for"; done
T 1709387440 18<27Earnestly18>	# for for in do; do echo "$for"; done
T 1709387442 18<25shbot18>	Earnestly: do
T 1709387452 18<27Earnestly18>	Somewhat self explanatory
T 1709387472 18<19zxd18>	ah
T 1709387491 18<27Earnestly18>	# set -- foo; for for do echo "$for"; done
T 1709387492 18<25shbot18>	Earnestly: foo
T 1709387524 18<27Earnestly18>	for xyz in "$@"; do <=> for xyz do
T 1709387564 18<27Earnestly18>	# help -s for
T 1709387565 18<25shbot18>	Earnestly: for: for NAME [in WORDS ... ] ; do COMMANDS; done
T 1709387773 18<28emanuele618>	51# for for do select select do case case in esac done done; echo :\)
T 1709387774 18<25shbot18>	emanuele6: bash: syntax error near unexpected token `done'
T 1709387777 18<28emanuele618>	51# for for do select select do case case in esac; done done; echo :\)
T 1709387779 18<25shbot18>	emanuele6: :)
T 1709387793 18<28emanuele618>	i think that was a bug
T 1709387856 18<28emanuele618>	need a semicolon before done at the end of a select command body
T 1709387916 18<19zxd18>	m# case { { ( { ) ( <<< :-\) cat ) }
T 1709387917 18<25shbot18>	zxd: :-)
T 1709387927 18<19zxd18>	what is it saying to the bot here what is 'm' ?
T 1709387990 18<28emanuele618>	yes, it looks like the select body was using the wrong type before bash 5.2
T 1709387998 18<28emanuele618>	zxd: it runs mksh instead of bash 5.2
T 1709388001 18<28emanuele618>	# triggers
T 1709388002 18<25shbot18>	emanuele6: Available triggers: +# bash-devel; 1# bash-1.14; 2# bash-2.05b; 32# bash-3.2; 3# bash-3.2; 42# bash-4.2; 43# bash-4.3; 44# bash-4.4; 4# bash-4.4; 50# bash-5.0; 51# bash-5.1; 52# bash-5.2; 5# bash-5.2; # bash-5.2; d# dash-0.5.9; sh# dash-0.5.9; k# ksh 93u+ 2012-08-01; m# mksh R59 2021/01/24; b# bourne; j# bourne(w/job);
T 1709388004 18<27Earnestly18>	# triggers
T 1709388005 18<25shbot18>	Earnestly: Available triggers: +# bash-devel; 1# bash-1.14; 2# bash-2.05b; 32# bash-3.2; 3# bash-3.2; 42# bash-4.2; 43# bash-4.3; 44# bash-4.4; 4# bash-4.4; 50# bash-5.0; 51# bash-5.1; 52# bash-5.2; 5# bash-5.2; # bash-5.2; d# dash-0.5.9; sh# dash-0.5.9; k# ksh 93u+ 2012-08-01; m# mksh R59 2021/01/24; b# bourne; j# bourne(w/job);
T 1709388017 18<28emanuele618>	# triggers
T 1709388018 18<25shbot18>	emanuele6: Available triggers: +# bash-devel; 1# bash-1.14; 2# bash-2.05b; 32# bash-3.2; 3# bash-3.2; 42# bash-4.2; 43# bash-4.3; 44# bash-4.4; 4# bash-4.4; 50# bash-5.0; 51# bash-5.1; 52# bash-5.2; 5# bash-5.2; # bash-5.2; d# dash-0.5.9; sh# dash-0.5.9; k# ksh 93u+ 2012-08-01; m# mksh R59 2021/01/24; b# bourne; j# bourne(w/job);
T 1709388026 18<28emanuele618>	there is no two without three :)
T 1709388058 18<25ormaaj18>	bot is mostly here for my entertainment
T 1709388098 18<28emanuele618>	checkbot: thank you for the entertainment
T 1709388098 18<28checkbot18>	emanuele6: You're welcome! \(=^.^= )/
T 1709388178 18<19zxd18>	checkbot-ai
T 1709388208 18<22militantorc18>	Is there a historical reason for the default of not including command invocations starting with spaces in the bash history?
T 1709388267 18<25ormaaj18>	nope. just a feature.
T 1709388268 18<28emanuele618>	default?
T 1709388273 18<28emanuele618>	that does not happen for me
T 1709388276 18<25ormaaj18>	not default
T 1709388279 18<25Lynx-18>	OK thanks Earnestly
T 1709388405 18<28emanuele618>	it seems you need to set   HISTCONTROL=ignorespace   or at least HISTCONTROL should contain ignorespace as one of its colon separated elements
T 1709388420 18<28emanuele618>	bash does not set it by default; i have it unset
T 1709388450 18<28emanuele618>	if you didn't set it yourself, it probably comes from the system's bash profile
T 1709388482 18<28emanuele618>	or system bashrc
T 1709388484 18<25ormaaj18>	It's supposedly there if you need to do something like type a raw password into a command
T 1709388506 18<25ormaaj18>	99% of the time if I type a password into the wrong place it's because the thing reading it was too slow
T 1709388515 18<28emanuele618>	i usually just copy it and use   "$(xclip -sel c -o)"
T 1709388548 18<22militantorc18>	emanuele6, seems default in my os
T 1709388556 18<28emanuele618>	which is?
T 1709388560 18<22militantorc18>	ubuntu
T 1709388612 18<22militantorc18>	energizer, do other distros don't enable it by default
T 1709388647 18<25ormaaj18>	I've never seen one
T 1709388720 18<22militantorc18>	i need to edit my histcontrol then
T 1709388777 18<25ormaaj18>	you also don't really need commands that start with spaces
T 1709388785 18<22militantorc18>	ormaaj, sometimes due to copy paste
T 1709388795 18<22militantorc18>	i make edits to the command
T 1709388807 18<28emanuele618>	i looked at the debian package for bash, and the default /etc/bash.bashrc /etc/profile don't set HISTCONTROL
T 1709388815 18<22militantorc18>	and then when i key up its not there
T 1709388818 18<22militantorc18>	a bit irritating
T 1709388833 18<22militantorc18>	emanuele6, then its ubuntu default
T 1709388835 18<28emanuele618>	oh, the skel for ~/.bashrc sets it
T 1709388840 18<28emanuele618>	https://sources.debian.org/src/bash/5.2.21-2/debian/skel.bashrc/
T 1709388851 18<22militantorc18>	either way, i changed the flag
T 1709388856 18<28emanuele618>	in your default ~/.bashrc you should have   HISTCONTROL=ignoreboth
T 1709388860 18<25ormaaj18>	I think it's literally only the first space of the command. Leading spaces for multi-line commands don't affect it, or I doubt they do anyway
T 1709388861 18<22militantorc18>	yeah
T 1709388863 18<22militantorc18>	thast wht i had
T 1709388863 18<28emanuele618>	in debian and ubuntu systems
T 1709388867 18<22militantorc18>	i changed to ignoredups
T 1709388883 18<28emanuele618>	but that is not default, it is just the default user configuration installed on debian ubuntu and family
T 1709389001 18<28emanuele618>	i guess it is default because the maintainers of the debian package for bash like ignorespace ¯\_(ツ)_/¯
T 1709389016 18<22militantorc18>	no big deal
T 1709389112 18<25ormaaj18>	is login really slow for anybody else or just me? :(
T 1709389125 18<25ormaaj18>	I have no clue why it takes like several seconds to show a prompt
T 1709389152 18<22militantorc18>	ormaaj, what hardwares
T 1709389154 18<22militantorc18>	and os
T 1709389164 18<24geirha18>	the worse configuration the debian package does is enabling the "source bashrc non-interactive if ssh" fuckery
T 1709389193 18<27Earnestly18>	arch does that as well, I imagine lots of distros copy debian
T 1709389218 18<25ormaaj18>	gentoo does it too. I'll probably file a bug. Just discovered it a few days ago
T 1709389246 18<25ormaaj18>	the bash package doesn't get much attention for some reason
T 1709389363 18<22militantorc18>	what shell does people use these days?
T 1709389389 18<19u0_a37218>	bash ig
T 1709389424 18<28emanuele618>	i use bash
T 1709389524 18<25ormaaj18>	bash is a bad habit
T 1709389566 18<28emanuele618>	bash is the best
T 1709389577 18<28emanuele618>	the bast
T 1709389767 18<25ormaaj18>	login hangs for several seconds on a poll syscall
T 1709389794 18<25ormaaj18>	twice... wtf is it reading
T 1709389980 18<25ormaaj18>	It's network crap. Probably some stupid PAM configuration.
T 1709390052 18<25ormaaj18>	definitely not a feature that I use
T 1709390523 18<25ormaaj18>	the problem is a function in /usr/lib64/libkrb5.so.3.3
T 1709390547 18<25ormaaj18>	yes definitely not thing I use
T 1709390615 18<28emanuele618>	it makes your os kerber
T 1709390805 18<25ormaaj18>	pambase has a kerberos switch. I shall flip it
T 1709390891 18<25ormaaj18>	it will probably complain about missing dependency next time I try to install samba though
T 1709391330 18<25ormaaj18>	Nope. None of this stuff needs that. Nice.
T 1709391405 18<28emanuele618>	my os is kerb enough
T 1709391630 18<25ormaaj18>	kerblesser
T 1709391901 18<28emanuele618>	krb5 is a dependency for mutt on archlinux
T 1709391927 18<25ormaaj18>	weird
T 1709391931 18<28emanuele618>	also openssh, curl, and a bunch of other libraries
T 1709391978 18<25ormaaj18>	yeah but pambase is just a pile of configuration files for pam. It doesn't actually provide anything.
T 1709392023 18<28emanuele618>	pambase is required by pam
T 1709392023 18<25ormaaj18>	you can have stuff installed linking against those libraries without a particular configuration
T 1709392040 18<28emanuele618>	and pam is required by everything basically
T 1709392054 18<25ormaaj18>	yes, but you don't have USE flags :P
T 1709392084 18<28emanuele618>	i cannot even tell archlinux; please build my programs without -fno-plt :(
T 1709392110 18<25ormaaj18>	tell them f-no!
T 1709392168 18<28qkzoo197818>	elif [ ans -eq 2 ]; exit 0   <-- what is wrong with that statement?
T 1709392185 18<25ormaaj18>	ans not a number
T 1709392210 18<25ormaaj18>	of course it doesn't -eq 2
T 1709392246 18<28emanuele618>	also probably missing then
T 1709392267 18<28emanuele618>	otherwise [] is just useless
T 1709392409 18<28qkzoo197818>	Ugh, ya, whoops. forgot the $ before the variable and the then
T 1709392442 18<25ormaaj18>	and quotes!
T 1709392543 18<25ormaaj18>	[[ $ans == 2 ]] is better.
T 1709392807 18<28qkzoo197818>	Good. Good. Thank you @emanuele6 and ormaaj
T 1709392871 18<25ormaaj18>	emanuele0-5 never answer
T 1709393196 18<28qkzoo197818>	Now, I have an : exit 1 which is supposed to completely exit the script, but it just exits the if/then/fi and continues on?
T 1709393214 18<25ormaaj18>	nope
T 1709393235 18<25ormaaj18>	exit exits immediately unless you've nerf'd it with a subshell
T 1709393258 18<28emanuele618>	never nerve an exit
T 1709393280 18<28qkzoo197818>	elif [ $ans == 2 ]; then exit 1; # Anything other than a zero will exit the script.
T 1709393314 18<28emanuele618>	zero?
T 1709393340 18<28emanuele618>	oh, you mean other than  exit 0
T 1709393340 18<25ormaaj18>	I guess they mean that status of test.
T 1709393352 18<28emanuele618>	yeah, so you are running exit in a subshell
T 1709393356 18<28emanuele618>	and you have set -e
T 1709393369 18<25ormaaj18>	ah set -e
T 1709393387 18<28qkzoo197818>	when did I start a subshell?
T 1709393401 18<25ormaaj18>	how would we know?
T 1709393410 18<28emanuele618>	it could be   var=$(myfunctionthatcallsexit)    or   foo | hereicallexit
T 1709393416 18<25ormaaj18>	show code or gtfo
T 1709393443 18<28emanuele618>	gtformaaj 🧀
T 1709393445 18<28qkzoo197818>	I guess I was asking what initiate a subshell,
T 1709393454 18<28emanuele618>	!subshell
T 1709393454 18<29greybot18>	http://mywiki.wooledge.org/SubShell
T 1709393455 18<25ormaaj18>	:)
T 1709393456 18<28qkzoo197818>	what would
T 1709393461 18<28qkzoo197818>	thx
T 1709393586 18<28qkzoo197818>	!subshell
T 1709393586 18<29greybot18>	http://mywiki.wooledge.org/SubShell
T 1709393593 18<28emanuele618>	!subshell
T 1709393593 18<29greybot18>	http://mywiki.wooledge.org/SubShell
T 1709393597 18<28emanuele618>	never two without three
T 1709393606 18<25ormaaj18>	!thanks
T 1709393606 18<29greybot18>	Don't thank me, I'm a bot. Did you mean to thank greycat?
T 1709393672 18<28emanuele618>	!pastebanquine
T 1709393673 18<29greybot18>	Paste is available without ads on https://pastebin.com/r​aw/r
T 1709393673 18<19pasteban18>	Paste is available without ads on https://pastebin.com/raw/r
T 1709393697 18<27userdocss18>	!thanks
T 1709393697 18<29greybot18>	Don't thank me, I'm a bot. Did you mean to thank greycat?
T 1709393702 18<28emanuele618>	!thanks
T 1709393702 18<29greybot18>	Don't thank me, I'm a bot. Did you mean to thank greycat?
T 1709393709 18<28emanuele618>	never two without three!
T 1709393752 18<27userdocss18>	are they getting pinged fromt that?
T 1709393776 18<28emanuele618>	greycat is not online
T 1709393798 18<28emanuele618>	he does not idle
T 1709394105 18<27userdocss18>	cats are know to lurk
T 1709394131 18<27userdocss18>	it's in their nature.
T 1709394911 18<28qkzoo197818>	Can someone explain what this means barny style for me: "$*" is the IFS expansion of all positional parameters, $1 $2 $3 ...
T 1709395164 18<28qkzoo197818>	input field seperator got it
T 1709395208 18<25ormaaj18>	!yw
T 1709395208 18<29greybot18>	You're welcome, human.
T 1709395385 18<24geirha18>	!$*
T 1709395385 18<29greybot18>	The difference between $@ and $*: "$@" (quoted) expands to each positional parameter as its own argument: "$1" "$2" ... while "$*" expands to the single argument "$1c$2c..." where c is the first character of IFS. You almost always want "$@". The same goes for arrays: "${array[@]}" or "${array[*]}". Unquoted $* and $@ are nonsense; DO NOT use
T 1709396137 18<28qkzoo197818>	!help
T 1709396137 18<29greybot18>	I can do: !faq {number|string}, !pf {number|string}, !learn key value, !meta key, !metaurl key, !forget key, !searchkeys string, !factstats, !faqstats, !faqpages, !date, !version. For help with Bash builtins, use "help command" in bash.
T 1709396148 18<28qkzoo197818>	awesome
T 1709396163 18<28qkzoo197818>	learned something new
T 1709396184 18<24geirha18>	!factstats
T 1709396184 18<29greybot18>	Top factoids: pe (3069), guide (2499), nabq (2253), ls (2247), find (2049), help (1837), quotes (1826), varcap (1521), umq (1422), pm (1421)
T 1709396732 18<28emanuele618>	!no
T 1709396732 18<29greybot18>	Don't make shit up
T 1709397127 18<27userdocss18>	!thanks
T 1709397127 18<29greybot18>	Don't thank me, I'm a bot. Did you mean to thank greycat?
T 1709397724 18<28qkzoo197818>	https://pastebin.com/CdnRsZBe <-- it keeps exiting without waiting for input, any advice on what I'm doing wrong?
T 1709397724 18<19pasteban18>	Paste is available without ads on https://pastebin.com/raw/CdnRsZBe
T 1709397725 18<28checkbot18>	qkzoo1978: I think the problem is on line 17. You need spaces around the comparison operator. See 6 issues on https://shellcheck.net/?id=cb97725
T 1709397872 18<24geirha18>	res=yes_no_abort just assigns a string to a variable. Your function is never run
T 1709398407 18<28qkzoo197818>	ok, bash is bizarre. I think I getit though
T 1709398581 18<28qkzoo197818>	Is there an alternative to: yes_no_abort; result=$?        ?
T 1709398592 18<28qkzoo197818>	or is that just how its done
T 1709398615 18<24geirha18>	res=$(yes_no_abort)
T 1709398623 18<28qkzoo197818>	sweet thx
T 1709398748 18<28qkzoo197818>	that seems to return all arguments, even invalid ones
T 1709398850 18<24geirha18>	Your function doesn't take any arguments. You're not making any sense
T 1709398920 18<24geirha18>	Also, make sure you fix the errors shellcheck pointed out. Your script won't work until you do
T 1709398987 18<28qkzoo197818>	yes, I added the -r.  It keeps saying line blah >  [: too many arguments for my if statements
T 1709399110 18<28qkzoo197818>	https://pastebin.com/CdnRsZBe
T 1709399110 18<19pasteban18>	Paste is available without ads on https://pastebin.com/raw/CdnRsZBe
T 1709399134 18<28qkzoo197818>	!checkbot
T 1709399134 18<29greybot18>	checkbot is an IRC frontend for !shellcheck. It responds to !check [url/snippet], and automatically to pastebin links with selected errors (/msg checkbot quiet).
T 1709399141 18<24geirha18>	# [ hi 0 == 0 ]
T 1709399143 18<25shbot18>	geirha: bash: [: too many arguments
T 1709399151 18<24geirha18>	yep, that would do it
T 1709399161 18<28qkzoo197818>	!check https://pastebin.com/CdnRsZBe
T 1709399162 18<19pasteban18>	Paste is available without ads on https://pastebin.com/raw/CdnRsZBe
T 1709399162 18<28checkbot18>	qkzoo1978: Line 18: Double quote to prevent globbing and word splitting. Line 19: Double quote to prevent globbing and word splitting. Line 20: Double quote to prevent globbing and word splitting. See https://shellcheck.net/?id=cb99162
T 1709399190 18<24geirha18>	remove the echo hi, or make it output to stderr instead of stdout
T 1709399196 18<24geirha18>	also fix the quoting
T 1709399245 18<24geirha18>	or better, switch to [[ ]] or case instead of [ ]
T 1709399313 18<28qkzoo197818>	I was going to do that, but it was bugging me that I couldn't figure out something seemingly simple!
T 1709399383 18<24geirha18>	in general it's not a good idea to guess on bash syntax. A lot of bad guesses will happen to be valid syntax, but do something very different than intended
T 1709399415 18<28qkzoo197818>	...just when I think I'm starting to get something....bash...
T 1709399469 18<24geirha18>	bash is 50 years of bad design decisions
T 1709399478 18<28qkzoo197818>	no kidding
T 1709399505 18<24geirha18>	extremely useful, but very easy to get wrong, and it doesn't help that
T 1709399507 18<24geirha18>	!crap
T 1709399507 18<29greybot18>	The overwhelming majority of bash scripts, code, tutorials, and guides on the Internet are crap. Sturgeon was an optimist.
T 1709399556 18<28qkzoo197818>	I should probably teach myself python or something, but at some point, you have to know bash for your python script
T 1709399607 18<24geirha18>	I recommdn you read throug the BashGuide, then peruse BashFAQ and BashPitfalls
T 1709399622 18<28qkzoo197818>	Will I fall asleep reading them
T 1709399625 18<28qkzoo197818>	?
T 1709399631 18<28qkzoo197818>	!bashguide
T 1709399631 18<29greybot18>	http://mywiki.wooledge.org/BashGuide or in PDF: http://s.ntnu.no/bashguide.pdf
T 1709399640 18<28qkzoo197818>	!bashpitfalls
T 1709399657 18<24geirha18>	!pf
T 1709399657 18<29greybot18>	geirha: No matches found at https://mywiki.wooledge.org/BashPitfalls
T 1709399667 18<26goodlings818>	!ls
T 1709399667 18<29greybot18>	DO NOT USE the output of ls in scripts. Its output format is neither portable nor reliable. Use globs instead. See https://mywiki.wooledge.org/ParsingLs
T 1709399682 18<26goodlings818>	!sh
T 1709399682 18<29greybot18>	sh is NOT bash; it is a POSIX shell. To run bash code, your script MUST use a bash shebang, and it MUST be executed directly or with bash (NOT sh myscript). Sometimes /bin/sh symlinks to bash, but you can't rely on this and it will disable many bash features. <http://mywiki.wooledge.org/BashGuide/Practices#Choose_Your_Shell>
T 1709399716 18<28qkzoo197818>	is sh better than bash?
T 1709399747 18<24geirha18>	No, sh is even more painful
T 1709399761 18<28qkzoo197818>	good to know.
T 1709399852 18<28qkzoo197818>	There. Both sites bookmarked.
T 1709400351 18<28qkzoo197818>	also bookmarked shellscript thing. that a new ai tool?
T 1709400405 18<24geirha18>	Just Haskell, not AI
T 1709400745 18<24geirha18>	Hard to spot with an untrained eye, but you can tell by shellcheck not being confidently incorrect like chatgpt
T 1709401247 18<25ormaaj18>	Are you sure? Completely!
T 1709401349 18<28qkzoo197818>	cool tool just the same. it just told me to add || or exit to all my "cd's" in my script
T 1709401360 18<28qkzoo197818>	err || exit
T 1709401411 18<24geirha18>	Yes, that's very important. Valve forgot to do that in their linux installer, which ended up with wiping a couple of unlucky people's homedirs
T 1709401420 18<24geirha18>	*linux installer for steam
T 1709401481 18<24Enissay18>	I am trying to parse a yaml with yq. Using `yq '.foo | keys'  config.yaml` it gives me a list of keys with dash before... I just want to raw key names so I can loop over...
T 1709401543 18<24geirha18>	Sounds like the go implementation of yq. I only really have experience with the saner python implementation
T 1709401604 18<24Enissay18>	There's another tool ? I am using it because it was the first to popup in search
T 1709401610 18<24geirha18>	anyway, try with '.foo | keys[]'
T 1709401635 18<24Enissay18>	geirha: sadly doesnt work, I tried already :x
T 1709401661 18<24Enissay18>	`Error: bad expression, please check expression syntax`
T 1709401684 18<20osse18>	Pipe it to map() or something like that, perhaps? Ie. do the looping within yq
T 1709401722 18<24geirha18>	that's why I don't like the go version. It doesn't use jq syntax
T 1709401823 18<24geirha18>	maybe it'll accept   '.foo | keys | .[]'  ?
T 1709401949 18<20osse18>	Seems to have a bunch of operators that work on keys, at least
T 1709401996 18<24geirha18>	With https://pypi.org/project/yq/    yq -r '.foo | keys[]'    works as expected since it actually uses jq syntax
T 1709402283 18<20osse18>	Doesn't it literally use jq itself undah da h00d?
T 1709402310 18<24geirha18>	Indeed
T 1709402315 18<22phogg18>	there's a version of yaml which is a superset of json, so it well might
T 1709402326 18<24geirha18>	that way you only need to learn one jq syntax, not several dialects
T 1709402351 18<24geirha18>	there's a version of yaml that ISN'T a superset of json?
T 1709402359 18<22phogg18>	yes, yaml v1
T 1709402548 19*	Now talking on 22#bash
T 1709402548 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709402548 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709402550 18<25Lynx-18>	is it obvious why this commit: https://github.com/lynxthecat/cake-autorate/compare/master...testing increases rather than decreases processing time?
T 1709402722 18<24geirha18>	757 line diff. Sorry, but not going to read through that
T 1709402735 18<22phogg18>	geirha: 1.2 support is still unfortunately uncommon. But one day you'll be able to switch between the two schemas in one file and gain the benefits of both.
T 1709403006 18<25Lynx-18>	geirha does this time -v comparison offer any insight? https://pastebin.com/raw/fNFR1qe6
T 1709403031 18<25Lynx-18>	the newer code has about double the numebr of "Voluntary context switches:"
T 1709403391 18<25Lynx-18>	does spreading computation out amongst different backgrounded processes somehow generally reasult in reduced computation?
T 1709403593 18<22phogg18>	no, just parallel
T 1709403635 18<25Lynx-18>	I
T 1709403695 18<25Lynx-18>	I just made a restructure of my bash program that shifted processing from what was previously backgrounded to main, which removed quite a bit of duplication in terms of writes/reads since it obviated having to pass processed data from the backgrounded process to main, but surprisingly it resulted in greater computation. Is there some sort of way I can profile and work out why?
T 1709403756 18<22phogg18>	"greater computation"? Is that more CPU cycles? More wall clock time?
T 1709403878 18<25Lynx-18>	phogg more CPU cycles - https://pastebin.com/raw/fNFR1qe6
T 1709451377 19*	Now talking on 22#bash
T 1709451377 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709451377 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709462396 18<29ZAJDAN18>	hi..I want to use variable during creation of directory in this way 'mkdir /here/daily_$myvar_backup' ..but when the variable is wrapped in underlines _ it does not works
T 1709462734 18<28emanuele618>	it should be   mkdir /here/daily_"$myvar"_backup
T 1709462871 18<29ZAJDAN18>	emanuele6: thank you...works
T 1709463833 18<27xx18>	cd / && find /var/lib/dpkg/info -name '*.md5sums' -exec md5sum --check --quiet {} +
T 1709463842 18<27xx18>	any way I can execute that without having to have the cd / part?
T 1709463870 18<24xmb18>	yes remove i4 its useless cmd
T 1709463892 18<24xmb18>	remove cd / && , for just the find cmd
T 1709463904 18<27xx18>	but then it doesn't work unless I am in /
T 1709463949 18<24xmb18>	it does , its cmd find at absolte path , oh wait ur md5sum smth
T 1709463967 18<27xx18>	the md5sums files don't contain absolute path, they contain relative paths to /
T 1709463977 18<24xmb18>	try -execpath , sec ..
T 1709463996 18<24xmb18>	sry u need else , min ..
T 1709464038 18<24xmb18>	xx , i ran find , it showed absolte paths to args
T 1709464061 18<24xmb18>	eg i tried find ../usr/bin it all showed ../usr/bin/ paths
T 1709464102 18<24xmb18>	there is a -exexdir opt to exec in same dir as found
T 1709464116 18<27xx18>	well it doesn't work, so I'll rephrase my question - can I make `find` switch to some different $PWD ?
T 1709464150 18<27xx18>	I guess I can make it all run in a subshell so that I don't need to cd back
T 1709464159 18<24xmb18>	thats simple ye
T 1709464208 18<24xmb18>	( cd && find )
T 1709464288 18<26lopid18>	what you mean is "i want find's files output prefix to be …"?
T 1709464313 18<24xmb18>	=)
T 1709464321 18<26lopid18>	not "how can i run this without doing that"?
T 1709464380 18<22phogg18>	xx: you could cd beore each invocation of md5sum instead, but it's strictly better to change before running find. A subshell works, but you could also pushd && find && popd
T 1709464427 18<27xx18>	yeah a subshell it is then, thanks
T 1709464485 18<24xmb18>	fs question , if id chmod a-rwx / , are /home users blocked or smth ?
T 1709464504 18<22phogg18>	sm1999: you will break your system very badly, don't do that
T 1709464512 18<22phogg18>	er, xmb I mean, sorry
T 1709464519 18<22phogg18>	weirdest failed tab complete
T 1709464526 18<24xmb18>	yea thats why i ask
T 1709464570 18<24xmb18>	i look from security against hacks point
T 1709464590 18<22phogg18>	xmb: your question seems to imply that it will specifically break access to home dirs for users. I will do a lot worse than tha.
T 1709464628 18<24xmb18>	yea i ask , if itd break /home users
T 1709464635 18<22phogg18>	xmb: no, it will not do that
T 1709464642 18<22phogg18>	xmb: it will break E V E R Y T H I N G
T 1709464657 18<24xmb18>	i got a good idea , i try on windows wsl debian , safe thing to re-install
T 1709464671 18<24xmb18>	ok everything , ...
T 1709464686 18<24xmb18>	very good , =p ill have to try
T 1709464703 18<22phogg18>	there's no point in even trying it. You are removing x from directories for root, so even root can't traverse them. You are removing x on all files even for root, so even root can't execute any processes
T 1709464724 18<24xmb18>	i dont think root will fail
T 1709464728 18<24xmb18>	or would it
T 1709464732 18<22phogg18>	of course it would
T 1709464743 18<24xmb18>	hm then cant do ye
T 1709464780 18<24xmb18>	oh removing x makes bins break
T 1709464785 18<24xmb18>	thxx++ mate
T 1709464800 18<22phogg18>	This is a Whole Hawg situation. Welcome to Unix, safety is not guaranteed.
T 1709464814 18<22phogg18>	s/Whole/Hole/
T 1709464835 18<24xmb18>	common with todays world , not guaranteed whats asked for ,  =)
T 1709464911 18<22phogg18>	no, it will do exactly what you asked for
T 1709464916 18<22phogg18>	maybe not what you *wanted*
T 1709464953 18<24xmb18>	ah ye similiar case , my english is only basic
T 1709464990 18<24xmb18>	but , i actually asked for a-rwx , .. i didnt plan on changing u or g
T 1709465001 18<24xmb18>	so root may still work ?
T 1709465284 18<24xmb18>	oh a = all and e i meant everyone else .. ?
T 1709465297 18<24xmb18>	uge oe uga
T 1709465368 18<24xmb18>	or* sry
T 1709465470 18<24xmb18>	u root wrx g root same , .. wont work ?
T 1709466580 18<25ormaaj18>	directory perms don't affect being able to execute things. It'll break your PATH lookups.
T 1709467343 18<28emanuele618>	ormaaj: well, not if you are root, but as a regular user if you don't have x permissions on a directory you won't be able do anything with the files in that directory or its subdirectories; you will only be able to see the file names of the files in the directory if you also have r permissions
T 1709467930 18<22militantorc18>	i like when you have x but no r
T 1709467942 18<22militantorc18>	seen in some androids
T 1709470563 18<22phogg18>	xmb: yes, a is all. What did you mean? I presume you meant o, for "other" aka world permission. If you do chmod -R o-rwx / the system probably won't entire;y break, but you will probably mess up permissions on /tmp
T 1709471768 18<24xmb18>	phogg , i meant u and g root normal , only the third field there -rwx , and only on / , no subs
T 1709478191 18<25kurahaupo18>	phogg: why suggest pushd / && find … && popd when that's less reliable than ( cd / && exec find … )
T 1709478377 18<25kurahaupo18>	(both popd and cd - can fail in various ways; the simplest is "permission denied"
T 1709478382 18<25kurahaupo18>	)
T 1709523463 19*	Now talking on 22#bash
T 1709523463 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709523463 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709523580 19*	Now talking on 22#bash
T 1709523580 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709523580 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709526741 18<22loganlee18>	hello. `find / -maxdepth 3 \( -path /dev -o -path /run -o -path /tmp -o -path /home/lost+found -o -path /root -o -path /lost+found -o -path /boot/efi \) -prune -o -type f -user logan -group logan -iname 'todo.sh' -print` here why is \( ... \) -prune -o ... and not \( ... \) -prune -a ...?
T 1709527084 18<27larryv18>	if it were -a then you would be telling find to print paths that satisfy every condition listed, which is not possible.
T 1709527356 18<22loganlee18>	larryv, if i change to \( ... \) -prune -a ... it gives not results
T 1709527363 18<22loganlee18>	no results*
T 1709527381 18<27larryv18>	yeah. as i just said, the resulting condition is impossible to satisfy.
T 1709527414 18<22loganlee18>	yep i think exclusion condition -o inclusion condition is valid but not exclusion condition -a inclusion condition?
T 1709527449 18<27larryv18>	i won't confirm such an overbroad statement.
T 1709527455 18<27larryv18>	just look at what you'd be asking
T 1709527464 18<27larryv18>	a path cannot both be e.g., /dev AND have a name todo.sh
T 1709527524 18<22loganlee18>	yep
T 1709527591 18<22loganlee18>	thanks a lot
T 1709527608 18<27larryv18>	mhm
T 1709527707 18<22loganlee18>	i'll ask again later after some further study. thanks a lot larryv
T 1709527717 18<27larryv18>	np
T 1709527725 18<22pj18>	If you read the find docs the example given for -prune explicitly uses -o
T 1709527733 18<22tirnanog18>	https://pubs.opengroup.org/onlinepubs/9699919799/utilities/find.html
T 1709527739 18<22tirnanog18>	it shall always evaluate as true.
T 1709527747 18<22loganlee18>	ok
T 1709527890 18<22pj18>	well, since -prune always returns true then one would think it shouldn't matter if the condition is -a or -o, but since the docs say to use -o I would just use that and not worry about it.
T 1709527962 18<22tirnanog18>	that's precisely why it matters.
T 1709527980 18<22pj18>	oh I think I get it
T 1709527982 18<27larryv18>	it matters because with -a and -print at the end, all the primaries have to be true simultaneously to ever print anything
T 1709527983 18<22tirnanog18>	upon -prune being reached and its effect applied, that which follows must surely be an alternative.
T 1709527995 18<22tirnanog18>	it does more than just be true, after all.
T 1709527997 18<22pj18>	if the preceding conditions return false then it short-circuits the -prune.
T 1709528019 18<22tirnanog18>	yes. all primaries are joined by an implicit -a where neither -a nor -o is given.
T 1709528054 18<22pj18>	so prune may return true, but only if it reaches -prune.
T 1709528072 18<22tirnanog18>	yes.
T 1709528074 18<22pj18>	which it won't if the -path conditions aren't satisfied.
T 1709528128 18<22pj18>	loganlee: does this help? ^^^^^^
T 1709528199 18<22loganlee18>	pj, i'm a little tired today. i'll have a look at it later. :D
T 1709536002 18<27chomwitt18>	Why a glob's wild chars can not match a '/' but using globbing in other commands , like for example in debian's dpgk-query --search' can ?
T 1709536549 18<20bent_fingers18>	loganlee: i used to think the same thing.
T 1709536600 18<28emanuele618>	then you tried drinking coffee and now you are not tired anymore
T 1709536617 18<27larryv18>	chomwitt: what dpkg-query does is not globbing
T 1709536641 18<24ano18>	there is no such a thing as glob(bing) std/spec, glob(bing) mostly mean https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_13 but it can be anything
T 1709536670 18<28emanuele618>	cool link
T 1709536687 18<27larryv18>	chomwitt: you're really comparing filename generation/expansion to pattern matching. the former has extra restrictions over general pattern matching
T 1709536694 18<27chomwitt18>	larryv: so dpkg-query doesnt it's own expansion ?
T 1709536704 18<27chomwitt18>	/s/doesnt/does
T 1709536712 18<27larryv18>	chomwitt: it's not doing filename expansion at all
T 1709536744 18<27larryv18>	not as understood in the shell language, at any rate
T 1709536780 18<28emanuele618>	* ? [] does not match / mostly because the glob is compared against a file name, not an entire path; however if you use the glob patter in case  case $var in *a*) ;; esac   or [[ $var == *a* ]]   then * will be able to match /
T 1709536830 18<27chomwitt18>	larryv: so dpkg-query does on its own a search on the space of all installed files and the similarity to unix shell glob is that is using glob like wildchars ?
T 1709536855 18<27larryv18>	more or less
T 1709536884 18<27larryv18>	like emanuele6 just said, even the shell itself uses patterns in slightly different ways
T 1709537012 18<27chomwitt18>	emanuele6: so that is like having relative meaning according to the context used . Is that behavior documented somewhere ?
T 1709537037 18<27larryv18>	https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_13_03
T 1709537070 18<28emanuele618>	you don't even have to think of it as working differently in different context; the glob pattern is matches against the file name which will not contain a /
T 1709537167 18<27larryv18>	yeah but there's also other stuff like initial '.' having to be matched explicitly
T 1709537187 18<28emanuele618>	also that  *  cannot match an empty string when the entire glob is *
T 1709537201 18<28emanuele618>	e.g.  /usr/bin/*/bash    cannot match /usr/bin//bash
T 1709537243 18<28emanuele618>	because it actually compares * against the file names of the files in /usr/bin/ which will not contain any file with a empty name, because those cannot exist
T 1709537283 18*	27chomwitt thanks for the clarification , insights and the opengroup link larryv and emmanuelux
T 1709537341 18<28emanuele618>	thank you for thanking emmanuelux, i always think they are underappreciated
T 1709537359 18<27colo18>	:D
T 1709537376 18<27larryv18>	is that your evil twin
T 1709537388 18<27colo18>	or maybe the good twin?
T 1709537393 18<27larryv18>	:O
T 1709537412 18<28emanuele618>	maybe; i had a vanishing twin, maybe that is where it has gone :o
T 1709537541 18<27chomwitt18>	emanuele6: sorry!
T 1709537578 18*	27chomwitt thanks emanuele6 .
T 1709537629 18<24ano18>	does anyone use less as pager at daily basis? looks like lesspipe.sh and gentoo builtin lessopen are awful
T 1709537947 18<20bent_fingers18>	ano: everyone uses less
T 1709538051 18<20cappy18>	bent_fingers: less is more but cat is a bat with wings and it flies circles around less, at least for this guy.
T 1709538079 18<20bent_fingers18>	chomwitt: please consider the plight of he who serves you https://www.givesendgo.com/GBH2M
T 1709538152 18<20bent_fingers18>	ano: you can fix that, and yes, it's awful
T 1709538160 18<24ano18>	fat bat
T 1709538199 18<20cappy18>	s/bat is a cat.../
T 1709538270 18<28emanuele618>	bats are not flying felines; that is a common misconception
T 1709538404 18<20cappy18>	emanuele6: Yes, truly. But seriously, I've found the bat(1) pager far superior with its language syntax highlighting.
T 1709538506 18<20bent_fingers18>	i'm colorblind. doesn't matter to me
T 1709538551 18<20cappy18>	Perhaps ano is not?
T 1709538569 18<20bent_fingers18>	i open my texts with less, press f, and i'm good
T 1709538578 18<20bent_fingers18>	sometimes i press /
T 1709538608 18<20bent_fingers18>	not much else to it really
T 1709538660 18<28emanuele618>	i use the occasional ?
T 1709538663 18<20bent_fingers18>	cappy: perhaps he's eyeless?
T 1709538687 18<28emanuele618>	either that or bat eyesight
T 1709538698 18<20cappy18>	That could make for difficult debugging of a missing quote here and there.
T 1709538905 18<20cappy18>	bat automatically pipes its output through a pager (by default: less).  So the foundation remains viable.
T 1709538940 18<28emanuele618>	how much does it cost?
T 1709538962 18<20bent_fingers18>	were any bats harmed in it's making?
T 1709538962 18<20cappy18>	It's in the debian repo.
T 1709538999 18<28emanuele618>	oh, i don't use debian
T 1709539002 18<20cappy18>	DEB package bat-musl
T 1709539048 18<20cappy18>	emanuele6: https://github.com/sharkdp/bat
T 1709539051 18<20bent_fingers18>	sounds like a lot of piping when you use bat
T 1709539068 18<20bent_fingers18>	he can't access that
T 1709539085 18<20bent_fingers18>	cappy: consider helping  https://www.givesendgo.com/GBH2M
T 1709539094 18<28emanuele618>	wow advertisements in the readme file :o
T 1709539104 18<24ano18>	bat will cost ~3MB of rusty bloatness
T 1709539117 18<28emanuele618>	ano: how much does that cost?
T 1709539127 18<28emanuele618>	i heard rust is free
T 1709539160 18<20bent_fingers18>	could be
T 1709539174 18<28emanuele618>	rust removal however... quite expensive
T 1709539175 18<20bent_fingers18>	some things are free out there, after all
T 1709539217 18<28emanuele618>	i installed bat
T 1709539228 18<28emanuele618>	and printed out a .bat file with it
T 1709539237 18<28emanuele618>	fancy colours
T 1709539268 18<28emanuele618>	it is using a salmon colour to highlight "echo"
T 1709539296 18<19sphertext18>	does any body have a suggestion for a good sed tutorial?
T 1709539297 18<24ano18>	think free as in "free coc", not "free memory"
T 1709539311 18<20bent_fingers18>	atlantic pink salmon, to be precise
T 1709539318 18<20cappy18>	emanuele6: try --list-themes and --list-colors
T 1709539323 18<28emanuele618>	highlight -Oansi uses the regular green colour, not special truecolour
T 1709539335 18<20cappy18>	sorry --list-languages
T 1709539354 18<20bent_fingers18>	sphertext: the one in the title of #sed
T 1709539362 18<28emanuele618>	hmm. i ran  --list-themes  and it dumped a bunch of text; not what i would expect from a pager
T 1709539384 18<28emanuele618>	unbuffer bat --list-themes | less -R   to the rescue...
T 1709539410 18<28emanuele618>	needed to unbuffer, or bat --list-themes just outputs the theme names separated by newline
T 1709539420 18<20bent_fingers18>	this is nerve wracking
T 1709539421 18<20cappy18>	Ha. bat --list-themes | bat
T 1709539425 18<19sphertext18>	bent_fingers oh hmm.. i had that saved in my bookmarks, don't remember where i got it from. i was going to use it, but i checked the one about find on the same website and it didn't seem very comprehensive. so i assumed the sed one maybe isn't either
T 1709539432 18<28emanuele618>	cappy...
T 1709539440 18<28emanuele618>	why are you being so mean? D:
T 1709539447 18<28emanuele618>	with the wrong suggestions D:
T 1709539463 18<20cappy18>	Not mean at all.
T 1709539463 18<28emanuele618>	i just told you that will list only the theme names
T 1709539472 18<20bent_fingers18>	will emanuele6 like the app or not? we're sitting on our seats biting our nails in anticipation of the oucome
T 1709539472 18<24ano18>	sphertext: chk #sed /topic
T 1709539482 18<19sphertext18>	ano i just replied to that
T 1709539500 18<19sphertext18>	i guess if multiple ppl say it's good i should check it
T 1709539507 18<28emanuele618>	also even if you use   unbuffer bat --list-themes | bat    that messes up the colours because it re-highlights the text
T 1709539526 18<28emanuele618>	unbuffer bat --list-themes | less -R   is just better to see look at the themes
T 1709539594 18<20cappy18>	emanuele6: Yeah, hadn't tried that. But the language list is extensive and works well for bash.
T 1709539603 18<20bent_fingers18>	ano: i told him that already. you can't snatch my kudos from me
T 1709539611 18<28emanuele618>	mean suggestion :(
T 1709539628 18<20bent_fingers18>	i need 997 more kudos to gain immunity from channel banning
T 1709539630 18<28emanuele618>	there is an  ansi  theme to use standard colours instead of truecolors
T 1709539712 18<28emanuele618>	bat --theme=ansi foo.bat   now echo is purple :o
T 1709539722 18<28emanuele618>	err, magenta
T 1709539731 18<28emanuele618>	the same colours as cappy's nickname in weechat :D
T 1709539763 18<20bent_fingers18>	sphertext: multiple people also believed influenza wsa influenced by the stars
T 1709539811 18<20bent_fingers18>	but i wouldn't recommend communing with them in hopes of alleviating any future illness that unhappily visits upon you
T 1709539814 18<19sphertext18>	my 16 ansi theme in my terminal is 15 shades of grey + one shade of red
T 1709539825 18<28emanuele618>	ew
T 1709539860 18<19sphertext18>	i find that collapsing the dimensionality of visual design spares my cognitive resources which are limited
T 1709539875 18<28emanuele618>	wow, upgrade your brain?
T 1709539888 18<28emanuele618>	lol
T 1709539907 18<20bent_fingers18>	mine is black, white, red, and blue for the 16
T 1709539911 18<28emanuele618>	doesn't that just make colours harder to differenciate?
T 1709539928 18<19sphertext18>	https://0x0.st/HdcG.png
T 1709539932 18<28emanuele618>	s/differenciate/differentiate/ i know how to spell
T 1709539952 18<28emanuele618>	sphertext: i don't even know how many colours you are showing
T 1709539953 18<19sphertext18>	no, i find it's actually sufficient
T 1709539963 18<19sphertext18>	15 colors
T 1709539973 18<19sphertext18>	the red is omitted and left as an exercise of imagination for the beholder
T 1709539975 18<28emanuele618>	you didn't reduce the number of colours, you just made them harder to differenciate
T 1709539996 18<19sphertext18>	no, i reduced the dimensionality of visual information
T 1709540002 18<28emanuele618>	there are clearly different shades, there; but i cannot easily tell if shades that are far apart are different or not
T 1709540015 18<19sphertext18>	i can tell the shades apart, easily
T 1709540036 18<28emanuele618>	wow
T 1709540040 18<28emanuele618>	impressive
T 1709540075 18<19sphertext18>	when there's information across the hue dimension as well, i find it distracting
T 1709540078 18<20bent_fingers18>	and yet we still are left on edge over the verdict of whether or not bat wins approval
T 1709540087 18<19sphertext18>	i need more mental effort to process it
T 1709540121 18<28emanuele618>	with that colour palette for sure
T 1709540126 18<19sphertext18>	which leaves means mental energy for other things
T 1709540134 18<19sphertext18>	* less
T 1709540136 18<20bent_fingers18>	you can see color but choose not to do so?
T 1709540137 18<28emanuele618>	lol
T 1709540141 18<20bent_fingers18>	what in the world?
T 1709540175 18<19sphertext18>	hue is a redundant dimensions of visual representation
T 1709540221 18<20bent_fingers18>	i agree
T 1709540236 18<20bent_fingers18>	we should all have surgery and become monochromatics
T 1709540247 18<19sphertext18>	i still use 1 shade of red
T 1709540253 18<20bent_fingers18>	black & white forever!
T 1709540254 18<19sphertext18>	it's the only one that has a semantic justification
T 1709540311 18<20bent_fingers18>	when i have a child, if he or she or whatever can see color, i'm dropping it off at the fire station
T 1709540355 18<19sphertext18>	my desktop wallpaper is pitch black
T 1709540366 18<20bent_fingers18>	my child can only see black and white, damn the reduntant dimensions! damn them all!
T 1709540368 18<19sphertext18>	like the abyss of existence
T 1709540499 18<28emanuele618>	my desktop wallpaper is https://commons.wikimedia.org/wiki/File:Cow_Moos_-_geograph.org.uk_-_1885583.jpg
T 1709540514 18<19sphertext18>	exhausting
T 1709540535 18<20bent_fingers18>	pastroal
T 1709540539 18<20bent_fingers18>	pastoral
T 1709540542 18<20bent_fingers18>	idyllic
T 1709540563 18<19sphertext18>	anyway i'm not a psycho, i actually run this in a window constantly on one of my screens https://www.youtube.com/watch?v=VZUkuY3oo2k
T 1709540564 18<20bent_fingers18>	Van Goph would have been proud
T 1709540664 18<20bent_fingers18>	sphertext: i'm not convinced
T 1709540722 18<19sphertext18>	i wrote a bash script that starts that video every day. i'm vaguely using it to regulate my circadian rhythm
T 1709541295 18<26razamatan18>	an encrypted loopback file mounting bash alias (on smartos [illumos]) used to work fine to have a nested command that prompted for a decrypting password, but oddly, something changed that it no longer blocks for user input for the password
T 1709541317 18<26razamatan18>	would this be bash or the password prompting command?
T 1709541696 18<24geirha18>	a bit odd to pack that much logic into an alias. I would use a function. Anyway, no generic answer to your question. It depends on what exactly it runs, and in what context
T 1709541715 18<26razamatan18>	are you familiar w/ the lofiadm command in solaris?
T 1709541769 18<26razamatan18>	it's really not that bad.. the alias is just: mount $(lofiadm -c aes-256-cbc -a /path/to/enc/file) /mnt/path
T 1709541827 18<24geirha18>	if lofiadm uses the tty on stdin to read password, that should work. I'd add the missing quotes though
T 1709541831 18<26razamatan18>	the lofiadm returns the /dev/ path to the loopback device holding the unencrypted file handle after getting the password to unlock
T 1709541850 18<26razamatan18>	(i have the quotes, i just retyped from memory)
T 1709541926 18<26razamatan18>	the odd thing is, it works fine if i reorder the commands (and explicitly set the /dev device path which makes the whole thing a bit more brittle: lofiadm -c aes-256-cbc -a /path/to/en/file /dev/lofi/2 && mount /dev/lofi/2 /mnt/path
T 1709541984 18<26razamatan18>	again, the original version used to work fine prior to doing a system upgrade (so it's hard to tell what is causing issues)
T 1709542471 18<24geirha18>	See what it shows when you enable xtrace (set -x):  (set -x ; youralias)
T 1709542567 18<24geirha18>	oh and, if you run the same  lofiadm command as you do inside the command subsittution, it still asks for password? (i.e. without specifying the lofi dev)
T 1709542590 18<26razamatan18>	it correctly does the nested lofiadm as the first command, and does the bad behavior of asking for the password 4 times without actually blocking for the read
T 1709542627 18<26razamatan18>	the behavior is that it just keeps prompting the full retry count (i think 4 based on what i'm seeing) and failing
T 1709542677 18<24geirha18>	printf '<%s>\n' "$(read -rp "type something: " var && printf %s "$var")
T 1709542683 18<24geirha18>	does that one wait for input?
T 1709542719 18<26razamatan18>	should i just cut and paste that in a live prompt, or put that in an alias?
T 1709542750 18<24geirha18>	alias shouldn't really affect it, but try both just to be sure
T 1709542789 18<24geirha18>	oh and it's missing the closing " at the very end there
T 1709542793 18<24geirha18>	printf '<%s>\n' "$(read -rp "type something: " var && printf %s "$var")"
T 1709542816 18<26razamatan18>	i had to switch it up to: printf '<%s>\n' "$(read -rp 'type something: ' var && printf %s \$var)"
T 1709542822 18<26razamatan18>	and it did prompt correctly
T 1709542912 18<26razamatan18>	https://github.com/illumos/illumos-gate/tree/b70bf3ee79d81df3ccc36e553e0ff11049a2b51a/usr/src/cmd/lofiadm
T 1709542925 18<24geirha18>	well, sounds like lofiadm is the one that has changed behavior somehow. It should definitely have the same ability as that read to read from the tty
T 1709542937 18<26razamatan18>	ok.. :/
T 1709542944 18<26razamatan18>	i'll follow up w/ the illumos folks
T 1709543126 18<26razamatan18>	geirha: thanks..
T 1709543174 18<27Soliton18>	having to change that code seems suspicious...
T 1709546167 18<19Clocked18>	Hi! When I need the last 3 parts of this-is-a-sting-where-I-need-to-get-1-2-3 should I do this with 3 times ${string##*:-} and glue it back together or use cut/awk/or so ?
T 1709546219 18<20osse18>	Clocked: is the part you want always numbers and the rest never numbers?
T 1709546243 18<19Clocked18>	osse nope otherwise it would have been easy indeed
T 1709546316 18<27Soliton18>	# string=this-is-a-sting-where-I-need-to-get-1-2-3; echo "${string#"${string%-*-*-*}"-}"
T 1709546319 18<25shbot18>	Soliton: 1-2-3
T 1709546352 18<19Clocked18>	oh yeah in this case that would be possible!
T 1709546372 18<19Clocked18>	I thought such inner was never possible
T 1709546756 18<27Earnestly18>	Clocked: It is in the parameter section of parameter expansion, but not in the expansion part
T 1709546788 18<19Clocked18>	indeed!
T 1709547501 18<24xmb18>	# s() { for s ; do printf %s\\t "${s#${s%%+(-+([0-9]))}-}" ; done ; } ; s a-b-c-1-2-3-4 1-d-e-8-2 a-8-b-9-7
T 1709547503 18<25shbot18>	xmb: 1-2-3-4 8-2     9-7
T 1709547702 18<19Clocked18>	nice!
T 1709547759 18<19mawk18>	what's the command from detaching a background job?
T 1709547764 18<19mawk18>	I have a void
T 1709547796 18<27Soliton18>	perhaps you mean disown.
T 1709547804 18<19mawk18>	aaaaaa disown yes
T 1709547805 18<19mawk18>	thanks
T 1709547879 18<19mawk18>	^Z; bg; disown
T 1709547891 18<19mawk18>	it doesn't work on all programs though for some reason
T 1709547895 18<19mawk18>	I guess it's when they mess up the terminal
T 1709547961 18<19mawk18>	and we can always stop them from another terminal, as SIGSTOP cannot be caught
T 1709555614 18<24RhineDevil18>	I need to define a config file containing a structure for "objects" whose data I'll dispatch in multiple associative arrays. In order to do so I'd like to use a proper config file format, easy to edit and that also can refer to some internal variables defined by the script. What could I do?
T 1709555679 18<28emanuele618>	dconf
T 1709555778 18<29fb`18>	redirecting a long running stdout through a fifo to netcat. need it to not block script execution. script eventually blocks on a full output buffer
T 1709556022 18<27Soliton18>	perhaps you can ask your os for a bigger pipe size.
T 1709556037 18<25ormaaj18>	prod the reader and tell it to get busy. Either don't let it fill or don't write to a pipe
T 1709556065 18<25ormaaj18>	Or use nonblocking or polled i/o which shell doesn't really support.
T 1709556209 18<29fb`18>	stdbuf has not helped. script is designed to be unattended, as in a reader may or may not connect to drain the buffer
T 1709556238 18<27Soliton18>	how is that design supposed to work in practice?
T 1709556263 18<27colo18>	"named pipes considered footguns"
T 1709556366 18<29fb`18>	in practice the output can top out around 1MB. script blocks around 132K which has been an issue
T 1709556401 18<27Soliton18>	# cat /proc/sys/fs/pipe-max-size
T 1709556403 18<25shbot18>	Soliton: 1048576
T 1709556437 18<27Soliton18>	sounds like you should ask your os for a bigger pipe.
T 1709556460 18<27Soliton18>	you could also use pv -B as an additional buffer.
T 1709556586 18<29fb`18>	tried pv, still blocks ~132K. pipe-max-size is ~1MB
T 1709556667 18<27Soliton18>	so set your pipe to that size.
T 1709556759 18<27colo18>	what exactly causes the nc process involved not to send off the data to its TCP peer?
T 1709556788 18<29fb`18>	environment is limited doesn't have perl, for example to run fcntl
T 1709556834 18<29fb`18>	a tcp peer may not connect, it's an optional output
T 1709556994 18<29fb`18>	considering a watchdog to detect blocking. it would connect a local dummy peer to and flush the buffer
T 1709557324 18<24RhineDevil18>	emanuele6: I'd prefer a config file format parsable by native bash
T 1709557362 18<24RhineDevil18>	Or by standard tools
T 1709557480 18<28emanuele618>	as opposed to foreign bash
T 1709557512 18<29fb`18>	RhineDevil a config file formatted like a shell script with simple key-value variables wouldn't work? values could be post-processed with cli tools
T 1709559527 18<24RhineDevil18>	fb`: That was my initial idea, but if it's a standard format even better
T 1709559622 18<24RhineDevil18>	In general I'd want either a standard format or something easily parseable for my objective (organized key/value pairs representing fictional objects), with preference for standard format
T 1709559634 18<29fb`18>	maybe xml, yaml, or json then? a tool like this can read/write: https://github.com/mikefarah/yq
T 1709559748 18<24geirha18>	A better yq implementation at   https://github.com/kislyuk/yq
T 1709559982 18<24RhineDevil18>	fb`: As said before I'd use these formats only if they're parseable from bash and standard tools
T 1709560026 18<24RhineDevil18>	Since I'm making a tool that should be generally usable as long you have bash and basic tools like jq I don't wanna request weird dependencies users will have problems in installing
T 1709560066 18<29fb`18>	standard tools defined as.. what your package manager can installer? basic posix commands?
T 1709560075 18<29fb`18>	*install
T 1709560085 18<24RhineDevil18>	basic posix commands
T 1709560100 18<24RhineDevil18>	As now requested dependencies are aapt find gawk sed jq zstd grep
T 1709560110 18<24geirha18>	jq is certainly not posix
T 1709560113 18<24geirha18>	nor gawk or zstd
T 1709560142 18<24RhineDevil18>	They're generally available also originally it wasn't my work
T 1709560150 18<27Soliton18>	but since you apparently already use jq what is even the question...
T 1709560177 18<24RhineDevil18>	Soliton: would be a mess writing a config file for all packages in json...
T 1709560183 18<24RhineDevil18>	Imagine mantaining the package list
T 1709560207 18<24RhineDevil18>	I mean there's a reason why people use stuff like toml and yaml instead of json
T 1709560214 18<20osse18>	how about using bash syntax for the file? read the file by sourcing it and update it by declare -p
T 1709560219 18<27Soliton18>	but you don't want to...
T 1709560220 18<29fb`18>	uhm, tell nodejs devs that
T 1709560291 18<24RhineDevil18>	osse: I remember I've read in this chat a better solution that did exactly this but with parsing instead of sourcing
T 1709560365 18<24RhineDevil18>	fb`: I use javascript only cause I'm forced by circumstances and I think the world would be better if it wasn't invented
T 1709560431 18<29fb`18>	fair enough. so you prefer bash instead?
T 1709560452 18<24RhineDevil18>	No
T 1709560468 18<24RhineDevil18>	Or I mean
T 1709560472 18<24RhineDevil18>	Depends on the task
T 1709560570 18<24RhineDevil18>	So anyway, approved solution is bash-like config file. But wasn't there a way for including just variables instead of code?
T 1709565207 18<24OnlineCop18>	Within a local git repo, I'm usually okay doing `grep 'PATTERN' $(git ls-files)` to limit my searches to only checked-in files, except in a few cases where those files contain spaces or special characters. Do I have to modify IFS, or assign all $(git ls-files) results to an array, in order to do something like this, or is there an alternate command/method I could use?
T 1709565244 18<28emanuele618>	hmm, git grep
T 1709565288 18<27Soliton18>	yeah, use git grep. your current approach is broken and cannot be fixed.
T 1709565317 18<24OnlineCop18>	I just thought of `git grep` after I wrote that... that may be what I'll end up doing. :) Thanks, both.
T 1709565329 18<28selckin18>	git ls-files -oc --exclude-standard | ack -x
T 1709565350 18<22ash_worksi18>	sometimes I want to write a blob of crap to sed or awk. I use heredocs for this, but it pollutes the command history; so I thought of just using stdin, (eg `awk '1' -`) but the result will interweave lines because it doesn't wait for me to finish (eg with ^D)
T 1709565401 18<22ash_worksi18>	is there a way to get a program to wait for my to finish? ... like what happens when you do `foo="$(cat)"`
T 1709565592 18<22ash_worksi18>	I guess `echo "$(cat)" | awk`
T 1709565593 18<27JanC18>	'sponge' from moreutils ?
T 1709565598 18<25greycat18>	if you simply do    foo; bar   bar won't run until foo exits
T 1709565623 18<22ash_worksi18>	oh
T 1709565695 18<27JanC18>	https://manpages.org/sponge
T 1709565719 18<25greycat18>	I would avoid sponge.  It's not safe (data can be lost).
T 1709565793 18<25greycat18>	!sponge
T 1709565793 18<29greybot18>	sponge() ( tmp=$(mktemp) && cat > "$tmp" && cat -- "$tmp" > "$1" && rm -- "$tmp"; ) # read and write the same file in a pipeline: grep -v '^#' file | sponge file
T 1709565867 18<27JanC18>	lost in what way?
T 1709565875 18<22ash_worksi18>	greycat: hmm. in `awk; echo`, awk waits, but it still processes each line after hitting enter so you get an AA'BB' effect if you write lines interactively
T 1709565920 18<26KillerWasp18>	JanC: maybe he want write a big documentation and don't exist Ctrl+S
T 1709565932 18<25greycat18>	People usually want to do something like the man page's example (sed '...' file | grep '...' | sponge [-a] file) but this will truncate the file before writing to it.  If the system crashes during that write, the original data's gone.
T 1709565959 18<27JanC18>	for anything that isn't throwaway you would just use a real file, no?
T 1709565985 18<25greycat18>	You want to write to a new/temp file and only replace the original once the writing is done.
T 1709566001 18<25greycat18>	ash_worksi: I have no idea what you're doing.
T 1709566006 18<27JanC18>	this would be writing to stdout
T 1709566014 18<27JanC18>	not a file
T 1709566030 18<27JanC18>	if I undestand ash_worksi correctly
T 1709566045 18<26KillerWasp18>	sponge() ( cat > "$1.temp" && cat -- "$1.temp" > "$1" && rm -- "$1.temp"; )
T 1709566086 18<26KillerWasp18>	now is more secure, not Ctrl+S, it's always saved.
T 1709566150 18<22ash_worksi18>	JanC: that is correct and the input is not a file, it just my fingers... or pasting
T 1709566185 18<27JanC18>	but ash_worksi wants something like: sponge | grep foo
T 1709566212 18<22ash_worksi18>	In this particular case, I wanted to add few lines of spacing to my paste.
T 1709566213 18<27JanC18>	well, with sed or awk instead of grep  :)
T 1709566235 18<25greycat18>	I can't tell what they want at all.  Is it something like "I type a command and it takes a while to run, which catches me by surprise, because I'm already typing the next command, and now the output of the first command and my typing of the second command are all jumbled"?
T 1709566297 18<27JanC18>	yes, that's what ash_worksi mentioned: "but the result will interweave lines because it doesn't wait for me to finish"
T 1709566322 18<27JanC18>	they mean "interweave input & output", I suppose
T 1709566341 18<25greycat18>	you think they're running an *interactive* command?
T 1709566346 18<27JanC18>	yes
T 1709566355 18<22ash_worksi18>	yes to all of that
T 1709566371 18<27JanC18>	based on "but it pollutes the command history"
T 1709566384 18<25greycat18>	... I'm totally lost.
T 1709566388 18<27Soliton18>	you could disable the terminal echo.
T 1709566389 18<27JanC18>	that would not happen in a script...
T 1709566413 18<27JanC18>	they want to see input & output, I'm sure
T 1709566594 18<27JanC18>	ash_worksi: when this is just text from the "clipboard" (without manual editing & where you don't need to see the source), another option might be to use a utility that reads data directly from there instead of pasting it...
T 1709566741 18<22ash_worksi18>	JanC: the copied source is an interactive docker container that doesn't have access to the awk script; I could add it, but it's torn down frequently enough to be a nusance and infrequent enough not to added it to a new image
T 1709566811 18<27Soliton18>	pretty sure they mean  xclip | awk  or similar.
T 1709566850 18<22ash_worksi18>	oh
T 1709566935 18<22ash_worksi18>	I'm surprised greycat gave me the time of day on that question. I figured they'd think, "whatever they're trying to do is too stupid for me to engage"
T 1709566974 18<22ash_worksi18>	they must be in a pretty generous mood.
T 1709567156 18<27JanC18>	xclip only works for X11, on wayland you'd need wl-paste or something like that I think
T 1709567210 18<27JanC18>	or an appropriate clipboard tool for whatever else your system uses  :)
T 1709567666 18<22ash_worksi18>	thanks for the help, and also interpretation JanC
T 1709569849 18<24RhineDevil18>	Do I remember uncorrectly or there was a placeholder technique for config files where you placed a placeholder and then you could substitute it with a variable before echoing it?
T 1709569859 18<24RhineDevil18>	Without sourcing of course
T 1709569878 18<27Soliton18>	!template
T 1709569878 18<29greybot18>	http://mywiki.wooledge.org/TemplateFiles
T 1709570019 18<27Soliton18>	if you're blindly injecting into shell code that is not a good idea of course.
T 1709570613 18<22ash_worksi18>	RhineDevil: nginx containers use `envsubst`
T 1709570663 18<22ash_worksi18>	I just realized that's on that page Soliton linked anyway
T 1709573310 18<29luva18>	Hello, I want to write a bash script that does a backup. In that bash script, I want to just for every DNS lookup use a specific nameserver, since it needs to use a private one, without setting one in the OS. Can someone help me on how to do it?
T 1709573501 18<27Soliton18>	sounds like you need to check the documentation of the tool that does the lookup on how to specify the server.
T 1709573586 18<29luva18>	well I cant change the host OS Soliton
T 1709573601 18<29luva18>	host DNS*
T 1709573640 18<26lopid18>	`man dig`
T 1709576816 18<25greycat18>	luva: some DNS lookup programs have a way to specify a server; some do not.  Find one that does, that you can use, and then do whatever it takes to specify the server.  E.g. with dig, you use @ip.add.res.ss.  With some others it'll be a mandatory or optional argument.
T 1709579605 18<20bent_fingers18>	Grymoires sed tutorial shows this example: sed s/day/night/ <old >new
T 1709579627 18<20bent_fingers18>	And says for unix beginners to try this one: sed s/day/night/ old >new
T 1709579642 18<20bent_fingers18>	Why the second for beginners?
T 1709579666 18<25greycat18>	Most likely they're trying to get you to think about those two commands, and understand how they differ, if at all.
T 1709579733 18<25greycat18>	It's equivalent to comparing   cat file1   and  cat <file1
T 1709579836 18<28emanuele618>	meow
T 1709580059 18<19Liver_K18>	Is there any difference between ${name:-} and ${name}?
T 1709580072 18<25greycat18>	probably when set -u is in effect
T 1709580078 18<29phy172918>	If set -u explodes
T 1709580264 18<20bent_fingers18>	one has sed read from stdin, the other from an argument/positional parameter
T 1709580303 18<20bent_fingers18>	What difference does it make?
T 1709580432 18<29phy172918>	If it's seekable, what error messages say, where in the command it can go
T 1709580434 18<20bent_fingers18>	I suppose it has something to do with bragging rights
T 1709580530 18<20bent_fingers18>	Seekable? Never heard of it. Must be why I don't have any pull requests to respond to
T 1709580557 18<25greycat18>	I don't think sed cares about seekability, but other commands might.
T 1709580576 18<29phy172918>	iirc diff generally does
T 1709580598 18<25greycat18>	diff <() <() works, though
T 1709580624 18<29phy172918>	Does it? I though I had to use diff =() =()   (zshism)
T 1709580640 18<29phy172918>	Maybe GNU diff is fancier
T 1709580699 18<20bent_fingers18>	Join us in GNU. We enjoy awkard acronyms.
T 1709620790 19*	Now talking on 22#bash
T 1709620790 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709620790 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709636674 18<26dionys18>	[_]ↄ ... cheers
T 1709637169 18<19Artfaith18>	c[▅]
T 1709637347 18<28emanuele618>	!pizza
T 1709637438 18<24ano18>	!gastritis
T 1709643423 18<29nvz18>	heh
T 1709643452 18*	29nvz looks that up
T 1709643552 18<29nvz18>	na.. not gastritis.. but I do seem to have somethin goin on
T 1709643734 18<24ruvik18>	Hello guys
T 1709643758 18<29nvz18>	no guys here.. just us chickens
T 1709643795 18<29nvz18>	right scooby?
T 1709644023 18<28emanuele618>	https://www.youtube.com/watch?v=miomuSGoPzI
T 1709645315 18<24depesz18>	hi. given such input (array of strings): ns=( "m 1" "m 2" "s 1" "b 1" ) - what would be the sanest way to get number of elements that start with "m " ?
T 1709645328 18<24depesz18>	I can grep|wc -l, but it doesn't look sane.
T 1709645487 18<19Artfaith18>	depesz, do you want with loop or not?
T 1709645509 18<24depesz18>	ideally simple one-liner. but I'll take anything.
T 1709645526 18<24depesz18>	currently my "best" approach is: printf '%s\n' "${ns[@]}" | grep -c "^m "
T 1709645560 18<24depesz18>	only one execve, and no interpreted loops. but i somehow feel that there should be better way…
T 1709645857 18<19Artfaith18>	# declare ns=( "m 1" "m 2" "s 1" "b 1" ); declare el r=(); for el in "${ns[@]}"; do if [[ "$el" =~ ^m ]]; then r+=( "${el//[A-Za-z +]/}" ); fi; done; declare -p -- r;
T 1709645860 18<25shbot18>	Artfaith: declare -a r=([0]="1" [1]="2")
T 1709645860 18<27Soliton18>	unless you have loop phobia you'd just loop over the element and count.
T 1709645945 18<19Artfaith18>	`+` in the regex is redundant though.
T 1709645946 18<27Soliton18>	that grep approach only works if the elements contain no newline, btw.
T 1709645969 18<24depesz18>	they don't. the original value comes from mapfile-t
T 1709646025 18<27Soliton18>	you can use mapfile to handle NUL delimited input.
T 1709646031 18<24depesz18>	sorry, not sure what the r+= does. you are extracting some value form the ns elements? sorry. it was meant to *count* the elements, not check their "appendages" :)
T 1709646041 18<24depesz18>	Soliton: i know, but not in this case :)
T 1709646050 18<24geirha18>	you could do a while read loop instead of mapfile and do the count at the same time
T 1709646064 18<27Soliton18>	# ns=( "m 1" "m 2" "s 1" "b 1" ); for n in "${ns[@]}"; do [[ $n = m\ * ]] && count=$((count + 1)); done; echo "$count"
T 1709646066 18<25shbot18>	Soliton: 2
T 1709646075 18<24depesz18>	i could, but then I would have to rebuild the array anyway, as it is needed in array form later on.
T 1709646098 18<24geirha18>	count in addition to populating the array ...
T 1709646107 18<24depesz18>	Soliton: any reason to not use (( count++ )) ?
T 1709646123 18<27Soliton18>	not really.
T 1709646176 18<24geirha18>	while IFS= read -r line ; do ns+=( "$line" ) ; [[ $line = m\ * ]] && (( mcount++ )) ; done
T 1709646268 18<24depesz18>	yeah. that looks ok.
T 1709646276 18<24depesz18>	not sure why IFS=, though
T 1709646297 18<24geirha18>	without it it will trim leading and trailing whitespace
T 1709646323 18<28emanuele618>	the BEST way is    IFS= eval printf -v _ '"${arr[*]/*/%c}%n"' '"${arr[@]%%[!m]*}"' mcount    there is no competition
T 1709646347 18<19Artfaith18>	The best they may not understand.
T 1709646364 18<19Artfaith18>	The above will allow to move on, and get into this part later.
T 1709646387 18<19Artfaith18>	Though, I see "EVAL"!
T 1709646394 18<19Artfaith18>	Eval is Evil!
T 1709646443 18<19Artfaith18>	Even if we know that Bash being REPL is eval itself ^^"
T 1709646673 18<28emanuele618>	hmm, something is wrong
T 1709646708 18<28emanuele618>	# arr=( mauris cursus mattis molestie a. elementum eu facilisis sed odio morbi quis commodo odio aenean. sociis natoque penatibus et magnis dis parturient. fermentum odio eu feugiat pretium nibh. eu sem integer vitae justo eget magna fermentum. ); (IFS= eval set -x\; printf -v m '"${arr[*]/*/%c}%n"' '"${arr[@]%%[!m]*}"' mcount)
T 1709646709 18<25shbot18>	emanuele6: ++ printf -v m %c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%n m '' m m '' '' '' '' '' '' m '' '' '' '' '' '' '' '' m '' '' '' '' '' '' '' '' '' '' '' '' '' '' m '' mcount
T 1709646714 18<28emanuele618>	that looks correct, but
T 1709646730 18<28emanuele618>	# arr=( mauris cursus mattis molestie a. elementum eu facilisis sed odio morbi quis commodo odio aenean. sociis natoque penatibus et magnis dis parturient. fermentum odio eu feugiat pretium nibh. eu sem integer vitae justo eget magna fermentum. ); IFS= eval printf -v m '"${arr[*]/*/%c}%n"' '"${arr[@]%%[!m]*}"' mcount;  declare -p m mcount
T 1709646732 18<25shbot18>	emanuele6: declare -- m="m"
T 1709646732 18<25shbot18>	emanuele6: declare -- mcount="36"
T 1709646741 18<28emanuele618>	m only contains one m, and mcount in 36
T 1709646759 18<19Artfaith18>	depesz, the `+=` adds to the array.
T 1709646768 18<19Artfaith18>	++ adds to the integer.
T 1709646789 18<28emanuele618>	# arr=( mauris cursus mattis molestie a. elementum eu facilisis sed odio morbi quis commodo odio aenean. sociis natoque penatibus et magnis dis parturient. fermentum odio eu feugiat pretium nibh. eu sem integer vitae justo eget magna fermentum. ); IFS= eval printf -v m '"${arr[*]/*/%.1s}%n"' '"${arr[@]%%[!m]*}"' mcount;  declare -p m mcount
T 1709646790 18<25shbot18>	emanuele6: declare -- m="mmmmmm"
T 1709646790 18<25shbot18>	emanuele6: declare -- mcount="6"
T 1709646834 18<19Artfaith18>	As in the most languages.
T 1709646837 18<28emanuele618>	i think that is just a bug in bash; with printf's %c specifier and %n; it always assumes %c prints a byte even when it does not
T 1709646853 18<28emanuele618>	%.1s works correctly
T 1709646879 18<28emanuele618>	i am not sure why m is set to m when using -v m and %c, but that is probably also a bug
T 1709646896 18<28emanuele618>	%c ''  messes up some internal count
T 1709647046 18<28emanuele618>	# arr=( mauris cursus mattis molestie a. elementum eu facilisis sed odio morbi quis commodo odio aenean. sociis natoque penatibus et magnis dis parturient. fermentum odio eu feugiat pretium nibh. eu sem integer vitae justo eget magna fermentum. ); IFS= eval printf '"${arr[*]/*/%c}%n"' '"${arr[@]%%[!m]*}"' mcount;  declare -p mcount
T 1709647047 18<25shbot18>	emanuele6: mmmmmmdeclare -- mcount="36"
T 1709647053 18<28emanuele618>	without -v the output is correct
T 1709647060 18<28emanuele618>	but mcount is still wrong
T 1709647198 18<24ano18>	what does "${!var[@]*}" mean?
T 1709647205 18<28emanuele618>	# dash -c 'printf %c ""' | od -An -tc
T 1709647207 18<25shbot18>	emanuele6:   \0
T 1709647209 18<28emanuele618>	# ksh -c 'printf %c ""' | od -An -tc
T 1709647211 18<25shbot18>	emanuele6:   \0
T 1709647217 18<28emanuele618>	# printf %c '' | od -An -tc
T 1709647219 18<25shbot18>	emanuele6:   \0
T 1709647219 18<28emanuele618>	wow
T 1709647240 18<28emanuele618>	so %c ''  prints a NUL, it is not the same as %.1s :o
T 1709647245 18<28emanuele618>	i didn't know that
T 1709647251 18<28emanuele618>	printf %c in sh truly sucks
T 1709647272 18<28emanuele618>	ano: it expands to the variable names that start with "var"
T 1709647320 18<24ano18>	# var2=var1; var1=var2; printf {%s} "${!var[@]*}"
T 1709647320 18<28emanuele618>	oh, i misread that as ${!var@} sorry
T 1709647322 18<25shbot18>	ano: {}
T 1709647336 18<28emanuele618>	there var is an array
T 1709647342 18<28emanuele618>	it concatenates the values of var by space
T 1709647364 18<28emanuele618>	# var=(var) var1= var2=; printf {%s} "${!var[@]*}"
T 1709647366 18<25shbot18>	emanuele6: {}
T 1709647372 18<28emanuele618>	then i am not sure what it does
T 1709647380 18<28emanuele618>	# var=(var) var1= var2=; printf {%s} "${!var[1]*}"
T 1709647382 18<25shbot18>	emanuele6: {}
T 1709647394 18<28emanuele618>	i don't know; maybe it is not even that
T 1709647417 18<28emanuele618>	maybe it is trying to expand to variables that start with var[@] that cannot exist
T 1709647491 18<28emanuele618>	yes, that is what it does
T 1709647493 18<27Soliton18>	given that it only works with @ or * appended i'd guess it is a parser quirk because of the variable name prefix matching.
T 1709647725 18<28emanuele618>	i guess you can use it to write inline comments :)
T 1709647755 18<28emanuele618>	$ ./bash -c 'var=(var) var1= var2=; printf {%s}\\n "${!var[1]*}"'
T 1709647757 18<28emanuele618>	emanuele6debug: all_variables_matching_prefix("var[1]") was called.
T 1709647759 18<28emanuele618>	{}
T 1709647769 18<28emanuele618>	so yeah, that is what it is doing; confirmed
T 1709647800 18<28emanuele618>	# echo hi ${!a[@]i am a comment he he he he*} hello
T 1709647802 18<25shbot18>	emanuele6: hi hello
T 1709647858 18<28emanuele618>	!learn %c #redirect printf%c
T 1709647858 18<29greybot18>	OK, emanuele6
T 1709648143 18<28emanuele618>	!learn printf%c The `%c' format specifier in sh's printf does not print the character of the ASCII code corresponding to its number argument as it does for other languages' printf; it takes a string argument, and prints its first byte; it is similar to `%.1s', except that if the argument is an empty string, it will print a NUL character (\0) instead of printing nothing.
T 1709648143 18<29greybot18>	OK, emanuele6
T 1709648147 18<28emanuele618>	>:(
T 1709648404 18<28emanuele618>	(POSIX) The argument to the c conversion specifier can be a string containing zero or more bytes. If it contains one or more bytes, the first byte shall be written and any additional bytes shall be ignored. If the argument is an empty string, it is unspecified whether nothing is written or a null byte is written.
T 1709648549 18<28emanuele618>	!forget printf%c
T 1709648550 18<29greybot18>	OK, emanuele6
T 1709648620 18<28emanuele618>	!learn printf%c The %c format specifier in sh's printf does not print the character of the ASCII code corresponding to its number argument as it does for other languages' printf; it takes a string argument, and prints its first byte; it is similar to %.1s, except that its behaviour is unspecified if the argument is an empty string (in bash, it prints a NUL character instead of printing nothing.)
T 1709648620 18<29greybot18>	OK, emanuele6
T 1709648629 18<28emanuele618>	so printf %c in sh sucks even more
T 1709648652 18<28emanuele618>	at least you can use it in bash as a golfed   printf \\0 :   printf %c   is one byte shorter
T 1709652139 18<24depesz18>	this is *not* bash question, but you are smart, maybe you will be able to help - on one machine `man grep` (or other man pages) doesn't show colors. I checked, and both this box, and another (that does show color) have the same pager, pager options, and LESS_TERMCAP_.. env variables.
T 1709652195 18<24depesz18>	https://dpaste.org/aftGn
T 1709652229 18<26lopid18>	have you tried #linux?
T 1709652238 18<24depesz18>	i didn't. thanks.
T 1709652436 18<27Soliton18>	see what  tput colors  outputs.
T 1709652559 18<24depesz18>	256 in both cases.
T 1709653855 18<27Earnestly18>	https://github.com/landley/toybox/commit/a2419ad52d489bf1a84a9f3aa73afb351642c765
T 1709654248 18<28emanuele618>	https
T 1709655547 18<24depesz18>	solved. in case you'd stumble upon it - it seems to be broken by groff 1.23. fix is to either "export MANROFFOPT=-c" or "export GROFF_NO_SGR=1"
T 1709656200 18<27Earnestly18>	depesz: Is the goal to disable colours?
T 1709656211 18<24depesz18>	Earnestly: enable them. they got disabled by groff upgrade
T 1709656246 18<27Earnestly18>	depesz: I have 1.23 and -c is to "start with color output disabled"
T 1709656260 18<24depesz18>	Earnestly: where do you see that ?
T 1709656265 18<27Earnestly18>	In the manual
T 1709656270 18<24depesz18>	manual to what?
T 1709656285 18<24depesz18>	please note that -c is *not* option to man
T 1709656289 18<27Earnestly18>	depesz: groff, but it appears to be related to grotty
T 1709656294 18<27Earnestly18>	-c     Use grotty's legacy output format (see subsection “Legacy output format” above).  SGR and OSC escape sequences are not emitted.
T 1709656307 18<24depesz18>	exactly. it changes how color is outputted.
T 1709656307 18<27Earnestly18>	This also appears to exclude them
T 1709656312 18<24depesz18>	not for me.
T 1709656321 18<27Earnestly18>	depesz: Is this on a linux tty?
T 1709656324 18<24depesz18>	for me setting either of these things, or both of them, brings back color to manpages
T 1709656337 18<24depesz18>	linux, yes, in various terminal emulators.
T 1709656386 18<27Earnestly18>	NO_SGR: If set, grotty's legacy output format is used just as if the -c option were specified; see subsection “Legacy output format” above.
T 1709656482 18<24depesz18>	not sure what that has to do with it. are you saying that what I said is not true? well, it seems to be rather obscure, but known, bug: https://unix.stackexchange.com/a/771560/70436
T 1709656496 18<27Earnestly18>	depesz: Yeah it appears specific to SGR sequences, so bold and underline, etc. works but obviously it's expecting something different for colour
T 1709656564 18<27Earnestly18>	I wonder if there's a new way
T 1709656691 18<24depesz18>	if you'll find another, i'll gladly read about it.
T 1709656709 18<24depesz18>	you will need to find computer with broken man/groff/less/term* first, though :)
T 1709656979 18<27Earnestly18>	depesz: Seems like they just removed sgr (the command specifically) but provide it via -c and NO_SGR, but it's not very clear
T 1709657002 18<27Earnestly18>	provide "it", not being the command but "remain supported"
T 1709657032 18<27Earnestly18>	depesz: It seems a bit odd that "NO"_SGR would enable SGR
T 1709658822 19*	Now talking on 22#bash
T 1709658822 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709658822 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709658916 18<22FakuVe18>	I am changing it to plaintext
T 1709658923 18<22FakuVe18>	But actually it should be the same
T 1709658928 18<22FakuVe18>	You are right
T 1709658937 18<22FakuVe18>	no need to pass it to plaintext
T 1709659069 18<22FakuVe18>	it is taking ages though
T 1709659075 18<22FakuVe18>	Maybe my potato computer
T 1709659079 18<27Earnestly18>	FakuVe: Yeah it would
T 1709659085 18<22FakuVe18>	Also that is operating in an sdcard
T 1709659091 18<22FakuVe18>	:D
T 1709659123 18<27Earnestly18>	FakuVe: A nested for-loop like this is alone O^2 (quadratic), but that's probably unavoidable. But you're also forking quite a lot of stuff in this fairly fast, nested, loop
T 1709659126 18<22FakuVe18>	definitely rsync is not written this way "D
T 1709659147 18<27Earnestly18>	FakuVe: Here's a basic rewrite: https://0x0.st/H7pJ.txt (find of -maxdepth 1 means you probably want a for loop)
T 1709659162 18<27Earnestly18>	FakuVe: Sorry, <= should be > 1
T 1709659180 18<27Earnestly18>	Although that doesn't really need to exist
T 1709659206 18<27Earnestly18>	Because if the array has 1 element, then your file = fileb will always succeed
T 1709659240 18<27Earnestly18>	FakuVe: Instead of forking pup for *every* fileb and file comparison, you can fork it once for just file and then only fork pup for fileb
T 1709659305 18<22FakuVe18>	Thats looking nice
T 1709659311 18<27Earnestly18>	FakuVe: Another way to do this, which is what I'd do, is generate a list of all files and their titles. Then sort that list and extracting the duplicates
T 1709659318 18<22FakuVe18>	does pup work without quoting
T 1709659343 18<27Earnestly18>	FakuVe: What do you mean?
T 1709659351 18<27Earnestly18>	For the .css-selector?
T 1709659403 18<27Earnestly18>	You only need to quote if there's something that would undergo glob file expansions, quoting is used to suppress the meaning the shell gives to strings. If there's no shell specific syntax then there's no need to quote
T 1709659414 18<27Earnestly18>	literal quoting anyway
T 1709659426 18<22FakuVe18>	yeah let me try yours
T 1709659460 18<27Earnestly18>	FakuVe: You also don't need -name '*' that's the default behaviour
T 1709659462 18<22FakuVe18>	Mine may be the worse algorythm ever. It took 10 mins to find the second ocurrence
T 1709659474 18<22FakuVe18>	alright
T 1709659553 18<27Earnestly18>	FakuVe: It's mostly bad because of the amount of forking you do which is particularly slow. Yes it's also quadratic but unless you have thousands of files that shouldn't be very noticible
T 1709659591 18<22FakuVe18>	I think its also my computer
T 1709659600 18<22FakuVe18>	But yours didnt give any output
T 1709659767 18<22FakuVe18>	yeah if files > 1  , instead
T 1709659774 18<22FakuVe18>	instead of <= 1
T 1709659861 18<27Earnestly18>	FakuVe: Yeah I suggested that correction earlier
T 1709659911 18<27Earnestly18>	FakuVe: The other problem is you call pup on fileb way more times than necessary
T 1709660072 18<22FakuVe18>	it has got an issue
T 1709660078 18<22FakuVe18>	once it removes a file
T 1709660100 18<22FakuVe18>	It will iterate through that file afterwards  , and will have a warning of file doesnt exists
T 1709660107 18<22FakuVe18>	it doesnt matter though
T 1709660137 18<27Earnestly18>	If you have files a b c, then looping a a b c, b a b c, c a b c will call pup on a b c 3 times more than necessary. Also as your loops are complete file lists, removing one file will fail when it attempts to access it if it already existed in the for loop's "list"
T 1709660175 18<22FakuVe18>	yeah , whatever
T 1709660183 18<22FakuVe18>	It works , thats ok for me
T 1709660189 18<22FakuVe18>	good to learn how to do it properly
T 1709660197 18<22FakuVe18>	And I appreciate so much your help
T 1709660209 18<22FakuVe18>	For this case is more than fine Earnestly thank you
T 1709660277 18<25Lynx-18>	Can anyone advise on an especially CPU-friendly way to prepend a word to line outputs of a binary file and pass the result onto a FIFO without buffering more than each line?
T 1709660332 18<25Lynx-18>	right now I simply do while read line; printf term line >; done, but I'm hoping there is a way to avoid the byte-by-byte read penalty that that incurs
T 1709660558 18<25Lynx-18>	And bonus would be to use bash builtins
T 1709660561 18<22FakuVe18>	it was the sd card , I used it in my internal memory and like 8 times faster at least
T 1709660574 18<20twkm18>	i'd likely use awk or sed, along with unbuffer.
T 1709660601 18<22FakuVe18>	Yeah cheers
T 1709660677 18<22FakuVe18>	I am going for a run will check this back , cheers all
T 1709660759 18<25Lynx-18>	twkm thanks. Is the only way in bash to just use a byte-by-byte read? No clever trick to avoid that?
T 1709660778 18<27Earnestly18>	FakuVe: Consider: https://0x0.st/H7pk.txt
T 1709661070 18<27Earnestly18>	FakuVe: Or https://0x0.st/H7pF.txt
T 1709661143 18<27Earnestly18>	Lynx-: read will read(2) one byte at a time if the input is a pipe. It buffers if the input is a file. Bash's read has -N if you want to do buffered reads yourself
T 1709661238 18<27Earnestly18>	Lynx-: Which then means you'll need to pay careful attention to the exit status of read as to whether the buffer was filled, wasn't filled or was a read error or read timeout.
T 1709661365 18<25Lynx-18>	Earnestly thanks. Is the output from binaries like ping typically such that it outputs line by line such that if you read -t 0 the exit status will show you data is available after complete line has been written?
T 1709661404 18<27Earnestly18>	Lynx-: I would use awk
T 1709661468 18<27Earnestly18>	Don't try to do read -t 0 hacks for this, and no. As I write, read -N lets you do buffered reads, but like C, you just have to manage the input, i.e. detecting record separation and building variables until you do
T 1709661930 19*	Now talking on 22#bash
T 1709661930 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709661930 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709662197 18<25Lynx-18>	Earnestly once the data has been read in with say -N 512, what's the most efficient way to split up the lines without byte-by-byte read then at that point? So far I have this: https://pastebin.com/raw/Y7gwst09
T 1709662265 18<25Lynx-18>	echo $line shows indeed how you get the nice 512 bytes at a time, but then I'm wondering how to avoid then having to end up reading every character to work out the positions of the new lines.
T 1709662373 18<25Lynx-18>	ultimately I'd like to just print out the complete lines as they are completed, without requiring a byte-by-byte read on the read-in 512 byte chunks, if this is at all possible
T 1709662538 18<25Lynx-18>	ah, I can just printf "${line}" .. I see.
T 1709662604 18<25Lynx-18>	intereting - strace shows: "read(10, "64 bytes from localhost (::1): i"..., 155) = 64" reads
T 1709662636 18<25Lynx-18>	do I read that correctly that when -N 512 is specified it is resulting in 64 byte reads?
T 1709662685 18<25Lynx-18>	here is the strace: https://pastebin.com/raw/eUbcRhyJ
T 1709667679 19*	Now talking on 22#bash
T 1709667679 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709667679 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709674382 19*	Now talking on 22#bash
T 1709674382 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709674382 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709675352 18<22FakuVe18>	Earnestly: those two lastones work fast , but they do delete all files
T 1709675354 18<22FakuVe18>	https://0x0.st/H7pF.txt
T 1709675519 18<25Lynx-18>	So -N 512 results in several read calls like: <<<read(10, "64 bytes from localhost (::1): i"..., 475) = 64>>> - what governs the number 64?
T 1709675595 18<25greycat18>	That's how many you got.  I'm more curious about the 475, which is how many were requested.
T 1709675857 18<28emanuele618>	ping outputs a line every few seconds; so that already read 37 bytes from the previous line (or lines), and only requests 475 this time
T 1709675897 18<28emanuele618>	with -N512, read won't return until bash has put 512 characters on the variable, or EOF is reached, so it just keeps collecting
T 1709675917 18<25greycat18>	yeah, makes sense if they didn't show us the first line
T 1709675923 18<25Lynx-18>	so the chunk size of collection is dictated by the manner in which the binary outputs the chunks?
T 1709675944 18<25greycat18>	64 is how many bytes you *actually got*.  It's how many were *there*.
T 1709675957 18<25Lynx-18>	greycat here: https://pastebin.com/raw/eUbcRhyJ
T 1709676051 18<25Lynx-18>	isn't it 64 read and 475 of the 512 remaining
T 1709676053 18<24Nintendo18>	Bitching about jq a few weeks ago paid off, because today I used “// empty”, and it made me happy.
T 1709676067 18<25Lynx-18>	you see the number decreasing with each line
T 1709676108 18<25Lynx-18>	and then: rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0; rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
T 1709676233 18<28nphard18>	what's the difference between alteranet uses of '>'?
T 1709676242 18<28nphard18>	cut file > nu_file
T 1709676260 18<28nphard18>	cut -f1 < file > nu_file
T 1709676264 18<28nphard18>	both do the same
T 1709676283 18<28nphard18>	even the difference between 'cut -f1 file' and cut -f1 < file'
T 1709676308 18<28emanuele618>	if file is -,  cut -f1 -  reads from stdin; while  cut -f1 < -  reads from a file named - in the current directory
T 1709676333 18<25greycat18>	In the last line, the first command, cut opens the file itself, and therefore it knows the file name and can report it in error messages and so on.  In the second command, bash opens the file and cut only receives the already-opened file descriptor.
T 1709676466 18<25greycat18>	In the redirection command, if the file *can't* be opened, cut never even gets executed.  Bash tries to open it, fails, gives an error message, and never calls cut.
T 1709676476 18<28nphard18>	the next logical question begged is: which one is better?
T 1709676486 18<25Lynx-18>	what's the most efficient way to split up a string including newline characters into an array with elements having those separate lines from string? Is there a way to do that without byte-by-byte read?
T 1709676498 18<25greycat18>	Lynx-: mapfile / readarray
T 1709676521 18<25Lynx-18>	ah, yes
T 1709676919 18<27xx18>	# echo abc `#def` ghi
T 1709676921 18<25shbot18>	xx: abc ghi
T 1709676931 18<27xx18>	# echo abc "$(#def)" ghi
T 1709676938 18<25shbot18>	xx: Missing terminating quote, bracket or keyword
T 1709676944 18<27xx18>	why?
T 1709677009 18<20arraybolt318>	# echo abc \"\$(#def)\" ghi
T 1709677011 18<25shbot18>	arraybolt3: bash: syntax error near unexpected token `('
T 1709677055 18<27xx18>	# echo abc "$(\#def)" ghi
T 1709677055 18<25shbot18>	xx: no output
T 1709677649 18<27larryv18>	xx: the parser probably closes ` by simply looking for the next unquoted `. the contents of $(...) are parsed more rigorously
T 1709686297 19*	Now talking on 22#bash
T 1709686297 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709686297 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709686298 18<19puchu18>	fifi
T 1709686319 18<19puchu18>	$PROXY_PREFIX cmd
T 1709686339 18<19puchu18>	this doesnt seem to work, how i make this work?
T 1709686356 18<29nightstrike18>	djph: yes
T 1709686369 18<19puchu18>	PROXY_PREFIX="http_proxy=http://127.0.0.1:8118 https_proxy=${http_proxy}"
T 1709686375 18<19puchu18>	$PROXY_PREFIX cmd
T 1709686378 18<29nightstrike18>	tirnanog: ok, I'll keep debugging
T 1709686446 18<22tirnanog18>	puchu: a) PROXY_PREFIX=$PROXY_PREFIX cmd or ... b) export PROXY_PREFIX; cmd
T 1709686470 18<22tirnanog18>	or c) export it at the same time as assigning
T 1709686502 18<19puchu18>	tirnanog: thanks
T 1709686561 18<27larryv18>	hm, i assumed puchu was trying to export http{,s}_proxy in a particularly convoluted manner
T 1709686573 18<22tirnanog18>	oh yeah.
T 1709686579 18<22tirnanog18>	just looked at the value. oh dear.
T 1709686741 18<22tirnanog18>	puchu: more like this then: if [[ ${PROXY_ENABLED} -eq 1 ]]; then export http_proxy=http://127.0.0.1:8118; export https_proxy=${http_proxy}; fi
T 1709686750 18<25ormaaj18>	I'd create the heredoc after running sudo using the execline heredoc command.
T 1709686786 18<25ormaaj18>	"Oh but I can't install anything". hax0r that b0x0r. permission granted.
T 1709686869 18<22tirnanog18>	nightstrike: I take it you can't rely on the exit status?
T 1709686873 18<22tirnanog18>	(of cmd)
T 1709686982 18<25ormaaj18>	I guess technically you can do that anyway using just bash.
T 1709687175 18<19puchu18>	tirnanog thanks, i did it exactly like your - like this - :)
T 1709687257 18<22tirnanog18>	otherwise, you would have had to issue http_proxy=$http_proxy https_proxy=$http_proxy cmd after assigning. seems simpler just to export to begin with.
T 1709687515 18<29nightstrike18>	tirnanog: correct, it's poorly written
T 1709687847 18<25ormaaj18>	sudo -- bash +o monitor -O lastpipe -c '{ printf %s "$2" | { shift; { BASH_ENV=/proc/self/fd/${fd} exec -- "$@"; } {fd}<&0 <&"$tty"-; } {tty}<&0' bash bash 'cd /server && source blahblah; shift; unset -v fd BASH_ENV {fd}<&-' arg1 arg2 ...
T 1709687872 18<29nightstrike18>	tirnanog: it seems to have almost random return statuses
T 1709687971 18<25ormaaj18>	sudo -- bash +o monitor -O lastpipe -c '{ printf %s "$2" | { shift; { BASH_ENV=/proc/self/fd/${fd} exec -- "$@"; } {fd}<&0 <&"$tty"-; } {tty}<&0' bash bash 'cd /server && source blahblah; unset -v fd BASH_ENV {fd}<&-' arg1 arg2 ...
T 1709687978 18<25ormaaj18>	shift in wrong place.
T 1709688000 18<22tirnanog18>	nightstrike: how awful.
T 1709688075 18<25ormaaj18>	If only bash were posix I wouldn't need those extra {}'s
T 1709688278 18<24yuesbeez18>	ormaaj: thanks. what would arg1 arg2 be passed to in this case?
T 1709688303 18<25ormaaj18>	the exec'd bash shell
T 1709688339 18<25ormaaj18>	$1 stores the "heredoc" data. then dump it into a pipe, shift it away, exec remaining args
T 1709688376 18<25ormaaj18>	Oh and I have them in the wrong order duh
T 1709688399 18<25ormaaj18>	sudo -- bash +o monitor -O lastpipe -c '{ printf %s "$2" | { shift; { BASH_ENV=/proc/self/fd/${fd} exec -- "$@"; } {fd}<&0 <&"$tty"-; } {tty}<&0' bash 'cd /server && source blahblah; unset -v fd BASH_ENV {fd}<&-' bash arg1 arg2 ...
T 1709688408 18<25ormaaj18>	the first "bash" is argv[0]
T 1709688432 18<26sybariten18>	Is the "bind" command a bash specific thing?
T 1709688443 18<25ormaaj18>	sybariten: mostly
T 1709688457 18<25ormaaj18>	basically yes. some other shells have different bind command.
T 1709688567 18<26sybariten18>	Someone in the fzf channel said that in order to change a key shortcut binding, for a tool called fzf, i would just need to export an env var.  I fail to understand how he meant exactly, if i look into the config today the line which is originally used is    bind -m emacs-standard '"\ec": " \C-b\C-k \C-u`__fzf_cd__`\e\C-e\er\C-m\C-y\C-h\e \C-y\ey\C-x\C-x\C-d"'
T 1709688696 18<26sybariten18>	Hm, maybe he meant something else actually. Oh well.
T 1709688777 18<22tirnanog18>	the bind builtin is for altering readline(3) bindings, as applied specifically to bash. as concerns environment variables, it's unclear what they meant.
T 1709688827 18<22tirnanog18>	it's quite possible that they didn't know either.
T 1709688852 18<26sybariten18>	Yep, i think they may have meant what that key binding _does_ , judging from how its worded.... i realize now.
T 1709688888 18<22tirnanog18>	the only env vars recognised by fzf itself are FZF_DEFAULT_COMMAND, FZF_DEFAULT_OPS and FZF_API_KEY, according to a brief skim of its manual.
T 1709688892 18<22tirnanog18>	OPTS*
T 1709688921 18<26sybariten18>	And i think i know which variable to export in that case. But for picking up the key itself, i dont think i should do that, i should probably make a new /usr/share/doc/fzf/examples/key-bindings.bash , modify that and source it from my .bashrc
T 1709688932 18<25ormaaj18>	heh i tried it and got an error from my own code
T 1709688937 18<25ormaaj18>	libinit: Error: The shell failed to set the (E)UID and re-execing it with the correct values somehow failed to fix it. That should never happen. Not trying again to prevent an exec loop.
T 1709688949 18<25ormaaj18>	that branch should never be taken...
T 1709688965 18<25ormaaj18>	also I used --norc --noprofile. wtf
T 1709688966 18<26sybariten18>	s/"make a new"/"copy"
T 1709688971 18<22tirnanog18>	what manner of Lovecraftian horror have you unearthed now.
T 1709689306 18<25ormaaj18>	https://bpa.st/raw/2OIA that is "init.bash" which is sourced from .bashrc
T 1709689307 18<28checkbot18>	ormaaj: I think the problem is on line 20. Parameter expansions can't start with .. Double check syntax. See 25 issues on https://shellcheck.net/?id=cb89307
T 1709689319 18<25ormaaj18>	ah checkbot loves me
T 1709689352 18<25ormaaj18>	somehow sudo triggers this, but normally it doesn't, and should never.
T 1709689429 18<25ormaaj18>	it means it tried to run `exec -- env UID=correct uid bash`, then tried measuring it in the new shell and it still didn't match. Does sudo have something that blocks overwriting UID somehow?
T 1709689539 18<25ormaaj18>	probably not that doesn't seem possible.
T 1709689578 18<25ormaaj18>	unless env looks for SUDO being set and env has some misfeature that does that
T 1709689739 18*	25ormaaj stracing...
T 1709690319 18<25ormaaj18>	i wonder why sudo is unsetting UID and EUID to begin with. It just unsets them and lets the child fill them in? I never noticed that.
T 1709690446 18<25ormaaj18>	hmm lets try my new bash ebuild that doesn't have that stupid SSH define. Maybe it's f'd because gentoo
T 1709690556 18<25ormaaj18>	I wouldn't think sudo would trigger that either
T 1709690862 18<25ormaaj18>	maybe it is. it shouldn't be forcing my .bashrc to run with --norc
T 1709693155 18<22des_h18>	any chance i can read a file from the end backwards (for performance reasons) in either awk or sed?
T 1709693391 18<20tanath18>	des_h: `awk '{a[i++]=$0} END {for (j=i-1; j>=0;) print a[j--] }' FILE`
T 1709693405 18<20tanath18>	where FILE is your filename
T 1709693474 18<22des_h18>	doesn't that still read the whole file from top to bottom before the END block is executed?
T 1709693509 18<25hleneto18>	des_h, there's tac.
T 1709693519 18<20tanath18>	yeah
T 1709693541 18<22des_h18>	i'd like to start reading from the bottom backwards and stop after X < FNR lines (once a condition is met), so that i don't actually read all of the lines
T 1709693603 18<20tanath18>	i hadn't paid attn to the performance part since i didn't have context. just saw you wanted to read in reverse and grabbed a method. sorry
T 1709693706 18<22des_h18>	is there a reason this way of reading a file is not built into canonical terminal programs?
T 1709693749 18<27larryv18>	it's a weird requirement.
T 1709693775 18<27larryv18>	and it could only work on regular files, not streams, adding complexity
T 1709693826 18<22des_h18>	i have a file which has data appended to it regularly. like a log. i'd like to periodically edit the data in this file, but only check the new lines which i haven't already edited. the new lines would be at the bottom of the file
T 1709693859 18<20tanath18>	maybe just `tail -n <number_of_lines_to_read> <file_path> | tac`
T 1709693881 18<22des_h18>	problem is i don't know in advance how many new lines have been appended since i last checked
T 1709693911 18<22des_h18>	so i need to go backwards until i find a line which i've already edited
T 1709693927 18<22des_h18>	and stop
T 1709694067 18<20tanath18>	you could use vim and have it remember your last position. when you open the file you're where you left off
T 1709694196 18<22des_h18>	hmm or i could just write the last position i checked in another file and retrieve it later. then use sed to print only the lines higher than that position. i think it would still improve performance somewhat
T 1709695809 18<25ormaaj18>	There should be a way to detect whether an expression is being evaluated with eval... to define an alias that hooks a function definition by only expanding in the global scope of a sourced file, you can just look at BASH_SOURCE[0], but eval doesn't modify BASH_SOURCE, so eval "$(<file)" will break the alias.
T 1709696521 18<25ormaaj18>	You can't unset or overload BASH_SOURCE. An unhackable variable :(
T 1709697491 18<29noobaroo18>	I'm really stupid and can't solve a simple math equation
T 1709697540 18<29noobaroo18>	How many minutes and seconds is a video that is 579MB and has a bitrate of 4000KB/second?
T 1709697618 18<29nightstrike18>	it's roughly 2 and a half minutes
T 1709697640 18<29nightstrike18>	579/4
T 1709697655 18<25ormaaj18>	don't you have to like extract the video from its container and get the length of the raw stream?
T 1709697667 18<29nightstrike18>	well if it's constant bitrate...
T 1709697676 18<29nightstrike18>	so like, some old codec
T 1709697695 18<25ormaaj18>	oh right that tells you nothing
T 1709697696 18<25ormaaj18>	heh
T 1709697696 18<29nightstrike18>	or if 4M is the average, it's close enough
T 1709697786 18<29noobaroo18>	I got 144.75 but it just seems incorrect, it has to be way longer than 2 minutes
T 1709697799 18<29noobaroo18>	It just doesn't seem right.
T 1709697802 18<29noobaroo18>	Thanks.
T 1709697835 18<20bent_fingers18>	does anyone really use `grep -f pattern_file`?
T 1709697848 18<29nightstrike18>	noobaroo: well maybe you use a variable bitrate, and 4M isn't the right average
T 1709697872 18<25ormaaj18>	If it's even like half of the screen is a solid blue box for the entire  video, then even the approximation will be way wrong
T 1709697880 18<29nightstrike18>	tirnanog: for my question from earlier, maybe I oversimplified... what I'm actually doing is...  cmd <<< "input string" |& grep -q Error
T 1709697892 18<29nightstrike18>	Could <<< be affecting the ability of that to work reliably?
T 1709697916 18<25ormaaj18>	no
T 1709697917 18<29nightstrike18>	noobaroo: just open it in VLC
T 1709697954 18<25ormaaj18>	don't use &| though. It sucks.
T 1709697959 18<25ormaaj18>	|&
T 1709697996 18<29nightstrike18>	why does it suck?
T 1709698009 18<25ormaaj18>	(there are no cshisms that don't suck so naturally)
T 1709698023 18<29nightstrike18>	I can't even parse that :P
T 1709698061 18<29nightstrike18>	and anyway, 2>&1 still doesn't work
T 1709698070 18<29nightstrike18>	so the problem is elsewhere
T 1709698110 18<25ormaaj18>	portability mainly. |& has completely different meaning in other shells.
T 1709698135 18<29nightstrike18>	hm...  works on the command line, not in the script
T 1709698140 18<25ormaaj18>	Also it evaluates very strangely
T 1709698186 18<29nightstrike18>	strangely?
T 1709698259 18<25ormaaj18>	cmd 2>&1 |& # won't do what you think. because it isn't like an alias for an ordinary redirection.
T 1709698435 18<29nightstrike18>	hm...  well FWIW, I reverted all my temporary kludges back to my original script, and now it works.  So there must have been something screwed up externally.
T 1709698450 18<29nightstrike18>	I think that means it's time for bed.
T 1709698637 18<29nightstrike18>	ok, so one last thing.. I got stuck on this for days and then forgot about it...  I need to match a line of an output stream, and then remove the matching line, the one after, and the two previous.  I got `sed -e 'N;/match/!P;D'` to discard the matched line and one prior, but I can't get two prior and can't get the one after
T 1709698722 18<29nightstrike18>	I guess I can ask again in #sed
T 1709700600 18<29nightstrike18>	lololol... this abomination works...   `cat x | (mapfile -t; for ((i=0; i<${#MAPFILE[@]}; i++)); do if [[ "${MAPFILE[$i]}" == *"match"* ]]; then unset "MAPFILE[$((i-2))]" "MAPFILE[$((i-1))]" "MAPFILE[$i]" "MAPFILE[$((i+1))]"; fi; done; for i in "${MAPFILE[@]}"; do echo "$i"; done)`
T 1709700638 18<29nightstrike18>	who said you can't shove that square peg through a concrete wall? :P
T 1709700887 18<25ormaaj18>	except uuoc
T 1709700900 18<29nightstrike18>	what's that?
T 1709700901 18<25ormaaj18>	!uuoc
T 1709700901 18<29greybot18>	Useless Use Of Cat (cat foo | grep bar). See https://mywiki.wooledge.org/BashFAQ/119 and http://www.iki.fi/era/unix/award.html#cat
T 1709700915 18<29nightstrike18>	lol, that's what you point out from that horror?
T 1709700925 18<29nightstrike18>	cat is a standin for some other command I'm running
T 1709700953 18<25ormaaj18>	it's not really that wrong
T 1709700961 18<29nightstrike18>	dude, it's awful
T 1709700964 18<25ormaaj18>	I'd use a read loop instead since you   only really want one line at a time
T 1709700986 18<29nightstrike18>	and it's all because `grep -v -C` doesn't DTRT
T 1709701012 18<25ormaaj18>	there are other details I guess
T 1709701033 18<27larryv18>	could probably be a pretty straightforward awk script
T 1709701034 18<25ormaaj18>	array[$((foo))] is pointless for indexed arrays
T 1709701047 18<29nightstrike18>	larryv: if I knew awk
T 1709701086 18<29nightstrike18>	ormaaj: what do you mean?
T 1709701106 18<25ormaaj18>	the index is implicitly evaluated as a math expression
T 1709701111 18<25ormaaj18>	unless the array is associative
T 1709701126 18<29nightstrike18>	you mean I can do `unset "MAPFILE[i-1]" ?
T 1709701132 18<25ormaaj18>	yes
T 1709701150 18<29nightstrike18>	...you sure?
T 1709701154 18<25ormaaj18>	quite
T 1709701157 18<29nightstrike18>	ok, I'll try it
T 1709701210 18<29nightstrike18>	well, you're right... but I just lost my ssh connection
T 1709701229 18<29nightstrike18>	stupid vpn time limit
T 1709701270 18<29nightstrike18>	even MAPFILE[i] doesn't need $i
T 1709701271 18<29nightstrike18>	nice
T 1709701296 18<25ormaaj18>	MAPFILE[i] is more correct. They aren't quite equivalent.
T 1709701386 18<25ormaaj18>	MAPFILE is hideous. just pick a name
T 1709701417 18<29nightstrike18>	lol
T 1709701430 18<29nightstrike18>	The whole thing is hideous :)
T 1709701455 18*	27JAA picks 'a'.
T 1709701457 18<29nightstrike18>	and sadly, while it works in my small test, doesn't even work in the real deal
T 1709701490 18<29nightstrike18>	JAA: I worked with a guy that wrote...   `int one_thousand_milliseconds_in_seconds = 1;`
T 1709701499 18<27JAA18>	:-)
T 1709701530 18<29nightstrike18>	this was on like a $50m project with many layers of QA. That takes balls.
T 1709701551 18<27JAA18>	Nice
T 1709701633 18<29nightstrike18>	I think he was essentially giving the finger to QA
T 1709701649 18<29nightstrike18>	ah ha!  in my real code, I forgot to swap "match" with the actual match text :)
T 1709701779 18<25ormaaj18>	mapfile -t a <"$x"; typeset -i i; for i in "${!a[@]}"; do [[ $i == *match* ]] && i+=i-2 command unset -v -- 'a[i++]'{,,,,}; done
T 1709701840 18<29nightstrike18>	whoa
T 1709701844 18<27JAA18>	Probably `[[ ${a[i]} == *match* ]]`
T 1709701858 18<25ormaaj18>	that
T 1709701865 18<29nightstrike18>	that looks like magic
T 1709701879 18<29nightstrike18>	what's this {,,,,} notation?
T 1709701890 18<27JAA18>	Very neat trick on the `unset`, yeah.
T 1709701911 18<29nightstrike18>	I know of {1..5} for generating a sequence...
T 1709701945 18<27JAA18>	It just generates 'a[i++]' five times.
T 1709701962 18<27JAA18>	You might only want four, not sure.
T 1709701980 18<29nightstrike18>	should be 4, yeah
T 1709702003 18<27JAA18>	The effect is that it unsets ${a[i++]} five times, and the post-increment takes care of $i.
T 1709702048 18<27JAA18>	So it's equivalent to `unset -v -- 'a[i]' 'a[i+1]' 'a[i+2]' 'a[i+3]' 'a[i+4]'; ((i+=5))` more or less.
T 1709702056 18<29nightstrike18>	i+=i-2..  that seems a little suspect, no?
T 1709702070 18<27JAA18>	Yeah, that should be i+=-2.
T 1709702079 18<27JAA18>	Or i=i-2.
T 1709702087 18<29nightstrike18>	ok, got it...
T 1709702116 18<29nightstrike18>	well that's certainly better than what I wrote.  I still maintain that grep -v -C should work :)
T 1709702129 18<29nightstrike18>	thanks ormaaj , mind if I use your solution?
T 1709702213 18<29nightstrike18>	I guess that's the point of posting in an irc channel :)
T 1709702576 18<25ormaaj18>	+# shopt -s lastpipe; set +m; printf '%s\n' {0..4} match {6..10} | mapfile -t a; typeset -i i; for i in "${!a[@]}"; do [[ ${a[i]} == *match* ]] && i+=-2 command unset -v -- 'a[i++]'{,,,}; done; printf '%s ' "${a[@]}"; echo
T 1709702579 18<25shbot18>	ormaaj: 0 1 2 7 8 9 10
T 1709702584 18<29nightstrike18>	hm.. your code is a lot slower, unfortunately
T 1709702612 18<25ormaaj18>	It should be faster :o
T 1709702619 18<29nightstrike18>	Maybe I typed it wrong
T 1709702642 18<29nightstrike18>	maybe it's hung
T 1709702651 18<25ormaaj18>	if it's slower it's probably bash doing some stupid backflips to export i to command
T 1709702696 18<29nightstrike18>	there's about 140k lines of input text.  Mine finished in maybe ten seconds.  Yours is going on a minute now.
T 1709702722 18<29nightstrike18>	but again, I could have typed it wrong.  it's after midnight for me.
T 1709702732 18<29nightstrike18>	yup
T 1709702733 18<29nightstrike18>	s.bash: line 129: [i++]: bad array subscript
T 1709702735 18<25ormaaj18>	the first one I wrote has some bugs
T 1709702739 18<29nightstrike18>	I must have screwed that up
T 1709702746 18<25ormaaj18>	use the one I sent to shbot
T 1709702750 18<29nightstrike18>	ok
T 1709702863 18<29nightstrike18>	hm... the bugs you fixed are ones that I also fixed...  i+=-2, the LHS of the ==, the three ,,, isntead of 4
T 1709702910 18<25ormaaj18>	wouldn't be too surprised if it does something weird with a huge input either
T 1709702962 18<25ormaaj18>	It would be faster to read one line at a time, unset the preveious too elements, seek ahead a line, and continue
T 1709703064 18<29nightstrike18>	It would be faster to use sed :P
T 1709703071 18<25ormaaj18>	yes
T 1709703079 18<29nightstrike18>	I just don't know how
T 1709703090 18<29nightstrike18>	and both times I asked in #sed got crickets
T 1709703103 18<25ormaaj18>	well with sed you have to use labels and junk. I wouldn't bother.
T 1709703160 18<25ormaaj18>	that's the only way to look ahead more than one line
T 1709703163 18<29nightstrike18>	hm... yeah, it's the i++ that's causing bash to choke
T 1709703199 18<25ormaaj18>	bash sux
T 1709703210 18<20bent_fingers18>	nobody uses grep -f pattern-file
T 1709703215 18<25ormaaj18>	you should figure out where and report a bug :{
T 1709703225 18<29nightstrike18>	hah, they won't accept the bug report
T 1709703229 18<29nightstrike18>	this is bash 4.1.2
T 1709703232 18<20bent_fingers18>	do you think they'll remove the feature if i file a bug?
T 1709703237 18<25ormaaj18>	ah yeah. bug highly likely
T 1709703243 18<25ormaaj18>	probably a bug I reported
T 1709703248 18<25ormaaj18>	years ago
T 1709703258 18<29nightstrike18>	I sadly have to support RHEL6 for another 8 months, so I gotta live with old bash for now
T 1709703268 18<27larryv18>	bent_fingers: no.
T 1709703283 18<25ormaaj18>	41# shopt -s lastpipe; set +m; printf '%s\n' {0..4} match {6..10} | mapfile -t a; typeset -i i; for i in "${!a[@]}"; do [[ ${a[i]} == *match* ]] && i+=-2 command unset -v -- 'a[i++]'{,,,}; done; printf '%s ' "${a[@]}"; echo
T 1709703302 18<25ormaaj18>	is there a 41??
T 1709703310 18<25ormaaj18>	# triggers
T 1709703311 18<25shbot18>	ormaaj: Available triggers: +# bash-devel; 1# bash-1.14; 2# bash-2.05b; 32# bash-3.2; 3# bash-3.2; 42# bash-4.2; 43# bash-4.3; 44# bash-4.4; 4# bash-4.4; 50# bash-5.0; 51# bash-5.1; 52# bash-5.2; 5# bash-5.2; # bash-5.2; d# dash-0.5.9; sh# dash-0.5.9; k# ksh 93u+ 2012-08-01; m# mksh R59 2021/01/24; b# bourne; j# bourne(w/job);
T 1709703321 18<25ormaaj18>	42# shopt -s lastpipe; set +m; printf '%s\n' {0..4} match {6..10} | mapfile -t a; typeset -i i; for i in "${!a[@]}"; do [[ ${a[i]} == *match* ]] && i+=-2 command unset -v -- 'a[i++]'{,,,}; done; printf '%s ' "${a[@]}"; echo
T 1709703323 18<25shbot18>	ormaaj: bash: [i++]: bad array subscript
T 1709703323 18<25shbot18>	ormaaj: bash: [i++]: bad array subscript
T 1709703323 18<25shbot18>	ormaaj: 2 3 4 match 6 7 8 9 10
T 1709703336 18<29nightstrike18>	yeah that's what I get, bad array subscript
T 1709703340 18<25ormaaj18>	fine piece of shit bash is.
T 1709703361 18<29nightstrike18>	42 specifies the version?
T 1709703368 18<25ormaaj18>	something like that
T 1709703377 18<29nightstrike18>	well that's a friendly bot!
T 1709703414 18<29nightstrike18>	GNU bash, version 4.1.2(2)-release (x86_64-redhat-linux-gnu)
T 1709703427 18<29nightstrike18>	CentOS release 6.10 (Final)
T 1709703451 18<25ormaaj18>	mapfile must have been very new
T 1709703461 18<25ormaaj18>	i think it came out only shortly  before
T 1709703462 18<29nightstrike18>	it's 4+ only
T 1709703467 18<29nightstrike18>	yeah
T 1709703747 18<25ormaaj18>	oh wait lastpipe wouldn't have been available then either
T 1709703799 18<25ormaaj18>	42# printf '%s\n' {0..4} match {6..10} | { mapfile -t a; typeset -i i; for i in "${!a[@]}"; do [[ ${a[i]} == *match* ]] || continue; i+=-2 command unset -v -- 'a[i++]'{,,,}; done; printf '%s ' "${a[@]}"; echo; }
T 1709703801 18<25shbot18>	ormaaj: bash: [i++]: bad array subscript
T 1709703801 18<25shbot18>	ormaaj: bash: [i++]: bad array subscript
T 1709703801 18<25shbot18>	ormaaj: 2 3 4 match 6 7 8 9 10
T 1709703808 18<25ormaaj18>	:o
T 1709703817 18<27JAA18>	Huh, it unsets 0 and 1?
T 1709703848 18<27JAA18>	Oh, a match on the first line would be fun, too.
T 1709703859 18<25ormaaj18>	42# printf '%s\n' {0..4} match {6..10} | { mapfile -t a; typeset -i i; for i in "${!a[@]}"; do [[ ${a[i]} == *match* ]] || continue; (( i-=2 )); unset -v -- 'a[i++]'{,,,}; done; printf '%s ' "${a[@]}"; echo; }
T 1709703861 18<25shbot18>	ormaaj: 0 1 2 7 8 9 10
T 1709703889 18<25ormaaj18>	hm rite
T 1709703912 18<29nightstrike18>	JAA: for my purpose, it is guaranteed to not match on the first line
T 1709703932 18<27JAA18>	A match on the last line might also make it sad, or matches on consecutive lines, or matches two lines apart.
T 1709704019 18<22des_h18>	i have a log file with unix timestamps prefixing each line. i want to generate a new file where i convert the timestamps to a human format. i can retrieve the timestamps with either awk or sed, but how do i call the external `date` utility to perform the conversation and substitute the new value in place so that I output a modified line? in sed with some kind of bash command substitution it would be like `s/timestamp/$(convert timestamp)/`
T 1709704093 18<27JAA18>	I'd probably do it in gawk.
T 1709704098 18<29nightstrike18>	The program is outputting..  "attempted command X\nError processing command\nError was NOTFOUND\nprogram failed on 'attempted command X'"
T 1709704130 18<29nightstrike18>	There are many possible errors, I'm only trying to silence specifically the NOTFOUND error, so I'm guaranteed to get those four lines of text all at once
T 1709704137 18<29nightstrike18>	but I don't want to silence any other errors
T 1709704155 18<29nightstrike18>	(and I can't modify the source program to be less annoying)
T 1709704167 18<27JAA18>	Ah, fun.
T 1709704238 18<29nightstrike18>	des_h: we're having fun with mapfile right now. You can do the same!! (no really, don't)
T 1709704245 18<29nightstrike18>	(but you could)
T 1709704275 18<27JAA18>	lol
T 1709704281 18<25ormaaj18>	42# printf '%s\n' 0 match 2 3 4 match match {7..10} | { mapfile -t a; typeset -i i; for i in "${!a[@]}"; do [[ '((i -= 2) < 0 && i = 0), 1' -ne 0 ${a[i]} == *match* ]] || continue; unset -v -- 'a[i++]'{,,,}; done; printf '%s ' "${a[@]}"; echo; }
T 1709704283 18<25shbot18>	ormaaj: bash: syntax error in conditional expression
T 1709704283 18<25shbot18>	ormaaj: bash: syntax error near `${a[i]}'
T 1709704289 18<27JAA18>	If in Bash, I'd just do a `read` loop + `printf`.
T 1709704318 18<25ormaaj18>	ugh wat
T 1709704324 18<25ormaaj18>	+# printf '%s\n' 0 match 2 3 4 match match {7..10} | { mapfile -t a; typeset -i i; for i in "${!a[@]}"; do [[ '((i -= 2) < 0 && i = 0), 1' -ne 0 ${a[i]} == *match* ]] || continue; unset -v -- 'a[i++]'{,,,}; done; printf '%s ' "${a[@]}"; echo; }
T 1709704326 18<25shbot18>	ormaaj: bash: syntax error in conditional expression
T 1709704326 18<25shbot18>	ormaaj: bash: syntax error near `${a[i]}'
T 1709704330 18<27JAA18>	wut is that string?
T 1709704339 18<25ormaaj18>	oh
T 1709704346 18<25ormaaj18>	+# printf '%s\n' 0 match 2 3 4 match match {7..10} | { mapfile -t a; typeset -i i; for i in "${!a[@]}"; do [[ '((i -= 2) < 0 && i = 0), 1' -ne 0 && ${a[i]} == *match* ]] || continue; unset -v -- 'a[i++]'{,,,}; done; printf '%s ' "${a[@]}"; echo; }
T 1709704349 18<25shbot18>	ormaaj: bash: [[: ((i -= 2) < 0 && i = 0), 1: attempted assignment to non-variable (error token is "= 0), 1")
T 1709704349 18<25shbot18>	ormaaj: bash: [[: ((i -= 2) < 0 && i = 0), 1: attempted assignment to non-variable (error token is "= 0), 1")
T 1709704349 18<25shbot18>	ormaaj: etc... ( http://paste.wooledge.org/29296 )
T 1709704372 18<25fireonlive18>	# exit
T 1709704373 18<25shbot18>	fireonlive: logout
T 1709704373 18<25shbot18>	fireonlive: (shell exited with 0)
T 1709704381 18<25ormaaj18>	mh I'm not testing wraparound either. Screw you if you need that.
T 1709704537 18<29nightstrike18>	ormaaj: what's the reason for { mapfile...} vs (mapfile...) ?
T 1709704568 18<25ormaaj18>	{ doesn't create a subshell
T 1709704573 18<29nightstrike18>	ah, ok
T 1709704622 18<25ormaaj18>	I don't know what the problem with that last one is
T 1709704625 18<27JAA18>	But really, what is that string in the comparison?
T 1709704643 18<29nightstrike18>	I'm still trying to get the first one working
T 1709704645 18<27JAA18>	Doesn't that need to be a `$((...))` or something?
T 1709704665 18<29nightstrike18>	ormaaj> 42# printf '%s\n' {0..4} match {6..10} | { mapfile -t a; typeset -i i; for i in "${!a[@]}"; do [[ ${a[i]} == *match* ]] || continue; i+=-2 command unset -v -- 'a[i++]'{,,,}; done; printf '%s ' "${a[@]}"; echo; }
T 1709704666 18<29nightstrike18>	that one
T 1709704715 18<25ormaaj18>	wow that is a bug
T 1709704737 18<25ormaaj18>	I can't do anything without finding a bug
T 1709704759 18<27JAA18>	lol
T 1709704770 18<27JAA18>	:-)
T 1709704859 18<25ormaaj18>	no shell accepts that expression
T 1709704865 18<25ormaaj18>	I don't understand what's wrong with it\
T 1709704886 18<25ormaaj18>	+# let '(i -= 2) < 0 && i = 0'
T 1709704888 18<25shbot18>	ormaaj: bash: let: (i -= 2) < 0 && i = 0: attempted assignment to non-variable (error token is "= 0")
T 1709704896 18<25ormaaj18>	looks correct to me
T 1709704917 18<25ormaaj18>	k# let '(i -= 2) < 0 && i = 0'
T 1709704919 18<25shbot18>	ormaaj: ksh: let: (i -= 2) < 0 && i = 0: assignment requires lvalue
T 1709704925 18<25ormaaj18>	there is a fucking lvalue
T 1709704940 18<27larryv18>	&& has higher precedence than =
T 1709704955 18<25ormaaj18>	>:(
T 1709705062 18<25ormaaj18>	41# printf '%s\n' 0 match 2 3 4 match match {7..10} | { mapfile -t a; typeset -i i; for i in "${!a[@]}"; do [[ '(i -= 2) < 0 && (i = 0), 1' -ne 0 && ${a[i]} == *match* ]] || continue; unset -v -- 'a[i++]'{,,,}; done; printf '%s ' "${a[@]}"; echo; }
T 1709705074 18<25ormaaj18>	42# printf '%s\n' 0 match 2 3 4 match match {7..10} | { mapfile -t a; typeset -i i; for i in "${!a[@]}"; do [[ '(i -= 2) < 0 && (i = 0), 1' -ne 0 && ${a[i]} == *match* ]] || continue; unset -v -- 'a[i++]'{,,,}; done; printf '%s ' "${a[@]}"; echo; }
T 1709705076 18<25shbot18>	ormaaj: 0 9 10
T 1709705079 18<25ormaaj18>	yay!
T 1709705081 18<25ormaaj18>	>:(
T 1709705104 18<27larryv18>	lolol
T 1709705631 18<29nightstrike18>	ormaaj: what was the ultimate fix for "bad subscript" with older bash?
T 1709705791 19*	Now talking on 22#bash
T 1709705791 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709705791 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709705846 18<29nightstrike18>	but what individual change made that go away? there were quite a few changes you were working with
T 1709705849 18<25ormaaj18>	which is odd, because an empty arithmetic expression is valid and equals zero. And those expressions were not empty
T 1709705871 18<25ormaaj18>	that last one looks like it works
T 1709705919 18<29nightstrike18>	I was trying to keep it simpler since I didn't need those extra cases
T 1709705923 18<29nightstrike18>	but I'll try it all the same
T 1709706040 18<29nightstrike18>	it doesn't
T 1709706299 18<29nightstrike18>	oh, hm..
T 1709706307 18<29nightstrike18>	it's almsot working
T 1709706351 18<29nightstrike18>	hey, it worked
T 1709706370 18<29nightstrike18>	both your one from before the extra requirements and the one you ended with
T 1709706407 18<29nightstrike18>	I had accidentally switched terminals to one that was using an older input program (the thing providing this garbage output), and its formatting was significantly different
T 1709706523 18<29nightstrike18>	it's still kinda slow, but it wokrs
T 1709706813 18<29nightstrike18>	ormaaj: ty for all the help. I'm gonna run with this.
T 1709706832 18<29nightstrike18>	Time to head to bed.   goodnight all
T 1709707318 18<25ormaaj18>	How are you supposed to get the max index of an array anyway?
T 1709707504 18<25ormaaj18>	# typeset -a a=([10]=); typeset -n r=a[-1]; echo "${!r}"
T 1709707507 18<25shbot18>	ormaaj: a[-1]
T 1709707510 18<25ormaaj18>	k# typeset -a a=([10]=); typeset -n r=a[-1]; echo "${!r}"
T 1709707512 18<25shbot18>	ormaaj: a[10]
T 1709707514 18<25ormaaj18>	fuck you bash.
T 1709707548 18<27JAA18>	Is iteration over keys guaranteed to be in order?
T 1709707555 18<25ormaaj18>	yes
T 1709707581 18<25ormaaj18>	I mean like, if you expand "${!a[@]}",  that will be in order
T 1709707611 18<27JAA18>	Yeah
T 1709707616 18<27JAA18>	Hmm
T 1709707651 18<25ormaaj18>	so b=("${!a[@]}"); echo "${b[-1]}"; will do it, but damn. All because Chet doesn't know how a freaking list should work.
T 1709707653 18<27JAA18>	And you can't do something like ${!a[-1]}.
T 1709707664 18<27JAA18>	Heh
T 1709707670 18<27JAA18>	Yeah, Bash arrays are weird.
T 1709710608 18<24xmb18>	if arr is without holes , ${#arr[@]} will return its next elem
T 1709710620 18<24xmb18>	0 1 2 , = 3
T 1709710634 18<27JAA18>	Yeah, but the discussion above was about sparse arrays.
T 1709710642 18<24xmb18>	ah k
T 1709710890 18<28emanuele618>	ack
T 1709712593 18<29andre144k18>	hello, how to "pgrep -f" for process "foo" or "bar" ?
T 1709712620 18<29andre144k18>	so when both is running once i get two process ids
T 1709712759 18<22pj18>	# ar=(); ar[1]=a ar[5]=b; ari=("${!ar[@]}"); echo "${ari[-1]}"
T 1709712761 18<25shbot18>	pj: 5
T 1709712773 18<22pj18>	JAA: This is the best way I can think of ^^^^^
T 1709712799 18<29andre144k18>	hopefully not for me ^^
T 1709712804 18<27JAA18>	Yeah
T 1709712817 18<22pj18>	basically copying the indexes into another array
T 1709712825 18<22pj18>	and then accessing the last element of that array
T 1709712873 18<22pj18>	oh, I see ormaaj came up with that earlier.
T 1709715092 18<24xmb18>	andre $( pgrep -f foo ; pgrep -f bar )
T 1709715125 18<24xmb18>	since it says only one pattern
T 1709715636 18<28emanuele618>	you can use  pgrep -f 'foo|bar'   i think
T 1709715676 18<28emanuele618>	yes
T 1709715746 18<29andre144k18>	thx
T 1709715748 18<27JAA18>	It's an ERE according to the man page.
T 1709715754 18<28emanuele618>	>:(
T 1709715781 18<27JAA18>	I completely missed it at first as it's tucked away near the bottom for some reason.
T 1709715857 18<28emanuele618>	did you know that "JAA" is a regular expression? :o
T 1709715872 18<27JAA18>	Whoa
T 1709715891 18<28emanuele618>	# printf 'Hello, %s\n' JAA emanuele6 | grep JAA
T 1709715892 18<25shbot18>	emanuele6: Hello, JAA
T 1709715921 18<27JAA18>	Amazing!
T 1709715933 18<28emanuele618>	JAAmazing!
T 1709715941 18<27JAA18>	:-)
T 1709718283 18<28nphard18>	is it posible a loop with two different values? cut -f1, cut -f2
T 1709718350 18<24xmb18>	u can save to two data structures
T 1709718351 18<28nphard18>	a yes with a variable perhaps?
T 1709718369 18<24xmb18>	whats the cut output look like
T 1709718406 18<28nphard18>	let's say the loop it's only for two iterations, how to tell the second time has to use 'cut -f2'?
T 1709718429 18<24xmb18>	show cut output plz ?
T 1709718441 18<28nphard18>	alright
T 1709718450 18<28nphard18>	it's kinda simple
T 1709718505 18<28nphard18>	https://dpaste.com/BLMFQKH44
T 1709718535 18<24xmb18>	u load -f1 into an arr , and -f2 to another
T 1709718547 18<24xmb18>	then u use those diff arrs for values
T 1709718658 18<28nphard18>	an array?
T 1709718689 18<20osse18>	while read -r num1 num2 num3; do blabla "$num1" "$num2" "$num3"; done
T 1709718702 18<20osse18>	no cut needed
T 1709718752 18<28nphard18>	osse: I need the columns
T 1709718773 18<28nphard18>	wow, so many ways, arrays, 'read -r'
T 1709718782 18<24xmb18>	v1=( 1 1 1 ) v2=( 2 2 2 ) v3=( 3 3 3 ) i=-1 ; while (( ++i <= ${#a[@]} )) ; do declare -n d1=a[i] d2=b[i] ; printf %s\\n "$i : $d1 / $d2" ; exit ; done
T 1709718799 18<28nphard18>	darn1!
T 1709718812 18<28nphard18>	that felt like a punch in the face.
T 1709718817 18<20osse18>	If the number of columns in known I would add num1, num2 and num3 to as many different arrays and process the arrays after the loop is done
T 1709718965 18<28nphard18>	alright, this is interesting, i'll be back to put all this into practice.
T 1709718965 18<24xmb18>	# v1=( 1 1 1 ) v2=( 2 2 2 ) v3=( 3 3 3 ) i=-1 ; while (( ++i <= ${#a[@]} )) ; do declare -n d1=v1[i] d2=v2[i] ; printf %s\\n "$i : $d1 / $d2" ; exit ; done
T 1709718968 18<25shbot18>	xmb: 0 : 1 / 2
T 1709718968 18<25shbot18>	xmb: logout
T 1709718968 18<25shbot18>	xmb: (shell exited with 0)
T 1709718970 18<28nphard18>	thanks all.
T 1709718978 18<24xmb18>	that one works
T 1709719024 18<28emanuele618>	# printf '1\t2\t3\na\tb\tc\nX\tY\tZ\n'
T 1709719026 18<25shbot18>	emanuele6: 1       2       3
T 1709719026 18<25shbot18>	emanuele6: a       b       c
T 1709719026 18<25shbot18>	emanuele6: X       Y       Z
T 1709719031 18<28emanuele618>	# printf '1\t2\t3\na\tb\tc\nX\tY\tZ\n' | jq -rnR '[ inputs / "\t" ] | transpose[] | join("\t")'
T 1709719033 18<25shbot18>	emanuele6: 1       a       X
T 1709719033 18<25shbot18>	emanuele6: 2       b       Y
T 1709719033 18<25shbot18>	emanuele6: 3       c       Z
T 1709719034 18<28nphard18>	xmb: but, declaring the variables with each column can become unwieldy with large numbers of files and unknown data fields.
T 1709719063 18<28nphard18>	xmb: does your solution need to put manually the data into the arrays manually for each file?
T 1709719075 18<24xmb18>	# v1=( 1 1 1 ) v2=( 2 2 2 ) v3=( 3 3 3 ) i=-1 ; while (( ++i <= ${#a[@]} )) ; do  printf %s\\n "$i : ${v1[i]} / ${v2[i]}" ; exit ; done
T 1709719077 18<25shbot18>	xmb: 0 : 1 / 2
T 1709719077 18<25shbot18>	xmb: logout
T 1709719077 18<25shbot18>	xmb: (shell exited with 0)
T 1709719096 18<24xmb18>	nphard it depends only on ur request
T 1709719103 18<28nphard18>	ths --> v1=( 1 1 1 ) v2=( 2 2 2 ) v3=( 3 3 3 )
T 1709719128 18<28nphard18>	*this
T 1709719147 18<28nphard18>	xmb: that's why I was using 'cut -fN'
T 1709719166 18<27Soliton18>	cut is very rarely useful.
T 1709719175 18<27Soliton18>	what is the goal?
T 1709719178 18<28nphard18>	pre-populating the arrays seems like hell of an extra work!!
T 1709719208 18<28nphard18>	Soliton: somthing like this --> https://dpaste.com/BLMFQKH44
T 1709719236 18<27Soliton18>	that is the input or output you want or what?
T 1709719255 18<28nphard18>	I was gonna use 'for in' but then realized is not that simple to change the values of '-fN' in the middle of the loop.
T 1709719279 18<28nphard18>	Soliton: 'cut -f1 file_with_cols'
T 1709719294 18<27Soliton18>	alright so there is no goal. nevermind.
T 1709719309 18<24xmb18>	awk ' { print $1 } '
T 1709719315 18<24xmb18>	this ur cut tries ?
T 1709719323 18<24xmb18>	print first col , then second
T 1709719325 18<28nphard18>	Soliton: separate the columns is the goal.
T 1709719330 18<24xmb18>	$1 only first
T 1709719345 18<28nphard18>	Soliton: in a loop
T 1709719345 18<27Soliton18>	and what does separate the columns mean?
T 1709719361 18<28nphard18>	filaA, fileB, fileC.
T 1709719367 18<27Soliton18>	!faq1
T 1709719367 18<29greybot18>	https://mywiki.wooledge.org/BashFAQ/001 -- How can I read a file (data stream, variable) line-by-line (and/or field-by-field)?
T 1709719432 18<28nphard18>	xmb: use it directly with the files? --> awk ' { print $1 } ' file_with_colums
T 1709719443 18<27Soliton18>	so far no idea how cut would do anything useful.
T 1709719463 18<28nphard18>	Soliton: that's why I am asking.
T 1709719479 18<27Soliton18>	but you're asking about cut and we have no idea what the actual goal is.
T 1709719481 18<28nphard18>	if I had the solution I would no be asking.
T 1709719494 18<24xmb18>	awk to print eleme
T 1709719502 18<28nphard18>	xmb: thanks, i'll try that
T 1709719508 18<24xmb18>	cut my tries failed , so awk
T 1709719517 18<24xmb18>	the point was , hold ..
T 1709719521 18<28nphard18>	xmb: can it be use in a loop?
T 1709719533 18<24geirha18>	while IFS=$'\t' read -r f1 f2 f3 ; do a+=( "$f1" ) b+=( "$f2" ) c+=( "$f3" ) ; done < file_with_cols
T 1709719539 18<24geirha18>	now you have three arrays
T 1709719554 18<28nphard18>	geirha: dope
T 1709719593 18<27Soliton18>	always amazes me a bit why people make it so hard to help them.
T 1709719594 18<28nphard18>	Soliton: why isn't 'cut' reccomended? Manually it was working quite well.
T 1709719595 18<24xmb18>	# dat=$'1 2 3\n1 2 3\n1 2 3' v1=( $( awk ' { print $2 } ' <<<"$dat" ) ) v2=( $( awk ' { print $2 } ' <<<"$dat" ) ) ; declare -p v2 v1
T 1709719597 18<25shbot18>	xmb: declare -a v2=([0]="2" [1]="2" [2]="2")
T 1709719597 18<25shbot18>	xmb: declare -a v1=([0]="2" [1]="2" [2]="2")
T 1709719603 18<24xmb18>	oo
T 1709719603 18<27Soliton18>	for what?
T 1709719614 18<24xmb18>	# dat=$'1 2 3\n1 2 3\n1 2 3' v1=( $( awk ' { print $1 } ' <<<"$dat" ) ) v2=( $( awk ' { print $2 } ' <<<"$dat" ) ) ; declare -p v2 v1
T 1709719615 18<25shbot18>	xmb: declare -a v2=([0]="2" [1]="2" [2]="2")
T 1709719615 18<25shbot18>	xmb: declare -a v1=([0]="1" [1]="1" [2]="1")
T 1709719622 18<27Soliton18>	if you want to do exactly what cut does then use it. you almost never do though.
T 1709719637 18<24geirha18>	don't do v1=( $(anything )   that's just broken
T 1709719640 18<24xmb18>	in this u make dat=.. away and both <<<"$dat" and replace em with ur file/s
T 1709719652 18<24xmb18>	awk ' code ' files
T 1709719713 18<27Soliton18>	i don't understand why you can't explain a goal. like "i have tab delimited input and i want to iterate it column by column" or whatever.
T 1709719730 18<24xmb18>	# printf $'1 2 3\n1 2 3\n1 2 3\n' >f1 ; v1=( $( awk ' { print $1 } ' f1 ) ) v2=( $( awk ' { print $2 } ' f1 ) ) ; declare -p v2 v1
T 1709719731 18<27Soliton18>	afaict it's just a big guessing game so far.
T 1709719733 18<25shbot18>	xmb: declare -a v2=([0]="2" [1]="2" [2]="2")
T 1709719733 18<25shbot18>	xmb: declare -a v1=([0]="1" [1]="1" [2]="1")
T 1709719742 18<29djph18>	Soliton: there's a bashphorism about that.
T 1709719839 18<27Soliton18>	(the only input shown so far wasn't tab delimited, btw.)
T 1709719875 18<24geirha18>	I'm just assuming the tabs got expanded into spaces either through copy/pasting or the pastebin itself
T 1709719903 18<24geirha18>	given that cut -f2 apparently works on the real data
T 1709719919 18<24xmb18>	the pastebin web looks like tabs
T 1709719954 18<27Soliton18>	i wonder how something not containing tabs looks like tabs.
T 1709719956 18<24xmb18>	# printf $'1\t2\t3\n1\t2\t3\n1\t2\t3\n' >f1 ; v1=( $( awk ' { print $1 } ' f1 ) ) v2=( $( awk ' { print $2 } ' f1 ) ) ; declare -p v2 v1
T 1709719958 18<25shbot18>	xmb: declare -a v2=([0]="2" [1]="2" [2]="2")
T 1709719958 18<25shbot18>	xmb: declare -a v1=([0]="1" [1]="1" [2]="1")
T 1709719986 18<24xmb18>	soli , there is much space between 1 and 2 and 3
T 1709719997 18<24xmb18>	im his web link , andro chrome client
T 1709720000 18<27Soliton18>	3 spaces in fact, yes. no tab in sight.
T 1709720005 18<24geirha18>	anyway, running cut or awk for each column is wasteful and you risk ending up with broken data. Especially bad when you use $() instead of reading it line by line
T 1709720006 18<24xmb18>	k
T 1709720043 18<24xmb18>	the $( is only format safe-format , he used 1 2 3 thats simple
T 1709720094 18<24geirha18>	That's obviously dummy data
T 1709720133 18<24xmb18>	ye well
T 1709720142 18<28emanuele618>	we yell
T 1709720149 18<24geirha18>	Consider what happens if you read column1 into array v1, then some process comes along and updates the tsv file, then you read column2 into array v2. Now v1 and v2 do not correspond to each other. Better to read the file once
T 1709720162 18<27Soliton18>	!using > nphard
T 1709720162 18<29greybot18>	nphard: "How can I do X using Y?" NEVER ask a question of that form. Y may not be the best way to do X. All you should ask is, "How do I do X?"
T 1709720209 18<24xmb18>	dude deliver code that uses [[ updated_file ]] then
T 1709720233 18<24geirha18>	wat?
T 1709720328 18<24xmb18>	erm i tried simple on topic
T 1709720362 18<24xmb18>	file read once , ye
T 1709720418 18<24xmb18>	# printf $'1\t2\t3\n1\t2\t3\n1\t2\t3\n' >f1 ; f=$( < f1 ) v1=( $( awk ' { print $1 } ' <<<"$f" ) ) v2=( $( awk ' { print $2 } ' <<<"$f" ) ) ; declare -p v2 v1
T 1709720420 18<25shbot18>	xmb: declare -a v2=([0]="2" [1]="2" [2]="2")
T 1709720420 18<25shbot18>	xmb: declare -a v1=([0]="1" [1]="1" [2]="1")
T 1709720479 18<27Soliton18>	!pf 50
T 1709720479 18<29greybot18>	https://mywiki.wooledge.org/BashPitfalls#pf50 -- Don't do this! -- hosts=( $(aws …) )
T 1709720550 18<27Soliton18>	why do you write code like that? do you think you're actually helping anyone?
T 1709721173 18<29netmonk18>	is there a good ressource explaining bash name expension regular expression
T 1709721175 18<29netmonk18>	?
T 1709721207 18<28llua18>	eh
T 1709721230 18<28emanuele618>	bash is a regular expression
T 1709721258 18<29netmonk18>	for instance, i do ls *foobar* which expand to 12_foobar and 12_foobar_1 but i would like to exclude the second one
T 1709721268 18<27Soliton18>	!glob
T 1709721268 18<29greybot18>	Globs are shell patterns that can be used for matching strings or expanding pathnames: [[ $name = Bob* ]]; rm -- *.txt; see http://mywiki.wooledge.org/glob
T 1709721277 18<27Soliton18>	!extblog
T 1709721281 18<27Soliton18>	!extglob
T 1709721281 18<29greybot18>	"Extended globs" (shopt -s extglob) allow you to say things like "all files that do not end in .jpg". See http://mywiki.wooledge.org/glob#extglob
T 1709721300 18<27Soliton18>	those are not regular expressions.
T 1709721338 18<29netmonk18>	ok i understand, is it possible just using blob to exlude 12_foobar_1 ?
T 1709721365 18<28llua18>	see the second link
T 1709721366 18<27Soliton18>	if you want the file to end with foobar then just don't put a * at the end.
T 1709721409 18<27Soliton18>	# touch 12_foobar 12_foobar_1; printf %s\\n *foobar
T 1709721411 18<25shbot18>	Soliton: 12_foobar
T 1709721462 18<29nvz18>	if you just want to exclude one file in particular you prob need to read the results of expansion and test
T 1709721478 18<27Soliton18>	or use an extglob.
T 1709721497 18<29netmonk18>	ok in this case yes, but this is not my exact current case. ls *foobar* -> 12_foobar_009_1 and 12_foobar_009 and 11_foobar_010_1 and 11_foobar_010
T 1709721514 18<29netmonk18>	i just want to keep the one not ending with _1
T 1709721527 18<27Soliton18>	# touch 12_foobar 12_foobar_1; printf %s\\n *foobar!(_1)
T 1709721529 18<25shbot18>	Soliton: 12_foobar
T 1709721543 18<27Soliton18>	(shbot has extglob enabled by default.)
T 1709721676 18<29netmonk18>	ok
T 1709721719 18<27Soliton18>	ah, you actually have more stuff in between.
T 1709721728 18<27Soliton18>	# touch 12_foobar_009_1 12_foobar_009 11_foobar_010_1 11_foobar_010; printf %s\\n *foobar!(*_1)
T 1709721729 18<25shbot18>	Soliton: 11_foobar_010
T 1709721729 18<25shbot18>	Soliton: 12_foobar_009
T 1709721732 18<29netmonk18>	and next issue, this doesnt work when the blob is an argument of a bash function
T 1709721792 18<27Soliton18>	# touch 12_foobar_009_1 12_foobar_009 11_foobar_010_1 11_foobar_010; f() { printf %s\\n "$@"; }; f *foobar!(*_1)
T 1709721794 18<25shbot18>	Soliton: 11_foobar_010
T 1709721794 18<25shbot18>	Soliton: 12_foobar_009
T 1709721802 18<27Soliton18>	not sure what you mean.
T 1709721836 18<27Soliton18>	you need to enable extglob (shopt -s extglob) in your shell to use extended globs.
T 1709721872 18<29netmonk18>	got a syntax error near token (
T 1709721878 18<27Soliton18>	you need to enable extglob (shopt -s extglob) in your shell to use extended globs.
T 1709721932 18<29netmonk18>	ok, this was the issue sorry im slow reader :)
T 1709721935 18<29netmonk18>	thanks solitonm
T 1709721942 18<29netmonk18>	s/nm/n/
T 1709721943 18<27Soliton18>	you're welcome.
T 1709721959 18<29nvz18>	that is a regular expression
T 1709722000 18<27Soliton18>	# [[ foo =~ *foobar!(*_1) ]]; echo $?
T 1709722001 18<25shbot18>	Soliton: 2
T 1709722017 18<27Soliton18>	nope, not a valid regular expression.
T 1709722039 18<29nvz18>	no i mean the search and replace
T 1709722095 18<29nvz18>	where they mispelled your nick
T 1709722487 18<29netmonk18>	that's right
T 1709722507 18<29netmonk18>	an old habit from #unix@ircnet to correct mispell by regexo
T 1709722553 18<28emanuele618>	+# [[ foo =~ *foobar!(*_1) ]]
T 1709722555 18<25shbot18>	emanuele6: bash: [[: invalid regular expression `*foobar!(*_1)': Invalid preceding regular expression
T 1709722564 18<28emanuele618>	nope; not a valid regular expression. :D
T 1709722629 18<28emanuele618>	because invalid preceding regular expression before *foobar!(*_1)
T 1709722662 18<28emanuele618>	no, actually it just prints the entire pattern for every error
T 1709722683 18<28emanuele618>	anyway, it prints the regex error from lib c in bash devel
T 1709722689 18<19Artfaith18>	Is it possible to change type of variable from array to string without any intermediary variable?
T 1709722715 18<19Artfaith18>	# declare a=( 0 1 ); declare a="${a[0]}"; declare -p a;
T 1709722717 18<25shbot18>	Artfaith: declare -a a=([0]="0" [1]="1")
T 1709722722 18<19Artfaith18>	# declare a=( 0 1 ); declare a="${a[1]}"; declare -p a;
T 1709722724 18<25shbot18>	Artfaith: declare -a a=([0]="1" [1]="1")
T 1709722782 18<19Artfaith18>	# declare a=( 0 1 ); declare _a="${a[1]}"; unset a; declare a="$_a"; declare -p a;
T 1709722784 18<25shbot18>	Artfaith: declare -- a="1"
T 1709722829 18<28emanuele618>	# eval 'unset -v a; a='"${a[1]@Q}"
T 1709722831 18<25shbot18>	emanuele6: no output
T 1709722861 18<19Artfaith18>	emanuele6, thank you, but is there any normal way?
T 1709722926 18<28emanuele618>	using declare with an assignment is not going remove attributes. to remove attributes you use  declare +a  (where a is the attribute letter). it is only legal to use +a on unset variables.
T 1709722963 18<28nphard18>	geirha: while IFS=$'\t' read -r f1 f2 f3 ; do a+=( "$f1" ) b+=( "$f2" ) c+=( "$f3" ) ; done < file_with_cols <--- this command, when reading back the variable 'echo $a' it only prints one character, not the actual column.
T 1709723003 18<27Soliton18>	!faq 5
T 1709723003 18<29greybot18>	https://mywiki.wooledge.org/BashFAQ/005 -- How can I use array variables?
T 1709723007 18<28emanuele618>	nphard:   printf %s\\n "${a[@]}"    not   echo $a
T 1709723057 18<28emanuele618>	note that if there are empty fields  IFS=$'\t'   will not work as you expect; empty fields are skipped
T 1709723080 18<28emanuele618>	a\t\tb   is the same as  a\tb\t    and  \t\tx   is the same as  x\t\t
T 1709723262 18<28nphard18>	interesting, had to clear the variable first after typing so many randomn commands.
T 1709723327 18<25ormaaj18>	I skip empty fields. Go to strawberry fields
T 1709723354 18<28nphard18>	mm.. this is quite interesting. So the columns have been split without any loop or awk or 'cut'.
T 1709723377 18<28nphard18>	somewhat wild.
T 1709723442 18<25ormaaj18>	woh
T 1709723470 18*	28nphard staring into the distance in state of shock
T 1709723478 18<25imi18>	hi, is there a better (quicker) way to check if given variable is an integer number than grep?
T 1709723513 18<28emanuele618>	!faq number
T 1709723513 18<29greybot18>	https://mywiki.wooledge.org/BashFAQ/018 -- How can I use numbers with leading zeros in a loop, e.g. 01, 02?
T 1709723518 18<28emanuele618>	hmm, not that
T 1709723553 18<28emanuele618>	anyway, you can use    case $x in ''|*[!0123456789]*) echo no;; *) echo yes; esac
T 1709723573 18<28emanuele618>	if it is empty, or contains a character that is not 0123456789 you could say it is not a number
T 1709723578 18<25imi18>	when I have leading zeroes I prefix it with 1 and then subtract 100. now the leading zeroes are gone
T 1709723593 18<19Artfaith18>	emanuele6, to clarify, remove attributes from unset variable?
T 1709723596 18<25imi18>	ok thanks
T 1709723603 18<19Artfaith18>	What is the reason to remove an attribute from anything unset?
T 1709723620 18<19Artfaith18>	Like, in case of local variable?
T 1709723634 18<28emanuele618>	you can only remove +a and +A from unset variables; if they have a value you cannot remove those attributes
T 1709723665 18<28nphard18>	emanuele6: so... when to use these? --> a\t\tb , a\tb\t , \t\tx , x\t\t
T 1709723666 18<28emanuele618>	other attributes e.g. l, x, u, i, can be removed whenever.
T 1709723666 18<19Artfaith18>	Other attributes can be remove but these two?
T 1709723682 18<19Artfaith18>	I see...
T 1709723689 18<19Artfaith18>	Thank you, emanuele6!
T 1709723713 18<28emanuele618>	# printf 'a\t\tb\n\ta\tb\n'
T 1709723714 18<25shbot18>	emanuele6: a               b
T 1709723715 18<25shbot18>	emanuele6:         a       b
T 1709723756 18<28emanuele618>	# printf 'a\t\tb\n\ta\tb\n' | while IFS=$'\t' read -r f1 f2 f3; do printf 'f1=%q f2=%q f3=%q\n' "$f1" "$f2" "$f3"; done
T 1709723758 18<25shbot18>	emanuele6: f1=a f2=b f3=''
T 1709723758 18<25shbot18>	emanuele6: f1=a f2=b f3=''
T 1709723786 18<28emanuele618>	nphard: i was saying that for   IFS=$'\t' read -r f1 f2 f3    those sets of two lines are the same
T 1709723815 18<28emanuele618>	if you have an hole in one of the columns
T 1709723840 18<28nphard18>	ah, yes, sometimes there'll be holes.
T 1709723861 18<25imi18>	emanuele6: what about negative numbers?
T 1709723880 18<28emanuele618>	you can use   case ${x#-} in ...
T 1709723889 18<25imi18>	ok thanks
T 1709723897 18<28emanuele618>	that way if there is a - at the start, and it still matches, it is allowed
T 1709723924 18<28emanuele618>	#- removes a - from the start of $x; so it checks the patterns on the value of $x with - removed
T 1709723976 18<25ormaaj18>	x<<1,x>>1
T 1709723986 18<28emanuele618>	!faq valid
T 1709723986 18<29greybot18>	https://mywiki.wooledge.org/BashFAQ/054 -- How can I tell whether a variable contains a valid number?
T 1709723994 18<28emanuele618>	that was the faq i was looking for :D
T 1709724017 18<25ormaaj18>	><
T 1709724020 18<28emanuele618>	ormaaj: x<<=1,x>>=1 ?
T 1709724031 18<25ormaaj18>	ya!
T 1709724194 18<28emanuele618>	nphard: then you cannot use  IFS=$'\t' read -r f1 f2 f3    you could use   while read -r; do a+=( "${REPLY%%$'\t'*}" ) REPLY=${REPLY#*$'\t'} b+=( "${REPLY%%$'\t'*}" ) REPLY=${REPLY#*$'\t'} c+=( "$REPLY" ); done
T 1709724274 18<28emanuele618>	# printf 'a\t\tb\n\ta\tb\n' | while read -r; do f1=${REPLY%%$'\t'*} REPLY=${REPLY#*$'\t'} f2=${REPLY%%$'\t'*} REPLY=${REPLY#*$'\t'} f3=$REPLY; printf 'f1=%q f2=%q f3=%q\n' "$f1" "$f2" "$f3"; done
T 1709724276 18<25shbot18>	emanuele6: f1=a f2='' f3=b
T 1709724276 18<25shbot18>	emanuele6: f1='' f2=a f3=b
T 1709724778 18<25ormaaj18>	shifty eyes <<
T 1709724800 18<25ormaaj18>	shifty numbers
T 1709724849 18<25ormaaj18>	there should be rotate operators :(
T 1709725054 18<28emanuele618>	x<<=1,x&=!!(x^x>>1)
T 1709725084 18<28emanuele618>	err |=
T 1709725108 18<28emanuele618>	hmm, i am not sure
T 1709725142 18<28emanuele618>	is bash's >> signed? if it is signed, it does not work
T 1709725158 18<28emanuele618>	# echo "$(( -2 >> 1 ))"
T 1709725159 18<25shbot18>	emanuele6: -1
T 1709725162 18<28emanuele618>	:\
T 1709725316 18<28emanuele618>	need to assume 64bit and use  x&(1<<63)     x=x<<1|!!(x&1<<63)
T 1709725334 18<25OMGOMG18>	emanuele6: what was that supposed to demonstrate?
T 1709725352 18<28emanuele618>	that -2 >> 1  is signed?
T 1709725408 18<25OMGOMG18>	what would the unsigned equivalent look like
T 1709725412 18<28emanuele618>	-2 is    1111111111111111111111111111111111111111111111111111111111111110
T 1709725426 18<28emanuele618>	if it is signed >>1 results in   1111111111111111111111111111111111111111111111111111111111111111
T 1709725430 18<28emanuele618>	so -1
T 1709725443 18<28emanuele618>	if it is not signed, it results in   0111111111111111111111111111111111111111111111111111111111111111
T 1709725459 18<28emanuele618>	that is 9223372036854775807
T 1709725470 18<25OMGOMG18>	ok
T 1709725473 18<25OMGOMG18>	thanks
T 1709725509 18<28emanuele618>	signed >> duplicates the top bit, so it adds a 0 if the top bit is 0, otherwise it adds a 1 if the top bit is 1
T 1709725518 18<28emanuele618>	while unsigned >> always adds 0s
T 1709725612 18<28nphard18>	darn! bash makes you think harder every step :/
T 1709725645 18<25OMGOMG18>	do you often encounter unsigned >> ?
T 1709725799 18<28emanuele618>	?
T 1709726060 18<24ano18>	what's the best way to strip trailing char?
T 1709726096 18<28emanuele618>	%%+([chars])  ?
T 1709726211 18<24ano18>	what about portable way, ${#... ${...%%[chars] loop?
T 1709726515 18<24ano18>	# char=/; var=/path/to//////////////; until (( "${#var}" == "${var_len=0}" )); do var_len=${#var}; var=${var%%${char}}; done; echo $var
T 1709726517 18<25shbot18>	ano: /path/to
T 1709726574 18<28emanuele618>	so busybox has (( but not +()?
T 1709726593 18<28emanuele618>	"$char" not $char
T 1709726656 18<28emanuele618>	also   ""  in  (( or $((  is a big no no in most shells
T 1709726657 18<24ano18>	hmm no it doesn't
T 1709726675 18<28emanuele618>	d# echo "$(( "${#PWD}" * 2 ))"
T 1709726676 18<25shbot18>	emanuele6: dash: 1: arithmetic expression: expecting primary: " "5" * 2 "
T 1709726717 18<28emanuele618>	anyway, if you want to remove just one characters; easiest way is probably  var=${var%"${var##*[!/]}"
T 1709726728 18<28emanuele618>	missing a }
T 1709727278 18<28emanuele618>	it would actually even work if you have multiple characters you want to remove now that i think about it
T 1709728181 19*	Now talking on 22#bash
T 1709728181 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709728181 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709728196 18<27Soliton18>	you can make up whatever syntax you want with a magic alias.
T 1709728199 18<24geirha18>	magic alias should handle that particular case ,yes
T 1709728225 18<29oskie18>	nice!
T 1709728227 18<28emanuele618>	how?
T 1709728303 18<27Soliton18>	you put a # before the syntax, get it from history and do whatever you want.
T 1709728348 18<24geirha18>	see the echo-literally example at the end of that page
T 1709728364 18<28emanuele618>	i was thinking of something like that with BASH_COMMAND, but i was not sure that is what was meant
T 1709728381 18<28emanuele618>	that would only make it work if it is the only command you run on that line
T 1709728409 18<24geirha18>	yes
T 1709728482 18<28emanuele618>	err, not bash_command, the other one
T 1709728560 18<25kurahaupo18>	ormaaj: sudo generally unsets everything
T 1709728583 18<28emanuele618>	hmm, there is only BASH_EXECUTION_STRING for bash-c; so it would have to read history
T 1709728642 18<28emanuele618>	i thought there was a variable like BASH_COMMAND that included the entire line
T 1709728665 18<28emanuele618>	i remember using it for something, but i cannot find it
T 1709729052 18<25ormaaj18>	ksh -c 'integer x="1"; while sleep .1; do printf %0.64.2d\\r "$(( (x<<=1), (x^=(x==-0)) ))"; done'
T 1709729234 18<25ormaaj18>	i don't like that i used , D:
T 1709729478 18<28emanuele618>	that one goes  0100000000000000000000000000000000000000000000000000000000000000 => -1000000000000000000000000000000000000000000000000000000000000000 => 0000000000000000000000000000000000000000000000000000000000000001
T 1709729529 18<28emanuele618>	you need %u instead of %d
T 1709729564 18<28emanuele618>	x^xx==-0  can just be  x^=!!x
T 1709729582 18<28emanuele618>	that can be | instead of ^
T 1709729593 18<25ormaaj18>	oh!
T 1709729611 18<28emanuele618>	err, no
T 1709729638 18<28emanuele618>	x|=!x just one !
T 1709729651 18<25ormaaj18>	i think it's the wrong width. %0.-65.2 keeps it constant
T 1709729664 18<28emanuele618>	%0.64.2u
T 1709729682 18<28emanuele618>	d adds a - in front if the top bit is set, u does not
T 1709729684 18<25ormaaj18>	oh the unsigned one ah
T 1709729709 18<28emanuele618>	ksh -c 'integer x="1"; while sleep .1; do printf %0.64.2u\\r "$(( x<<=1, x^=!x ))"; done'
T 1709729740 18<28emanuele618>	or  x|=!x   instead of  x^=!x
T 1709729753 18<25ormaaj18>	:D!
T 1709729817 18<28emanuele618>	it looks nicer with x=0
T 1709729839 18<28emanuele618>	anyway this only works for the purpose of this animation; it does not actually rotate
T 1709729928 18<25ormaaj18>	and it's two steps
T 1709729946 18<28emanuele618>	x=x<<1|!!(x&1<<63)   is one step
T 1709729960 18<25ormaaj18>	:o
T 1709729995 18<28emanuele618>	ksh -c 'integer x=2#1011101; while sleep .1; do printf %0.64.2u\\r "$(( x=x<<1|!!(x&1<<63) ))"; done'
T 1709730062 18<28emanuele618>	oh, ksh has unsigned :D
T 1709730076 18<28emanuele618>	maybe you can use my other approach that does not hardcode 63
T 1709730146 18<28emanuele618>	em   ksh:  x<<=1,x|=!(x^x>>1) : invalid floating point operation
T 1709730211 18<25ormaaj18>	oh that's weird. When you pick a type for x it should just stay integer
T 1709730229 18<28emanuele618>	i used  integer -u
T 1709730256 18<28emanuele618>	it works until it has to wrap around; then it prints that warning
T 1709730289 18<25ormaaj18>	2>/dev/null >:(
T 1709730301 18<28emanuele618>	well, but it is fatal
T 1709730306 18<25ormaaj18>	D:
T 1709730317 18<28emanuele618>	with   typeset -iu x=2#1011101   it looks like it makes the number 32 bit
T 1709730339 18<25ormaaj18>	yeah it needs -l for long
T 1709730359 18<28emanuele618>	oh, hmm, 32bit convention
T 1709730389 18<25ormaaj18>	typeset is arch-dependent. integer always picks the largest type
T 1709730482 18<28emanuele618>	hmm
T 1709730507 18<28emanuele618>	-1<<1  turns the number negative
T 1709730515 18<28emanuele618>	it is not supposed to do that if it is unsigned
T 1709730541 18<25ormaaj18>	k is for krap
T 1709730582 18<28emanuele618>	not sure what -u is supposed to do if it does not change the behaviour of << and >>
T 1709730589 18<28emanuele618>	maybe it is just for print -v
T 1709730616 18<28emanuele618>	or to tell ksh how to convert the number to a string when you use $var
T 1709730636 18<28emanuele618>	it does not make operators unsigned
T 1709730638 18<25ormaaj18>	oh. yeah print -v could be buggy. print -C is sometimes better.
T 1709730660 18<25ormaaj18>	Also if you export to a command it does an implicit conversion to string first
T 1709730687 18<28emanuele618>	with -lu it works the same as integer;  with -ilu  it triggers the floating point warning similarly to  integer -u
T 1709730741 18<28emanuele618>	maybe -lu is interpreted as uppercase
T 1709730771 18<28emanuele618>	and -ilu / unsigned long is bugged
T 1709730879 18<25ormaaj18>	oh also it's `typeset -i[base]`. The thing after -i is the radix. `typeset -Z[width]` zero fills to constant width
T 1709730905 18<25ormaaj18>	so you can actually get rid of the printf format with the right type setting
T 1709730921 18<25ormaaj18>	or, should
T 1709730968 18<25ormaaj18>	typeset has optional option args D:
T 1709731095 18<25ormaaj18>	sheesh mcdutchie changed 1k+ lines every day this week
T 1709731100 18*	25ormaaj rebuilds
T 1709731129 18<25ormaaj18>	it's mostly the mamfiles
T 1709731565 18<28emanuele618>	the correct version of the formula i had in mind is   x=x<<1|!!(x<<1>>1^x)
T 1709731619 18<28emanuele618>	but it does not work there is now way to have unsigned >>1
T 1709731627 18<28emanuele618>	s/now/no/
T 1709731731 18*	25ormaaj c[_]
T 1709732244 18<28emanuele618>	creatememfd 3 x foreground ' '{gcc,-std=c2x,-includetime.h,-includestdio.h,-w,-xc,-,-o/dev/fd/3} <<<'main(){struct timespec t={0,1e8};unsigned long x=0b1011101;while(nanosleep(&t,0)!=-1){printf("%.64lb\r",(x=x<<1|!!(x<<1>>1^x)));fflush(stdout);}}' '' /dev/fd/3
T 1709732314 18<29oskie18>	I must say, that Magic Aliases trick was truly awesome. Thanks geirha.
T 1709732355 18<25ormaaj18>	groan magic alias
T 1709732396 18<25ormaaj18>	C is for cookie
T 1709732435 18<25ormaaj18>	works
T 1709732903 18<29oskie18>	when you run  bash -c "foo"  bash will not load .bash_profile/.bashrc etc. If you add -i it will do. But then it also expects to be run from a pty. Is there a way to have bash load all the usual init files but still not run in a terminal?
T 1709732962 18<20osse18>	perhaps bash -c "source ~/.bashrc; foo" ?
T 1709732996 18<29oskie18>	yeah, I will give it a try.
T 1709733099 18<29oskie18>	to run aliases, bash still wants -i
T 1709733123 18<29oskie18>	ooh. shopt -s expand_aliases
T 1709733186 18<24geirha18>	that will need to be on a line by itself due to weirdness in how bash parses aliases
T 1709733200 18<24geirha18>	but you can set it with -O   bash -O expand_aliases -c '...'
T 1709733272 18<29oskie18>	bash -O expand_aliases -c 'alias ll="ls -l"; ll'   <- I expected this to work, but it gave me "ll: command not found"
T 1709733308 18<25ormaaj18>	if you expected that then aliases probably aren't your thing.
T 1709733350 18<28emanuele618>	bash -O expand_aliases -c 'alias ll="ls -l"'$'\n''ll'    or   bash -O expand_aliases -c 'alias ll="ls -l"; eval ll'
T 1709733377 18<29oskie18>	ah. the newline! thanks
T 1709733396 18<25ormaaj18>	happy til the next unexpected thing
T 1709733403 18<28emanuele618>	ll needs to be read after the alias is already defined, if it is on the same line as the definition, it does not work because bash already read it and didn't expand it
T 1709733461 18<29oskie18>	ormaaj: can't disagree with you there :)
T 1709733498 18<25ormaaj18>	bash must have two different alias things to go along with its to source reading functions
T 1709733522 18<25ormaaj18>	because aliases appear to work the same in a sourced file
T 1709733543 18<20osse18>	bash 'll() { ls -l "$@"; }; ll'
T 1709733548 18<20osse18>	# bash -c 'll() { ls -l "$@"; }; ll'
T 1709733550 18<25shbot18>	osse: total 0
T 1709734682 18<24ano18>	# printf %s\\n all files contained main\(\) {} are c files > f.txt; file -i f.txt
T 1709734684 18<25shbot18>	ano: f.txt: text/x-c; charset=us-ascii
T 1709734724 18<24ano18>	just me or file utility kinda unusable?
T 1709734926 18<25Soni18>	selckin: in the name
T 1709734957 18<20osse18>	ano: if you adhere to the GNU coding standard it works
T 1709734972 18<20osse18>	# printf %s\\n all files contained 'main ()' {} are c files > f.txt; file -i f.txt
T 1709734974 18<25shbot18>	osse: f.txt: text/plain; charset=us-ascii
T 1709735026 18<27Guest1118>	Hola
T 1709735052 18<25ormaaj18>	why do I get unexpected end of file AFTER calling this function. That like never happens. https://bpa.st/raw/VZXQ
T 1709735062 18<25ormaaj18>	unmagical
T 1709735128 18<25ormaaj18>	like bash parsed the function wrong and tries to run the mis-parsed code
T 1709735241 18<25ormaaj18>	also wtf it's running the expanded code twice!
T 1709735258 18<25ormaaj18>	that also never happens
T 1709736264 18<25ormaaj18>	I think it wants a semicolon at the end of every line
T 1709736272 18<25ormaaj18>	I have never seen "unexpected token newline"
T 1709736290 18<25ormaaj18>	https://bpa.st/raw/ZJWA
T 1709736343 18<25ormaaj18>	but there's no way to inject one there
T 1709737082 18<28emanuele618>	i remember seeing unexpected token newline
T 1709737085 18<28emanuele618>	# eval for
T 1709737087 18<25shbot18>	emanuele6: bash: syntax error near unexpected token `newline'
T 1709737126 18<28emanuele618>	for, select and case if there is a newline before the variable
T 1709737506 18<28emanuele618>	also a newline after <, <<, >, >>, <<<, etc
T 1709737513 18<28emanuele618>	# eval \<\<
T 1709737515 18<25shbot18>	emanuele6: bash: syntax error near unexpected token `newline'
T 1709741069 18<25kurahaupo18>	ormaaj: why does your alias 'f' end with '<'
T 1709742099 18<25ormaaj18>	kurahaupo: turns `name()` into `function thing { return <()`. It kills the ()
T 1709742256 18<25ormaaj18>	i'm trying to write an alias the turns a function into a noop, and only function definitions in the global scope of a file.
T 1709742291 18<25ormaaj18>	while skipping the corresponding function calls
T 1709742297 18<28emanuele618>	that is not possible; < at the end of the alias and ( would be separate tokens; it cannot be equivalent to <(
T 1709742316 18<25ormaaj18>	it is possible, because it works. :)
T 1709742341 18<25ormaaj18>	bash seems to merge them
T 1709742497 18<25ormaaj18>	the code doesn't even really have to evaluate properly because a return is being injected first, so as long as it parses it should work.
T 1709742589 18<28emanuele618>	it works?
T 1709742603 18<28emanuele618>	# alias f='echo <'; f (:)
T 1709742605 18<25shbot18>	emanuele6: bash: syntax error near unexpected token `:'
T 1709742608 18<28emanuele618>	# alias f='echo <'; f(:)
T 1709742610 18<25ormaaj18>	`function name` is a lot better for hacking with than `name()`... that () is a pain in the arse.
T 1709742611 18<25shbot18>	emanuele6: bash: syntax error near unexpected token `:'
T 1709742619 18<28emanuele618>	right eval
T 1709742622 18<28emanuele618>	# alias f='echo <'; eval 'f (:)'
T 1709742623 18<25shbot18>	emanuele6: bash: syntax error near unexpected token `('
T 1709742624 18<28emanuele618>	# alias f='echo <'; eval 'f(:)'
T 1709742625 18<25shbot18>	emanuele6: /dev/fd/63
T 1709742627 18<28emanuele618>	wow
T 1709742636 18<28emanuele618>	oh, because ( is a meta character :o
T 1709742649 18<25ormaaj18>	yes :)
T 1709742654 18<28emanuele618>	# alias f='echo <'; eval 'f<< lol cat'
T 1709742656 18<25shbot18>	emanuele6: cat
T 1709742672 18<28emanuele618>	# alias f='<'; eval 'f<< lol cat'
T 1709742673 18<25shbot18>	emanuele6: lol
T 1709742694 18<28emanuele618>	wow
T 1709742699 18<28emanuele618>	does posix require that?
T 1709742713 18*	25ormaaj tames cthulhu ~~(~.~)~~
T 1709742723 18<28emanuele618>	# alias f='echo $'; eval 'f(ls)'
T 1709742724 18<25shbot18>	emanuele6: bash: syntax error near unexpected token `('
T 1709742727 18<25ormaaj18>	it likes me because I clean its box.
T 1709742733 18<28emanuele618>	hmm, it only works for <
T 1709742751 18<25ormaaj18>	yeah no clue about posix. Posix doesn't require much when it comes to aliases
T 1709742778 18<28emanuele618>	# alias f='echo $('; eval 'f(1+2))'
T 1709742779 18<25shbot18>	emanuele6: 3
T 1709742783 18<28emanuele618>	d# alias f='echo $('; eval 'f(1+2))'
T 1709742785 18<25shbot18>	emanuele6: dash: 1: eval: 1+2: not found
T 1709742856 18<28emanuele618>	bash is probably doing some parser hack to support <( and $(( that unintentionally make alias x='... meta'; xmeta  work
T 1709742947 18<25ormaaj18>	bash does intentionally do some extra effort to make aliases work where they wouldn't normally by allowing it to re-parse an overall command including words that have already been substituted.
T 1709743033 18<25ormaaj18>	so a word that was categorized by the lexer one way can change
T 1709743325 18<28emanuele618>	you mean that $(ALIAS) gets expanded twice? well, that is probably never helpful
T 1709743349 18<28emanuele618>	# alias echo='echo hi'; printf %s\\n "$(echo hello)"
T 1709743356 18<25shbot18>	emanuele6: hi hello
T 1709743357 18<28emanuele618>	# alias echo='echo hi'; eval 'printf %s\\n "$(echo hello)"'
T 1709743364 18<25shbot18>	emanuele6: hi hello
T 1709743366 18<25ormaaj18>	There is some kind of double-expansion  going on in my code. I haven't figured out why.
T 1709743368 18<28emanuele618>	wot
T 1709743382 18<28emanuele618>	why does that not print hi hi hello?
T 1709743394 18<28emanuele618>	# alias echo='echo hi'; eval 'a(){ printf %s\\n "$(echo hello)";};a'
T 1709743400 18<25shbot18>	emanuele6: hi hello
T 1709743417 18<25ormaaj18>	no $() doesn't because that should only be parsed once
T 1709743429 18<28emanuele618>	no, it is parsed every time
T 1709743456 18<25ormaaj18>	I don't think  so
T 1709743457 18<28emanuele618>	it just needs to be valid when the command is read; but the expansion code reparses everything in words every time
T 1709743489 18<28emanuele618>	# alias echo='echo hi'; eval 'a(){ printf %s\\n "$(echo hello)";};alias echo=echo\ boo; a'
T 1709743497 18<25shbot18>	emanuele6: boo hello
T 1709743497 18<25shbot18>	emanuele6: c[?7l[2J[0mSeaBIOS (version 1.15.0-1)
T 1709743497 18<25shbot18>	emanuele6: etc... ( http://paste.wooledge.org/29311 )
T 1709743502 18<28emanuele618>	wtf
T 1709743532 18<28emanuele618>	anyway, you can see it prints   boo hello   instead of  hi hello  there because the alias is reparsed
T 1709743547 18<28emanuele618>	err, i mean the word is reparsed
T 1709743555 18<24ano18>	looks like a qemu boot.log
T 1709743573 18<28emanuele618>	ah, i think i remember now; i posted how it works in #shell-lang some months ago
T 1709743614 18<28emanuele618>	   "$(ALIAS)"   has to be valid with ALIAS expanded when the command is read, but bash saves the word in the simple command with the alias unexpanded iirc
T 1709743624 18<28emanuele618>	and then the expansion code re-expands it every time
T 1709743645 18<28emanuele618>	# alias echo='echo hi'; eval 'a () { x=$(echo) ;}'; typeset -pf a
T 1709743652 18<25shbot18>	emanuele6: a ()
T 1709743652 18<25shbot18>	emanuele6: {
T 1709743652 18<25shbot18>	emanuele6: etc... ( http://paste.wooledge.org/29312 )
T 1709743656 18<28emanuele618>	# alias echo='echo hi'; eval 'a () { x=$(echo) ;}'; typeset -pf a | paste -s -
T 1709743663 18<25shbot18>	emanuele6: a ()    {           x=$(echo)   }
T 1709743671 18<28emanuele618>	see, it is not expanded
T 1709743679 18<28emanuele618>	# alias echo='echo ('; eval 'a () { x=$(echo) ;}'; typeset -pf a
T 1709743686 18<25shbot18>	emanuele6: a ()
T 1709743686 18<25shbot18>	emanuele6: {
T 1709743686 18<25shbot18>	emanuele6: etc... ( http://paste.wooledge.org/29313 )
T 1709743701 18<28emanuele618>	it is actually never expanded
T 1709743718 18<28emanuele618>	only at runtime, so you cannot use a magic alias in a $()
T 1709743776 18<28dumbledoor18>	When my cursor is at a space character just after a word, C-w does not work in vi mode. Is this normal? If not, how can I fix this?
T 1709743938 18<25ormaaj18>	heh did you win pony?
T 1709743968 18*	25ormaaj kicks qemu
T 1709744025 18<28emanuele618>	shbot does not have a floppy
T 1709744057 18<28emanuele618>	hmm. not actually it does, but it is not bootable :o
T 1709744064 18<25ormaaj18>	don't copy that floppy
T 1709744112 18<28emanuele618>	# ls /dev
T 1709744113 18<25shbot18>	emanuele6: console  full  random  stdin   tty    urandom
T 1709744113 18<25shbot18>	emanuele6: fd       null  stderr  stdout  ttyS0  zero
T 1709744121 18<28emanuele618>	hmm
T 1709744221 18<28emanuele618>	hmm, is that ^W thing a bug?
T 1709744307 18<28dumbledoor18>	does it happen on your end too emanuele?
T 1709744323 18<28emanuele618>	well, it is bound to vi-unix-word-rubout instead of unix-word-rubout so that is one difference
T 1709744337 18<28emanuele618>	i just tried it, and yes
T 1709744353 18<28emanuele618>	i don't use vi mode; i don't like it, and every time i use it i find a bug
T 1709744377 18<28emanuele618>	https://lists.gnu.org/archive/html/bug-bash/2023-04/msg00023.html
T 1709744477 18<28emanuele618>	it may be a posix mandated thing
T 1709744495 18<28dumbledoor18>	i see. thanks.
T 1709744534 18<24ano18>	# set -o posix; alias echo='echo hi'; eval 'a () { x=$(echo) ;}'; typeset -pf a | paste -s -
T 1709744536 18<25shbot18>	ano: a ()    {           x=$(echo hi)        }
T 1709744587 18<28emanuele618>	if i have     a hi bzz    and i move my cursor before hi; ^W does nothing, but if i put it after the space it deletes the space, and then if i press it again, it deletes hi
T 1709744592 18<28emanuele618>	so probably it is a bug
T 1709744618 18<28emanuele618>	anyway, that is different from standard emacs mode ^W that would delete both space and hi in one go
T 1709744657 18<28emanuele618>	well, if you want to make ^W work like in emacs mode, you can just rebind ^W to  unix-word-rubout  instead of  vi-unix-word-rubout  probably
T 1709744679 18<28emanuele618>	# set -o posix; alias echo='echo hi'; eval 'a () { x=$(echo hello) ;}'; a
T 1709744681 18<25shbot18>	emanuele6: no output
T 1709744689 18<28emanuele618>	# set -o posix; alias echo='echo hi'; eval 'a () { printf %s\\n "$(echo hello)" ;}'; a
T 1709744691 18<25shbot18>	emanuele6: hi hello
T 1709744703 18<28emanuele618>	hmm, but still, it does not double expand
T 1709744713 18<28emanuele618>	# set -o posix; alias echo='echo hi'; eval 'a () { printf %s\\n "$(echo hello)" ;}'; set +o posix; a
T 1709744719 18<25shbot18>	emanuele6: hi hi hello
T 1709744721 18<28emanuele618>	now it does :D
T 1709744800 18<28emanuele618>	so in POSIX mode, aliases in words expand when the word is read, and not when the expansion code re-parses the code; and, in standard mode, aliases in words are only expanded at runtime when the expansion code re-parses the code
T 1709744847 18<28emanuele618>	so if you want to use a magic alias in $() you can enable POSIX mode to declare the function and then turn off POSIX mode, and change the alias :D
T 1709744917 18<28emanuele618>	# set -o posix; alias A='if [[ $a = b ]]; then echo hi'; eval 'a () { printf %s\\n "$(A; fi)" ;}'; set +o posix; unalias A; A () { :;}; a
T 1709744918 18<25shbot18>	emanuele6: no output
T 1709744932 18<28emanuele618>	hmm
T 1709744934 18<28emanuele618>	oh, right
T 1709744944 18<28emanuele618>	hmm
T 1709745097 18<28emanuele618>	ah, what i was trying to do is
T 1709745137 18<28emanuele618>	# alias A=; eval 'a () { printf %s\\n "$(A fi)" ;}'; a; alias A=echo; a
T 1709745140 18<25shbot18>	emanuele6: bash: command substitution: line 1: syntax error near unexpected token `fi'
T 1709745140 18<25shbot18>	emanuele6: bash: command substitution: line 1: `A fi'
T 1709745140 18<25shbot18>	emanuele6: etc... ( http://paste.wooledge.org/29315 )
T 1709745146 18<28emanuele618>	which you can do in standard mode
T 1709745170 18<28emanuele618>	anyway, if that is the interaction between aliases in words and POSIX mode, you can probably do something interesting with it
T 1709745248 18<24cheater18>	hi all
T 1709745254 18<24cheater18>	any clue how to get this to split on tabs? while IFS=$'\t' read a; do echo "$a"; done < <(echo $'aaa\tbbb\tc\tddd')
T 1709745283 18<28emanuele618>	sounds like you want -d $'\t' not IFS=$'\t'
T 1709745299 18<24cheater18>	hmm what does IFS do? i thought it meant input field separator
T 1709745311 18<28emanuele618>	yes, the input field separator
T 1709745332 18<24cheater18>	so aren't those input fields
T 1709745333 18<28emanuele618>	you want to delimit records with tab there, not fields
T 1709745340 18<24cheater18>	what are fields then?
T 1709745357 18<28emanuele618>	fields are what are in records (a.k.a. rows)
T 1709745408 18<28emanuele618>	# printf '%sX%sY' HELLO HI BEE BZZ
T 1709745410 18<25shbot18>	emanuele6: HELLOXHIYBEEXBZZY
T 1709745470 18<28emanuele618>	# printf '%sX%sY' HELLO HI BEE BZZ | { i=1; while IFS=X read -rdY f1 f2; do printf 'record 1:\tfield1=%q\tfield2=%q' "$f1" "$f2"; done
T 1709745476 18<25shbot18>	emanuele6: Missing terminating quote, bracket or keyword
T 1709745477 18<28emanuele618>	oops
T 1709745490 18<28emanuele618>	# printf '%sX%sY' HELLO HI BEE BZZ | { i=1; while IFS=X read -rdY f1 f2; do printf 'record 1:\tfield1=%q\tfield2=%q\n' "$f1" "$f2"; done }
T 1709745492 18<25shbot18>	emanuele6: record 1:       field1=HELLO    field2=HI
T 1709745492 18<25shbot18>	emanuele6: record 1:       field1=BEE      field2=BZZ
T 1709745519 18<24cheater18>	# printf '%sX%sY' HELLO HI BEE BZZ
T 1709745520 18<25shbot18>	cheater: HELLOXHIYBEEXBZZY
T 1709745571 18<28emanuele618>	# printf '%sX%sY' HELLO HI BEE BZZ | awk -vOFS=\\t -FX -vRS=Y '{ print "record " NR, "field1=" $1, "field2=" $2 }'
T 1709745573 18<25shbot18>	emanuele6: record 1        field1=HELLO    field2=HI
T 1709745573 18<25shbot18>	emanuele6: record 2        field1=BEE      field2=BZZ
T 1709745595 18<28emanuele618>	i forgot to add i++ in the bash version, whoops
T 1709745615 18<28emanuele618>	# printf '%sX%sY' HELLO HI BEE BZZ | { i=0; while IFS=X read -rdY f1 f2; do printf 'record %s:\tfield1=%q\tfield2=%q\n' "$(( ++i ))" "$f1" "$f2"; done }
T 1709745617 18<25shbot18>	emanuele6: record 1:       field1=HELLO    field2=HI
T 1709745617 18<25shbot18>	emanuele6: record 2:       field1=BEE      field2=BZZ
T 1709745668 18<28emanuele618>	HELLOXHIYBEEXBZZY  is separated into two records by Y:   HELLOXHI BEEXBZZ
T 1709745703 18<28emanuele618>	and then echo record is separated into fields by X; "HELLO" "HI" for HELLOXHI  and  "BEE" "BZZ" for BEEXBZZ
T 1709745816 18<24ano18>	# IFS=$'\t' read -rd '' -a array < <(printf 'foo\tbar\tbaz'); printf {%s} "${array[@]}"
T 1709745817 18<25shbot18>	ano: {foo}{bar}{baz}
T 1709745891 18<28emanuele618>	s/echo/each/
T 1709745970 18<28emanuele618>	# IFS=$'\t' read -rd '' -a array < <(printf 'fo\tbar\tbaz'); printf {%s} "${array[@]}"
T 1709745971 18<25shbot18>	emanuele6: {fo}{bar}{baz}
T 1709745981 18<28emanuele618>	now that command has only ano
T 1709745985 18<25ormaaj18>	k works
T 1709745986 18<25ormaaj18>	https://bpa.st/raw/3VVQ
T 1709746123 18<24ano18>	# IFS= readarray -td $'\t' array < <(printf 'foo\tbar\tbaz'); printf {%s} "${array[@]}"
T 1709746124 18<25shbot18>	ano: {foo}{bar}{baz}
T 1709746133 18<28emanuele618>	twoo
T 1709746146 18<28emanuele618>	someo
T 1709746272 18<24cheater18>	emanuele6: ahhhhhhhhh
T 1709746273 18<24cheater18>	i se
T 1709746275 18<24cheater18>	e
T 1709746278 18<24cheater18>	thank you very much
T 1709746327 18<24cheater18>	that makes a lot more sense
T 1709746330 18<24cheater18>	hey, what's the absolute smallest way of saying, when you're in a loop, "don't run this line the first time around, but run it any other time"?
T 1709746402 18<24ano18>	what kind of loop?
T 1709746582 18<24cheater18>	any
T 1709746607 18<24cheater18>	the idea is to have something that's going to be useful anywhere
T 1709746705 18<24cheater18>	the idea i had was i=0; ... loop ... (( $i++ > 0)) && do_something; ...
T 1709746717 18<24cheater18>	but maybe there's some tricky syntax that's even tinier
T 1709746783 18<24kishar18>	The c-style loop syntax is more commonly written as  for ((i = 0; i > 10; i++)); do something; done
T 1709746839 18<24ano18>	cheater: (( i++ )) && do_something
T 1709746840 18<28emanuele618>	i don't think it is ever written like that
T 1709746899 18<24cheater18>	ano: thanks. that's a little smaller
T 1709746908 18<24cheater18>	kishar: i'm not asking about c-style loop syntax.
T 1709746912 18<28emanuele618>	&& does not make any sense
T 1709746928 18<24cheater18>	of course it does
T 1709746929 18<28emanuele618>	that never runs anything if i starts at 0
T 1709746937 18<24cheater18>	oh really?
T 1709746943 18<24cheater18>	why would it start at 0?
T 1709746944 18<28emanuele618>	oh, i misread the qeustion
T 1709746949 18<24cheater18>	right
T 1709746964 18<28emanuele618>	i guess i++ works
T 1709746973 18<24cheater18>	kishar: i'm asking, if you have a larger loop that does a bunch of stuff, then if you have one command that you only want to start running on the 2nd iteration and after, what do you do
T 1709746992 18<24cheater18>	kishar: i don't want *the whole body of the loop* to start running on the 2nd iteration. that would be stupid.
T 1709746996 18<28emanuele618>	if (( i )); then do_something; else i=1; fi  would be better
T 1709747003 18<24kishar18>	couldn't you put an if [[ i=0 ]]; then do_nothing; else ...
T 1709747005 18<28emanuele618>	kishar: i<10
T 1709747017 18<24kishar18>	emanuele6: you're right, typo.
T 1709747018 18<28emanuele618>	and now [[ i=0 ]] is always true
T 1709747032 18<28emanuele618>	same for [[ $i=0 ]]
T 1709747052 18<28emanuele618>	[[ $i = 0 ]] is how to do do it
T 1709747056 18<24kishar18>	well, I meant putting that conditional nested inside your "do something" meat of it
T 1709747057 18<28emanuele618>	do do
T 1709747068 18<24Guest123518>	For reasons I cannot fathom, this bash function which helps me manage my iptables rule set is taking forever to run.  Can anyone here please suggest ways I might optimize its performance?  https://gist.github.com/hesco/524cfb563ad69e76a6118c962fbd169d#file-00100-iptables_start-sh
T 1709747081 18<24cheater18>	emanuele6: i'm asking about the absolutely smallest way of doing this.
T 1709747085 18<24cheater18>	not the most readable one.
T 1709747109 18<24ano18>	!check https://gist.github.com/hesco/524cfb563ad69e76a6118c962fbd169d/raw/a5ffd8206ed107b9ab1d47d377bf2b6215edc049/00100--iptables_start.sh
T 1709747111 18<28checkbot18>	ano: Line 13: Double quote to prevent globbing and word splitting. Line 15: Double quote to prevent globbing and word splitting. Line 20: Double quote to prevent globbing and word splitting. See https://shellcheck.net/?id=cb47111 for all 6 issues.
T 1709747158 18<28emanuele618>	cheater: and ((i++)) only works  18446744073709551616  times.
T 1709747158 18<24kishar18>	cheater: Personally, I abhor obfuscated code, to the point of using --long-options to help self-document.
T 1709747168 18<24cheater18>	emanuele6: holy fuck wow
T 1709747190 18<28emanuele618>	if (( i )); then do_something; else i=1; fi  works forever
T 1709747194 18<24cheater18>	kishar: i'm trying to figure out an idiom.
T 1709747196 18<28emanuele618>	that is how cool it is
T 1709747201 18<24cheater18>	emanuele6: that's stupid lmao
T 1709747216 18<28emanuele618>	what is stupid?
T 1709747264 18<24ano18>	hmm what happens with (( i++ )) || continue after 18446744073709551616 times?
T 1709747281 18<28emanuele618>	ano: it is 0 that time
T 1709747283 18<28emanuele618>	then 1 again
T 1709747289 18<24ano18>	declare -i i=18446744073709551616; (( i++ )); echo $? $i
T 1709747295 18<24ano18>	# declare -i i=18446744073709551616; (( i++ )); echo $? $i
T 1709747296 18<25shbot18>	ano: 1 1
T 1709747302 18<24ano18>	# declare -i i=18446744073709551615; (( i++ )); echo $? $i
T 1709747303 18<25shbot18>	ano: 0 0
T 1709747315 18<28emanuele618>	if you want obfuscated, even  ((i=1,$i)) &&   is better than ((i++)) &&
T 1709747348 18<28emanuele618>	# declare -i i=18446744073709551615; (( i++ )); echo $? $i; (( i++ )); echo $? $i; (( i++ )); echo $? $i;
T 1709747350 18<25shbot18>	emanuele6: 0 0
T 1709747350 18<25shbot18>	emanuele6: 1 1
T 1709747350 18<25shbot18>	emanuele6: 0 2
T 1709747357 18<28emanuele618>	# declare -i i=18446744073709551614; (( i++ )); echo $? $i; (( i++ )); echo $? $i; (( i++ )); echo $? $i;
T 1709747359 18<25shbot18>	emanuele6: 0 -1
T 1709747359 18<25shbot18>	emanuele6: 0 0
T 1709747359 18<25shbot18>	emanuele6: 1 1
T 1709747426 18<28emanuele618>	it is false for the 1st line, for the 18446744073709551616th line; for the 36893488147419103232nd time, for the 55340232221128654848th time, for the 73786976294838206464th time, and so on
T 1709747458 18<28emanuele618>	hmm, actually
T 1709747473 18<28emanuele618>	it is false for the 1st line, for the 18446744073709551617th line; for the 36893488147419103233rd time, for the 55340232221128654849th time, for the 73786976294838206465th time, and so on
T 1709747498 18<28emanuele618>	1+2**(64*k)   from k=0 to inf
T 1709747516 18<28emanuele618>	hmm
T 1709747518 18<28emanuele618>	wrong
T 1709747529 18<24Guest123518>	thanks ano, will take a closer look at that.
T 1709747538 18<24Guest123518>	!check https://gist.github.com/hesco/524cfb563ad69e76a6118c962fbd169d#file-00100-iptables_start-sh
T 1709747539 18<28checkbot18>	Guest1235: Line 13: read without -r will mangle backslashes. Line 18: Instead of 'let expr', prefer (( expr )). Line 50: Double quote to prevent globbing and word splitting. See https://shellcheck.net/?id=cb47539 for all 12 issues.
T 1709747554 18<28emanuele618>	checkbot: also thank you
T 1709747554 18<28checkbot18>	emanuele6: You're welcome! \(=^.^= )/
T 1709747761 18<24Guest123518>	I'm making extensive use of the $() subshell construct, but shellcheck.net keeps advising me: "Double quote to prevent globbing and word splitting".  Is that really relevant here?  And does that mean: ??? foo-$("some_command $arg1 $arg2") ???
T 1709747799 18<24Guest123518>	rather: foo=$("some_command $arg1 $arg2")
T 1709747895 18<19Artfaith18>	Guest1235, I believe it tells it for the command inside.
T 1709747998 18<19Artfaith18>	# a() { printf "'%s'," "$@"; }; arg1='1 2'; arg2='3 4'; b=$( a $arg1 $arg2; ); declare -p b;
T 1709747999 18<25shbot18>	Artfaith: declare -- b="'1','2','3','4',"
T 1709748018 18<19Artfaith18>	# a() { printf "'%s'," "$@"; }; arg1='1 2'; arg2='3 4'; b=$( a "$arg1" "$arg2"; ); declare -p b;
T 1709748020 18<25shbot18>	Artfaith: declare -- b="'1 2','3 4',"
T 1709748070 18<24ano18>	Guest1235: https://www.shellcheck.net/wiki/SC2086 also u can get more info about errs via SCNNNN links, it has has some $() quoting examples
T 1709748112 18<24ano18>	emanuele6: (( i ? i : i++ )) will be ok too, right?
T 1709748168 18<28emanuele618>	but ((i=1,$i)) is shorter
T 1709748216 18<24ano18>	curious which one will be more resource expensive
T 1709748261 18<28emanuele618>	:'s cost money
T 1709748408 18<19Artfaith18>	ano, I would suggest BPF programs in such case then.
T 1709748411 18<28emanuele618>	((x?x:x++)) is way faster
T 1709748414 18<19Artfaith18>	1. https://ebpf.io/
T 1709748420 18<28emanuele618>	$x in bash is slow af
T 1709748424 18<19Artfaith18>	Related: https://github.com/bpftrace/bpftrace/blob/master/man/adoc/bpftrace.adoc#examples
T 1709748440 18<28emanuele618>	:\
T 1709748665 18<28emanuele618>	i tried  ((x&=1,x++)) but that is also slower
T 1709748706 18<28emanuele618>	i think part of the reason why x?x:x++  is faster other than not using $x is that it avoids assignments
T 1709748735 18<19Artfaith18>	emanuele6, how do you check? `time`? BPFs? What is it?
T 1709748741 18<28emanuele618>	then with that logic, you can use  x||x=1   which can be even faster
T 1709748766 18<28emanuele618>	Artfaith: before i tell you, i want you to tell me how to check with that link you just posted
T 1709748809 18<19Artfaith18>	A few moments then. I am in train.
T 1709748879 18<24ano18>	emanuele6: (( i || (i=1) )) ? it's always true
T 1709748934 18<28emanuele618>	err, sorry, i meant  i&&i=1
T 1709748941 18<28emanuele618>	err
T 1709748951 18<28emanuele618>	i meant   x||x++
T 1709748958 18<28emanuele618>	that is what i had in my test
T 1709749083 18<28emanuele618>	that is ~5% faster
T 1709749091 18<28emanuele618>	than x?x:x++
T 1709749910 18<28emanuele618>	and ((x?x:x++)) is ~20-25% faster than ((x=1,$x))   ((i||i++)) on average is a little under 30% faster
T 1709750327 18<28emanuele618>	those percentages are not very accurate; i am just timing  ((x?x:x++))  vs  ((x=1,$x))  in my test loop and computing a percentage
T 1709750383 18<28emanuele618>	really, we should expect that  ((x||x++))  is ~200% faster than  ((x?x:x++))  since it recalls x only once instead of two times
T 1709750400 18<24ano18>	did some tests too, ((i||i++)) looks like a best way to go
T 1709750535 18<28emanuele618>	you could also just   (( i )) || { i=1; continue;}
T 1709750737 18<24ano18>	looks the same as ((i||i++)) || continue
T 1709750758 18<28emanuele618>	i yes, because it recalls i only once
T 1709750775 18<28emanuele618>	if the first i is non-zero, it does not have to run anything else
T 1709750896 18<28emanuele618>	i?i:i++   is slower, because if the first i is non-zero, it has to recall i again to return it
T 1709750921 18<28emanuele618>	if you use   i?1:i++   it is probably going to be faster
T 1709751006 18<24ano18>	what do u mean? it's slower
T 1709751016 18<28emanuele618>	no, it takes pretty much the same time
T 1709751043 18<28emanuele618>	so it is ?: that is causing it to be slower; not the fact that x is being recalled two times
T 1709751073 18<24ano18>	still slower + ~40ms on 100500 iterations
T 1709751078 18<24ano18>	*for
T 1709751105 18<28emanuele618>	that is nothing...
T 1709751245 18<24ano18>	nothing here, nothing here, and now there's something
T 1709751281 18<24ano18>	s/something/bloathing/
T 1709751598 18<28emanuele618>	40ms is an unsignificant amount,  you cannot possibly measure a difference that small
T 1709751694 18<28emanuele618>	if you run the commands other times, the result will change
T 1709751713 18<24ano18>	curious if elektron etc full of "insignificant" amounts
T 1709751741 18<28emanuele618>	that does not make any sense
T 1709751746 18<25kurahaupo18>	emanuele6: ano just did measure it
T 1709751770 18<28emanuele618>	wow,
T 1709751820 18<25kurahaupo18>	40ms is slow enough that (if repeated) a human will hear distinct clicks rather than a continuous hum
T 1709751869 18<27JAA18>	That's a massive difference when it comes to benchmarking. Once you get into the microseconds, it gets trickier. But statistics say you just need more samples then.
T 1709751886 18<28emanuele618>	kurahaupo: did you measute it repeatedly? i was not able to
T 1709751905 18<28emanuele618>	you said that ano did measure it
T 1709751911 18<25kurahaupo18>	Why so me?
T 1709751927 18<28emanuele618>	because you said it was done
T 1709751969 18<25kurahaupo18>	Because ano said it was done. It's certainly not impossible to measure, I've often measured times much shorter than that.
T 1709752018 18<28emanuele618>	you three are not making any sense at all
T 1709752043 18<28emanuele618>	we are measuring something that takes less than a microsecond to run, with multiple iterations
T 1709752049 18<27JAA18>	I've measured differences in the dozens of nanoseconds before. Low-level Python stuff, for example.
T 1709752058 18<27JAA18>	You just need many samples to filter out the noise.
T 1709752059 18*	25kurahaupo casts a spell of discombobulation on emanuele6
T 1709752086 18<28emanuele618>	if you think that you can get a measurement that does not fluctuate by at least +- 200ms with 100500 iterations of that (()) thing, please show me how you do it
T 1709752122 18<24ano18>	https://clbin.com/JcdLl
T 1709752142 18<28emanuele618>	 $()
T 1709752144 18<28emanuele618>	that is a syscall
T 1709752147 18<25kurahaupo18>	emanuele6: bind a CPU & memory to a cgroup
T 1709752181 18<28emanuele618>	you are not showing any result, you are telling me to waste my time with your stupid idea
T 1709752184 18<27JAA18>	Can you give the concrete 'that (()) thing' including input? There were so many suggestions above that I'm not even sure what you're comparing right now.
T 1709752209 18<28emanuele618>	this is   ((x?1:x++))  vs   ((x?x:x++))
T 1709752224 18<27JAA18>	With which initial value for x?
T 1709752271 18<27JAA18>	And are we talking about applying that in sequence 100k times or trying that from the same initial value 100k times?
T 1709752271 18<28emanuele618>	it does not matter
T 1709752281 18<25kurahaupo18>	JAA: it hardly matters; it can be zero for at most one cycle
T 1709752299 18<28llua18>	how did we get to this point of optimization within bash
T 1709752310 18<27JAA18>	Wouldn't the second one recall x again on the first branch?
T 1709752319 18<28emanuele618>	yes.
T 1709752337 18<27JAA18>	So we're trying to show that that's slower for x = 0?
T 1709752365 18<28emanuele618>	x=0 is the initial value for the test, but it does not matter obviously
T 1709752374 18<25kurahaupo18>	The numeric evaluator has pretty much zero optimisations; looking up variables is unreasonably expensive
T 1709752388 18<27JAA18>	That's why I ask about
T 1709752389 18<27JAA18>	> applying that in sequence 100k times or trying that from the same initial value 100k times
T 1709752390 18<28emanuele618>	kurahaupo: wow....
T 1709752396 18<28emanuele618>	you are saying so much nonsense
T 1709752400 18<27JAA18>	In the former, yes, the initial value is basically irrelevant.
T 1709752407 18<27JAA18>	In the latter, it gets reset every time.
T 1709752408 18<28emanuele618>	ano is saying that the one with ?1  is slower; not ?x
T 1709752459 18<28emanuele618>	JAA: ?
T 1709752475 18<25kurahaupo18>	ano: could you please clarify which expressions you were comparing?
T 1709752500 18<28emanuele618>	because apparently you are not even following the conversation
T 1709752517 18<28emanuele618>	JAA: the second one returns x if x is not 0, otherwise it returns 0, and sets x to 1
T 1709752525 18<27JAA18>	emanuele6: The former is `x=0; for i in {1..100000}; do ((x?1:x++)); done`. The latter is `for i in {1..100000}; do x=0; ((x?1:x++)); done` (though you need to exclude the `x=0` assignment from the time measurement).
T 1709752547 18<24ano18>	yeah i compared ((i?i:i++)) vs ((i||i++)) there is 40ms diff, didn't try ((x?1:x++)), sorry bad eyes
T 1709752550 18<25kurahaupo18>	I thought it was comparing ((x||x++)) with ((x?1:x++))
T 1709752558 18<28emanuele618>	you should not reset x=0...
T 1709752575 18<27JAA18>	That was my question the whole time, whether it should be reset or not!
T 1709752581 18<27JAA18>	They're two different benchmarks.
T 1709752603 18<28emanuele618>	then ano just said something nonsensical from the start
T 1709752611 18<25kurahaupo18>	# echo $(( 2 ?: 3))
T 1709752612 18<25shbot18>	kurahaupo: bash: 2 ?: 3: expression expected (error token is ": 3")
T 1709752613 18<27JAA18>	One averages over different values of x, the other specifically evaluates the first branch only.
T 1709752621 18<25kurahaupo18>	Dang
T 1709752640 18<25kurahaupo18>	# echo $(( 2 || 3))
T 1709752641 18<25shbot18>	kurahaupo: 1
T 1709752645 18<24ano18>	emanuele6: sorry, "i" looks like a "1" via my eyes/fonts
T 1709752660 18<28emanuele618>	ano: elektron xD xD xD
T 1709752662 18<28emanuele618>	dXxxdXDX
T 1709752765 18<28emanuele618>	how about you do something interesting like   bind a CPU & memory to a cgroup   and getting a stable time measurement for   ((x?x:x++))  vs  ((x?1:x++)) ?
T 1709752779 18<28emanuele618>	actually doing something interesting for once
T 1709752961 18<24ano18>	what's the point to compare ((x?x:x++)) and ((x?1:x++))? need compare ((i||i++)) vs ((x?1:x++))
T 1709752982 18<24ano18>	((x||x++)) vs ((x?1:x++))
T 1709752991 18<28emanuele618>	<emanuele6> if you use   i?1:i++   it is probably going to be faster
T 1709752993 18<28emanuele618>	<ano> what do u mean? it's slower
T 1709753033 18<28emanuele618>	elektronz
T 1709753224 18<24ano18>	hmm looks the same
T 1709753304 18<28emanuele618>	:o <emanuele6> no, it takes pretty much the same time
T 1709753540 18<24ano18>	((x?1:x++)) + ~3ms slower, ((x||x++)) still better (at least in my env)
T 1709754804 18<25ormaaj18>	A recent ksh change made :, true, and false in loop invariants basically noops. So should be at least as good as ! ! in bash without the syntax hack.
T 1709754831 18<25ormaaj18>	(It was probably already way faster than bash sadly)
T 1709754837 18<28emanuele618>	does ksh not have $_ ?
T 1709754848 18<25ormaaj18>	It does but it doesn't work like bash
T 1709754859 18<28emanuele618>	it has nothing like bash's $_?
T 1709754884 18<25ormaaj18>	_ is similar in certain contexts but isn't set after every simple command. It requires a new line.
T 1709754897 18<25ormaaj18>	in mksh it only works in interactive mode
T 1709754911 18<28emanuele618>	yeah, also in dash
T 1709754936 18<28emanuele618>	hmm, no
T 1709754978 18<28emanuele618>	in dash it only works in interactive mode, but it works like bash's
T 1709754980 18<19Artfaith18>	emanuele6, you sure know what kprobes is I believe. I am still on train, but I recalled why I mentioned BPF or Berkley Packet Filter with a tool BCC, or toolset to manipulate Kernel live via kprobes (used for Kernel debugging and tracing by probing or inserting breakpoints to certain call stack of a third party program) to collect data you want at times when needed. I found the script I used a few
T 1709754982 18<19Artfaith18>	years ago for shell pipe watch I used to collect data from one program to another by PID with `strace` disabled, and it also included times in nanoseconds: https://dpaste.org/PyXr3 . Here is a CPU profiler from bookmarks using the same approach https://github.com/iovisor/bcc/blob/master/tools/profile.py . The function which is used for time is
T 1709754984 18<19Artfaith18>	https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md#3-bpf_ktime_get_ns . Please check the following: https://opensource.com/article/17/11/bccbpf-performance , https://lwn.net/Articles/132196/ , and there various solutions to visualize the data not in TUI like histograms but also graphs like https://www.parca.dev/docs/concepts
T 1709755017 18<28emanuele618>	is that a chatbot? :o
T 1709755029 18<19Artfaith18>	...
T 1709755040 18<19Artfaith18>	I regret speaking with you.
T 1709755045 18<25ormaaj18>	lol
T 1709755048 18<28bprompt18>	hehe
T 1709755056 18<28emanuele618>	i don't know what a kprobes is
T 1709755069 18<25ormaaj18>	it's a kernel debugging thing
T 1709755082 18<19Artfaith18>	It's fucking 6th time you literally put into me into your disgusting shit, emanuele6..
T 1709755084 18<28emanuele618>	that sounds like a name for kernel debugging thing, yes
T 1709755098 18<28llua18>	zzz
T 1709755114 18<28emanuele618>	i have never heard of that honestly
T 1709755125 18<25ormaaj18>	person has issues
T 1709755176 18<25ormaaj18>	now they'll be back except with their new sockpuppet account
T 1709755182 18<25ormaaj18>	just wait
T 1709755244 18<24ano18>	did anyone compare modern ksh implementations, which one is faster?
T 1709755276 18<28emanuele618>	we are talking about ksh93, not pdksh forks like openbsd ksh, mksh, pdksh, netbsd ksh, etc
T 1709755296 18<28emanuele618>	anyway the core is the same
T 1709755328 18<28emanuele618>	there is much reason why one of them would be faster than the other, mksh has more features i guess
T 1709755408 18<24ano18>	https://github.com/ksh93/ksh this one?
T 1709755437 18<28emanuele618>	that one is the maintained for of ksh93, yeah
T 1709755453 18<28emanuele618>	shbot has a different fork
T 1709755480 18<28emanuele618>	s/is much/is not much/
T 1709755562 18<28llua18>	when even the dialect has dialects.
T 1709755569 18<25ormaaj18>	that's the one. u+m is a fork of u. There's also v- which is unmaintained, has extra features, some missing ones, and a lot more bugs. There's also a 3rd fork, 2020, which is unmaintained and pretty much no point in using that one unless you plan to develop it further.
T 1709755610 18<28emanuele618>	shbot has 2020
T 1709755623 18<25ormaaj18>	wat? geirha updated it?
T 1709755636 18<28emanuele618>	k# typeset -p .sh.version
T 1709755638 18<25shbot18>	emanuele6: .sh.version='Version AJM 93u+ 2012-08-01'
T 1709755643 18<28emanuele618>	hmm, nevermind
T 1709755644 18<25ormaaj18>	nah that is not 2020
T 1709755655 18<25ormaaj18>	just an old random version
T 1709755671 18<28emanuele618>	it works similarly to 2020 which is the version i have installed on my pc, so i thought it was 2020
T 1709755790 18<25ormaaj18>	at this point backporting the important stuff from v- to u+m is probably the way to go considering there's been about 1.5k commits worth of divergence.
T 1709755855 18<28emanuele618>	when i timed  : $x  vs  : "$x"  in different shells yesterday, i noticed that ksh93 2020 is slower than bash quite a bit
T 1709755934 18<20bent_fingers18>	because ksh93 is out of coffee
T 1709755952 18<28emanuele618>	should've been written in java
T 1709755966 18<25ormaaj18>	because its creators are retired
T 1709755996 18<25ormaaj18>	possibly also tired, but they might have coffee.
T 1709756052 18<25ormaaj18>	some of that AST stuff was written in java. I forgot what it was.
T 1709756095 18<25ormaaj18>	maybe it wasn't included but a few things by the same group that did ast and uwin
T 1709756158 18<28emanuele618>	i just tried u+m and it is marginally faster than bash; 2020 is very slow ~3 times slower than bash
T 1709756184 18<28emanuele618>	also ksh93 is like bash  : $x   is faster than  : "$x"   but not by as much
T 1709756209 18<25ormaaj18>	that is very strange
T 1709756221 18<25ormaaj18>	quoted should be faster
T 1709756283 18<28emanuele618>	no, that is not what i expected, and it is measurably slower than unquoted (when no field splitting/pathname expansion/elision occurs)
T 1709756324 18<25ormaaj18>	you can't disable field splitting
T 1709756326 18<24jamiejackson18>	i'm redirecting both stdout and stderr from a command but i still see output in the terminal. why might this be? https://gist.github.com/jamiejackson/c5031958d7b89bfa1b4b944e57d6acf6
T 1709756327 18<28emanuele618>	because i know bash replaces all the quoted parts with  \v\a\l\u\e   to then re-remove the \s after the pathname expansion step
T 1709756347 18<25ormaaj18>	ah well that's clumbsy. certainly if it does it that way
T 1709756356 18<28emanuele618>	that is how the implementation works all the time, and it is very costly if $x is long; in the test it was a string of 4096 .s
T 1709756363 18<28emanuele618>	in most shells "$x" is faster, but not in bash
T 1709756415 18<28emanuele618>	jamiejackson: you are only redirecting the stderr of the sed command
T 1709756430 18<28emanuele618>	try   (jenkins-plugin-cli --list   | grep -v ':'   | sed 's/ /:/') > /tmp/plugins.lock.txt   2> /tmp/error1
T 1709756452 18<25ormaaj18>	I do know that the ksh implementation supposedly has some similar limitations. There are a few unfixable bugs caused by metadata being passed through expansion-stages in-band with an escaping scheme.
T 1709756507 18<28emanuele618>	in u+m  : "$X"  and  : $X  take pretty much the same time, unquoted is very marginally faster; in busybox, dash, and bash the difference is more substantial
T 1709756537 18<24jamiejackson18>	you're a genius, emanuele6. i learned something new about chained commands.
T 1709756584 18<20bent_fingers18>	indeed he is
T 1709756602 18<20bent_fingers18>	jamiejackson: please consider supporting his cause: https://www.givesendgo.com/GBH2M
T 1709756758 18<28llua18>	please don't do that
T 1709756769 18<24yuesbeez18>	ormaaj: hi just following up from yesterday. sudo -- bash +o monitor -O lastpipe -c '{ printf %s "$2" | { shift; { BASH_ENV=/proc/self/fd/${fd} exec -- "$@"; } {fd}<&0 <&"$tty"-; } {tty}<&0' bash 'cd /server && source blahblah; unset -v fd BASH_ENV {fd}<&-' bash gives me bash: -c: line 2: syntax error: unexpected end of file. also my end goal is to have an interactive shell so should i omit the arg1 and arg2?
T 1709756807 18<28emanuele618>	ormaaj: if you missed it yesterday, the timing setup is  (printf '%.0s: $X\n' {1..20000}) > testscript1   (printf '%.0s: "$X"\n' {1..20000}) > testscript2    printf -v X %.1s .{1..4096}    time X=$X "$sh" testscript1
T 1709756853 18<25ormaaj18>	-.-
T 1709756866 18<28emanuele618>	err,   (echo {; printf '%.0s: $X\n' {1..20000}; echo }) > testscript    actually
T 1709757842 19*	Now talking on 22#bash
T 1709757842 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709757842 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709757859 18<28emanuele618>	but it looks like it is not used for anything; maybe it used to do something in the past, now it does nothing afaict
T 1709757915 18<28emanuele618>	it has existed since the beginning of the git repo
T 1709758034 18<28emanuele618>	it looks like it never did anything
T 1709758064 18<28emanuele618>	it is a static variable in shell.c and it is not used for anything, so it just does nothing i guess
T 1709758139 18<28emanuele618>	maybe some old debugger/testsuite that they were using passes --debug when the program is being tested/debugged
T 1709758148 18<28emanuele618>	so they just accept it and ignore it
T 1709758670 18<25ormaaj18>	I wish there was something like `set -v` except that prints after alias expansion
T 1709758720 18<25ormaaj18>	you have to guess what's going on in commands that don't normally output anything for set -x... like function definitions in this case
T 1709759890 18<25ormaaj18>	I think that might be some thing that triggers bashdb
T 1709759974 18<25ormaaj18>	portage blocks installing it with bash 5.3 for some reason. I doubt anybody has tested it
T 1709760008 18<25ormaaj18>	but then it also tries to use it to display debug info for something or other and fails obviously, which just generates a bunch of errors.
T 1709760028 18<25ormaaj18>	not an actual problem afaict, just annoying.
T 1709762446 18<27xx18>	is a symlink a regular file for the purposes of "-f FILE        True if file exists and is a regular file."
T 1709762460 18<27xx18>	my testing says it is but it feels strange
T 1709762708 18<27Earnestly18>	xx: -f file follows the symlink
T 1709762764 18<27Earnestly18>	(In general symlinks are supposed to be transparent unless you specifically check if something is a symlink)
T 1709763030 18<27xx18>	probably for the best
T 1709763031 18<27xx18>	thanks
T 1709763337 18<20bent_fingers18>	!indirect
T 1709763356 18<20bent_fingers18>	!indirection
T 1709763356 18<29greybot18>	Bash is one of the few languages that causes a brain glitch in most people's heads making them want to put data in variable names. Don't do that. You probably want associative arrays or functions instead.
T 1709763753 18<20bent_fingers18>	If i want to declare my variables at the top (for easier reading) then process options, is this a sane way to do it? https://termbin.com/jvsz
T 1709763776 18<20bent_fingers18>	the issue is processing $1
T 1709763801 18<20bent_fingers18>	i want $1 to be a pattern if it's not an option
T 1709763813 18<20bent_fingers18>	and options start with `-`
T 1709763845 18<20bent_fingers18>	the only other thing i can think of is to place `pattern="$1"` after the options processing
T 1709763920 18<20bent_fingers18>	it works, but it looks a little ugly to me
T 1709764208 18<20bent_fingers18>	nevermind, i'll move the variables under option processing
T 1709774324 19*	Now talking on 22#bash
T 1709774324 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709774324 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709777052 18<19`]18>	tar exited with code 130 - police of which country is concerned?
T 1709777092 18<19`]18>	Oh, nevermind. It wasn't tar
T 1709781292 18<25kurahaupo18>	ormaaj: apropos "post-alias set -v", I wish that bash -x would print (at least the name of) function definitions as they're encountered, and the values assigned using "let a=b" and ((a=b)) and typeset -i a=b.
T 1709784480 18<20bent_fingers18>	ormaaj: interesting
T 1709784701 18<20bent_fingers18>	ormaaj: i have a script that prints "I like cookies" on the screen. perhaps i could show you how to do it one day
T 1709786353 19*	Now talking on 22#bash
T 1709786353 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709786353 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709787188 19*	Now talking on 22#bash
T 1709787188 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709787188 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709790361 19*	Now talking on 22#bash
T 1709790361 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709790361 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709790453 18<25ormaaj18>	you could do it with a debug trap. That will itself slow things down measurably.
T 1709790780 18<25ormaaj18>	If you've optimized your algorithms and their rendering in shell is good - which you can normally determine without much measurement - then it comes down to bash being slow. It's worse to contort good code to comply with weird bash performance characteristics than just leave it alone.
T 1709790797 18<26lockywolf18>	How do I encode a newline in a string?
T 1709790829 18<26lockywolf18>	found
T 1709808329 19*	Now talking on 22#bash
T 1709808329 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709808329 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709808445 18<25ormaaj18>	I use dbus-send :o
T 1709810810 19*	Now talking on 22#bash
T 1709810810 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709810810 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709811088 18<25marcopolo118>	 How do you put functions in bashrc ? You just reference your script and give it an alias?
T 1709811590 19*	Now talking on 22#bash
T 1709811590 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709811590 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709811660 18<25marcopolo118>	Like i want to execute a python script from bash terminal using an alia
T 1709812215 18<27Earnestly18>	marcopolo1: The shell is made for executing commands
T 1709812244 18<27Earnestly18>	marcopolo1: I'm not sure what is difficult for you here, maybe show real examples
T 1709813197 18<19randomhero18>	that'd require him to not be trolling, which is a stretch
T 1709815372 18<26FreeBDSM18>	hi. I have a bunch of small files in 1 dir. `cat /dir/* >> joined` says argument list too long, how to solve this task properly? I feel like xargs should be applicable here somehow, but I don't get how
T 1709815468 18<24depesz18>	FreeBDSM: find /dir/ -maxdepth 1 -type f -exec cat {} + >> joined
T 1709815475 18<24depesz18>	should work. mostly
T 1709815497 18<27mindhunter18>	depesz: do you not need the \; at the end?
T 1709815502 18<24depesz18>	NO
T 1709815509 18<24depesz18>	+, not \;. totally different thging
T 1709815518 18<27mindhunter18>	Ah
T 1709815597 18<24depesz18>	mindhunter: compare time find /etc/ -type f -exec cat {} + &>/dev/null vs. time find /etc/ -type f -exec cat {} \; &>/dev/null
T 1709815618 18<26FreeBDSM18>	depesz, thanks!
T 1709815663 18<26FreeBDSM18>	I thought that would somehow sub-optimal as it'd probably call cat once per each file, but that's exactly what xargs here is for
T 1709815694 18<28selckin18>	+ does multiple files in batches ; is one per file
T 1709815723 18<24depesz18>	xargs could still be helpful, if you needed the files to be concatenated in order.
T 1709816699 18<27JorgeBorges18>	hey
T 1709816851 18<28nphard18>	JorgeBorges: look type this into a terminal --> echo  {0000..0050} | tr ' ' '\n' | sed 's/^/<a href="/g'
T 1709816933 18<27JorgeBorges18>	the message has been probably cut off
T 1709816951 18<28nphard18>	JorgeBorges: no, that's the first part
T 1709816957 18<27JorgeBorges18>	it displays <a href="0000 0001 0002..."
T 1709816978 18<28nphard18>	JorgeBorges: are you running linux?
T 1709816980 18<24depesz18>	nphard: simpler: printf '<a href="%s\n' {0000..0050}
T 1709816982 18<27JorgeBorges18>	yes
T 1709817348 19*	Now talking on 22#bash
T 1709817348 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709817348 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709817364 18<24depesz18>	scripts?
T 1709817401 18<27JorgeBorges18>	hm?
T 1709817430 18<24depesz18>	you asked about ... "such scripts". what do you mean? the one liner with seq|sed ? or my approach with printf ?
T 1709817440 18<24depesz18>	neither of these would qualify as scripts, tbh.
T 1709817451 18<28nphard18>	JorgeBorges: I have an improved one
T 1709817498 18<28nphard18>	{0000..0050} | tr ' ' '\n' | sed 's/\(^.*$\)/<a href="\1"/g'
T 1709817502 18<27JorgeBorges18>	errata: how many hours daily you code in bash to be able to write such very simple one liners by hand?
T 1709817701 18<24depesz18>	i write bash for ~ 1 hour a day. but i think the more important fact is that I do it for many years. otoh, realisically - read man pages/help pages to printf, sed, tr, nl, bash, and you will learn how to do it. most importantly - try. play with stuff.
T 1709817715 18<28nphard18>	JorgeBorges: it's only a quick example
T 1709817743 18<24depesz18>	nphard: you don't need grouping in sed, also g flag is not needed.
T 1709817779 18<24depesz18>	| sed 's/.*/<a href="&"/' - will do the sed thing as well :)
T 1709817935 18<28nphard18>	depesz: aahh!! I was looking for that one, but I was doing it wrong 's/^.*$/href=&/'
T 1709817935 18<27Earnestly18>	FreeBDSM: {} + supplies all arguments to -exec such that it fits in ARG_MAX and then splits over that. ; calls -exec once per argument
T 1709817976 18<28nphard18>	JorgeBorges: true, reading man pages/info is quite important.
T 1709818019 18<27Earnestly18>	FreeBDSM: And as an aside, the {} in '{} +' is not the same as the {} in ;
T 1709818133 18<25marcopolo118>	Whats the difference between piping and stdout
T 1709818139 18<27Earnestly18>	(That is, with -exec ; the {} is optional and used as placeholder. With -exec {} + the '{} +' represents the entire "terminator" for -exec, and is required in that specific order. Why they didn't just use +, I'm not sure
T 1709819427 18<26FreeBDSM18>	now I need to clean up all files in that dir except files with names from a list [2,3,86,88,90], I can't think of any solution better than a for file loop
T 1709819523 18<25kurahaupo18>	Earnestly: in principle it should be possible to have find support putting {} anywhere, not just at the end: find … -exec mv {} /dir/1/ + -o -exec mv {} /dir/2/ +
T 1709820022 18<24iconoclast_hero18>	I'm trying to take the error output from ssh regarding host id changing and pipe it to a script that will take the indicated ssh-keygen line and run it for me automatically...  e.g., `$ ssh whatever 2>&1|revokessh`
T 1709820056 18<26FreeBDSM18>	so I need some kind of combination of `xargs` or `find ... -exec` and some regexmatch
T 1709820100 18<24iconoclast_hero18>	and I read the output with a while read loop and put the line ` ssh-keygen -f "/home/user/.ssh/known_hosts" -R "[ssh.address.com]:0000 ` in an array and try to run the array as a command.
T 1709820106 18<26FreeBDSM18>	IDs of correct interfaces are all lower that 100, filenames match IDs, so a fast and dirty solution would be to rm all files with names 100 and higher
T 1709820124 18<24iconoclast_hero18>	which errors out on `Cannot stat "/home/user/.ssh/known_hosts": No such file or directory`
T 1709820148 18<26FreeBDSM18>	can I use expansion like `rm {100..500000}`?
T 1709820152 18<24iconoclast_hero18>	and I'm guessing because it is looking for '"/home/user/.ssh/known_hosts"' not '/home/user/.ssh/known_hosts'
T 1709820224 18<24iconoclast_hero18>	and that I have to parse that line and execute e.g., ssh-keygen -f  "$file" "$address"
T 1709820226 18<24iconoclast_hero18>	correct?
T 1709820346 18<26FreeBDSM18>	`rm {100..500000}` generally works, but only for smaller ranges, with such a range I get error 'argument list too long'
T 1709820634 18<26FreeBDSM18>	ah, so `ls -1 | egrep -v "^(1,2,3,99)$" | xargs rm`
T 1709820699 18<24iconoclast_hero18>	also, using eval didn't work either.
T 1709820786 18<24depesz18>	FreeBDSM: I don't think this egrep does what you want it do.
T 1709820810 18<24depesz18>	check seq 1 100 | egrep "^(1,2,3,99)$"
T 1709820818 18<26FreeBDSM18>	depesz, my mistake: commas instead of pipes
T 1709820822 18<26FreeBDSM18>	1|2|3|99
T 1709820837 18<26FreeBDSM18>	but the problem is that I still get argument list too long error
T 1709820842 18<26FreeBDSM18>	what the hell
T 1709820856 18<26FreeBDSM18>	is it because I actually use `xargs sudo rm`?
T 1709820866 18<24depesz18>	FreeBDSM: with xargs? add -n 100, or something.
T 1709820908 18<26FreeBDSM18>	depesz, ha, it worked! thanks!
T 1709821234 18<29phy172918>	!ls
T 1709821234 18<29greybot18>	DO NOT USE the output of ls in scripts. Its output format is neither portable nor reliable. Use globs instead. See https://mywiki.wooledge.org/ParsingLs
T 1709823726 18<19cousteau18>	Hi
T 1709823747 18<19cousteau18>	`seq` is not POSIX nor required to exist, right?
T 1709823770 18<27colo18>	right.
T 1709823839 18<19cousteau18>	Asking because the shbot right now has an "Easter egg" implementation of seq that doesn't do the expected thing instead of just telling you politely not to use seq
T 1709823886 18<19cousteau18>	(It might be nicer if the bot just told you that seq command is not found, just saying...)
T 1709823946 18<29phy172918>	But not as fun
T 1709823951 18<29phy172918>	which is fun too
T 1709824029 18<27JanC18>	even POSIX things are only required if you care about 100% POSIX compatibility...
T 1709825025 18<25ormaaj18>	lol it would not.
T 1709825034 18<25ormaaj18>	# botsmack
T 1709825035 18<25shbot18>	Segmentation fault
T 1709825286 18<25ormaaj18>	hm i wonder if there's unicode tally marks. It could do tallies!
T 1709825355 18<24depesz18>	𝍷𝍸
T 1709825399 18<25ormaaj18>	best counting system
T 1709825410 18<24depesz18>	https://github.com/garabik/unicode is great piece of software for such things.
T 1709825438 18<28emanuele618>	i agree, i use it often
T 1709825459 18<25ormaaj18>	mh
T 1709825479 18<25ormaaj18>	i don't like how you can't control what kind of input you're giving or what field it's searching in
T 1709825488 18<28emanuele618>	:o
T 1709825505 18<28emanuele618>	you can
T 1709825550 18<24ano18>	# enable seq; seq 1 3
T 1709825552 18<25shbot18>	ano: 1
T 1709825552 18<25shbot18>	ano: 2
T 1709825552 18<25shbot18>	ano: 3
T 1709825557 18<25ormaaj18>	hm
T 1709825578 18<28emanuele618>	-x hexadecimal codepoint, -d decimal codepoint, -o octal codepoint, -b binary codepoint, -r regular expression search names, -s string search names
T 1709825625 18<25ormaaj18>	:o
T 1709825647 18<24depesz18>	unicode --help helps :)
T 1709825664 18<28emanuele618>	i also have a manual page for unicode
T 1709825689 18<25ormaaj18>	oh that's input. There's a --format for output
T 1709825699 18<25ormaaj18>	which is not in the manual D:
T 1709825716 18<24depesz18>	specification of output should be added to manual/help, true.
T 1709825759 18<24depesz18>	you can find output format spec docs in https://github.com/garabik/unicode/blob/master/README#L83
T 1709825792 18<22CrtxReavr18>	Here's a fun font test: touch $(echo -ne '\ufdfd')
T 1709825954 18<24ano18>	looks like a rectangle
T 1709825997 18<24ano18>	imho there are to many rectangles in unicode
T 1709826020 18<25ormaaj18>	# tοuсh $(есhο -nе '\ufdfd'); lѕ -а
T 1709826021 18<25shbot18>	ormaaj: bash: $'\320\265\321\201h\316\277': command not found
T 1709826021 18<25shbot18>	ormaaj: bash: $'t\316\277u\321\201h': command not found
T 1709826021 18<25shbot18>	ormaaj: bash: $'l\321\225': command not found
T 1709826027 18<25ormaaj18>	not working.
T 1709826153 18<25ormaaj18>	# export LC_CTYPE=en_US.UTF-8; tοuсh $(есhο -nе '\ufdfd'); lѕ -а
T 1709826155 18<25shbot18>	ormaaj: bash: есhο: command not found
T 1709826155 18<25shbot18>	ormaaj: bash: tοuсh: command not found
T 1709826155 18<25shbot18>	ormaaj: bash: lѕ: command not found
T 1709826195 18<24ano18>	# : > $(есhο -nе '\ufdfd'); lѕ -а
T 1709826197 18<25shbot18>	ano: bash: $'\320\265\321\201h\316\277': command not found
T 1709826197 18<25shbot18>	ano: bash: $(есhο -nе '\ufdfd'): ambiguous redirect
T 1709826197 18<25shbot18>	ano: bash: $'l\321\225': command not found
T 1709826240 18<28emanuele618>	lmao   unicode --brexit
T 1709826662 18<25ormaaj18>	I am not trusted with +s for some reason D:
T 1709826680 18<28emanuele618>	a good reason?
T 1709826686 18<25ormaaj18>	probably!
T 1709826700 18<25ormaaj18>	i mean no, stupid reason.
T 1709826720 18*	25ormaaj want colors and backwards text
T 1709826743 18<24ano18>	>$'l\321\225': command not found /why it breaks interpreter?
T 1709826762 18<25ormaaj18>	magic
T 1709826948 18<28emanuele618>	it is not breaking anything; those commands don't exist, as the error message says
T 1709826990 18<28emanuele618>	now we know that ano has a font with unicode characters because they don't see rectangles :o
T 1709827001 18<28emanuele618>	cover blown
T 1709827181 18<24ano18>	if it doesn't break anything then where (ls -a) output?
T 1709827212 18<25ormaaj18>	must be broken or smth.
T 1709827554 18<24ano18>	oh ic, tmux doesn't stick w/ unicode ranges(?) on next-word, emacs does
T 1709827561 18<28emanuele618>	it's not ls, it's $'l\321\225'
T 1709827622 18<28emanuele618>	what you see as s, is actually a lower case cyrillic dze
T 1709827738 18<24ano18>	y figured out already emacs jumping around words strictly instead tmux copy-mode, in emacs u will end on char from diff range/group (?) instead end of word on forward-word, bash cmd homograph attack
T 1709827832 18<28emanuele618>	elektron xD
T 1709828045 18<25kurahaupo18>	FreeBDSM: printf %s\\0 !([1-3]|99) | xargs -r0 rm -vf
T 1709828069 18<24OnlineCop18>	Without using getopt/getopts (I need custom handling), would I want to match single-character options like `-h` in a case statement like: `case "$1" in -*([a-gi-z])h*([a-z]) ) show_help;; ...;; esac` ? Or is there a shorter/simpler way to check that 'h' is somewhere in there?
T 1709828196 18<25kurahaupo18>	OnlineCop: what's wrong with *h* ?
T 1709828213 18<24OnlineCop18>	So `-*h* )` ?
T 1709828223 18<29phy172918>	(Assuming there are no options that take args)
T 1709828244 18<24OnlineCop18>	Some of the other options take additional args.
T 1709828261 18<25kurahaupo18>	I would walk through the args and action "help" when I see -h*)
T 1709828290 18<29phy172918>	Then you need to be a bit fancier if you want to support the POSIX guidelines
T 1709828315 18<25kurahaupo18>	There's no point rejecting -hh
T 1709828332 18<29phy172918>	There is a point in supporting -uusername_with_h
T 1709828341 18<25kurahaupo18>	Exactly
T 1709828343 18<24OnlineCop18>	I want to avoid `--choose` from triggering on `-*h*`, so thought that a regex that would match `-[a-gi-z]*h[a-z]*` would be safest...
T 1709828367 18<25kurahaupo18>	What about --hold)
T 1709828384 18<25ormaaj18>	It's always silly when it starts with "without using x, ..."
T 1709828397 18<24OnlineCop18>	Would `-*([a-g-z])h*([a-z]) )` be safe enough?
T 1709828410 18<29phy172918>	Maybe check if it's a long opt first and have those go down a different code path
T 1709828412 18<25kurahaupo18>	OnlineCop: why the extra complication?
T 1709828439 18<29phy172918>	Then pop letters off the front until you don't recognize one or one takes an argument
T 1709828445 18<25kurahaupo18>	OnlineCop: it doesn't save you anything over -*h*
T 1709828467 18<25kurahaupo18>	(they're both equally wrong, mind you)
T 1709828468 18<27Earnestly18>	kurahaupo: Yeah, I agree. That's probably what was originally intended as well
T 1709828469 18<24OnlineCop18>	Doesn't `-*h*` allow `--h` though?
T 1709828510 18<24OnlineCop18>	I typically check for `-` options before `--` options, but if I add all my `--*` cases first, then having `-*h*` at the end might work.
T 1709828539 18<25kurahaupo18>	OnlineCop: you're going about this wrong. You still need to cope with "-f file" AND "-ffile"
T 1709828594 18<25kurahaupo18>	Or "-m whole" and "-mwhole"
T 1709828597 18<27Earnestly18>	Well, you don't /have/ to. If you document the grammar as -f file then people who use -ffile can keep the pieces
T 1709828617 18<25kurahaupo18>	But it's unfriendly not to
T 1709828630 18<27Earnestly18>	Although it's not very difficult to support both I guess
T 1709828636 18<24OnlineCop18>	kurahaupo: This doesn't currently have short options that take arguments, but I don't mind moving the `-` option handling after all the `--` ones.
T 1709828648 18<27Earnestly18>	I mean you pop off the -f so whatever's left must be the argument
T 1709828687 18<27Earnestly18>	I've seen a generally successful strat being to manually parse --longs into -shorts and then handing the whole thing to getopts, being careful to preserve order
T 1709828692 18<25kurahaupo18>	Just have  « --?*) die 64 "invalid option $1" ;; » before any short options
T 1709828715 18<25kurahaupo18>	But why not simply pop off each option as you go?
T 1709828755 18<27Earnestly18>	(That won't support [=optionals] though)
T 1709828786 18<24OnlineCop18>	I haven't written it out far enough to find a singular `-` (not followed by another `-`) and then build/pop the options from the remaining letters. This is all still pretty new to me, so Best Practices is not always easy to find.
T 1709828880 18<25kurahaupo18>	It looks like: for ((;$#;)) do case $1 in … -h|--help ) yeehar! ;; … -[abchvx]?*) set X "${1:0:2}" -"${1:2}" "${@:2}" ;; … *) break ; esac ; shift ; find
T 1709828918 18<25kurahaupo18>	Where -a -b -c -h -v and -x are the single letter options that don't take args
T 1709828920 18<28emanuele618>	find
T 1709828999 18<25kurahaupo18>	Oh, last before *) break is -*) die 64 "Invalid option $1"
T 1709829041 18<25kurahaupo18>	Note that "set X …" compensates for the next "shift"
T 1709829113 18<24OnlineCop18>	I don't appear to have `die` ...
T 1709829263 18<27Earnestly18>	!die
T 1709829264 18<29greybot18>	command -v foo >/dev/null || die "please install the foo command" # Using a custom 'die' function from http://mywiki.wooledge.org/BashFAQ/101
T 1709831888 18<20bent_fingers18>	Guest1235: async dns?
T 1709832291 18<28apteryx18>	hello!  in the nx-libs project Makefile, one of the recipe does '. replace.sh' (source a replace.sh shell script).  This fails with: sh: .: replace.sh: file not found, although the file does exist.  I'm puzzled; what could be the reason?
T 1709832354 18<28emanuele618>	apteryx: . foo  searchs  foo  in PATH as if you just ran   foo   as a command
T 1709832386 18<28emanuele618>	if replace.sh is in the current directory, that means that you don't have . in PATH, which is normal
T 1709832406 18<28emanuele618>	to source replace.sh in the current directory you should use     . ./replace.sh
T 1709832452 18<28emanuele618>	it is the same in bash, but bash, as an extension, if it does not find  foo  in PATH, will try to source  ./foo
T 1709832463 18<28emanuele618>	not all other shells do it
T 1709832487 18<28apteryx18>	I see!  I think I'm using Bash as sh (its POSIX compatibility mode)
T 1709832498 18<28apteryx18>	thanks for the kind and thorough explanation
T 1709832554 18<28emanuele618>	it is recommended to use  . ./replace.sh   even when using bash in standard mode, because if it finds for some reason  replace.sh  in e.g.  /usr/local/bin/replace.sh    for some reason, it will source that instead of ./replace.sh
T 1709832574 18<28emanuele618>	you are welcome
T 1709833122 18<28apteryx18>	I've reported the issue here: https://github.com/ArcticaProject/nx-libs/issues/1071
T 1709833501 18<24ano18>	what's wrong with posix ver numeration (POSIX.1 -> POSIX.1b -> POSIX.1c > POSIX.2 -> POSIX.1-2001 -> ...) ?
T 1709833562 18<28llua18>	ask them
T 1709833719 18<24ano18>	are posix man pages outdated e.g. (man 7 regex) >regex - POSIX.2 regular expressions, or regex spec unchanged since POSIX.2?
T 1709833769 18<24ano18>	ugh it's >Linux man-pages, looks like there is no(?) posix man page for regex
T 1709836410 18<28nphard18>	is this legal? echo $(foo $(foo))
T 1709836435 18<29phy172918>	No, the shell police will arrest you shortly
T 1709836439 18<29phy172918>	!echo$(
T 1709836440 18<29greybot18>	$(echo ...) and echo $(...) are both pointless. Drop the echo and $(), just write ...: rm "$(echo myfile)" -> rm myfile --- echo "$(df -h)" -> df -h; http://www.iki.fi/era/unix/award.html#echo
T 1709836471 18<29phy172918>	If you just mean can you nest $( in $(, yes
T 1709836592 18<28nphard18>	mm.. nevermind this worked : mkdir $( somecomand )
T 1709836821 18<24ano18>	!chk mkdir $( somecomand )
T 1709836837 18<24ano18>	!check mkdir $( somecomand )
T 1709836837 18<28checkbot18>	ano: Line 1: Quote this to prevent word splitting. See https://shellcheck.net/?id=cb36837
T 1709836848 18<24ano18>	nphard: ^
T 1709836911 18<24ano18>	!-- > nphard
T 1709836911 18<29greybot18>	nphard: The special option -- means "end of options" to every POSIX command except echo and test, and to many other commands. E.g. «mv -- *.png /somedir» (in case one of the filenames begins with "-"). See http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html#tag_12_02 and http://wiki.bash-hackers.org/dict/terms/end_of_options
T 1709837349 18<28nphard18>	like this? mkdir -- "$( somecomand )"
T 1709837390 18<24ano18>	y
T 1709838686 18<24lavaball18>	last line of file into variable. better way then x=$(tail -n1 file)?
T 1709838696 18<24lavaball18>	than
T 1709838784 18<28emanuele618>	that looks good
T 1709838793 18<29phy172918>	<sarcasm>  while IFS= read -r x; do :; done <file   It's pure shell  </sarcasm>
T 1709838899 18<28emanuele618>	<sarcasm> yeah, that is better                                       </sarcasm>
T 1709839230 18<24lavaball18>	thanks guys                        <(don't quit your day job)
T 1709839759 18<24lavaball18>	read is the best thing to search for in the man page. you get to see all the sights before you read the actual function.
T 1709840626 18<28nphard18>	I had a brilliant idea! make some tutorial for bash with Scratch interface!!
T 1709840638 18<28nphard18>	for learning purposes.
T 1709840658 18<20arraybolt318>	Scrash
T 1709840664 18<28emanuele618>	good idea
T 1709840667 18<20arraybolt318>	Scratcsh
T 1709840683 18<20arraybolt318>	Batch
T 1709840687 18<20arraybolt318>	trying to think of names for it
T 1709840701 18<24Milos18>	If I have a command like journalctl | cut [ ... ] | less +F, how do I make CTRL+C only apply to less?
T 1709840706 18<28nphard18>	this is how it'd look --> https://en.wikipedia.org/wiki/Scratch_(programming_language)#/media/File:Scratch_Beginner_Scripts.png
T 1709840742 18<28emanuele618>	⚡sh
T 1709840757 18<24Milos18>	With less +F, it won't let me scroll when it's in follow mode, so I have to CTRL+C to get out of follow mode (unless there's another way)? however as you know, CTRL+C is a global thing and applies to everything in the pipe...
T 1709840814 18<28emanuele618>	^X disables follow mode in less
T 1709840819 18<24ano18>	>Waiting for data... (^X or interrupt to abort)
T 1709840848 18<24Milos18>	emanuele6, d'oh. I just saw that
T 1709840851 18<24Milos18>	!!!!!!
T 1709840855 18<28emanuele618>	it seems it does not say it when you use less +F
T 1709840867 18<24Milos18>	it does say it
T 1709840873 18<24Milos18>	apparently I just never noticed
T 1709840874 18<28emanuele618>	it's F (shift+f) to turn it back on if you don't know
T 1709840877 18<24Milos18>	yup
T 1709840904 18<24Milos18>	the problem with CTRL+X is if I do it too frequently I'll start CTRL+Xing things I'm supposed to CTRL+C
T 1709840908 18<24Milos18>	:|
T 1709840925 18<24Milos18>	so - for education, is it possible to do what I originally requested?
T 1709840954 18<24Milos18>	I assume something to do with traps, can traps be used per piped command?
T 1709840976 18<28emanuele618>	i am not sure what you want is, because if you kill less, cut and journalctl will die the next time they try to print something
T 1709840988 18<24Milos18>	why didn't they just make F enable/disable follow mode, would be so much easier
T 1709841001 18<24Milos18>	emanuele6, CTRL+C doesn't kill less, it stops the live follow
T 1709841018 18<24Milos18>	I am just used to doing that, have always been doing it that way
T 1709841021 18<28emanuele618>	hm
T 1709841027 18<24Milos18>	today I learned I could CTRL+X but I'd rather not because muscle memory
T 1709841043 18<24Milos18>	would have been great if you could just F to toggle :|
T 1709841124 18<28emanuele618>	i see
T 1709841268 18<28emanuele618>	well, one way you could do it is if you start the pipeline with  { less +F & fg ;} < <(journalctl | cut [ ... ])
T 1709841273 18<28emanuele618>	but that is a bit silly
T 1709841317 18<28emanuele618>	probably the best general solution is finding the pid of the program, and then running  kill -sINT 123  in another terminal
T 1709841331 18<24Milos18>	damn
T 1709841371 18<24Milos18>	how come you can't less +F <(stuff to send it)?
T 1709841389 18<27cluelessperson18>	How do you log all the upcoming output of a script to a log file from within the script?
T 1709841390 18<28emanuele618>	or stop the process the pipeline with ^Z and figure out the pid with jobs
T 1709841452 18<27cluelessperson18>	I've gotten close with,  `set -x; echo &>  >(tee test.log); echo "Hello there!"`  but that has some weird buffering problem with tee I'm not sure how to solve?
T 1709841460 18<28emanuele618>	Milos: ^C sends INT to the entire process group of the foreground process;  less +F & fg  makes less run in a separate group, so that is why the other processes don't get killed
T 1709841472 18<24Milos18>	ah!
T 1709841498 18<24Milos18>	and what is the significance of { } there?
T 1709841515 18<28emanuele618>	it is just to group   less +F   and   fg
T 1709841537 18<28emanuele618>	to make the   < <(journalctl | cut ...)  redirection apply to both
T 1709841563 18<24Milos18>	cluelessperson, I don't know much but if you have a buffering issue you could use stdbuf -oL to make it line-buffered
T 1709841571 18<24Milos18>	in front of the command that is buffering
T 1709841609 18<24Milos18>	emanuele6, I don't think I've sene that get used before, it looks interesting
T 1709841613 18<24Milos18>	s/sene/seen/
T 1709841633 18<24Milos18>	I thought grouping/subshells was done with $()
T 1709841643 18<28emanuele618>	well, it is something that only makes sense for your interactive manual process management
T 1709841661 18<24Milos18>	out of curiosity could the command you wrote be rewritten without { }?
T 1709841665 18<28emanuele618>	hmm, no; $() runs a command, and then expands to its output
T 1709841676 18<24Milos18>	where can I read more about { }?
T 1709841679 18<28emanuele618>	Milos: I guess, yeah
T 1709841686 18<24Milos18>	is it the same as func() { } ?
T 1709841737 18<28emanuele618>	you would do   exec {fd}< <(journalctl | cut [ ... ]); less +F <&"$fd"- & exec {fd}<&-; fg
T 1709841744 18<28emanuele618>	{ } saves having to cleanup manually
T 1709841754 18<28emanuele618>	it is the same as the { } in func() { } yeah
T 1709841765 18<24Milos18>	wow, that looks so intense :D
T 1709841773 18<24geirha18>	syntax for a function is  name() compound-command.  A command grouping, { ...; }, happens to be the most commonly used one for functions
T 1709841805 18<28emanuele618>	in case you didn't know; you can write    guess () if [ "$1" = 100 ]; then echo you win!; else echo no; fi   :o
T 1709841810 18<27cluelessperson18>	hm, I'm stuck
T 1709841821 18<24Milos18>	yeah, I suppose like in C-like languages you can do if(condition) return; without needing to do if(condition) { return; } if the brevity is appropriate
T 1709841838 18<24Milos18>	so {} just groups stuff
T 1709841915 18<24geirha18>	yes
T 1709841916 18<28emanuele618>	and also kind of like in C; if you have   int x = 2; { int x = 3; func(x) /* this calls func(3) */ ;} func(x) /* this calls func(2) */    you don't have to restore x after the block
T 1709841932 18<28bprompt18>	Milos: other languages allow the same like Perl, however I prefer enclosing with {} for readability, so I know where one ends and another starts
T 1709841952 18<28emanuele618>	likewise if you have   { ...; } < foo   you don't have to restore/cleanup stdin manually to its original value after exiting }
T 1709841977 18<28bprompt18>	Milos: likewise in Python, you don't have to use ";", however I do
T 1709841983 18<24Milos18>	emanuele6, I didn't realise C scoped like that
T 1709842019 18<28emanuele618>	edubashion
T 1709842042 18<24ano18>	# guess () if [[ "$1" = 100 ]] then { echo you win!; } else { echo no; } fi; guess 100
T 1709842044 18<25shbot18>	ano: you win!
T 1709842049 18<24Milos18>	bprompt, PEP8 has entered the chat...
T 1709842088 18<24geirha18>	Woah, you guessed right on the first try. Well done!
T 1709842103 18<24Milos18>	emanuele6, honestly had no idea this applied to C! https://stackoverflow.com/a/1677799
T 1709842109 18<24Milos18>	I feel like I've never noticed it before
T 1709842158 18<28emanuele618>	in C++, if you declare variables with destructors, destructors get called automatically on those variables when you exit }
T 1709842185 18<28emanuele618>	{} in C/C++ (also in bash for redirections) is pretty much like try-with-resources in java, or with in python
T 1709842301 18<24chives18>	Is this a bash or linux question?  If I'm basically starting a shell just to run a screen command, but sometimes I cant access the terminal(i guess that is the name?) anymore and sometimes have to detach from that running session i guess maybe is the name... is there a way to have the terminal logout?  I can only have so many terminals before i get kind of locked out so was wondering there may be a
T 1709842303 18<24chives18>	better way
T 1709842390 18<24Milos18>	emanuele6, got it, thanks a lot for explaining all this in detail :D learned a lot
T 1709842441 18<24chives18>	I guess its prob more a linux question will ask there
T 1709842451 18<24Milos18>	emanuele6, also on that note, I had to add stdbuf -oL before 'cut' to make the command I want work, because otherwise it just doesn't. Do you know why this is needed in this case, but not in regular uses of cut?
T 1709842470 18<24Milos18>	just doesn't => less gets no text
T 1709842493 18<24geirha18>	!faq buffer
T 1709842493 18<29greybot18>	https://mywiki.wooledge.org/BashFAQ/009 -- What is buffering?  Or, why does my command line produce no output: tail -f logfile | grep 'foo bar' | awk ...
T 1709842514 18<28emanuele618>	that is something you usually have to do when you want to see immediately the output of a program that is not writing to a terminal
T 1709842554 18<24Milos18>	geirha, thanks - looking now
T 1709842555 18<28emanuele618>	when not writing to a terminal (in this case cut is writing to a pipe, that less reads and shows on the terminal), programs write more lazily
T 1709842627 18<24Milos18>	for reference, I am actually doing `journalctl -f -u some_service -u some_other_service | cut [ ... ] | less +F, so that my tmux scrollback doesn't end up consuming 2GB RAM after running journalctl -f for weeks with lots of logs output being displayed. I wanted a solution where I could view the output live but also scroll backwards if needed, without consuming scrollback history. so I guess now less is the p
T 1709842628 18<24Milos18>	rogram that's slowly eating memory, but I can easily kill and restart it without needing to restart my entire tmux session
T 1709842665 18<24Milos18>	so I think because I am using journalctl -f, it messes with buffering and requires me to do stdbuf -oL before cut
T 1709842692 18<28nphard18>	that's the price for storing logs in binary format I guess
T 1709842697 18<28bprompt18>	chives: "to run a screen command"? so, you want to run some application, and the application opens a terminal every time, right?   so if you run that app hmm 20 times, you get 20 terminals, is that it?
T 1709842723 18<24geirha18>	no, it's just that cut detects that stdout is not a tty (it's a pipe), so it starts buffering
T 1709842737 18<24Milos18>	oh
T 1709842824 18<24Milos18>	geirha, how does it know if it's a tty or not?
T 1709842827 18<24geirha18>	and it's not really explicitly doing it, but implicitly through using libc functions like printf(3), so you'll find a lot of commands do these unless they explicitly work around it
T 1709842831 18<24Milos18>	I'm slowly reading through that webpage
T 1709842838 18<24geirha18>	man 3 isatty
T 1709842843 18<24chives18>	bprompt: well kind of i think, im running mosh then screen then weechat, but mosh is great for restarting sessions, but if you reboot or close the terminal local side its forever unable to be logged back in to
T 1709842860 18<24Milos18>	geirha, so the dev purposely puts in this efficiency improvement and without it, no buffering would occur?
T 1709842870 18<24Milos18>	i.e. if you do not put in extra work to buffer, it would 'just work'?
T 1709842874 18<24Milos18>	but be slower?
T 1709842884 18<24chives18>	so thats one reason i use screen i can just restart it in the new session but now i have an extra session that takes up a port i only have so many of
T 1709842885 18<24geirha18>	no, it's extra work to not buffer
T 1709842897 18<24Milos18>	well if they are calling isatty() isn't that more work?
T 1709842919 18<28emanuele618>	the standard C library (stdio.h) decides how to buffer automatically for you, if you use puts(), printf() etc functions
T 1709842934 18<28emanuele618>	it decides based on the file type of stdout
T 1709842944 18<24Milos18>	what is stdout's file type or how can I check it?
T 1709842964 18<24chives18>	so was thinking if i had a special session that started screen, when screen terminated itd close the mosh session out and free up that port
T 1709842971 18<28emanuele618>	for cmd in   cmd | ...    stdout is the pipe that connects it with ...
T 1709843007 18<24Milos18>	right - but you said earlier it was dynamically checked based on the file type, so how is that part done?
T 1709843008 18<24geirha18>	in C,  if (isatty(1)) ...    in bash:  if [[ -t 1 ]] ; then
T 1709843014 18<24Milos18>	ah, so it's isatty
T 1709843038 18<28emanuele618>	# if [[ -p /dev/stdout ]]; then echo stdout is pipe >&2; elif [[ -t 1 ]]; then echo stdout is tty >&2; else echo stdout is something else >&2; fi
T 1709843039 18<25shbot18>	emanuele6: stdout is tty
T 1709843044 18<28emanuele618>	# if [[ -p /dev/stdout ]]; then echo stdout is pipe >&2; elif [[ -t 1 ]]; then echo stdout is tty >&2; else echo stdout is something else >&2; fi | cat
T 1709843046 18<25shbot18>	emanuele6: stdout is pipe
T 1709843049 18<28emanuele618>	# if [[ -p /dev/stdout ]]; then echo stdout is pipe >&2; elif [[ -t 1 ]]; then echo stdout is tty >&2; else echo stdout is something else >&2; fi > foobar
T 1709843051 18<25shbot18>	emanuele6: stdout is something else
T 1709843070 18<28emanuele618>	there are definitely way for a program to check the type of its stdout
T 1709843078 18<28emanuele618>	s/ay/ays
T 1709843093 18<24Milos18>	this is super interesting
T 1709843104 18<24Milos18>	ok so the default case then, if you were to just write a program, and use it in a pipe, and do no checks, does it buffer or not buffer?
T 1709843127 18<24Milos18>	depends on the functions used (puts etc?)
T 1709843132 18<24Milos18>	is that the answer>?
T 1709843161 18<28emanuele618>	most C programs use the stdio.h functions to print, if they do, you will get buffering because there is code in the standard C library that does it
T 1709843166 18<28bprompt18>	chives: not acquainted with "mosh", I don't use it, hmmm but you could try asking at #ubuntu :)
T 1709843203 18<24geirha18>	if you use any of stdio.h functions for output, it will do the automatic buffering. If you use the write(2) system call directly, the write will be immediate
T 1709843210 18<28emanuele618>	if the program does some direct write syscalls, or print in some other different way, it will not buffer, or it may buffer in a different way that is not disableable by  stdbuf -oL
T 1709843270 18<24Milos18>	got it - so geirha that's why you said it's more work not to buffer, if you used the standard libraries which most stuff probably does, then you have to explicitly flush buffers or whatever to disable it
T 1709843276 18<28emanuele618>	there is also code in the C standard library that understand that a program is run with   stdbuf -oL   and uses line (L) buffering instead of the default in that case; so if the program is using some other library for output buffering, stdbuf will not have any effect
T 1709843287 18<24chives18>	bprompt: why ubuntu? is that that devs? someone had said something about it in irc somewhere because i was having some serious lag trying to type and correct text and it helps
T 1709843310 18<24Milos18>	emanuele6, and the difference between line-buffered and buffer flushed after each char is just efficiency, nothing breaks?
T 1709843328 18<24Milos18>	(not talking about standard library buffering which is greater than a single line)
T 1709843333 18<24geirha18>	Milos: yes, either use write(2) directly, or call fflush(3) after doing a printf or similar
T 1709843336 18<28emanuele618>	in simple cases, pretty much yes
T 1709843370 18<24Milos18>	got it
T 1709843376 18<28emanuele618>	-o0 is no buffering at all; -oL is flush up to the last newline if there are newline in the buffer or the buffer is full
T 1709843394 18<28emanuele618>	default is typically -o4096 iirc; so flush after the buffer is full, and the buffer is 4096 bytes
T 1709843398 18<28bprompt18>	chives: it'd be likely someone either runs it and uses it at #ubuntu
T 1709843404 18<24Milos18>	so I could do -o0 but it would just be silly since you need the whole line before you see it, or at least it makes more sense to have the whole line
T 1709843428 18<24Milos18>	good to know about the default buffer size!
T 1709843472 18<24Milos18>	the only time I consciously needed to flush the buffer is when I made an animation on the terminal when stuff was loading, so I had to make it erase the line and rewrite the line and then flush the buffer
T 1709843478 18<28emanuele618>	except that the default for terminals is -oL since there is probably a human at the terminal that wants to see the output immediately
T 1709843486 18<24chives18>	oh ok will try and see im guessing its not a mosh question more of a terminal setting type question but
T 1709843528 18<24Milos18>	or I could have just started python with PYTHONUNBUFFERED :D
T 1709843532 18<28emanuele618>	yeah, there you need to flush because it is buffering with -oL so it won't actually print anything until you print a newline
T 1709843537 18<24Milos18>	yup
T 1709843579 18<24Milos18>	so the fact that it's line-buffered, that is handled by printf() or whatever python's print() statements maps to on the C level?
T 1709843626 18<28emanuele618>	no, the default is 8192 actually, not 4096
T 1709843635 18<24Milos18>	:O
T 1709843637 18<28emanuele618>	gcc -include stdio.h -xc -E -<<< BUFSIZ | tail    shows 8192 for me at least
T 1709843643 18<28emanuele618>	that is the default
T 1709843654 18<27cluelessperson18>	chives   I was on scrollback,  but you can configure the session to exit once it finishes with `exit`
T 1709843681 18<28emanuele618>	Milos: not necessarily C, but yeah, it is handled by the program itself, or its libraries, not by the file or the kernel
T 1709843776 18<24chives18>	cluelessperson: oh ok so start with a .sh file and finish with exit?
T 1709843850 18<24Milos18>	hm... probably a question for another channel, but I am wondering if C's write() is buffered, because I assume python's sys.stdout.write() calls C's write(), and if I was doing the animation I talked about earlier, then if it's not buffered I wouldn't need to flush, but I did, so it must be buffering
T 1709843892 18<28emanuele618>	no, write is a direct system call to the kernel, and it will write immediately; also note that C write() is not defined in stdio.h; it is a unix standard function
T 1709843904 18<24Milos18>	ah
T 1709843983 18<28emanuele618>	important to note that if you have    printf("hello %d", i); write(STDOUT_FILENO, "! hi", 4); putchar('\n');   that will probably print out of order
T 1709844021 18<28emanuele618>	important to not mix stdio.h and write; or at least always flush before calling write on a fd that you are using with stdio.h
T 1709844040 18<28emanuele618>	that likely prints   ! hihello, 123<newline>
T 1709844055 18<28emanuele618>	same would happen in python
T 1709844066 18<24Milos18>	I did not expect to go down such a deep rabbit hole on this - just shows how much I have no idea about
T 1709844084 18<24Milos18>	that's really fascinating
T 1709844180 18<27cluelessperson18>	chives   I would suggest searching google for more answers around running a process in the background after logout,  but you can just do `command & disown`,  but it can be tiresome/tedious to reconnect and maange them if you don't cause for them to close themselves properly.
T 1709844218 18<27cluelessperson18>	Can someone suggest a better way for me to do this?    `exec &> >(tee output.log)`
T 1709844240 18<27cluelessperson18>	it almost does exactly what I want, but seems to hang waiting for the user to hit enter?
T 1709844251 18<27cluelessperson18>	I think it's a line buffering thing, but I'm not sure how to figure that out.
T 1709844485 18<24geirha18>	if you don't wait for the process substitution to end before exiting the script, then you risk it flushing the last data it has after the script has exited, and after the next interactive prompt ir printed, overwriting/interleaving it
T 1709844693 18<27cluelessperson18>	geirha  How do I wait for ... *googles*
T 1709844991 18<24geirha18>	wait "$!"  if it's the only background job in the script. Otherwise, you'll need to use a named pipe instead of a procsub
T 1709844998 18<28emanuele618>	you save the pid of the process substitution after creating it with   exec ... >(...); procpid=$!    and then either before exiting or with a trap EXIT, you call   wait -- "$procpid"  at the end
T 1709845397 18<28emanuele618>	Milos: i think   sys.stdout.write()  does not call write directly; it is more similar to C's fwrite() function which is buffered
T 1709845463 18<28emanuele618>	perhaps you were thinking of  os.write(os.STDOUT_FILENO, "foo")   which actually calls write directly
T 1709845508 18<25ormaaj18>	aw I thought emanuele was mad, but the !'s were someone else
T 1709845520 18<24lavaball18>	can i have a { printf print printf  } >> output file? like the while read ... { } < inputfile just in reverse?
T 1709845531 18<28emanuele618>	hmm, looks like os.STDOUT_FILENO doesn't exist; you have to hardcode 1
T 1709845564 18<24lavaball18>	i think { } 1 >> outputfile   right?
T 1709845590 18<28emanuele618>	and you must pass a bytes to os.write, not a string; so  b'foo'   or bytes(mystr)
T 1709845604 18<28emanuele618>	or mystr.encode() however you prefer encoding your strings
T 1709845620 18<25ormaaj18>	13:47      emanuele6 │ it seems it does not say it you useless F! F! Turn it back on if you don't know!
T 1709845635 18<28emanuele618>	$ python3 -c 'import os; i=123; print(f"hello {i}", end=""); os.write(1, b"! hi"); print("")'
T 1709845637 18<28emanuele618>	! hihello 123
T 1709845648 18<28emanuele618>	$ python3 -c 'import sys; i=123;print(f"hello {i}", end="",flush=False); sys.stdout.write("! hi"); print("")'
T 1709845650 18<28emanuele618>	hello 123! hi
T 1709845679 18<28emanuele618>	:O
T 1709845691 18<25ormaaj18>	:D
T 1709845742 18<25ormaaj18>	Usually it's the python read people complain about being magical
T 1709845758 18<25ormaaj18>	readlines or whatever
T 1709845781 18<25ormaaj18>	write could be too
T 1709845829 18<28emanuele618>	err, the second command was supposed to be just   python3 -c 'import sys; i=123; print(f"hello {i}", end=""); sys.stdout.write("! hi"); print("")'
T 1709845842 18<28emanuele618>	same result either way
T 1709846239 18<25finsternis18>	I have a script like this https://sprunge.us/TuHcOD  and want to do something like this:  ./myscript.sh | grep "foo" >> file.txt      But then I have to ctrl-c since it's waiting for input, that I don't want to pass. If I type the keystroke ctrl-c, file.txt is empty but if instead I do   kill -s SIGINT $(pgrep myscript)  then file.txt contains the matched string. Why?
T 1709846386 18<28emanuele618>	^C is not how you enter nothing; to do that you either press enter, or press ^D (pressing ^D will make the read command fail)
T 1709846600 18<25finsternis18>	emanuele6: and is it possible to automatically send ^D to the script? I mean to simulate it
T 1709846626 18<25finsternis18>	maybe expect script?
T 1709846779 18<25ormaaj18>	print(' '.join(bracex.expand("foo{1..5}{a,b}")))
T 1709846779 18<25ormaaj18>	foo1a foo1b foo2a foo2b foo3a foo3b foo4a foo4b foo5a foo5b
T 1709846863 18<25ormaaj18>	if only it globbed too
T 1709846974 18<29nvz18>	yeah its a shame its not like open source software you could add features to :P
T 1709849060 18<27Earnestly18>	ormaaj: Add Glob.glob()
T 1709849542 18<24lavaball18>	oh,without the 1. just { } >> outputfle.
T 1709849644 18<24lavaball18>	is it bad practice to read the first line of a file with read -r firstline < filename ? i feel like i should close it or something.
T 1709849796 18<27larryv18>	there's nothing wrong with that, and there's no need to "close" anything
T 1709849805 18<20twkm18>	that will close it, after the read completes.
T 1709849818 18<24lavaball18>	okay. thanks a bunch.
T 1709849829 18<20twkm18>	i.e., you didn't open it long-term (that's possible too).
T 1709849978 18<24lavaball18>	is it better practice to have a do you wanna question set a variable, which is then checked during output, or should i put the do you wanna question in between the output and forgo the variable?
T 1709850135 18<25ormaaj18>	kind of depends on context I'd say.
T 1709850228 18<25ormaaj18>	like, I would do something different depending on what the variable is for and what kind of check is most convenient. Not really a universal best practice.
T 1709850492 18<24lavaball18>	https://bpa.st/JXMA the persist=1 thing the bottom. gets checked at line 98.
T 1709850493 18<28checkbot18>	lavaball: I think the problem is on line 98. This expression is constant. Did you forget the $ on a variable? See 54 issues on https://shellcheck.net/?id=cb50493
T 1709850516 18<24lavaball18>	what?
T 1709850531 18<27larryv18>	you got checkbot'd
T 1709850539 18<25ormaaj18>	I always get checkbot'd
T 1709850561 18<25ormaaj18>	checkbot: thank you
T 1709850561 18<28checkbot18>	ormaaj: You're welcome! \(=^.^= )/
T 1709850565 18<25OMGOMG18>	almost as bad as getting yellow mustarded
T 1709850587 18<28emanuele618>	checkbot always checkbots my tcl scripts :(
T 1709850603 18<24lavaball18>	the checkbot is right though.
T 1709851022 18<25ormaaj18>	it looks a lot more complicated than it is because of all the printfs... maybe consolidating some of those would be more readable.
T 1709851042 18<24lavaball18>	how?
T 1709851060 18<24lavaball18>	does printf " ... \ ... \ .... " work?
T 1709851079 18<24lavaball18>	or should i just printf " .. \n ... \n ... \n ..."
T 1709851120 18<25ormaaj18>	oh there's a bunch of ways. can use heredocs and loops where it makes sense. shell printf implicitly loops over the format string for any number of args so you can do `printf '%s\n' 'line 1' 'line 2' 'line 3'`
T 1709851132 18<24lavaball18>	oh, right heredocs! i read about those.
T 1709851150 18<24lavaball18>	okay, the loop thing i don't understand.
T 1709851151 18<27Earnestly18>	# printf '[%s]' {a..f}
T 1709851153 18<25shbot18>	Earnestly: [a][b][c][d][e][f]
T 1709851184 18<24lavaball18>	but how does that help me here?
T 1709851218 18<25ormaaj18>	you can put some of those variables into arrays too
T 1709851243 18<27Earnestly18>	lavaball: I looked at your paste and would personally use heredocs
T 1709851249 18<25ormaaj18>	also lots of missing quotes... should go through all the shellcheck things where it says to add quotes and add them
T 1709851305 18<24lavaball18>	i've been told if i'm 100% sure there aren't space it's okay.
T 1709851321 18<25ormaaj18>	not really no
T 1709851332 18<24lavaball18>	!heredocs
T 1709851332 18<29greybot18>	Here documents. cat <<EOF followed by several lines of text, followed by the literal string EOF on a new line, NOT indented. The portion between the EOFs is passed to the command as standard input. If 'EOF' is 'quoted', substitutions WON'T be done; otherwise they are. See <<- for the indented variety.
T 1709851353 18<24lavaball18>	i was hoping for a link.
T 1709851363 18<27larryv18>	lavaball: half of these unquoted variables are user input
T 1709851374 18<25ormaaj18>	not quoting is incorrect except in special circumstances.
T 1709851386 18<27larryv18>	(i say half only because it's clearly a lot of them and i'm not about to count.)
T 1709851421 18<27larryv18>	also spaces are hardly the only thing to worry about
T 1709851438 18<24lavaball18>	what else is  there?
T 1709851473 18<25ormaaj18>	# x=/*; echo $x
T 1709851474 18<25shbot18>	ormaaj: /bin /dev /etc /init /lib /lib64 /proc /root /tmp /usr /var
T 1709851531 18<24lavaball18>	i mean i'm sure you are right, but if i have anything in there that needs quotes the resulting text files are kaputt anyway.
T 1709851554 18<25ormaaj18>	huh?
T 1709851564 18<27larryv18>	ormaaj: fishing for excuses to not quote. typical
T 1709851585 18<25ormaaj18>	!qefs
T 1709851585 18<29greybot18>	"$Quote" "$Every" "$Fucking" "$Substitution"
T 1709851613 18<25ormaaj18>	good advice greybot!
T 1709851616 18<25ormaaj18>	!yw
T 1709851616 18<29greybot18>	You're welcome, human.
T 1709851977 18<25ormaaj18>	!quotes
T 1709851977 18<29greybot18>	https://mywiki.wooledge.org/Quotes
T 1709852009 18<25ormaaj18>	mh I should peek to see if that page is as bad as UsingFind
T 1709852070 18<25ormaaj18>	Nope, better than UsingFind.
T 1709852087 18<27larryv18>	lavaball: heredoc example https://paste.wooledge.org/29349
T 1709852180 18<25ormaaj18>	that first paragraph is so well written. probably knows their stuff.
T 1709852215 18<28emanuele618>	it is missing a comma :o
T 1709852221 18<24lavaball18>	larryv, that is really kind of you. much appreciated.
T 1709852231 18<25ormaaj18>	O.O
T 1709852274 18<24lavaball18>	and you did the variable:+ thing!!!!!
T 1709852285 18<24lavaball18>	i thought nobody ever needs that like ever when i read about it.
T 1709852310 18<28lmat18>	I'm running   watch -n .5 tail -n 40 logfile;  When I see something remarkable in the log, I want to stop running tail and examine the output, but watch clears the screen when it leaves (rmcup?). How do I get watch to leave the screen as it was when I quit the command?
T 1709852314 18<25ormaaj18>	nah all the good scripts use a billion of those
T 1709852376 18<25ormaaj18>	no tail -f?
T 1709852429 18<25ormaaj18>	just don't use watch
T 1709852455 18<25ormaaj18>	use a loop and some tput if tail -f isn't good enough
T 1709852703 18<25ormaaj18>	if you actually need the polling too then pick your favorite filesystem event tool and use that, probably in a loop, with tput to rewind the cursor and clear the printed region. That would be about the most intricate way for a shell script.
T 1709852819 18<28lmat18>	ormaaj: tail -f isn't working because the file is on a sshfs to a sftp server. It's not updating often enough.
T 1709852831 18<25ormaaj18>	ah fun
T 1709852852 18<25ormaaj18>	that'll break all the other inotify things just the same.
T 1709852856 18<28lmat18>	It looks like    watch -n .5 tail -n 40 logfile && tail -n 40 logfile; isn't too bad.
T 1709852862 18<28lmat18>	ormaaj: Yeah, I haven't even tried inotify xD
T 1709852873 18<22loganlee18>	watch command seems awesome!
T 1709852879 18<28lmat18>	loganlee: It is.
T 1709852886 18<22loganlee18>	lmat, XD
T 1709852887 18<25ormaaj18>	but tail -f has a polling mode for when inotify isn't available
T 1709852888 18<28lmat18>	loganlee: ls is really cool, too... ;-)
T 1709852893 18<22loganlee18>	lmat, :D
T 1709852941 18<25ormaaj18>	best to switch to a proper filesystem
T 1709852947 18<25ormaaj18>	<.<
T 1709853071 18<25ormaaj18>	sshfs has some fancy mount options as well maybe there is some way to get modification events
T 1709853114 18<25ormaaj18>	sftp doesn't really have anything to facilitate that, not sure how that would work.
T 1709853161 18<28emanuele618>	i use watch to look at my cpu temperature
T 1709853171 18<28emanuele618>	with  watch acpi -t
T 1709853177 18<25ormaaj18>	:D
T 1709853181 18<28emanuele618>	also nice for other things
T 1709853773 18<25ormaaj18>	I don't know which sensors this board exposes through acpi but clearly either neither of them are the cpu, or they are measuring the heatsink temp or something.
T 1709854210 18<25ormaaj18>	(ins)root 18 (1568975) 0 ~ # sensors -- acpitz-\* coretemp-\* | grep ° | head -n 3
T 1709854210 18<25ormaaj18>	temp1:        +27.8°C
T 1709854210 18<25ormaaj18>	temp2:        +29.8°C
T 1709854211 18<25ormaaj18>	Package id 0:  +58.0°C  (high = +82.0°C, crit = +100.0°C)
T 1709854225 18<25ormaaj18>	coretemp is always the most accurate if it's an intel chip
T 1709859326 18<20bent_fingers18>	`cat /dev/urandom` doesn't seem to be a viable screensaver
T 1709859358 18<20bent_fingers18>	it causes the cpu fans to kick into high gear
T 1709859371 18<20bent_fingers18>	any way to limit it's cpu consumption?
T 1709859375 18<20bent_fingers18>	its
T 1709859417 18<25OMGOMG18>	sleep occasionally
T 1709859436 18<25hleneto18>	nice cat /dev/urandom.
T 1709859567 18<27JAA18>	Use `pv --rate-limit`
T 1709859591 18<27JAA18>	Or something with a similar effect.
T 1709859769 18<25finsternis18>	could you please explain why when I execute this https://sprunge.us/6VNGh1  script with just  ./myscript.sh  it works, prints the last string "hello ${first_name}" and the  first_name variable is correctly initialized with the input I type, whereas if I execute with:  ./myscript | grep "foo" >> file.txt   it prints nothing, even if I pass the input string as well
T 1709859926 18<27larryv18>	finsternis: because all the output, including the prompt, gets filtered through grep into file.txt
T 1709859986 18<25finsternis18>	larryv: and is there a way to avoid this behaviour?
T 1709860019 18<29fb`18>	if you want to see the output on your terminal _and_ log to file.txt, you using something like `./script | tee -a file.txt`
T 1709860066 18<27larryv18>	finsternis: what do you expect to see printed to the terminal, exactly
T 1709860088 18<29fb`18>	grep can before or after the first pipe depending on what you want written to the file
T 1709860137 18<25finsternis18>	larryv: hello finsternis     if I type "finsternis" whan it's asking me to enter the first name
T 1709860186 18<27larryv18>	so you want the prompt and "hello [name]" to print to the terminal. in that case, what text do you want to end up in the file?
T 1709860187 18<25finsternis18>	to the file.txt it should write the matched string, so "foobar whatever hello world"
T 1709860277 18<27larryv18>	what if the name matches
T 1709860385 18<25finsternis18>	I thought grep would have worked only on the strings echoed before the input typed
T 1709860403 18<25ormaaj18>	bent_fingers: There's this new kind of monitor called an LCD. No burn in!
T 1709860412 18<27larryv18>	finsternis: it filters everything you print to stdout. which in your case is everything
T 1709860416 18<25ormaaj18>	should upgrade
T 1709860449 18<27larryv18>	finsternis: is some of this text should always go to the terminal and not to stdout, then you should specify which text that is
T 1709860451 18<27larryv18>	*if some
T 1709860487 18<25finsternis18>	larryv: it's not a problem if it matches also the name
T 1709860489 18<25ormaaj18>	actually that's a lie but that only happens if you have like a "smart billboard" that's displaying the same graphic 24/7 for years.
T 1709860576 18<27larryv18>	finsternis: it's weird that you don't seen to have a concrete idea of which output you want to go into the filtered file and which you don't
T 1709860590 18<25finsternis18>	in file.txt it already redirects what I want, the problem is that it doesn't execute the last command, that is  echo "hello ${first_name}"  so it doesn't print anything to stdout
T 1709860624 18<27larryv18>	it absolutely does execute that command. its output is filtered out by grep unless the name matches the pattern
T 1709860646 18<27larryv18>	again, it doesn't print to stdout because you are redirecting stdout into grep.
T 1709860742 18<25finsternis18>	larryv: doesn't seem to be right what you said..I tried to pass in input "foo", so that even name is matched, but I got nothing printed to stdout as well
T 1709860758 18<27larryv18>	it. is. going. through. grep
T 1709860761 18<27larryv18>	check file.txt
T 1709860767 18<25finsternis18>	only to the file
T 1709860778 18<25finsternis18>	yes, it's in the file now
T 1709860780 18<27larryv18>	yeah. because you redirected the output to the file.
T 1709860787 18<25finsternis18>	"hello foo"  too
T 1709860808 18<27larryv18>	this seems to be what you want https://paste.wooledge.org/29356
T 1709861005 18<25finsternis18>	larryv: yes, thanks
T 1709861009 18<19stability18>	if i use  ${rsyncprotonosparse:+--sparse} in a shell command then i can do rsyncprotonosparse=t mycommand, or just to mycommand, to control whether --sparse is included.  however, the sense is the opposite of what i want.  i tried ${rsyncprotonosparse:---sparse} but it does not have the opposite sense.
T 1709861075 18<19stability18>	is there a construct or a trick to getting the opposite sense, in which i can do rsyncprotonosparse=t mycommand to get no --sparse and mycommand to get --sparse?
T 1709861307 18<27larryv18>	not really. check for [[ -z $whatever ]] and construct the command as desired
T 1709861352 18<27larryv18>	e.g., args=(); if [[ -z $whatever ]]; then args+=(--sparse); fi; cmd "${args[@]}"
T 1709934726 19*	Now talking on 22#bash
T 1709934726 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709934726 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709935197 18<25ormaaj18>	I tried to make elgetpositionals in execline https://bpa.st/raw/V24A
T 1709935224 18<25ormaaj18>	I can't get it to handle whitespace D:<
T 1709935250 18<25ormaaj18>	I typed it into a bash shell so this is a bash question.
T 1709935252 18<27JAA18>	ormaash when?
T 1709935268 18<25ormaaj18>	:D
T 1709935304 18<25ormaaj18>	when I clone myself. clone will write it.
T 1709935354 18<27JAA18>	:-)
T 1709935463 19*	Now talking on 22#bash
T 1709935463 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709935463 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709935633 19*	Now talking on 22#bash
T 1709935633 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709935633 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709935661 18<25ormaaj18>	I think the whole approach is wrong. I'll have to do something like make rewrite each argument as a block and encode them that way
T 1709935678 18<28emanuele618>	it should be something like    multisubstitute { define _x x define _y y } multisubstitute { define x $_x define y $_y define z $_x$_x define w $_y$_y } cmd $x $y $z $w
T 1709936054 19*	Now talking on 22#bash
T 1709936054 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709936054 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709936056 18<25ormaaj18>	yeah I didn't use backtick -E, it waits to expand that
T 1709936141 18<25ormaaj18>	it's the sed injecting the escape that cannot work properly
T 1709936158 18<28emanuele618>	i understand what it is doing now
T 1709966630 19*	Now talking on 22#bash
T 1709966630 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709966630 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709968315 18<25Lynx-18>	ano thank you for your input earlier concerning truncation
T 1709969040 19*	Now talking on 22#bash
T 1709969040 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709969040 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709971806 18<24Aryan18>	Hi!
T 1709971826 18<24Aryan18>	why escape characters get removed in 2 and 3 ? https://paste.rs/5Kb3J.txt
T 1709971830 18<22evaloop18>	hola
T 1709971980 18<26lopid18>	perhaps you need read -r
T 1709972038 18<24Aryan18>	let me see
T 1709972123 18<24Aryan18>	thank you
T 1709975301 19*	Now talking on 22#bash
T 1709975301 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709975301 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709975561 19*	Now talking on 22#bash
T 1709975561 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709975561 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709978956 19*	Now talking on 22#bash
T 1709978956 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709978956 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709980395 19*	Now talking on 22#bash
T 1709980395 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709980395 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709985712 18<26hozgento18>	I am not sure why i am getting this error: https://bpa.st/6LBA
T 1709985849 18<26hozgento18>	is it the correct way to pass the parameters inside a function?
T 1709986048 18<26hozgento18>	and it worked fine if i copy&paste the args from the printed error and pass them to qemu-system-x86_64
T 1709986332 18<26hozgento18>	s/if/when
T 1709986657 18<24geirha18>	!faq complex
T 1709986658 18<29greybot18>	https://mywiki.wooledge.org/BashFAQ/050 -- I'm trying to put a command in a variable, but the complex cases always fail!
T 1709986672 18<24geirha18>	correct way is to use an array
T 1709986693 18<24geirha18>	qemu_args=(
T 1709986696 18<24geirha18>	  --enable-kvm
T 1709986700 18<24geirha18>	  --boot "$boot"
T 1709986706 18<24geirha18>	)
T 1709986721 18<25ormaaj18>	^
T 1709986724 18<24geirha18>	qemu-system-x86_64 "${qemu_args[@]}" "$@"
T 1709986736 18<25ormaaj18>	sorry :)
T 1709986856 18<24geirha18>	as a bonus, you can have comments within the array assignment, so it's easy to comment in/out options
T 1709987166 18<26hozgento18>	geirha: qemu-system-x86_64: -drive file=/home/x/vms/artix.img,format=raw: invalid option
T 1709987201 18<26hozgento18>	now it doesn't pass any args to qmeu-system-x86_64
T 1709987204 18<24geirha18>	sounds like you put the option and option argument into the same argument
T 1709987233 18<24geirha18>	maybe you typoed the variable name?
T 1709987255 18<26hozgento18>	https://bpa.st/ZTIQ
T 1709987278 18<24geirha18>	!check
T 1709987279 18<28checkbot18>	geirha: Looks good to me
T 1709987374 18<24geirha18>	looks correct. Run it with xtrace enabled to see what's going on;  set -x
T 1709987375 18<24geirha18>	!-x
T 1709987375 18<29greybot18>	set -x (or ''bash -x myscript'') makes bash output the exact command that it will run after parsing and expansion. You can put ''set -x'' just before the code you want to debug (turn off with ''set +x''). To add more information, change PS4 first: eg. PS4='+($?) $BASH_SOURCE:$FUNCNAME:$LINENO:'
T 1709987470 FiSHLiM plugin unloaded
T 1709988023 19*	Now talking on 22#bash
T 1709988023 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709988023 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709988032 18<24geirha18>	and depending on how this is meant to be used, you may want to validate that img_path contains a value that is safe to be embedded inside that -drive argument
T 1709988057 18<24geirha18>	e.g. if it contains comma, it may fail, or do something unintentional
T 1709988167 18<26hozgento18>	geirha: i think it works now, thank you so much
T 1709988196 18<24geirha18>	If you want to learn why your earlier attempts fail, I recommend reading https://mywiki.wooledge.org/Arguments
T 1709988243 18<26hozgento18>	ah thanks, will definitely read that
T 1709988269 18<26hozgento18>	re: e.g. if it contains comma, it may fail, or do something unintentional
T 1709988317 18<26hozgento18>	in this case what would be the solution ?
T 1709988343 18<28aesthetics18>	one should make a book from that wiki, and sell it
T 1709988364 18<25danza18>	probably already done
T 1709988374 18<26hozgento18>	because i think it has this problem now: DISPLAY="sdl,grab-mod=rctrl" the qemu works fine now but it seems like it doesn't recognize the display arg
T 1709988545 18<24geirha18>	if [[ $img_path = *[![:alnum:]/._-]* ]] ; then printf >&2 'image path should only consist of alphanumerics, slash, dot, underscore and hyphen: %s\n' "$img_path" ; exit 1 ; fi   # is one way. Just checking against a whitelist or characters
T 1709988592 18<24geirha18>	hozgento: Well, another issue with your code is the use of uppercase variable names. It's best avoided
T 1709988596 18<24geirha18>	!varcap
T 1709988596 18<29greybot18>	By convention, environment variables (PATH, EDITOR, SHELL, ...) and internal shell variables (BASH_VERSION, RANDOM, ...) are fully capitalized. All other variable names should be lowercase. Since variable names are case-sensitive, this convention avoids accidentally overriding environmental and internal variables. https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap08.html
T 1709988628 18<24geirha18>	DISPLAY happens to be an environment variable that tells X programs where they can find the X server, and you've overridden it with "garbage"
T 1709988710 18<26hozgento18>	ah interesting, thank you. i think i read it somewhere that the global vars should be in uppercase. total derp
T 1709988721 18<24geirha18>	!crap
T 1709988721 18<29greybot18>	The overwhelming majority of bash scripts, code, tutorials, and guides on the Internet are crap. Sturgeon was an optimist.
T 1709988745 18<26hozgento18>	lol agree
T 1709989119 18<24cheater18>	i'm doing some data recovery. i'm using grep -oba to find a string in a block device. i'm looking for the string "Profile = {". I know a file with this string exists on that block device (i just mounted it and checked). I know i'm selecting the right block device. however, grep isn't finding it. why isn't grep finding it?
T 1709989195 18<24cheater18>	and, can i use something other than grep?
T 1709989196 18<25ormaaj18>	grep isn't good for searching through binary garbage
T 1709989234 18<24cheater18>	i'm open to suggestions
T 1709989311 18<24cheater18>	the command i'm using is literally just `grep -oba 'Profile = {' /dev/nvme0n1p8 | tee -a found.log`
T 1709989335 18<25ormaaj18>	is it unencrypted and uncompressed
T 1709989342 18<25ormaaj18>	what filesystem
T 1709989344 18<25ormaaj18>	raid?
T 1709989349 18<25ormaaj18>	too many factors
T 1709989386 18<24cheater18>	none of that.
T 1709989394 18<24cheater18>	and the block device is fully healthy. i'm just trying to recover a file that was truncated by a program that crashed because the programmers are lamers
T 1709989399 18<24cheater18>	it's ext4
T 1709989413 18<25ormaaj18>	mount the device read-only
T 1709989419 18<26hozgento18>	geirha: works now as expected here is the full script: https://bpa.st/OEJA, thanks!
T 1709989427 18<24cheater18>	it's unmounted
T 1709989429 18<24cheater18>	it doesn't matter
T 1709989434 18<24cheater18>	it finds other strings, but not this one
T 1709989455 18<25ormaaj18>	trying to fish that out of a raw block device is insane
T 1709989638 18<24cheater18>	ok i don't think you know what you're talking about
T 1709989654 18<24cheater18>	maybe just don't talk if you're going to come up with bs like that thank you
T 1709989668 18<25ormaaj18>	lol
T 1709989701 18<25ormaaj18>	i'm not the idiot grepping through a block device for a random string
T 1709989895 18<28emanuele618>	lol  sudo grep -oba grep /dev/sda
T 1709990059 18<28emanuele618>	i tried   sudo grep -coba creatememfd /dev/sda   but i had to stop it because it was taking too long
T 1709990079 18<28emanuele618>	anyway many many thousands :o
T 1709990137 18<24cheater18>	it takes 15 minutes to scan the whole drive
T 1709990139 18<24cheater18>	so what?
T 1709990142 18<24cheater18>	that's not the fucking problem
T 1709990336 18<24cheater18>	there we fucking go, it actually found something. what do you know
T 1709990345 18<24cheater18>	wonder why it didn't previously
T 1709990356 18<25ormaaj18>	grep would likely tell them whether it's there. I'd use LC_CTYPE=C and probably just look for the offset. Wouldn't attempt to actually get the data back that way
T 1709990518 18<24cheater18>	actually i'm doing this to get the data back while read i; do skip="$(python3 -c "print($i//1024)")"; dd if=/dev/nvme0n1p8 of="$i".found bs=1K count=102 skip="$skip"; done < <(cat ../found.log | grep 'Profile = {' | cut -f1 -d:)
T 1709990559 18<25ormaaj18>	good grief
T 1709990590 18<28emanuele618>	you don't need to use CTYPE=C; -ob is enough
T 1709990607 18<24cheater18>	hell yea i found the data
T 1709990609 18<24cheater18>	it's great
T 1709990614 18<28emanuele618>	hell ye
T 1709990785 18<25ormaaj18>	maybe grep is better than bash. I don't trust random gnu tools to decode strings properly
T 1709990922 18<24cheater18>	there's nothing to "decode" here.
T 1709990926 18<24cheater18>	it's just ascii.
T 1709990943 18<28emanuele618>	i trust GNU grep grep -Paboe "$thing"\\x00   to give me the right offsets to hax:D
T 1709991048 18<25ormaaj18>	yeah they like to decode things whether you like it or not is the problem
T 1709991215 19*	Now talking on 22#bash
T 1709991215 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709991215 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709991237 18<28emanuele618>	-b will always give you a byte offset, not a character offset
T 1709991256 18<25ormaaj18>	ah
T 1709991389 18<25ormaaj18>	well it might give you a byte offset, i'm more concerned about the searching than getting back a wrong offset
T 1709991415 18<24cheater18>	you don't need to use -P
T 1709991432 18<24cheater18>	not for what i'm doing
T 1709991518 18<28emanuele618>	if the pattern is ascii, there is no way it can match it incorrectly
T 1709991638 18<25ormaaj18>	really? does it switch to searching bytes if the pattern looks like ascii?
T 1709991680 18<28emanuele618>	but also if it is utf-8 i think; because a utf-8 sequence always starts with 110xxxx 1110xxxx 11110xxx 111110xx or 1111110x followed by one or more 10xxxxxx   so if there is a valid utf-8 sequence it can always match it, because it would error at the first byte
T 1709991723 18<28emanuele618>	you would probably only need to set LC_ALL=C if you want to match something like -P '\x80\x80\x81'
T 1709991754 18<28emanuele618>	ormaaj: what do you mean?
T 1709991828 18<25ormaaj18>	what do you mean error at the first byte? :o
T 1709991842 18<28emanuele618>	actually \x80 \x80 is a bad example; i think it could even work if you don't set LC_ALL=C
T 1709991916 18<28emanuele618>	ormaaj: to look a character string, you use a function that given a string, tells you how long the next character is, and what its codepoint is
T 1709991927 18<28emanuele618>	s/look/loop/
T 1709992008 18<28emanuele618>	if you have an invalid utf-8 byte followed by a valid utf-8 sequence, it will still match it correctly, because it will recognise the invalid as one invalid byte, followed by the utf-8 sequence, there is nothing that makes it not work
T 1709992096 18<28emanuele618>	e.g. if you have  \xc3\xa8\x20\x73\x61\x62\x61\x74\x6f\x0a    grep will scan the string looking for 'è s'
T 1709992102 18<28emanuele618>	err
T 1709992117 18<28emanuele618>	e.g. if you have  \x80\xc3\xa8\x20\x73\x61\x62\x61\x74\x6f\x0a    and grep is scanning the string looking for 'è s'
T 1709992160 18<28emanuele618>	the first character is \x80 that is an invalid with value 0x80, of length one byte; it is not 'è', so grep keeps looking
T 1709992202 18<28emanuele618>	now it has    \xc3\xa8\x20\x73\x61\x62\x61\x74\x6f\x0a    (because it shifted 1 byte), and the next character is  \xc3\xa8  that is è, and is long two bytes
T 1709992260 18<28emanuele618>	then it shifts 2, it has \x20\x73\x61\x62\x61\x74\x6f\x0a, and the first character is \x20 that is ' ' one byte, then the next character is \x73 that is 's' so you have a match
T 1709992336 18<28emanuele618>	an invalid byte in the file can never corrupt a following valid utf-8 sequence, or ascii character, because an invalid utf-8 can never contain a byte that could be part of a following valid utf-8 sequence
T 1709992478 18<25ormaaj18>	110xxxxx
T 1709992550 18<28emanuele618>	if you have  abc   and  ab is a invalid seqeunce, e.g. \xf8\xbc  that is invalid because \xf8 can only introduce a five byte utf-8 sequence  it is never possible that bc is valid because \xbc can never start a valid utf-8 sequence and it is not an ascii value
T 1709992598 18<28emanuele618>	you can always figure a utf-8 sequence is invalid before it overlaps a valid utf-8 sequence
T 1709992690 18<28emanuele618>	so whatever literal string you search it should always be fine even if you don't use C locale. the only reason you might want to do that is if you want . in  'a.\{12\}b'   to match 12 bytes and not 12 characters/invalid bytes
T 1709992773 18<28emanuele618>	hmm, actually, i think the BRE engine skips invalids, i don't remember, so .{12} may not work in any locale if you want 12 arbitrary bytes that could be >7f, anyway, for substrings, it is fine
T 1709993006 18<25ormaaj18>	heh yeah i never use the bre really
T 1709993022 18<22axet18>	hello! can I get linux CPU load average past minute / 5 mins? sesms proc/loadavg only show tasks not CPU
T 1709993424 18<28emanuele618>	i remember that sed does something weird with invalid sequences and ., but maybe it is sed specific; iirc sed has its own engine
T 1709993464 18<25ormaaj18>	if the top bit is zero it's one byte?
T 1709993501 18<28emanuele618>	if the top bit is zero, it is an ascii value (0x00-0x7f) so it is a one-byte character, yeah
T 1709993526 18<28emanuele618>	# sed 's/./a/g' <<< $'f\x80\xf9\xbcè' | od -An -c
T 1709993529 18<25shbot18>	emanuele6:    a   a   a   a   a   a  \n
T 1709993540 18<28emanuele618>	oh, in C locale, it does not do the weird thing
T 1709993548 18<28emanuele618>	# LC_ALL=en_US.utf-8 sed 's/./a/g' <<< $'f\x80\xf9\xbcè' | od -An -c
T 1709993551 18<25shbot18>	emanuele6:    a 200 371 274   a  \n
T 1709993557 18<28emanuele618>	# LC_ALL=en_US.utf-8 sed 's/../a/g' <<< $'f\x80\xf9\xbcè' | od -An -c
T 1709993559 18<25shbot18>	emanuele6:    f 200 371 274 303 250  \n
T 1709993625 18<28emanuele618>	yeah, so . only matches valid characters, there it does not match fè or $'f\x80' because $'\x80' is an invalid, and invalids are not skipped, they just cannot match .
T 1709993629 18<28emanuele618>	# LC_ALL=en_US.utf-8 sed 's/.\x80/a/g' <<< $'f\x80\xf9\xbcè' | od -An -c
T 1709993631 18<25shbot18>	emanuele6:    a 371 274 303 250  \n
T 1709993638 18<28emanuele618>	it cannot match \x80 either
T 1709993668 18<28emanuele618>	GNU sed has \xXX (at least i know it has \x00)
T 1709993693 18<28emanuele618>	# LC_ALL=en_US.utf-8 grep -o '..' <<< $'f\x80\xf9\xbcè' | od -An -c
T 1709993695 18<25shbot18>	emanuele6: no output
T 1709993711 18<28emanuele618>	it is the same in grep . will not match an invalid
T 1709993716 18<28emanuele618>	# grep -o '..' <<< $'f\x80\xf9\xbcè' | od -An -c
T 1709993718 18<25shbot18>	emanuele6:    f 200  \n 371 274  \n 303 250  \n
T 1709993752 18<28emanuele618>	but in C locale, it does match it; so you can use   LC_ALL=C grep -ob 'a.{12}b'   to match a and b with 12 bytes in-between, yeah
T 1709993762 18<28emanuele618>	# grep -o '..' <<< $'f\x80\xf9\xbcèx' | od -An -c
T 1709993764 18<25shbot18>	emanuele6:    f 200  \n 371 274  \n 303 250  \n
T 1709993782 18<28emanuele618>	oops, forgot LC_ALL=
T 1709993792 18<28emanuele618>	# LC_ALL=en_US.utf-8 grep -o '..' <<< $'f\x80\xf9\xbcèx' | od -An -c
T 1709993793 18<25shbot18>	emanuele6:  303 250   x  \n
T 1709993813 18<28emanuele618>	# LC_ALL=en_US.utf-8 grep -o $'.\x80' <<< $'f\x80\xf9\xbcè' | od -An -c
T 1709993815 18<25shbot18>	emanuele6:    B   i   n   a   r   y       f   i   l   e       (   s   t   a
T 1709993815 18<25shbot18>	emanuele6:    n   d   a   r   d       i   n   p   u   t   )       m   a   t
T 1709993815 18<25shbot18>	emanuele6:    c   h   e   s  \n
T 1709993826 18<28emanuele618>	# LC_ALL=en_US.utf-8 grep -ao $'.\x80' <<< $'f\x80\xf9\xbcè' | od -An -c
T 1709993828 18<25shbot18>	emanuele6:    f 200  \n
T 1709993842 18<28emanuele618>	if you use $'.\x80' \x80 will match the invalid \x80
T 1709993856 18<28emanuele618>	# LC_ALL=en_US.utf-8 grep -a $'.\x80.' <<< $'f\x80è' | od -An -c
T 1709993858 18<25shbot18>	emanuele6:    f 200 303 250  \n
T 1709993869 18<28emanuele618>	also in the middle of the string
T 1709993904 18<28emanuele618>	. matches any "valid" character then; not any "character" :)
T 1709993928 18<28emanuele618>	# LC_ALL=en_US.utf-8 sed $'s/.\x80/a/g' <<< $'f\x80\xf9\xbcè' | od -An -c
T 1709993929 18<25shbot18>	emanuele6:    a 371 274 303 250  \n
T 1709993948 18<28emanuele618>	in GNU sed it works if you use $'\x80', but not if you use \x80 :o
T 1709993996 18<28emanuele618>	oh, maybe the GNU sed on shbot does not have \xXX support; on my PC it works with GNU sed 4.9
T 1709994141 18<28emanuele618>	it's the same with PCRE
T 1709994161 18<28emanuele618>	and ERE; . only matches valid characters
T 1709994247 18<28emanuele618>	in perl; a\x80b matches a.b just fine
T 1709994253 18<28emanuele618>	$ perl -E 'say "a\x80b" =~ /a.b/'
T 1709994255 18<28emanuele618>	1
T 1709994436 18<28emanuele618>	s/matched/is matched by/
T 1709994606 18<27mingdao18>	emanuele6: You abuse the hell out of this bot!
T 1709994631 18<27mingdao18>	Maybe /query shbot or something to keep from polluting the channel.  :^)
T 1709994908 18<28emanuele618>	mingdao: heh? you think that makes sense?
T 1709994962 18<28emanuele618>	i can just use my terminal if i want to see what a command does; i use shbot to show it to the channel.
T 1709995168 18<27mingdao18>	Aren't you special.  :^)
T 1709995628 18<19randomhero18>	bbbbbbbbbbbbbbbutthurt
T 1709995665 18<19randomhero18>	should have old quake multi-kill sound bites playing when he shows things using the shbot :-)
T 1709996379 18<22FakuVe18>	Hi there , I am in a quick need. Does anyone know how to sort an associative array by its keys alphabetically
T 1709997214 18<24ano18>	FakuVe: bash assoc arrays unsorted by design, there is no way to sort them
T 1709997517 18<22FakuVe18>	There has to be a way , algorithmicaly
T 1709997832 18<24ano18>	# declare -A assoc=([charlie]=x-ray [alfa]=zulu [bravo]=yankee); while IFS= read -rd '' key; do printf {%s} "$key"; done < <(printf %s\\0 "${!assoc[@]}" | sort -z)
T 1709997833 18<25shbot18>	ano: {alfa}{bravo}{charlie}
T 1709998036 18<22FakuVe18>	Ok
T 1709998047 18<22FakuVe18>	So you do it at the creation of the array
T 1709998123 18<24ano18>	FakuVe: nope, that's how read sorted via unportable (sort -z) assoc array keys one by one
T 1709998144 18<22FakuVe18>	Sorry for my hard understanding
T 1709998214 18<24ano18>	FakuVe: what are u trying to achieve, can u show some real example?
T 1709998228 18<22FakuVe18>	I need thisone to be sorted by keys
T 1709998230 18<22FakuVe18>	https://termbin.com/iebmy
T 1709998251 18<22FakuVe18>	Basically thats why I am using an associative array, so I can operate correctly with this kind of operations
T 1709998301 18<24ano18>	!check https://termbin.com/iebmy > FakuVe
T 1709998302 18<28checkbot18>	ano: Looks good to me
T 1709998324 18<24ano18>	!check https://termbin.com/iebmy
T 1709998325 18<28checkbot18>	ano: Line 1: Quote the parameter to -name so the shell won't interpret it. Line 1: Use ./*glob* or -- *glob* so names with dashes won't become options. Line 12: Double quote to prevent globbing and word splitting. See https://shellcheck.net/?id=cb98325 for all 6 issues.
T 1709998372 18<22FakuVe18>	buf
T 1709998566 18<22FakuVe18>	Ok I get
T 1709998584 18<22FakuVe18>	I get it . I will modify it for this globbing , basically quote all of them variables
T 1709998587 18<22FakuVe18>	But
T 1709998596 18<22FakuVe18>	Is there a way to sort this?
T 1709998605 18<22FakuVe18>	by their keys?
T 1709998633 18<24ano18>	>bash assoc arrays unsorted by design, there is no way to sort them
T 1709998708 18<22FakuVe18>	There has to be a way
T 1709998715 18<22FakuVe18>	Algorithmically
T 1709998723 18<22FakuVe18>	Or creating a new array
T 1709998725 18<22FakuVe18>	ordered
T 1709998759 18<22FakuVe18>	I see this
T 1709998761 18<22FakuVe18>	https://www.reddit.com/r/bash/comments/5wma5k/is_there_a_way_to_sort_an_associative_array_by/
T 1709998763 18<22FakuVe18>	Is not working for me
T 1709998773 18<22FakuVe18>	Is messing with the order in a different way
T 1709999096 18<25Lynx-18>	ano I understand that there is some saving by employing a file descriptor with file held open rather than >> inside while loop. Is there a similar kind of saving in respect of reading from a file inside a while loop? I am thinking specifically of reading from rx_bytes and tx_bytes "/sys/class/net/${dl_if}/statistics/tx_bytes"
T 1709999179 18<25Lynx-18>	And thanks for your input yesterday regarding the file descriptor / truncation issue. I managed to shave a few percent in CPU run time by switching to buffered reads and using file descriptor.
T 1709999324 18<24ano18>	FakuVe: if u mean KnowsBash solution, it doesn't sort assoc array itself but put sorted assoc array keys in new indexed array, u can then iterate over that "${sorted[@]}" indexed array
T 1709999502 18<22FakuVe18>	yeah I have discovered it
T 1709999525 18<22FakuVe18>	printf "%s\n" "${!colors[@]}" | sort -t = -k 1
T 1709999529 18<22FakuVe18>	oops sorry
T 1709999534 18<22FakuVe18>	mapfile -t sorted_links_to_paths < <(printf "%s\n" "${!links_to_paths[@]}" | sort -t = -k 1)
T 1709999549 18<22FakuVe18>	Then you need to iterate through this array , and use the associativbe array accordingly
T 1709999583 18<22phogg18>	that's the normal way to sort a hash in any language
T 1709999692 18<22FakuVe18>	good to know hehe
T 1710000528 18<24ano18>	Lynx-: /sys is sysfs is pseudo fs, doubt there is a way to keep it open and continuously read somehow, afaik such files should be reopened every time per read
T 1710000862 18<22FakuVe18>	That is amazing mio brother
T 1710001915 18<29nvz18>	Lynx-: yes sysfs is different than a normal filesystem in that it allows userland access to kernel space data, when you read from userland the kernel is creating a buffer and transferring kernel space data into userspace and I'm not intimately familiar but I believe its more a one-shot thing done when openeing and reading, so if you want to poll, you need to continually reopen the file
T 1710001949 18<29nvz18>	Lynx-: however if you're programming around it, you can likely use a library designed for sysfs rather than accessing it through the filesystem like its a normal file
T 1710002059 18<25Lynx-18>	don't suppose any of you know about file recovery in ubifs?
T 1710002062 18<29nvz18>	Lynx-: these sorts of memory-backed "filesystems" are essentially created on the fly and don't have a similar persistent state like normal files
T 1710002114 18<25Lynx-18>	I wrote over file in error and wondering if I can recover it. I have the UBI mtdblock file
T 1710007285 18<25ormaaj18>	!m
T 1710007285 18<29greybot18>	🐄
T 1710007549 18<28emanuele618>	!o
T 1710007549 18<29greybot18>	🐮
T 1710007629 18<28emanuele618>	à
T 1710009283 22*	26ChanServ gives channel operator status to 18geirha
T 1710009287 22*	26geirha sets ban on 18docmax*!*docmax@*$##fix_your_connection
T 1710009287 22*	26geirha removes ban on 18golu*!*golu@*$##fix_your_connection
T 1710009287 22*	26geirha removes channel operator status from 18geirha
T 1710009495 18<20bent_fingers18>	# echo -e "\x00" | sed 's/\x00/+/'
T 1710009497 18<25shbot18>	bent_fingers: +
T 1710010168 18<20no_gravity18>	Any downside to mapping "grep" to "grep -P"? I think I would always want PCRE. Or am I missing something?
T 1710010196 18<20bent_fingers18>	youre choice
T 1710010210 18<20bent_fingers18>	you mean with an alias?
T 1710010276 18<20no_gravity18>	Yup
T 1710010288 18<20bent_fingers18>	then it's fine
T 1710010307 18<20no_gravity18>	For ls for example I use: alias ls='ls -Alhv --color --time-style=long-iso --group-directories-first'
T 1710010329 18<20twkm18>	you might be surprised if you copy&paste suggestions without translating a bre to pcre.
T 1710010338 18<20no_gravity18>	True
T 1710010347 18<26lopid18>	might as well use pcregrep or pcre2grep
T 1710010363 18<20bent_fingers18>	the man page says treating null data `-z` is experimental with grep -P
T 1710010368 18<20no_gravity18>	lopid: Any benefit of doing that?
T 1710010396 18<26lopid18>	grep -P, "this option is experimental"
T 1710010422 18<26lopid18>	little doubt the proper one has better support
T 1710010481 18<24geirha18>	I vote for "grepp"
T 1710010503 18<20no_gravity18>	How about "preg"?
T 1710010664 18<24geirha18>	greÞ
T 1710010703 18<27JAA18>	PCRE is also significantly slower than the other options in grep. And you wouldn't be able to override it directly, you'd have to use `\grep -F` to bypass the alias.
T 1710010784 18<27JAA18>	From the now-deprecated `fgrep` and `egrep`, it should be `pgrep`, but that's another thing already. :-/
T 1710010867 18<20no_gravity18>	# time for i in {1..1000}; do echo $RANDOM | grep 123; done
T 1710010874 18<25shbot18>	no_gravity: no output within the time limit
T 1710010882 18<20no_gravity18>	2.068s here
T 1710010889 18<20no_gravity18>	# time for i in {1..1000}; do echo $RANDOM | grep -P 123; done
T 1710010896 18<25shbot18>	no_gravity: 12347
T 1710010908 18<20no_gravity18>	2.133s here
T 1710010909 18<27JAA18>	That's going to be dominated by the loop and forking and grep startup.
T 1710010930 18<20no_gravity18>	# time for i in {1..100}; do echo $RANDOM | grep 123; done
T 1710010937 18<25shbot18>	no_gravity: no output within the time limit
T 1710010944 18<20no_gravity18>	# time for i in {1..100}; do echo $RANDOM | grep -P 123; done
T 1710010950 18<25shbot18>	no_gravity: no output within the time limit
T 1710010963 18<20no_gravity18>	shbot can't do 100 greps?
T 1710010967 18<27JAA18>	Try something like `time seq 10000000 | grep -P 123 | cat >/dev/null`. (The `cat` is needed at least with GNU grep.)
T 1710011012 18<20no_gravity18>	JAA: 0.276s
T 1710011021 18<27JAA18>	-P takes about 4 times as long as -F here.
T 1710011027 18<20no_gravity18>	0.081s without the P
T 1710011030 18<20no_gravity18>	Yeah
T 1710011030 18<28emanuele618>	cat is needed for what?
T 1710011036 18<27JAA18>	No option and -E are between.
T 1710011056 18<28emanuele618>	cat just makes it run slower for me
T 1710011072 18<20no_gravity18>	But 10M greps in 0.3s is still fast.
T 1710011075 18<27JAA18>	emanuele6: For an accurate time measurement. It appears that GNU grep has some optimisation when you redirect to /dev/null, so you get a much faster time than it would actually take in a real setting.
T 1710011116 18<20no_gravity18>	Real setting: time seq 10000000 | grep -P 123 | wc
T 1710011121 18<20no_gravity18>	0.279s
T 1710011129 18<20no_gravity18>	0.081s without the P
T 1710011139 18<20no_gravity18>	So the /dev/null seems to have no impact.
T 1710011149 18<28emanuele618>	 $ printf %s\\n '' 'foo' | strace -qqewrite -efd=1 grep foo >/dev/null
T 1710011153 18<28emanuele618>	nothing at all
T 1710011155 18<28emanuele618>	vov
T 1710011197 18<20no_gravity18>	time seq 10000000 | grep -P '^1.*2$' | wc
T 1710011199 18<27JAA18>	I wonder if it just activates -q quietly.
T 1710011206 18<20no_gravity18>	0.308s
T 1710011213 18<20no_gravity18>	Holy cow that thing is fast.
T 1710011264 18<27JAA18>	The /dev/null thing matters more when your processing takes a while. 0.3 s is probably too short to see much of a difference.
T 1710011266 18<28emanuele618>	JAA: -q would change the behaviour of the command, it probably just consumes the input after the first match though
T 1710011282 18<27JAA18>	Ah, yeah.
T 1710011295 18<27JAA18>	`exec cat` :-)
T 1710011327 18<28emanuele618>	to save writes, you run a program that writes after every read with no buffering? :o
T 1710011416 18<27JAA18>	`time seq 100000000 | grep 1 >/dev/null` = 0.8 seconds, `time seq 100000000 | grep 1 | cat >/dev/null` = 4.3 seconds
T 1710011425 18<27JAA18>	That's more like it.
T 1710011442 18<27JAA18>	I've seen an order of magnitude before, too.
T 1710011503 18<20no_gravity18>	Ok, thanks for the infos! Cu!
T 1710011538 18<28emanuele618>	time seq 100000000 | grep 1 >/dev/null = 1.2s   time seq 100000000 | grep 1 | cat >/dev/null = 6.2s
T 1710011554 18<28emanuele618>	time seq 100000000 | grep -q 1 = 0.007s :)
T 1710011648 18<27JAA18>	:-)
T 1710012277 18<28emanuele618>	cat does not optimise >/dev/null
T 1710012281 18<28emanuele618>	:\
T 1710012334 18<28emanuele618>	i guess you can use  sed -n ''  as more efficient  cat >/dev/null
T 1710012365 18<29phy172918>	!uuoc
T 1710012365 18<29greybot18>	Useless Use Of Cat (cat foo | grep bar). See https://mywiki.wooledge.org/BashFAQ/119 and http://www.iki.fi/era/unix/award.html#cat
T 1710012424 18<28emanuele618>	or  grep ^  :o
T 1710013741 18<20bent_fingers18>	emanuele6: cat is needed to reverse tac
T 1710013865 18<28emanuele618>	need a positive to cancel a negative as they say
T 1710022914 18<24cart18>	Is there a tool that adds a specific string to a specific line of a text file and shifts the rest of the strings down one line?
T 1710022971 18<27xx18>	sed?
T 1710022979 18<27koollman18>	yes, sed could do that. the syntax is not really intuitive, but it works
T 1710023087 18<27koollman18>	cart: (echo foo; echo bar; echo baz; echo quux) | sed '3i hello'
T 1710023137 18<27koollman18>	(works also with a instead of i, to add after rather than before)
T 1710023171 18<27JAA18>	I'd probably do it with AWK if only because my brain refuses to understand sed's syntax beyond simple substitute.
T 1710023185 18<24cart18>	koollman: Ok wait what does that do? add echo foo \n echo bax \n echo quux \n  ?
T 1710023205 18<20bent_fingers18>	there's no way to change the default regextype of `find` so that it only has to be set once for all instances?
T 1710023207 18<24cart18>	koollman: Ohh nvm I just ran it
T 1710023227 18<20bent_fingers18>	cart: sed
T 1710023325 18<20bent_fingers18>	i suppose i could use fd
T 1710023405 18<24cart18>	koollman: Ok so how do I use sed on a file?
T 1710023422 18<28bprompt18>	cart:    3i, for before line 3, and 3a for after it
T 1710023464 18<20bent_fingers18>	sed 'do stuff' file
T 1710023465 18<27JAA18>	# printf '%s\n' foo bar >file; sed '2i ohai'; paste - - - <file
T 1710023472 18<25shbot18>	JAA: no output within the time limit
T 1710023478 18<27JAA18>	ಠ_ಠ
T 1710023496 18<27JAA18>	Oh
T 1710023497 18<20bent_fingers18>	cart: https://www.grymoire.com/Unix/Sed.html#uh-0
T 1710023501 18<28bprompt18>	heheh
T 1710023503 18<27JAA18>	# printf '%s\n' foo bar >file; sed -i '2i ohai' file; paste - - - <file
T 1710023506 18<25shbot18>	JAA: foo     ohai    bar
T 1710023508 18<20bent_fingers18>	cart: https://www.pement.org/sed/sedfaq.html
T 1710023516 18<27JAA18>	It would help to use sed correctly.
T 1710023527 18<28emanuele618>	( ͡° ͜ʖ ͡°)
T 1710023543 18<20bent_fingers18>	haha
T 1710023559 18<28bprompt18>	cart:  pretty much that command, just simply append the filename
T 1710023593 18<27JAA18>	And, in the command I showed, -i for inplace editing, although you'll probably want to specify a backup suffix.
T 1710023595 18<27koollman18>	as show by others, -i to modify the file, and you can even use -i.bak to also create a backup named file.bak (often a good idea)
T 1710023604 18<27JAA18>	Heh
T 1710023619 18<27koollman18>	and don't do stuff like sed < file > file ... because then you have lost your file content :)
T 1710023647 18<20bent_fingers18>	is the ability for `.` to match a null in regex generally favorable over not matching a null?
T 1710023658 18<27JAA18>	What's a 'null'?
T 1710023665 18<27larryv18>	NUL, presumably
T 1710023670 18<27JAA18>	Ah, yeah
T 1710023671 18<20bent_fingers18>	so many regex types, dunno which to use
T 1710023679 18<20houseparty18>	sed
T 1710023682 18<28emanuele618>	vim regexps are best
T 1710023691 18<27JAA18>	I like PCRE-ish.
T 1710023693 18<28emanuele618>	it has funny sequences like \@<=
T 1710023696 18<20bent_fingers18>	the gnu docs use the locution "null character"
T 1710023700 18<28bprompt18>	yeap, Perl is Da Bomb
T 1710023703 18<20houseparty18>	She sed he wears short shorts
T 1710023711 18<27koollman18>	bent_fingers: 'it depends'
T 1710023715 18<28emanuele618>	that is (?<=) but you use it backwards
T 1710023730 18<27JAA18>	Lookarounds are awesome.
T 1710023741 18<27JAA18>	My favourite are nested negative lookarounds. :-)
T 1710023746 18<20bent_fingers18>	i know they are
T 1710023747 18<28emanuele618>	\(abc\)\@<=  for  (?<=abc)
T 1710023760 18<27JAA18>	Too many backslashes >:-(
T 1710023799 18<24cart18>	Basically something like     printf '%s\n' libparted/arch/linux.c >file; sed -i '3i #include <sys/sysmacros.h>' file; paste - - - <file
T 1710023801 18<28emanuele618>	\v([[)@<=
T 1710023808 18<28emanuele618>	too few backslashes?
T 1710023815 18<24cart18>	I want it to replace the file -> libparted/arch/linux.c
T 1710023823 18<25vanfanel6418>	I noticed that bash allows redefining fuctions, with no warning or anything:
T 1710023824 18<25vanfanel6418>	# foo() { echo ABC; }; foo; foo() { echo DEF; }; foo;
T 1710023826 18<25shbot18>	vanfanel64: ABC
T 1710023826 18<25shbot18>	vanfanel64: DEF
T 1710023839 18<27larryv18>	cart: the paste command was just for demonstration
T 1710023841 18<25vanfanel6418>	Is there a way to make it warn?
T 1710023843 18<28emanuele618>	i meant  \v(abc)@<=
T 1710023850 18<25vanfanel6418>	When a function exists
T 1710023870 18<28emanuele618>	you cannot make bash warn you about function redefinition
T 1710023885 18<25vanfanel6418>	@< looks like a duck and the = is like a comic-like visualizing of sound (quaking)
T 1710023907 18<28emanuele618>	that is precisely why vim regexps are the best kind of regexps
T 1710023916 18<20bent_fingers18>	anyhow, gnu find doesn't have sed or pcre regex types
T 1710023933 18<25vanfanel6418>	emanuele6, that and Perl's regex support is unmatched
T 1710023944 18<27JAA18>	This should match leap years: ^(?!(?![2468][048]|[13579][26])\d{2}00)\d{2}([02468][048]|[13579][26])$
T 1710023946 18<27larryv18>	bent_fingers: i would just use whatever the default is so i don't have to specify it every time, unless it literally is not suitable for the job
T 1710023957 18<20bent_fingers18>	actually, my version does have sed regextype, but it's not documented https://www.gnu.org/software/findutils/manual/html_node/find_html/Regular-Expressions.html
T 1710023977 18<20bent_fingers18>	larryv: the default requires too many backslashes
T 1710023988 18<27larryv18>	get over it
T 1710023989 18<20bent_fingers18>	too ugly for me
T 1710024017 18<25vanfanel6418>	So is it possible to make bash complain about function redefinitions?
T 1710024025 18<27Earnestly18>	vanfanel64: dynamic function redefinition is one of its rare strengths
T 1710024030 18<28emanuele618>	there is no option to do that
T 1710024034 18<27JAA18>	I use `... | perl -pe 's/x/y/' | ...` sometimes for 'sed but with good regexes'.
T 1710024080 18<28emanuele618>	sed, but the last character of the pattern space is newline
T 1710024106 18<25vanfanel6418>	Earnestly, I agree that it is a strench/good thing normally, but sometimes I want to know if I writing a function that might alreay exist, like when sourcing a bash file full of functions, like typo or forgot there was a foo in there
T 1710024158 18<28emanuele618>	so stronk
T 1710024187 18<27Earnestly18>	vanfanel64: I don't think that's a reasonable requirement because the same could apply to overriding any command, from PATH or otherwise, which a shell is intended to do. You could check if a function exists every time you define one, but that /is/ a stench
T 1710024204 18<25vanfanel6418>	emanuele6, stronk, as in getting stuck in the head?
T 1710024239 18<28emanuele618>	stronk is strength as an adjective
T 1710024258 18<25vanfanel6418>	Earnestly, comamnds and functions are separate things, with some similar attributes (like $@/$*, $1, $2... args)
T 1710024262 18<27Earnestly18>	vanfanel64: They are not
T 1710024272 18<25vanfanel6418>	huh
T 1710024277 18<25vanfanel6418>	they are not the same
T 1710024300 18<25vanfanel6418>	a command is a whole program, a function is a shell-wise reusable piece of code
T 1710024336 18<25vanfanel6418>	s/piece/chunk/
T 1710024347 18<28emanuele618>	stroink is a C function that extracts pigs from strings
T 1710024388 18<27Earnestly18>	vanfanel64: They are the same thing; you're applying programming language logic to a shell and trying to treat it like one which always leads to trouble
T 1710024408 18<25vanfanel6418>	emanuele6, does it handle wild hogs too?
T 1710024422 18<27Earnestly18>	vanfanel64: Especially when users think they can turn scripts into "libraries"
T 1710024433 18<28emanuele618>	in sh, a command is a statement
T 1710024479 18<25vanfanel6418>	Earnestly, you are mainly right, though I only wanted to know if a function was already defined
T 1710024493 18<28emanuele618>	this everrepeating programming language troll is so boring because the definition of command is made up to fit whatever you want to say
T 1710024502 18<27Earnestly18>	vanfanel64: The only practical difference, which is unfortunate, is when trying to use functions in bernstein chains that expect an exec(3), but then it might be worth turning your function into a ./script and calling it without modification
T 1710024503 18<25vanfanel6418>	emanuele6, ah, I mistakenly took command as program
T 1710024527 18<27Earnestly18>	vanfanel64: You can only test before defining it
T 1710024561 18<28emanuele618>	vanfanel64: it is fine to call programs command, but Earnestly is pretending as usual that it means something else, and that you are wrong, etc, etc, to say the same thing they always say
T 1710024703 18<27Earnestly18>	vanfanel64: (A command is a program)
T 1710024849 18<25vanfanel6418>	Ah, there IS a way!
T 1710024853 18<25vanfanel6418>	# foo() { echo ABC; }; foo; readonly -f foo; foo() { echo DEF; }; foo
T 1710024855 18<25shbot18>	vanfanel64: ABC
T 1710024855 18<25shbot18>	vanfanel64: bash: foo: readonly function
T 1710024855 18<25shbot18>	vanfanel64: ABC
T 1710024880 18<25vanfanel6418>	I would only use this in very limited situations, granted, but it is good to know
T 1710024897 18<28emanuele618>	i didn't know that :o
T 1710024917 18<28emanuele618>	i guess that is a little different, you have to specify the functions you don't want to redefine
T 1710024926 18<27Earnestly18>	vanfanel64: I thought you wanted to check if a function was already defined? I suppose you could use the exit status of readonly -f if it doesn't
T 1710024995 18<27Earnestly18>	it doesn't/it isn't already defined
T 1710025023 18<25vanfanel6418>	Earnestly, I was wondering if there was a way to make bash warn about redefinition attempts, and this effectively does that
T 1710025057 18<27Earnestly18>	In a roundabout way, yeah
T 1710025094 18<27Earnestly18>	vanfanel64: It also prevents you from actually redefining it if you decided to do so later on in the script
T 1710025160 18<27Earnestly18>	vanfanel64: As in, bash has type -t which can print 'function' if it is so
T 1710025745 18<25ormaaj18>	remember tacgnol the evil longcat
T 1710026476 19*	Now talking on 22#bash
T 1710026476 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1710026476 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1710026480 18<28emanuele618>	some tools have \< to match start of word boundary, \> for end of word boundary, and \b for either \< or \> boundaries
T 1710026503 18<28emanuele618>	less only has \b, so you need to remember to use that in less :/
T 1710026565 19*	Now talking on 22#bash
T 1710026565 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1710026565 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1710026588 18<28emanuele618>	it does not work in other standard tools though
T 1710026604 18<28emanuele618>	hleneto: hmm, maybe i am thinking of another tool; i remember there is one in which you must use \b
T 1710026628 18<28emanuele618>	it is less! \< does not work in my less
T 1710026635 18<28emanuele618>	are you sure you are using less?
T 1710026857 19*	Now talking on 22#bash
T 1710026857 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1710026857 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1710027100 19*	Now talking on 22#bash
T 1710027100 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1710027100 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1710027160 18<28emanuele618>	oh, it is not a patch, less can be built with different regex engines
T 1710027221 18<25hleneto18>	emanuele6, that explains it then.
T 1710027242 18<28emanuele618>	the archlinux package uses pcre2 instead of the default which would use glibc regular expressions :/
T 1710027382 18<28emanuele618>	debian is using gnu regexps
T 1710027396 18<20bent_fingers18>	any trick to omit binaries from the results of find?
T 1710027408 18<28emanuele618>	archlinux packages are lame :/
T 1710027420 18<20bent_fingers18>	we told you to switch to gentoo
T 1710027424 18<20bent_fingers18>	but you're stubborn
T 1710027440 18<28emanuele618>	they chose to randomly make one of the standard tools use a different regex flavour \:
T 1710027469 18<28emanuele618>	bent_fingers: you mean like programs?
T 1710027518 18<20bent_fingers18>	the ones that yield this in `file` --> ELF 64-bit LSB executable
T 1710027539 18<28emanuele618>	oh, hmm
T 1710027549 18<20bent_fingers18>	programs, yes
T 1710027562 18<27Earnestly18>	bent_fingers: Check if the file contains a NUL byte
T 1710027567 18<20bent_fingers18>	aren't scripts programs? well, that's besides the point
T 1710027585 18<27Earnestly18>	The presence of a NUL is what defines a binary
T 1710027601 18<20bent_fingers18>	ok, thanks
T 1710027618 18<28emanuele618>	bent_fingers: you could call file for each file with    -exec sh -c 'case $(file -b "$1") in ELF*) false; esac' _ {} \;
T 1710027642 18<28emanuele618>	like    find .... -exec sh -c 'case $(file -b "$1") in ELF*) false; esac' _ {} \; -print   for example
T 1710027649 18<28emanuele618>	# type file
T 1710027650 18<27Earnestly18>	bent_fingers: Keep in mind that it'll include tar files, etc. But that's the heuristic tools use (like gnu grep). Ideally you'd just handle them in the same pipeline
T 1710027652 18<25shbot18>	emanuele6: file is /bin/file
T 1710027668 18<28emanuele618>	# find /bin -exec sh -c 'case $(file -b "$1") in ELF*) false; esac' _ {} \; -print | paste -s -
T 1710027674 18<25shbot18>	emanuele6: no output within the time limit
T 1710027684 18<28emanuele618>	hmm
T 1710027718 18<28emanuele618>	# find -L /bin -type f -exec sh -c 'case $(file -b "$1") in ELF*) false; esac' _ {} \; -print
T 1710027724 18<25shbot18>	emanuele6: /bin/gawk
T 1710027724 18<25shbot18>	emanuele6: /bin/rev
T 1710027724 18<25shbot18>	emanuele6: /bin/bunzip2
T 1710027749 18<28emanuele618>	those are the only non elfs in /bin on shbot :o
T 1710027760 18<27Earnestly18>	Alternatively you could use fine-free-file which has -00 and --mime-type (and -b) and just parse that output
T 1710027761 18<28emanuele618>	since when shbot has bunzip2??
T 1710027775 18<28emanuele618>	and why does gawk have a wrapper?
T 1710027856 18<28emanuele618>	# type gunzip
T 1710027857 18<25shbot18>	emanuele6: gunzip is /bin/gunzip
T 1710027872 18<28emanuele618>	wow, i completely missed that shbot had decompression stuff
T 1710027883 18<28emanuele618>	a world of new possibilities has opened up
T 1710027930 18<28emanuele618>	i don't know what the /bin/gawk is; it is not on shbot-initramfs
T 1710027941 18<28emanuele618>	# cat /bin/gawk
T 1710027946 18<25shbot18>	emanuele6: ELF>��@Pr
T 1710027946 18<25shbot18>	emanuele6: @8   @@@@��888
T 1710027946 18<25shbot18>	emanuele6: etc... ( http://paste.wooledge.org/29392 )
T 1710027956 18<28emanuele618>	huh?
T 1710027962 18<28emanuele618>	# file -b /bin/gawk
T 1710027963 18<25shbot18>	emanuele6: symbolic link to gawk5
T 1710027981 18<28emanuele618>	oh, oops
T 1710028001 18<28emanuele618>	# find /bin -type f -exec sh -c 'case $(file -b -- "$1") in ELF*) false; esac' _ {} \; -print
T 1710028008 18<25shbot18>	emanuele6: /bin/rev
T 1710028008 18<25shbot18>	emanuele6: /bin/bunzip2
T 1710028034 18<28emanuele618>	# find /usr/bin -type f -exec sh -c 'case $(file -b -- "$1") in ELF*) false; esac' _ {} \; -print | paste - - -
T 1710028037 18<25shbot18>	emanuele6: /usr/bin/jq     /usr/bin/loadables      /usr/bin/bashlib
T 1710028037 18<25shbot18>	emanuele6: /usr/bin/ls
T 1710028046 18<24geirha18>	hum, no idea why bunzip2 was added
T 1710028085 18<28emanuele618>	on shbot-initramfs gunzip is a script that calls gzip, but, on shbot, it is an elf
T 1710028104 18<28emanuele618>	# file /bin/gunzip
T 1710028106 18<25shbot18>	emanuele6: /bin/gunzip: POSIX shell script, ASCII text executable
T 1710028111 18<28emanuele618>	hmm, nevermind
T 1710028118 18<28emanuele618>	why does the file command not print it then?
T 1710028198 18<28emanuele618>	# ls -dl /bin/gunzip
T 1710028200 18<25shbot18>	emanuele6: -rwxrwxr-x 1 root root 33 Mar 13  2021 /bin/gunzip
T 1710028293 18<28emanuele618>	maybe it times out
T 1710028350 18<28emanuele618>	yeah, that is why it didn't print anything when i used paste -s - earlier
T 1710028395 18<20bent_fingers18>	to organize my scripts into sections I could put a label "Variables" over the grouping of variables, "Functions" over the grouping of functions, but what how can i categorize the last part of my script where i actually run the stuff?
T 1710028397 18<20bent_fingers18>	code?
T 1710028520 18<28emanuele618>	the big brain idea is to declare a main function and put in under function, and then just call   main "$@"   at the bottom
T 1710028533 18<28emanuele618>	so you don't have to come up with a name for a new section!
T 1710028556 18<20bent_fingers18>	oh yeah, i've seen that
T 1710028764 18<28emanuele618>	yay!
T 1710028794 18<28emanuele618>	with bzip2 the 13kB loadable i was able to create last time is just 693 B!
T 1710028801 18<25OMGOMG18>	isn't it pretty obvious already what's variables and what's functions
T 1710028854 18<28emanuele618>	what if you declare a variable in a function?
T 1710028872 18<28emanuele618>	is there a nested ## Variables comment?
T 1710028962 18<28emanuele618>	693bytes is still far too big though :/
T 1710029007 18<28emanuele618>	maybe if i make strings shorter in the builtin it improves
T 1710029230 18<20bent_fingers18>	another script done
T 1710029286 18<20bent_fingers18>	OMGOMG: sure, but i find my eyes alighting on the target more readily with sections
T 1710029301 18<20bent_fingers18>	i don't use syntax highlighting cuz i'm colorblind
T 1710029668 18<28emanuele618>	it definitely helps, but it is still 588B
T 1710029773 18<28emanuele618>	removing sections helped, 541B
T 1710029829 18<28emanuele618>	539
T 1710030054 18<28emanuele618>	hmm, i got it to 510B; then i removed even more stuff (to the point that the builtin is named "", and if use help "", it will crash bash), and it became 531B D:
T 1710031100 19*	Now talking on 22#bash
T 1710031100 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1710031100 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1710031109 18<28emanuele618>	i have noticed that if i remove stuff from the end of the elf it keeps wroking
T 1710031145 18<28emanuele618>	i am blindly trimming random stuff from the end of the elf until it does not work anymore :D
T 1710031184 18<28aesthetics18>	... that colorscheme is actually quite nice
T 1710031190 18*	28aesthetics stfu
T 1710031304 18<28emanuele618>	lmao 258 bytes with gzip!
T 1710031606 18<28emanuele618>	# x=H4sIALEB7WUAA+3ZsRLBQBAG4E0kQhQxGjoeQUljNFQaKh0zVBqGqHkMr+A5NB7BCyh0GoVG5NgdyY3JSGv+r/DbvVvJaW/T6XVNwyCRoRZ9KqI257gW7TXIDj9dyr/2WpSg+D3VXFaVVW5reaV4Rucc9UXeR8syxVPmzJTPy3EOzv7USjFnRNKM1EJ6cn6i7bvJvYvd31MCtacUvp1T0xZGK3+5nvhSyrqcQ/4fT+sb+u8AAAAAAAAAAAAAAAAAAPwJucse8sXt7RHMVS64tnn9yHWW6x3XLtd5zgJnhdPhPPF+uYeta3Oy/x68n2+mO8bvZs2hZx/cJ157F5EIIAAA ksh -c 'typeset -b y;print -nv x>f';enable -f./f ''
T 1710031607 18<25shbot18>	emanuele6: bash: enable: cannot open shared object ./f: ./f: invalid ELF header
T 1710031620 18<28emanuele618>	the bash on shbot does not like that i truncated the elf :/
T 1710031667 18<28emanuele618>	oh, i am stupid; i need to decompress it
T 1710031847 18<25kurahaupo18>	bent_fingers: depending on how you define "word boundary", you can match "beginning of line or non-word character" immediately before a "word character"; e.g. sed 's#\(^\|[[:space:]]\)\([[:alnum:]][_[:alnum:]]*\)#\1matched(\2)#g'
T 1710031928 19*	Now talking on 22#bash
T 1710031928 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1710031928 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1710032555 18<20bent_fingers18>	aesthetics: i made a coloblind scheme; actually my main problem is `micro` doesn't support tree-sitter or language-server yet
T 1710032664 18<20bent_fingers18>	kurahaupo: good to know
T 1710033024 18<28emanuele618>	:D
T 1710033069 18<28emanuele618>	i had to increase the split_msg_max_length setting in weechat, because i didn't have any space left to write any code
T 1710033075 18<28emanuele618>	# ksh<<<'typeset -b x=H4sIALEB7WUAA+3ZsRLBQBAG4E0kQhQxGjoeQUljNFQaKh0zVBqGqHkMr+A5NB7BCyh0GoVG5NgdyY3JSGv+r/DbvVvJaW/T6XVNwyCRoRZ9KqI257gW7TXIDj9dyr/2WpSg+D3VXFaVVW5reaV4Rucc9UXeR8syxVPmzJTPy3EOzv7USjFnRNKM1EJ6cn6i7bvJvYvd31MCtacUvp1T0xZGK3+5nvhSyrqcQ/4fT+sb+u8AAAAAAAAAAAAAAAAAAPwJucse8sXt7RHMVS64tnn9yHWW6x3XLtd5zgJnhdPhPPF+uYeta3Oy/x68n2+mO8bvZs2hZx/cJ157F5EIIAAA;printf %B x'|gunzip>f;enable -f./f '';enable '';printf hi;'';printf \ hello;'';printf \ -
T 1710033076 18<25shbot18>	emanuele6: hi hello - hello - - -
T 1710033094 18<28emanuele618>	it is a loadable named '' that calls fork() :D
T 1710033119 18<28emanuele618>	that is the first ever loadable builtin uploaded to shbot via an irc message i think
T 1710033315 18<28emanuele618>	thank you for including gzip and bzip2 in shbot! without them, it would have been impossible
T 1710033577 18<20bent_fingers18>	smh
T 1710033577 18<27JAA18>	# type zstd
T 1710033579 18<25shbot18>	JAA: bash: type: zstd: not found
T 1710033581 18<27JAA18>	Lame
T 1710033616 18<20bent_fingers18>	shbot dislikes facebook
T 1710033623 18<28aesthetics18>	emanuele6: what were you "blindly trimming" ? does it means ELFs have some "useless" garbage at the bottom of the file ?
T 1710033695 18<28emanuele618>	stuff bash does not use when loading the shared elf as loadable, not necessarily useless...
T 1710033714 18<28aesthetics18>	oh ok!
T 1710033735 18<28emanuele618>	anyway shared elfs are huge, they are not just code and an elf header like regular elfs
T 1710033816 18<20bent_fingers18>	regular elfs help make toys
T 1710033849 18<28emanuele618>	shared elf share their toys to avoid having to make new ones
T 1710033913 18<27JAA18>	Wouldn't that be a sharing elf?
T 1710033934 18<28emanuele618>	those don't exist!
T 1710034416 18<28emanuele618>	# PS1=;ksh<<<'typeset -b x=H4sIALEB7WUAA+3ZsRLBQBAG4E0kQhQxGjoeQUljNFQaKh0zVBqGqHkMr+A5NB7BCyh0GoVG5NgdyY3JSGv+r/DbvVvJaW/T6XVNwyCRoRZ9KqI257gW7TXIDj9dyr/2WpSg+D3VXFaVVW5reaV4Rucc9UXeR8syxVPmzJTPy3EOzv7USjFnRNKM1EJ6cn6i7bvJvYvd31MCtacUvp1T0xZGK3+5nvhSyrqcQ/4fT+sb+u8AAAAAAAAAAAAAAAAAAPwJucse8sXt7RHMVS64tnn9yHWW6x3XLtd5zgJnhdPhPPF+uYeta3Oy/x68n2+mO8bvZs2hZx/cJ157F5EIIAAA;printf %B x'|gunzip>f;enable -f./f '';enable '';printf 1;eval "'' "{1..5}\;;printf 0
T 1710034423 18<25shbot18>	emanuele6: 100000000000000000000000000000000
T 1710034434 18<28emanuele618>	that is 2**(2**5) in binary!
T 1710034610 18<25ormaaj18>	:o
T 1710035115 18<20arraybolt318>	emanuele6: so wait, the maximum IRC message length is enforced by the client, not the server?
T 1710035135 18<20arraybolt318>	I figured sending messages that big would be impossible.
T 1710035178 18<28emanuele618>	the stuff to upload the file fits in 512, but then only  enable -f ./<space> fits after that
T 1710035214 18<28emanuele618>	the server has a limit, but if you send more than the server limit, your message will blindly get truncated
T 1710035235 18<28emanuele618>	s/blindly/silently/
T 1710035250 18<28emanuele618>	and you have no way of telling that since you don't receive your own messages
T 1710035303 18<20arraybolt318>	maybe shbot needs a way of stitching together multiple messages...
T 1710035308 18<28emanuele618>	so all clients will generally split your message into multiple messages of up to 512bytes each to prevent your longer messages from being truncated
T 1710035340 18<28emanuele618>	arraybolt3: then what? an http that lets me upload the file directly?
T 1710035343 18<28emanuele618>	lol
T 1710035364 18<20arraybolt318>	#u https://example.org/my-script.sh
T 1710035371 18<20arraybolt318>	something like that :P
T 1710035377 18<28emanuele618>	even in the server's maximum message length is more than 512 bytes
T 1710035394 18<28emanuele618>	s/http/& api/
T 1710035436 18<20arraybolt318>	# ping -c1 8.8.8.8
T 1710035437 18<25shbot18>	arraybolt3: bash: ping: command not found
T 1710035453 18<20arraybolt318>	if only the VMs had network access things would be easy... but that has way too many risks
T 1710035457 18<28emanuele618>	# cat </dev/tcp/localhost/1234
T 1710035459 18<25shbot18>	emanuele6: bash: localhost: System error
T 1710035459 18<25shbot18>	emanuele6: bash: /dev/tcp/localhost/1234: Invalid argument
T 1710035468 18<28emanuele618>	no tcp/ip or ip at all
T 1710035476 18<20arraybolt318>	but yeah, some way of telling the bot to fetch a file and plug it in would be cool
T 1710035494 18<28emanuele618>	s/cool/lame/
T 1710035512 18<20arraybolt318>	s/s\/cool\/lame\/s\/cool\/really cool\//
T 1710035524 18<20arraybolt318>	#BotchedSed
T 1710035533 18<20arraybolt318>	I was trying to do something cool there but it failed
T 1710035567 18<28emanuele618>	it's almost correct
T 1710035574 18<28emanuele618>	impressive
T 1710035587 18<20arraybolt318>	s/s\/cool\/lame\//s\/cool\/really cool\//
T 1710035591 18<20arraybolt318>	that's correct I think
T 1710035606 18<27larryv18>	just use a different separator
T 1710035612 18<28emanuele618>	# sed 's/s\/cool\/lame\//s\/cool\/really cool\//' <<<'s/cool/lame/'
T 1710035614 18<25shbot18>	emanuele6: s/cool/really cool/
T 1710035614 18<20arraybolt318>	well yeah but what's the fun in that?
T 1710036085 18<27JAA18>	emanuele6: I think Libera's ircd supports echo-message, actually.
T 1710036190 18<28emanuele618>	test
T 1710036213 18<28emanuele618>	i am not sure what you mean, and i do not know what that is
T 1710036229 18<28emanuele618>	i can see that nothing is being sent back to me
T 1710036233 18<27JAA18>	IRCv3 capability where the server sends back to you every message you sent.
T 1710036241 18<27JAA18>	But the client also needs to support it to do something with it.
T 1710036254 18<28emanuele618>	it is not sending anything
T 1710036263 18<27JAA18>	It can be used to implement a 'message delivered' thing where you know the message made it to the network.
T 1710036266 18<28emanuele618>	maybe you need to register to it to use it
T 1710036277 18<27JAA18>	Yes, you need to enable the capability, as with most IRCv3 things.
T 1710036367 18<28emanuele618>	https://ircv3.net/specs/extensions/echo-message
T 1710036383 18<28emanuele618>	yes, this will let the client tell you if your message has been truncated
T 1710036421 18<27JAA18>	Can confirm, it works on Libera.
T 1710037447 18<25ormaaj18>	If you have a shorter nick you get to post longer messages
T 1710037495 18<25ormaaj18>	so JAA gets 3 extra chars!
T 1710037962 18<27JAA18>	Even more!
T 1710037967 18<27JAA18>	It's the entire user mask that counts.
T 1710037986 18<27JAA18>	jaa!~jaa@user/jaa vs emanuele6!~emanuele6@user/emanuele6
T 1710038060 18<27JAA18>	I love that 'shbot' has the same length as '#bash'. So if something works in query, it also works here.
T 1710038086 18<22mute18>	mildly interesting
T 1710038127 18<22mute18>	hm whats shortest domain i've got
T 1710038260 18<22mute18>	well i could save one char there but this one is wayyy cooler
T 1710038263 18<27JAA18>	Maybe you could in theory use a TLD as the PTR. So a three-letter TLD for six-digit dollars and a single-char nick with identd to get the shortest possible 'x!x@tld'.
T 1710038308 18<27JAA18>	But maybe it requires that it's at least a second-level domain, then it'd be a char longer.
T 1710038331 18<27JAA18>	Getting one of those one-letter domains on a ccTLD might be even more expensive though than a gTLD. :-)
T 1710038342 18<20twkm18>	1x two letter .com, 3x three letter .com, lost 1x one letter .cc (after paying for it for years they said that i was violating their tos).
T 1710038380 18<22mute18>	i think that's probably worth $185k
T 1710038455 18<22mute18>	best i got is san.aq. i remember asking internic for r.com but they said it was not allowed. must've been after x.com got theirs
T 1710038772 18<25ormaaj18>	A few got grandfathered in
T 1710038779 18<25ormaaj18>	x.com x.org
T 1710038812 18<25ormaaj18>	q.com is another
T 1710038886 18<22mute18>	the heck, q.com says 1999
T 1710039139 18<25ormaaj18>	I know that one because I was stuck with with their terrible DSL for ages!
T 1710039175 18<25ormaaj18>	DSL is interesting old tech. How much bandwidth can you shove down the shittiest wire possible
T 1710039223 18<25ormaaj18>	most interesting since that thing where you put your phone onto the microphone thing ^^
T 1710039344 18<22mute18>	what thing?
T 1710039366 18<22mute18>	oh the acoustic coupler
T 1710039370 18<25ormaaj18>	yeah that one
T 1710039400 18<22mute18>	i think those max at 300 baud
T 1710039474 18<25ormaaj18>	I'm sure they were awful
T 1710039513 18<22mute18>	DSL is highly dependent on distance from the central office. when they made at&t u-verse they moved the DSLAM into the neighborhood.  you can be too close to!
T 1710049342 19*	Now talking on 22#bash
T 1710049342 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1710049342 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1710051048 18<22mosasaur18>	I'm using scite as a code editor, it can fold code blocks and can comment/uncomment them. Now I need some trick to create a code block that doesn't do anything, to fold a part of code that is turned into comments. I'm currently using "if 0; then echo fi" around the code segment. Is there a better way?
T 1710051168 18<27larryv18>	if 0 doesn't do nothing, it will try to run a command named "0"
T 1710051178 18<27larryv18>	# if 0; then :; fi
T 1710051180 18<25shbot18>	larryv: bash: 0: command not found
T 1710051213 18<22mosasaur18>	larryv: yes, I think I need a 'nop'
T 1710051257 18<27larryv18>	if false
T 1710051264 18<22mosasaur18>	ah right
T 1710051319 18<22mosasaur18>	anything else I could use instead of 'if' ?
T 1710051643 18<22mosasaur18>	# if false
T 1710051650 18<25shbot18>	mosasaur: Missing terminating quote, bracket or keyword
T 1710051839 18<27larryv18>	# if false; then echo this will not run; fi
T 1710051841 18<25shbot18>	larryv: no output
T 1710051954 18<22mosasaur18>	# if true; then echo 'thanks!'; fi
T 1710051955 18<25shbot18>	mosasaur: thanks!
T 1710051979 18<22mosasaur18>	oh wait, I wanted to thank larryv
T 1710052007 18<27larryv18>	lol np
T 1710070831 18<27Earnestly18>	https://github.com/flonatel/pipexec
T 1710071075 18<24geirha18>	That looks more complicated than just using shell redirection
T 1710071104 18<24geirha18>	Also, the images are useless in dark mode
T 1710071729 18<27Earnestly18>	geirha: It would be a tad more useful with sh and possibly in cases where the command (systemd Exec or so) is not a shell without having to worry about injection so much (unless it has its own)
T 1710071774 18<27Earnestly18>	I remember MacIlroy wanted to make multi-dimentional pipelines but couldn't settle on a nice syntax to express it
T 1710071838 18<27Earnestly18>	geirha: The cyclic example, in sh I did something like: https://0x0.st/HhaB.sh - can bash do anything about this?
T 1710073179 18<28emanuele618>	missing a par of {} in the end block
T 1710074885 18<24ano18>	!0x0
T 1710074919 18<24ano18>	!0x0.st
T 1710074919 18<29greybot18>	0x0.st serves scripts with a MIME type that indicates it's a runnable program, so some web browsers can't easily show it as a plain text file; please be nice to us and use paste.debian.net instead
T 1710074935 18<28emanuele618>	# echo $[0x0]
T 1710074939 18<25shbot18>	emanuele6: 0
T 1710074940 18<28emanuele618>	# echo ${PWD[0x0]}
T 1710074942 18<25shbot18>	emanuele6: /root
T 1710075086 18<24ano18>	should be called 0x0.shit since fucked up mime types/exts and doesn't allow tor users even read pastas
T 1710075670 18<28emanuele618>	https://0x0.st/Hhav.txt
T 1710078283 18<24ano18>	# coproc fds { while IFS= read -r var; do echo "${var~~}"; done; }; echo moo >&"${fds[1]}"; while IFS= read -ru "${fds[0]}" 'arr[++i]'; do printf "${arr[i]}"; echo "${arr[i]}" >&"${fds[1]}"; ((i==10)) && break; done
T 1710078284 18<25shbot18>	ano: [1] 51
T 1710078284 18<25shbot18>	ano: MOOmooMOOmooMOOmooMOOmooMOOmoo
T 1710078293 18<24ano18>	Earnestly: ^
T 1710079131 18<28fatal18>	any idea why bashcompletion gets messed up when i use GRN='\e[0;30;32m' instead of GRN='\[\e[0;30;32m\]' for PS1="${GRN}\$${ESC} " ?
T 1710079231 18<28emanuele618>	fatal: readline will think \e [ 0 ; 3 0 ; 3 2 m occupy 10 columns
T 1710079285 18<28emanuele618>	\[ and \] represent a \1 and \2 character respectively, and tell readline that everything between \1 and \2 occupies no space, so it can position the prompt correctly
T 1710079441 18<28fatal18>	all the examples i'm looking at only use e.g. '\e[0;32m'
T 1710079465 18<28emanuele618>	well, that has never worked correctly
T 1710079495 18<28fatal18>	so more escapes is always better? it seems to work for me.
T 1710079508 18<28emanuele618>	more escapes?
T 1710079581 18<28fatal18>	like  \[ \e \] instead of just \e
T 1710079792 18<24ano18>	see (inf -n 'controlling the prompt' bash)
T 1710079803 18<28emanuele618>	escapes that are part of the prompt always need to surrounded by \[ / \] or \1 / \2 characters, or it cannot be displayed correctly
T 1710079806 18<24ano18>	s/inf/info/
T 1710079865 18<28emanuele618>	also if you have a function that prints something and you include it in the prompt with $()
T 1710080003 18<28emanuele618>	e.g.   currentunixtime(){ printf 'current \E[32mUNIX\E[m time: %(%s)T\n' -1;}     PS1='[$(currentunixtime)]$ '    that will also break the prompt
T 1710080031 18<28emanuele618>	it needs to print \1 and \2 to delimit parts with color sequences
T 1710080053 18<28emanuele618>	  currentunixtime(){ printf 'current \1\E[32m\2UNIX\1\E[m\2 time: %(%s)T\n' -1;}
T 1710080342 18<28fatal18>	ok, got it.
T 1710080517 18<28fatal18>	interesting tho since every site that i look up for bash prompt does not tell you that
T 1710080598 18<28fatal18>	...well not every.
T 1710080598 18<28emanuele618>	maybe they never tab complete, or user never use ^R, or similar  ¯\_(ツ)_/¯
T 1710080609 18<28emanuele618>	s/user //
T 1710080664 18<26lolok18>	why do i get files like '.bash_history-12345.tmp' randomly in my home folder sometimes?
T 1710080771 18<28xFCFFDFFFFEFFFAF18>	‛
T 1710080840 18<28emanuele618>	lolok: websearch says that is what happens when you run a fork bomb in an interactive shell
T 1710080907 18<26lolok18>	hmmm, afaik i havent been doing that, seems like something i would have noticed
T 1710080916 18<24ano18>	hmm does bash itself create such file, even when histappend enabled?
T 1710081008 18<28emanuele618>	maybe you have been killing interactive shells with SIGKILL or similar?
T 1710081051 18<26lolok18>	less than graceful reboot maybe?
T 1710081063 18<26lolok18>	if that would cause it than that would explain it
T 1710081127 18<26lolok18>	i dont usually notice until days later so im not really sure
T 1710081131 18<28emanuele618>	it is probably an intermediate file bash uses to save the history when you exit
T 1710081164 18<28emanuele618>	so if you abruptly kill it when it's in the process of saving history, that would happen
T 1710081316 18<28fatal18>	ano: haven't used that one in a while.
T 1710081354 18<26lolok18>	ok, gotta get in the habit of properly logging out before i pull the plug, see if that makes it stop happening
T 1710081955 18<28fatal18>	hm, there is no node in info bash 'controlling the prompt', this a gpt answer?
T 1710082058 18<24ano18>	fatal: >no node ?
T 1710082106 18<28fatal18>	info -n=NODENAME
T 1710082114 18<24ano18>	https://www.gnu.org/software/bash/manual/html_node/Controlling-the-Prompt.html
T 1710082386 18<24ano18>	that manual should be generated from the same texinfo
T 1710083360 18<28emanuele618>	info -n 'controlling the prompt' bash   as ano typed it works for me
T 1710083412 18<28emanuele618>	but not much interesting there
T 1710084584 18<28fatal18>	here it just says "No menu item 'bash' in node '(dir)Top'" at the bottom of the ncurses interface with `info -n 'controlling the prompt' bash`
T 1710084713 18<28fatal18>	oh, it needs package: bash-doc. nvm, then.
T 1710086969 18<19DarkenedGentlema18>	I'm looking to pipe stdout to one program but stderr to another. ex: ./prog1 | logger || echo "stderr"
T 1710086974 18<19DarkenedGentlema18>	where am i going wrong here?
T 1710087166 18<28emanuele618>	?
T 1710087335 18<26lopid18>	cmd 2> >( stderr prog ) > >( stdout prog )
T 1710087419 18<19DarkenedGentlema18>	Sorry, that's not what I'm trying to do. lol, brain today is already not working.  Better explanation.  I'm using flock on a command running from cron.  I want the stdout of that command to be sent to logger, but if flock fails I want it to echo "blah still running"
T 1710087503 18<19DarkenedGentlema18>	my basic stest is this.
T 1710087504 18<19DarkenedGentlema18>	flock -n test.flock ./testflock.sh |logger || echo "still runnnin"
T 1710087529 18<19DarkenedGentlema18>	testflock.sh is a simple sleep 5 to simulate the prog still running.
T 1710087603 18<28emanuele618>	(flock -n test.flock ./testflock.sh || echo >&2 something stderr) | logger
T 1710088489 18<19DarkenedGentlema18>	emanuele6: Thank you!  Question, can i pass the name of the prog somenow to the echo?  $0 just shows bash
T 1710088516 18<28emanuele618>	hmm, the name of what program?
T 1710088533 18<19DarkenedGentlema18>	In this case testflock.sh
T 1710088549 18<28emanuele618>	can't you just write it again?
T 1710088578 18<19DarkenedGentlema18>	Ya I could.  I was just curious if there was a simple var i was missing
T 1710088610 18<28emanuele618>	there is "$_" that is the last argument of the previous command; so in this case it would be ./testflock.sh
T 1710088619 18<28emanuele618>	but the shell has to be bash for that to work
T 1710088628 18<28emanuele618>	it does not work on sh that cron could be running
T 1710088645 18<28emanuele618>	you could create your own variable, like
T 1710088678 18<28emanuele618>	(x=./testflock.sh; flock -n test.flock -- "$x" || printf >&2 '%s: something stderr\n' "$x") | logger
T 1710088720 18<28emanuele618>	* it does not work on any sh that cron could be running
T 1710088733 18<19DarkenedGentlema18>	Thanks, I just want to keep it simple, what you provided above will work fine.
T 1710097130 18<22olspookishmagus18>	is there a way to ONLY display the lines NOT in HISTFILE?
T 1710097210 18<22olspookishmagus18>	or maybe I should parse how many lines does ~/.bash_history file have and then use that as an offset indicator?
T 1710097292 18<28bprompt18>	olspookishmagus: what are you trying to do? besides the obvious
T 1710097393 18<24geirha18>	history -a /dev/stdout
T 1710097500 18<24geirha18>	only works once though. After that it thinks it has written those lines to history
T 1710097501 18<22olspookishmagus18>	I want to view whatever commands are there in my session and to see if any of those are wort of keeping into my .bash_history file
T 1710097527 18<24geirha18>	but you can run it in a subshell
T 1710097606 18<28emanuele618>	another way is   a='\#'; history "${a@P}"
T 1710097619 18<28emanuele618>	that works as many time as you want
T 1710097624 18<22olspookishmagus18>	good idea geirha
T 1710097635 18<22olspookishmagus18>	and thank you bprompt and emanuele6 too
T 1710097647 18<28emanuele618>	no, thank you!
T 1710097657 18<22olspookishmagus18>	I wasn't expecting that
T 1710097779 18<28bprompt18>	olspookishmagus: consider it a DST day thanks from emanuele6 =)
T 1710098174 18<27Earnestly18>	ano: I wondered if a solution might be using coproc, I've rarely managed to use it for anything useful. Thanks
T 1710098325 18<24ano18>	y it's pretty limited because of 1 per proc limitation, but it can be nested i think...
T 1710101257 18<24iconoclast_hero18>	 breakout
T 1710101281 18<24iconoclast_hero18>	sorry, was searching backscroll
T 1710101332 18<24iconoclast_hero18>	i have a script with a function to `trap '{ breakout; exit 1; }' INT`
T 1710101365 18<24geirha18>	mh, you should never exit from a SIGINT trap
T 1710101463 18<27larryv18>	!sigint
T 1710101463 18<29greybot18>	How the shell handles ^C (SIGINT) and why: http://www.cons.org/cracauer/sigint.html
T 1710101503 18<20bent_fingers18>	linux console is a terminal? https://en.wikipedia.org/wiki/List_of_terminal_emulators
T 1710101581 18<24geirha18>	terminal emulator, yes
T 1710101657 18*	24iconoclast_hero is one of the "Users who have problems problems getting rid of runaway shell scripts using Control-C. Or have interactive applications that don't behave right when sending SIGINT."
T 1710101661 18<24iconoclast_hero18>	thanks
T 1710101718 18<24geirha18>	trap 'breakout ; trap - INT ; kill -INT "$$"' INT
T 1710101766 18<24iconoclast_hero18>	well, for one thing the script that I have (which someone here basically wrote) calls another script to kill all the child processes
T 1710101786 18<24iconoclast_hero18>	so that's not really a good example to do what i need to in my current instance.
T 1710101990 18<27larryv18>	you never stated what you need to do
T 1710102055 18<20bent_fingers18>	oh, the console being the framebuffer console, i get it
T 1710102523 18<24iconoclast_hero18>	well, i'm not sure where to begin.  what i have is a script that launches four parallel ffmpeg conversion jobs and there's a helper script that goes out and kills all of them, much more than what I need here.  In the particular case I'm dealing with, I'm using something called gum  (https://github.com/charmbracelet/gum) to create a list I can scroll
T 1710102538 18<24iconoclast_hero18>	and once I select an item it goes to another gum menu
T 1710102565 18<24iconoclast_hero18>	^c from the first still goes to the second, so the faq sent addresses the issue larryv
T 1710103375 18<24iconoclast_hero18>	hey, so can I ask a question here?
T 1710103399 18<24iconoclast_hero18>	in https://www.cons.org/cracauer/sigint.html it says, "And here is where the problem arises: Once they catch the signal, the system will no longer communicate the "I-exited-on-SIGINT" status to the calling program (the parent). Even if the program exits immediately in the signal handler of SIGINT. Once it catches the signal, it has to take care of communicating the signal status itself.
T 1710103399 18<24iconoclast_hero18>	Some programs don't do this. On SIGINT, they do cleanup and exit immediatly, but the calling shell isn't told about the non-normal exit and it will call the next program in the script."
T 1710103400 18<24ano18>	!ask
T 1710103400 18<29greybot18>	If you have a question, please just ask it. Don't look for topic experts. Don't ask to ask. Don't PM! Don't ask if people are awake, or in the mood to help. Just ask the question straight out, and be patient waiting for an answer. http://mywiki.wooledge.org/NetEtiquette
T 1710103408 18<24iconoclast_hero18>	rhetorical
T 1710103418 18<24iconoclast_hero18>	sorry
T 1710103457 18<27larryv18>	no questions in this channel. answers only
T 1710103465 18<24iconoclast_hero18>	is what this is saying is that gum is oneof those programs that is not taking care of communicating the signal status itself OR
T 1710103496 18<24iconoclast_hero18>	that I'm not receiving it properly once gum's caught it?
T 1710103981 18<24geirha18>	not unlikely
T 1710104010 18<24geirha18>	(that gum is mishandling it)
T 1710104193 18<24iconoclast_hero18>	so if that is the case then i should just do the immediate uncontrollable exit if that is acceptable in my case?
T 1710104249 18<27larryv18>	IUE/WUE/WCE aren't choices you can make
T 1710104289 18<27larryv18>	they're strategies for how the shell itself behaves
T 1710104295 18<27larryv18>	you can't pick one
T 1710104318 18<24iconoclast_hero18>	yeah, that seemed a bit confusing.
T 1710104381 18<24geirha18>	#!/bin/bash
T 1710104382 18<24geirha18>	gum choose one two three
T 1710104386 18<24geirha18>	printf 'Still here\n'
T 1710104412 18<27AntonioPt18>	hi everyone need a stupid help :D
T 1710104414 18<24geirha18>	test with that script. While gum is waiting for user input, hit Ctrl+C.  If you see the "Still here" message, gum is misbehaving
T 1710104428 18<24iconoclast_hero18>	thank you
T 1710104432 18<24iconoclast_hero18>	if it is, am I SOL?
T 1710104471 18<24iconoclast_hero18>	yes, it mishandles it.
T 1710104496 18<24geirha18>	you can slap  || exit   after it as a work around, but it's just moving the problem one layer further out
T 1710104511 18<24geirha18>	best option is to report a bug against gum and hope it gets fixed
T 1710104530 18<27AntonioPt18>	inxi -Sz i get multiple result not i want ex to know bits so im using inxi -Sz | grep -ioP 'bits:\s[0-9]+' and output is bits: 64 but i just want 64
T 1710104573 18<24geirha18>	I looked at gum's source code, and it doesn't set any signal handler for SIGINT as far as I can see, so it's likely one of the modules/libraries it uses that does it
T 1710104667 18<24iconoclast_hero18>	@geirha, i posted a discussion since that's the way their discord sort of points you...
T 1710104673 18<24iconoclast_hero18>	a discussion on github.
T 1710104693 18<24iconoclast_hero18>	but yes, ultimately I would file a feature request, but you would suggest that is a bug?
T 1710104766 18<24geirha18>	your use of terminology is a bit off, but I think you still get the problem described well enough
T 1710104824 18<24iconoclast_hero18>	j=$(gum choose --height 40 "${playedarr[@]}")
T 1710104858 18<24iconoclast_hero18>	j=$(gum choose --height 40 "${playedarr[@]}" || exit) doesn't seem right
T 1710104878 18<27larryv18>	i guess the only way it exits with a nonzero status is on C-c or Esc? https://github.com/charmbracelet/gum/blob/main/input/input.go#L62-L71
T 1710104880 18<24geirha18>	j=$(gum ...) || exit
T 1710104904 18<27larryv18>	or timeout
T 1710104920 18<24iconoclast_hero18>	so what is that saying then j= the result of gum or exit?
T 1710104922 18<27larryv18>	so you could do, er, what geirha just did
T 1710104943 18<27larryv18>	j is set to whatever gum puts on stdout
T 1710104962 18<24geirha18>	it's assuming gum at least returns a non-zero exit status when it exits from a SIGINT
T 1710104974 18<25ormaaj18>	# x=$(false || exit 42); echo $?
T 1710104976 18<25shbot18>	ormaaj: 42
T 1710104985 18<27larryv18>	j=$(foo || exit) is wrong because $() is a subshell, exit will only change its exit status
T 1710105029 18<24geirha18>	# f() { printf 'data\n' ; exit 0 ; } ;   var=$(f) || exit ; declare -p var
T 1710105031 18<25shbot18>	geirha: bash: syntax error near unexpected token `$'{\302\240printf''
T 1710105038 18<24geirha18>	gah, bloody nbsp
T 1710105043 18<24geirha18>	# f() { printf 'data\n' ; exit 0 ; } ;   var=$(f) || exit ; declare -p var
T 1710105045 18<25shbot18>	geirha: declare -- var="data"
T 1710105052 18<24geirha18>	# f() { printf 'data\n' ; exit 42 ; } ;   var=$(f) || exit ; declare -p var
T 1710105054 18<25shbot18>	geirha: logout
T 1710105054 18<25shbot18>	geirha: (shell exited with 42)
T 1710105199 18<24iconoclast_hero18>	what i'm getting at is that exiting with the declaration of a variable is what i'm learning...more than the exact syntax.
T 1710105240 18<25ormaaj18>	what's gum?
T 1710105244 18<25ormaaj18>	abc gum?
T 1710105249 18<24iconoclast_hero18>	charm gum
T 1710105260 18<24iconoclast_hero18>	it's a go-based script thingiemajig
T 1710105273 18<24geirha18>	see the github url larryv posted 7 minutes ago
T 1710105284 18<25ormaaj18>	:o
T 1710105300 18<24iconoclast_hero18>	i saw it on one of those things google chrome puts on your android phone one day.
T 1710105441 18<27larryv18>	iconoclast_hero: unless var is readonly, the exit status of var=$(cmd) is that of cmd. so you can use that as if you weren't doing an assignment
T 1710105468 18<24iconoclast_hero18>	yeah i was just typing that out and decided that was pretty obvious
T 1710105504 18<24iconoclast_hero18>	so basically gum results in a non zero exit code if i hit ^C and then that triggers the OR exit part.
T 1710105531 18<27larryv18>	right
T 1710105544 18<24iconoclast_hero18>	and that would be the same for any $(command) expansion
T 1710105579 18<24iconoclast_hero18>	oh so much nicer than having to deal with trap today
T 1710105659 18<27larryv18>	the ^C part would not be the same
T 1710105668 18<27larryv18>	and the exit status thing is only the same for assignments
T 1710105678 18<24iconoclast_hero18>	oh right
T 1710105681 18<24iconoclast_hero18>	good point
T 1710105685 18<24iconoclast_hero18>	i overgeneralized
T 1710105882 18<24iconoclast_hero18>	what's the ! on getopts and/or handling flags?
T 1710105901 18<27larryv18>	!faq options
T 1710105901 18<29greybot18>	https://mywiki.wooledge.org/BashFAQ/035 -- How can I handle command-line options and arguments in my script easily?
T 1710106201 18<27cabalcrow18>	When I call [[ -e $result ]] from a script I get that the file doesn't exist even if it does, however if I use the same result interactively it works properly
T 1710106234 18<25ormaaj18>	weird
T 1710106252 18<28emanuele618>	that should not happen
T 1710106269 18<25ormaaj18>	pebkac
T 1710106297 18<28emanuele618>	!pebkac
T 1710106297 18<29greybot18>	Problem Exists Between Keyboard and Chair. A humorous way to describe a problem caused by the user, not the system. Similar forms: PEBCAK/PIBCAC/PEBKAM.
T 1710106334 18<24iconoclast_hero18>	what makes a case statement a better choice than a if/elif construction?
T 1710106354 18<28emanuele618>	not many things
T 1710106367 18<25ormaaj18>	does pattern matching if posix
T 1710106375 18<24iconoclast_hero18>	looks a bit more svelte
T 1710106440 18<25ormaaj18>	you can do weird fallthrough logic with it with &; and &;;
T 1710106486 18<24iconoclast_hero18>	I wouldn't presume *I* can do anything of the sort, lol.
T 1710106497 18<24geirha18>	is perhaps $result a relative path?
T 1710106527 18<24iconoclast_hero18>	thanks, i realized i have an extended if/elif script that could be a case statement.
T 1710106544 18<24iconoclast_hero18>	that does what the first example does basically.
T 1710106567 18<27cabalcrow18>	result is a relative path yes
T 1710106596 18<27cabalcrow18>	I tried adding the full path as well in the test like [[ -e /home/user/temp/$result ]]
T 1710106613 18<27cabalcrow18>	again does not work in the script, but works interactively
T 1710106622 18<24iconoclast_hero18>	i bet that means it's not expanding when you think it's expanding
T 1710106650 18<25ormaaj18>	that would expand
T 1710106732 18<24geirha18>	cabalcrow: ok, where does result come from? maybe it comes from a source with windows line-endings (\r\n AKA CRLF)?
T 1710106758 18<24geirha18>	if it is the case, xtrace output should reveal it
T 1710106759 18<24geirha18>	!-x
T 1710106759 18<29greybot18>	set -x (or ''bash -x myscript'') makes bash output the exact command that it will run after parsing and expansion. You can put ''set -x'' just before the code you want to debug (turn off with ''set +x''). To add more information, change PS4 first: eg. PS4='+($?) $BASH_SOURCE:$FUNCNAME:$LINENO:'
T 1710106791 18<24iconoclast_hero18>	what's PS4?
T 1710106848 18<24geirha18>	variable used by set -x, so you can prefix more helpful data to each line
T 1710106856 18<27larryv18>	!ps4
T 1710106856 18<29greybot18>	The value of $PS4 is printed (after expansion) before each command bash displays during an execution trace. See man bash, under PROMPTING. # http://wiki.bash-hackers.org/scripting/debuggingtips#use_shell_debug_output Try PS4='+($?) $BASH_SOURCE:$FUNCNAME:$LINENO:'
T 1710106863 18<24geirha18>	PS4=
T 1710106866 18<24geirha18>	err
T 1710106893 18<27cabalcrow18>	It doesn't come from there. That being said I found how to fail this interactively as well. Basically if I set result="aoeu\ -\>\ aoeu", & then I test via $result it fails, however if I type it out as aoeu\ -\>\ aoeu then it works
T 1710106915 18<24geirha18>	PS4='+ $BASH_SOURCE:$LINENO:' bash -xic ''   # is a common trick to see exactly what files get sourced when an interactive bash is started
T 1710106951 18<24geirha18>	cabalcrow: oh, are you parsing ls output?
T 1710106975 18<27cabalcrow18>	yeah
T 1710106995 18<24geirha18>	well ... don't do that
T 1710106996 18<27cabalcrow18>	I'm parsing eza (ls replacement) into into fzf for the colouring
T 1710107001 18<24geirha18>	!ls
T 1710107001 18<29greybot18>	DO NOT USE the output of ls in scripts. Its output format is neither portable nor reliable. Use globs instead. See https://mywiki.wooledge.org/ParsingLs
T 1710107001 18<27cabalcrow18>	& then I'm parsing it back
T 1710107021 18<27cabalcrow18>	I know globs are the better way, but I have to redo everything eza/ls is doing then
T 1710107027 18<27cabalcrow18>	for the actual choice selection in fzf
T 1710107046 18<27cabalcrow18>	so it is easier to parse back the ls/eza output instead
T 1710107056 18<27cabalcrow18>	except for this, this is the only case I can't figure out
T 1710107142 18<24geirha18>	the only case you happen to know of. I'm sure there are many more cases
T 1710107150 18<27xx18>	which printf special character do I use to encode a null byte? I'm trying to do something like `printf '%b' 'xx\0xx\0xx' | base64` but it fails when it is literal xx in there
T 1710107159 18<27xx18>	probably because it interprets \0x as something
T 1710107163 18<27xx18>	instead of it being a \0 and a x
T 1710107190 18<24geirha18>	# printf '%b' 'xx\0xx\0xx' | od -An -tx1 -c
T 1710107192 18<25shbot18>	geirha:   78  78  00  78  78  00  78  78
T 1710107192 18<25shbot18>	geirha:    x   x  \0   x   x  \0   x   x
T 1710107212 18<24geirha18>	looks like it outputs the expected bytes
T 1710107242 18<27xx18>	damn it... I thought I was using bash but it's zsh
T 1710107252 18<27xx18>	nevermind then
T 1710107254 18<27xx18>	thanks
T 1710107371 18<27cabalcrow18>	got my whole problem into 3 commands https://paste.centos.org/view/63dcd8a2
T 1710107500 18<24geirha18>	ah, well the two are different
T 1710107546 18<24geirha18>	aoeu\ -\>\ aoeu   is  "aoeu -> aoeu"
T 1710107575 18<24geirha18>	you added unecessary backslashes to the double quoted string
T 1710107659 18<24geirha18>	"aoeu\ -\>\ aoeu"  using only backslash-quoting is:  aoeu\\\ -\\\>\\\ aoeu
T 1710107664 18<27cabalcrow18>	I tried it with a single quote & it still doesn't work
T 1710107672 18<27cabalcrow18>	result='aoeu\ -\>\ aoeu'
T 1710107691 18<24geirha18>	equally broken. Adds three backslashes to the data
T 1710107696 18<24geirha18>	just like the "" version does
T 1710107722 18<28emanuele618>	result=aoeu\ -\>\ aoeu
T 1710107737 18<28emanuele618>	or result='aoeu -> aoeu' which looks neater
T 1710107803 18<24geirha18>	# printf '%s\n' 'aoeu\ -\>\ aoeu' "aoeu\ -\>\ aoeu" aoeu\\\ -\\\>\\\ aoeu
T 1710107805 18<25shbot18>	geirha: aoeu\ -\>\ aoeu
T 1710107805 18<25shbot18>	geirha: aoeu\ -\>\ aoeu
T 1710107805 18<25shbot18>	geirha: aoeu\ -\>\ aoeu
T 1710107811 18<24geirha18>	# printf '%s\n' 'aoeu -> aoeu' "aoeu -> aoeu" aoeu\ -\>\ aoeu
T 1710107813 18<25shbot18>	geirha: aoeu -> aoeu
T 1710107813 18<25shbot18>	geirha: aoeu -> aoeu
T 1710107813 18<25shbot18>	geirha: aoeu -> aoeu
T 1710109467 19*	Now talking on 22#bash
T 1710109467 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1710109467 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1710109520 18<28emanuele618>	there is a  eza_colors-explanation  man page
T 1710109531 18<28emanuele618>	compressed yeah
T 1710109605 18<28emanuele618>	i also say bold red, that is not mentioned, but that is very obviously for unix sockets
T 1710109619 18<28emanuele618>	so many colours
