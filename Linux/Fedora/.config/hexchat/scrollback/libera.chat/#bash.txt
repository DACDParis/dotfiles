T 1708461269 18<28bprompt18>	Pikk3wyn: hmm the movie?   nahh it was a trial case agains Mark Zuckeberg, the claim from the Winklevoss twins is that he stole their idea, however Mark was the technical guy they hire whilst at Harvard, so the technical part was Mark's, before and after
T 1708461339 18<28bprompt18>	larryv: yeap, we maybe too offtopic, I'm aware, my bad
T 1708461423 18<26HumbleGuy18>	i'm trying to open a script from keyboard shortcut but it doesnt work. The script is executable, in PATH and contains feh /dir/to/img. But when I assign it to my DE keyboard nothing happens, why is that
T 1708461471 18<28bprompt18>	DE keyboard?
T 1708461488 18<26HumbleGuy18>	desktop enviroment keybord shortcut
T 1708461503 18<29Pikk3wyn18>	HumbleGuy: what are you using to open it?
T 1708461510 18<29Pikk3wyn18>	likely the DE does not have it in PATH in the env
T 1708461513 18<28bprompt18>	HumbleGuy: I'd think that has to do with the desktop manager, how it does the mapping
T 1708461524 18<29Pikk3wyn18>	HumbleGuy: where do you add it to PATH
T 1708461538 18<26HumbleGuy18>	well any other application opens perfectly fine with custom shortcut
T 1708461546 18<26HumbleGuy18>	Pikk3wyn in .bashrc
T 1708461556 18<29Pikk3wyn18>	how do you launch xorg?
T 1708461561 18<26HumbleGuy18>	you think the DE sourses it differently?
T 1708461564 18<29Pikk3wyn18>	do you use startx or a DM?
T 1708461570 18<26HumbleGuy18>	yes, gdm
T 1708461594 18<29Pikk3wyn18>	your display manager launches by itself, so it doesnt have your shell env
T 1708461608 18<29Pikk3wyn18>	and xorg starts from the display manager as opposed to your shell
T 1708461634 18<25greycat18>	You claim it's a script.  Is it really?  It must have a #! header and have +x permissions.
T 1708461634 18<29Pikk3wyn18>	I'd recommend to add it to the display manager env, or possibly the child xorg env
T 1708461661 18<29Pikk3wyn18>	you can accomplish this maybe using .profile, or by using an altered xinit, or just with gdm itself
T 1708461678 18<26HumbleGuy18>	oh it doesnt have a header but it has +x perimssions greycat
T 1708461683 18<25greycat18>	If it has those two things, and if your GUI launcher runs it by absolute pathname, then it should run.  Remember that it won't have a controlling terminal.
T 1708461685 18<26HumbleGuy18>	but in terminal it opens perfectly fine
T 1708461686 18<29Pikk3wyn18>	im pretty sure you can change env/export vars in some config tho i don't use gdm
T 1708461699 18<29Pikk3wyn18>	HumbleGuy: your terminal executes the .bashrc
T 1708461703 18<29Pikk3wyn18>	so PATH is as you want
T 1708461706 18<26HumbleGuy18>	oh so I should export the PATH to .profile instead
T 1708461713 18<25greycat18>	gdm does not read .profile
T 1708461719 18<29Pikk3wyn18>	i am not sure if it reads .profile
T 1708461723 18<29Pikk3wyn18>	that was example
T 1708461726 18<25greycat18>	.bashrc is not relevant here.  your GUI launcher won't read that.
T 1708461730 18<29Pikk3wyn18>	ja
T 1708461748 18<25greycat18>	PATH is not relevant as long as you use the full path *in* the launcher, and why wouldn't you
T 1708461760 18<28bprompt18>	HumbleGuy: right, as greycat said, hmmm I dump many of my shortcuts .sh files at $HOME/bin and to my desktop manager I simply give it the full path on key bindings
T 1708461778 18<29Pikk3wyn18>	you can just change the xinit
T 1708461799 18<29Pikk3wyn18>	there is still an xinitrc (maybe called xsetup in this idk) that executes when you start the session
T 1708461811 18<29Pikk3wyn18>	or, basically all display managers work like this so i assume it does
T 1708461825 18<29Pikk3wyn18>	you can just make a custom one that sets your custom PATH and exports it
T 1708461832 18<25greycat18>	It depends on the operating system, the display manager, and possibly configuration choices.
T 1708461839 18<29Pikk3wyn18>	ja
T 1708461851 18<25greycat18>	Stop building things that rely on assumptions about what random DMs will do.
T 1708461858 18<26HumbleGuy18>	ohh, let me try that
T 1708461871 18<27Soliton18>	if the script has no proper shebang it's not executable.
T 1708461879 18<29Pikk3wyn18>	greycat: to be fair, I cannot think of a single DM that does not support this
T 1708461892 18<27Soliton18>	bash will run the script with itself as a fallback.
T 1708461910 18<25greycat18>	as far as "but it works in bash", that's because when bash tries to run a thing that gives exec format error, bash will open the file, read 128 bytes, and if there are no NUL bytes, bash will treat it like a script, and launch a subshell to read it
T 1708461917 18<25greycat18>	but GUI launchers will not do that
T 1708461942 18<29Pikk3wyn18>	gdm definitely works like this, I just don't know how the scripts are named or where to set a custom one
T 1708461969 18<25greycat18>	works like what?
T 1708461985 18<29Pikk3wyn18>	runs some form of startup script for the session
T 1708462010 18<25greycat18>	In Debian, there is .xsessionrc (not .xsession) which even gdm3 will read.  But that's Debian.
T 1708462029 18<25greycat18>	In general, it's a fucking mess.
T 1708462042 18<29Pikk3wyn18>	i agree
T 1708462060 18<29Pikk3wyn18>	i don't bother with a DM, tho I am leaning towards trying 'ly
T 1708462069 18<25greycat18>	I don't either.  I use startx.
T 1708462074 18<29Pikk3wyn18>	ja
T 1708462086 18<29Pikk3wyn18>	it's only a few lines to setup session so why bother with the rest
T 1708462102 18<26HumbleGuy18>	i just inserted the shebag and mentioned full path in the shortcut command
T 1708462119 18<26HumbleGuy18>	#!/bin/bash
T 1708462126 18<29Pikk3wyn18>	as opposed to?
T 1708462127 18<26HumbleGuy18>	but still it doesnt open up
T 1708462134 18<29Pikk3wyn18>	open how
T 1708462140 18<29Pikk3wyn18>	are you expecting a terminal to pop?
T 1708462145 18<26HumbleGuy18>	no, the image
T 1708462151 18<29Pikk3wyn18>	what is the exact command
T 1708462156 18<26HumbleGuy18>	the script contains a simple line with 'feh'
T 1708462161 18<29Pikk3wyn18>	what line
T 1708462164 18<29Pikk3wyn18>	feh can be finnicky
T 1708462170 18<26HumbleGuy18>	#!/bin/bash
T 1708462171 18<26HumbleGuy18>	feh /home/george/.config/scripts/orar/5vineri.png
T 1708462181 18<28bprompt18>	HumbleGuy: may be give us a pastebin look on the script and its path
T 1708462193 18<26HumbleGuy18>	and the script is located in ~/.local/bin/
T 1708462212 18<26HumbleGuy18>	bprompt this is everything the script contains
T 1708462251 18<26HumbleGuy18>	echo $PATH
T 1708462252 18<26HumbleGuy18>	~/.local/bin:/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/lib/jvm/default/bin
T 1708462265 18<29Pikk3wyn18>	HumbleGuy: try have the script do:
T 1708462266 18<29Pikk3wyn18>	lol
T 1708462271 18<29Pikk3wyn18>	wat
T 1708462277 18<29Pikk3wyn18>	how is /bin not in $PATH
T 1708462284 18<26HumbleGuy18>	umm, idk
T 1708462290 18<22tirnanog18>	not needed on a systemd distro, really.
T 1708462298 18<22tirnanog18>	or, rather, ones that have undergone a /usr merge.
T 1708462317 18<25greycat18>	on some systems, /bin is a legacy symlink to /usr/bin
T 1708462318 18<22tirnanog18>	everything is in /usr/bin in Arch.
T 1708462319 18<29Pikk3wyn18>	not important tho cos you used full path anyway
T 1708462329 18<29Pikk3wyn18>	tirnanog: ja, it's beautiful
T 1708462336 18<29Pikk3wyn18>	was just interesting
T 1708462336 18<22tirnanog18>	and I can see that's Arch because I'm a smartarse.
T 1708462338 18<28bprompt18>	hmmm which is most I think, I've seen bin in /usr/bin from a long time ago
T 1708462342 18<29Pikk3wyn18>	HumbleGuy: xterm -- feh /home/george/.config/scripts/orar/5vineri.png
T 1708462355 18<25greycat18>	recent Debian has merged /usr as well
T 1708462359 18<26HumbleGuy18>	tirnanog how did you know
T 1708462364 18<25greycat18>	hobbit:~$ ls -ld /bin
T 1708462364 18<25greycat18>	lrwxrwxrwx 1 root root 7 Feb 17 12:28 /bin -> usr/bin/
T 1708462365 18<29Pikk3wyn18>	xterm '-- feh /home/george/.config/scripts/orar/5vineri.png; read'
T 1708462372 18<22tirnanog18>	greycat: did they go all the way now? /sbin and all?
T 1708462373 18<29Pikk3wyn18>	xterm -- 'feh /home/george/.config/scripts/orar/5vineri.png; read'
T 1708462377 18<29Pikk3wyn18>	or some crap like that
T 1708462383 18<25greycat18>	lrwxrwxrwx 1 root root 8 Feb 17 12:28 /sbin -> usr/sbin/
T 1708462387 18<22tirnanog18>	ah.
T 1708462388 18<29Pikk3wyn18>	so you can atleast see the error if applicable
T 1708462423 18<26HumbleGuy18>	are you sure its correct command Pikk3wyn?
T 1708462430 18<29Pikk3wyn18>	because at this point if it's not showing the image, there is some issue either with it executing at all, or with feh
T 1708462431 18<25greycat18>	Pikk3wyn: xterm -e feh ...
T 1708462432 18<26HumbleGuy18>	xterm: bad command line option
T 1708462439 18<29Pikk3wyn18>	greycat: thanks :)
T 1708462446 18<29Pikk3wyn18>	HumbleGuy: with xterm -e
T 1708462449 18<25greycat18>	but if you really want that ";read" you will need a shell
T 1708462457 18<29Pikk3wyn18>	tru leme make a new line
T 1708462462 18<26HumbleGuy18>	ok so it works with xterm
T 1708462469 18<29Pikk3wyn18>	oh?
T 1708462474 18<29Pikk3wyn18>	what happens
T 1708462488 18<26HumbleGuy18>	the image opens up )
T 1708462497 18<29Pikk3wyn18>	tf
T 1708462508 18<26HumbleGuy18>	but when I do Shift+Super+1 it doesnt
T 1708462508 18<29Pikk3wyn18>	so feh must not be executing before im guessing
T 1708462550 18<26HumbleGuy18>	wdym must not be executing
T 1708462550 18<28bprompt18>	or "feh" is not in "$PATH" as seen by the desktop manager
T 1708462581 18<29Pikk3wyn18>	HumbleGuy: feh must not be executing properly, i am guessing it is not in PATH
T 1708462584 18<22tirnanog18>	if you want to know: exec 2>>"$HOME/feh-wrapper.log"; set -x; ...
T 1708462619 18<26HumbleGuy18>	what is with that ...
T 1708462629 18<25greycat18>	to see if the thing is actually running
T 1708462630 18<22tirnanog18>	that would be where you run feh, as you are presently.
T 1708462632 18<22tirnanog18>	in your script.
T 1708462654 18<22tirnanog18>	add this to your script, on other words.
T 1708462654 18<28bprompt18>	HumbleGuy: do a "whereis feh" to check its path
T 1708462661 18<25greycat18>	type -a feh
T 1708462688 18<26HumbleGuy18>	`/usr/bin/feh /usr/share/feh /usr/share/man/man1/feh.1.gz
T 1708462708 18<25greycat18>	maybe do an "env > ~/env.log" in the script as well
T 1708462730 18<29Pikk3wyn18>	(set -x; &>~/fehlog.txt feh /home/george/.config/scripts/orar/5vineri.png) &>~/trace.txt
T 1708462779 18<26HumbleGuy18>	Pikk3wyn your command opens it up
T 1708462788 18<29Pikk3wyn18>	ehhhhhhhhh
T 1708462800 18<29Pikk3wyn18>	is the subshell reading bashrc or something????
T 1708462802 18<29Pikk3wyn18>	what in tf
T 1708462804 18<29Pikk3wyn18>	oh wait
T 1708462809 18<26HumbleGuy18>	env log: https://0x0.st/H5ik.log
T 1708462817 18<29Pikk3wyn18>	maybe its a bg thing
T 1708462832 18<29Pikk3wyn18>	HumbleGuy: try your old regular feh but add & after?
T 1708462837 18<29Pikk3wyn18>	or just put in a subshell?
T 1708462871 18<29Pikk3wyn18>	surely the subshell should have same env
T 1708462873 18<26HumbleGuy18>	Pikk3wyn what do you refer to by old regular feh
T 1708462884 18<29Pikk3wyn18>	just feh /path/img.png
T 1708462888 18<29Pikk3wyn18>	but add & after
T 1708462907 18<29Pikk3wyn18>	if that doesnt work, try (feh /path/.../img.png)
T 1708462915 18<26HumbleGuy18>	it works
T 1708462923 18<29Pikk3wyn18>	ah
T 1708462936 18<29Pikk3wyn18>	it didn't background the child process
T 1708462941 18<29Pikk3wyn18>	goddamn it lmao
T 1708462949 18<29Pikk3wyn18>	it wasnt even any path issue or anything at all
T 1708462962 18<29Pikk3wyn18>	it literally just didnt background the child XD
T 1708462982 18<29Pikk3wyn18>	good heavens hehe
T 1708462987 18<29Pikk3wyn18>	well, i'm glad its sorted
T 1708463024 18<29Pikk3wyn18>	watch out btw feh will write a .fehbg unless you use --no-fehbg
T 1708463050 18<29Pikk3wyn18>	not sure if it only does with --bg-*
T 1708463099 18<26HumbleGuy18>	this is what is in my .fehbg #!/bin/sh
T 1708463100 18<26HumbleGuy18>	feh --no-fehbg --bg-fill '/home/george/Wallpapers/building.png'
T 1708463114 18<29Pikk3wyn18>	ok sweet it didn't overwrite
T 1708463139 18<29Pikk3wyn18>	watch tho that you keep a backup fehbg incase it overwrites and you lose which file it was
T 1708463152 18<29Pikk3wyn18>	sounds crazy but it's happened to me too many times over the years lol
T 1708463167 18<29Pikk3wyn18>	HumbleGuy: what DE are you using
T 1708463280 18<26HumbleGuy18>	budgie desktop
T 1708463315 18<26HumbleGuy18>	maybe its problem of gdm
T 1708463458 18<26HumbleGuy18>	whoops did you guy say something?
T 1708463479 18<28bprompt18>	nope yet
T 1708463540 18<26HumbleGuy18>	https://wiki.archlinux.org/title/environment_variables#Per_Xorg_session
T 1708463547 18<26HumbleGuy18>	what about this
T 1708463617 18<25greycat18>	are you on Arch?
T 1708463658 18<26HumbleGuy18>	yes
T 1708463672 18<26HumbleGuy18>	how do I write in ~/.config/environment.d/envvars.conf to source .bashrc
T 1708463785 18<22tirnanog18>	you don't. systemd doesn't read such files using a shell, nor execute shell code.
T 1708463816 18<22tirnanog18>	though the syntax is superficially similar.
T 1708463825 18<26HumbleGuy18>	but its written in the wiki
T 1708463848 18<22tirnanog18>	what is?
T 1708463866 18<26HumbleGuy18>	https://wiki.archlinux.org/title/environment_variables#Per_Xorg_session
T 1708463889 18<25greycat18>	Are you trying to obtain the Holy Grail?  A way to configure your login environment that works on ANY system, ANY login method, ANY init system, ANY shell?  It doesn't exist.  There is no Grail.  It is a hopeless quest.
T 1708463937 18<22tirnanog18>	I see nothing there implying that systemd will source and evaluate shell code in the course of applying environtment.d files (which it won't).
T 1708463946 18<25greycat18>	In practice, you will end up needing to write 2-3 different files that possibly all source (or dot in) one master file, and that will just cover the method you personally use on ONE system.
T 1708463989 18<25greycat18>	There are a lot of things out there that LOOK like they might offer you the Grail, but they are all lies.  pam.d's /etc/environment is one.  systemd's environment.d is another.
T 1708464034 18<25greycat18>	(I meant pam_env's /etc/environment there)
T 1708464056 18<26HumbleGuy18>	so in conclusion, what tf do I do now
T 1708464081 18<22tirnanog18>	at best, you could invert the premise, by sourcing environment.d files from a bash dotfile. you would need to avoid any features of the shell that stray outside of the syntax defined by environment.d(5), however.
T 1708464093 18<22tirnanog18>	all that said, I wasn't following from the beginning, so not sure what the goal is.
T 1708464119 18<25greycat18>	I think the initial goal was "I want to configure my GUI so that when I press a certain key combo, it runs a script that I wrote".
T 1708464131 18<25greycat18>	I don't know whether that goal has been solved.
T 1708464166 18<26HumbleGuy18>	no it wasnt
T 1708464179 18<26HumbleGuy18>	basically I want a image to open up when i press a combo on keyboard
T 1708464213 18<25greycat18>	So you've got a script, which has a shebang and +x, right?  And you've put commands in it to log the fact that it gets executed?  Does it get executed?
T 1708464231 18<26HumbleGuy18>	yes, it executes perfectly from cli
T 1708464238 18<26HumbleGuy18>	its just the gui that's dumb
T 1708464243 18<25greycat18>	Does it get executed when you press the magic keys?
T 1708464249 18<22tirnanog18>	so you still haven't checked a trace in the relevant context.
T 1708464253 18<26HumbleGuy18>	tf is a magic key
T 1708464260 18<25greycat18>	whatever the fuck you are configuring
T 1708464268 18<22tirnanog18>	don't be obtuse. the key that invokes the script, obviously.
T 1708464312 18<26HumbleGuy18>	unfortunately, the magic keys are not magicing
T 1708464319 18<25greycat18>	I think you mentioned shift-super-1 or something, though I've never personally seen a keyboard with a Super key
T 1708464364 18<25greycat18>	If your magic key combo does not EXECUTE the script at all, then the problem is in your GUI configs.
T 1708464376 18<22tirnanog18>	do what I said earlier, make sure all prior logging files exist, then issue the key combo.
T 1708464389 18<22tirnanog18>	if the log file springs into existence, you know it's executing at least, regardless of what it contains.
T 1708464414 18<22tirnanog18>	rather, make sure all prior logging files have been removed.
T 1708464429 18<26HumbleGuy18>	wait, ill do a X restart real quick
T 1708464616 18<26HumbleGuy18>	ok so i moved the script to /usr/bin and now the gui executes it fine
T 1708464630 18<26HumbleGuy18>	the problem is the new path isnt detected
T 1708464636 18<22tirnanog18>	where was it prior?
T 1708464649 18<26HumbleGuy18>	~/.local/bin
T 1708464667 18<26HumbleGuy18>	where does the login manager source the variables,
T 1708464671 18<27Soliton18>	just bind to the complete path.
T 1708464672 18<22tirnanog18>	have your script write out env and execute it in the APPROPRIATE context.
T 1708464684 18<22tirnanog18>	by using the key combo again.
T 1708464684 18<26HumbleGuy18>	wdym
T 1708464696 18<22tirnanog18>	env > ~/env.log
T 1708464705 18<26HumbleGuy18>	ok
T 1708464707 18<22tirnanog18>	but launch it with your keyboard shortcut
T 1708464753 18<28bprompt18>	HumbleGuy: or just provide an absolute path to the image
T 1708464764 18<27Soliton18>	s/image/script/
T 1708464770 18<26HumbleGuy18>	https://0x0.st/H5--.log
T 1708464778 18<22tirnanog18>	PATH=/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/lib/jvm/default/bin:/usr/bin/site_perl:/usr/bin/vendor_perl:/usr/bin/core_perl:/usr/lib/rustup/bin
T 1708464781 18<22tirnanog18>	that explains it.
T 1708464798 18<26HumbleGuy18>	yeah, apparently it doesnt source
T 1708464804 18<22tirnanog18>	which display manager do you use?
T 1708464807 18<22tirnanog18>	if any.
T 1708464819 18<26HumbleGuy18>	Mutter (budgie desktop)
T 1708464826 18<22tirnanog18>	that's not a display manager.
T 1708464829 18<22tirnanog18>	is it gdm?
T 1708464839 18<26HumbleGuy18>	oh sorry
T 1708464842 18<26HumbleGuy18>	gdm yes
T 1708464843 18<22tirnanog18>	gdm respects ~/.profile, iirc.
T 1708464852 18<25greycat18>	On *some* systems it might.
T 1708464852 18<26HumbleGuy18>	oh
T 1708464872 18<22tirnanog18>	ok. well, I think it does on this platform. I don't feel like proving it myself right now.
T 1708464884 18<26HumbleGuy18>	what do I write in .profile? to source .bashrc?
T 1708464899 18<26HumbleGuy18>	or have separate path variables
T 1708464900 18<22tirnanog18>	if [ "$BASH" ] && [ -f ~/.bashrc ]; then . ~/.bashrc; fi
T 1708464903 18<22tirnanog18>	will do.
T 1708464903 18<28bprompt18>	HumbleGuy: I can tell  you what I do with my DM, which is LXQT for "global shortcuts", I dump my .sh files in $HOME/bin and since it's in $PATH, I just launch the FILENAME.sh from there, in the .sh file is #!/bin/bash and the command(s) and all the arguments, quoted as needed
T 1708464905 18<25greycat18>	test -r ~/.bashrc && . ~/.bashrc
T 1708464918 18<25greycat18>	tirnanog: ah, checking $BASH is also nice
T 1708464919 18<22tirnanog18>	it needs to be guarded for ~/.profile, really
T 1708464921 18<22tirnanog18>	yeah
T 1708464943 18<26HumbleGuy18>	bprompt hos is $HOME/bin in PATH, only you have this
T 1708464949 18<22tirnanog18>	so try doing that and altering PATH there instead.
T 1708464954 18<22tirnanog18>	then logging in again.
T 1708464965 18<27Soliton18>	all this to avoid writing the full path to the script?
T 1708464966 18<25greycat18>	Try not needing a special PATH when you launch these things with keys.
T 1708464975 18<28bprompt18>	HumbleGuy: yes, I added it in .bashrc
T 1708464977 18<25greycat18>	As we've said about 10 times nwo.
T 1708465027 18<22tirnanog18>	.bashrc is no good for such.
T 1708465029 18<26HumbleGuy18>	tirnanog I alter now the path from bashrc or profile
T 1708465034 18<22tirnanog18>	Soliton: not contesting it is a perfectly reasonable solution.
T 1708465040 18<22tirnanog18>	do _not_ use .bashrc to do it.
T 1708465048 18<22tirnanog18>	it absolutely won't help.
T 1708465132 18<26HumbleGuy18>	Soliton no full path wont solve this apparently
T 1708465149 18<22tirnanog18>	poor Soliton
T 1708465152 18<22tirnanog18>	:(
T 1708465169 18<22tirnanog18>	that actually hurt my brain.
T 1708465175 18<26HumbleGuy18>	tirnanog to make sure, This implies i write the PATH in .profile AND remove it from .bashrc for no repitition
T 1708465187 18<26HumbleGuy18>	tirnanog gotta keep that grey matter working
T 1708465198 18<28bprompt18>	HumbleGuy:  wait, I don't have it in .bashrc hmmm, it may be coming from /etc/profile
T 1708465202 18<22tirnanog18>	working, yes. atrophying, preferably not.
T 1708465223 18<22tirnanog18>	that is, it makes no sense whatsoever to say that specifying the full path to something doesn't solve it.
T 1708465230 18<22tirnanog18>	an absolute path suppresses PATH lookup.
T 1708465251 18<26HumbleGuy18>	oh so that doesnt make sense then
T 1708465253 18<22tirnanog18>	anyway, yes. if you're going to faff with PATH, try it in ~/.profile and nowhere else.
T 1708465307 18<26HumbleGuy18>	ill do a X restart again
T 1708465319 18<28bprompt18>	HumbleGuy: yeap, that's where I added ~/bin at ~/.profile  , mind you that I did a long long time ago
T 1708465377 18<27Soliton18>	maybe full path for them means ~/...
T 1708465382 18<22tirnanog18>	probably.
T 1708465393 18<22tirnanog18>	definitely not the sharpest tool in the shed, so to speak.
T 1708465403 18<27Soliton18>	humble though
T 1708465424 18<28bprompt18>	some DM well, depends on what's being run, don't like ~/, or $HOME,
T 1708465481 18<27Soliton18>	there should be little expectation that a random program supports ~ like a shell.
T 1708465504 18<20cappy18>	Trying to locate ELF objects in a project hierarchy with this:
T 1708465504 18<27Soliton18>	there certainly are some that do though.
T 1708465508 18<20cappy18>	find . -exec file {} \; | grep -i elf | awk '{print $1}'
T 1708465536 18<22tirnanog18>	it will be horrifying slow and clunky. do yourself a favour and install pax-utils for scanelf.
T 1708465552 18<26HumbleGuy18>	Apparently my gdm login is not working anymore
T 1708465555 18<26HumbleGuy18>	Wtf happened
T 1708465556 18<28bprompt18>	wb HumbleGuy
T 1708465556 18<20cappy18>	Is there a better tool? Specifically, I'm using Rust cargo(1) and the --release option removes too much.
T 1708465576 18<22tirnanog18>	scanelf(1)
T 1708465589 18<28bprompt18>	HumbleGuy: yeap, that's where I added ~/bin at ~/.profile  , mind you that I did a long long time ago
T 1708465599 18<20cappy18>	tirnanog: pax-utils, yes. Thank you.
T 1708465606 18<27Soliton18>	HumbleGuy: how did you specify the full path?
T 1708465620 18<22tirnanog18>	cappy: take a look at its formatting options too (-F)
T 1708465622 18<28bprompt18>	HumbleGuy: gdm login not working?
T 1708465634 18<20cappy18>	tirnanog: Will do. Tks.
T 1708465645 18<22tirnanog18>	cappy: the only bad thing about it is that it can't produce NUL-delimited output, so pathnames containing $'\n' shouldn't be fed to it.
T 1708465652 18<26HumbleGuy18>	No, the password is not working for gdm
T 1708465661 18<26HumbleGuy18>	Tyy still can login
T 1708465670 18<20cappy18>	tirnanog: Appreciate the pointer.
T 1708465728 18<22tirnanog18>	HumbleGuy: did you lock yourself out by any chance? faillock
T 1708465749 18<26HumbleGuy18>	Yes, but i got acces to tty
T 1708465751 18<22tirnanog18>	(that's a utility)
T 1708465768 18<22tirnanog18>	I'm enquiring about the pam_lock mechanism specifically.
T 1708465772 18<26HumbleGuy18>	Why in the world would my password break
T 1708465778 18<22tirnanog18>	(sigh)
T 1708465784 18<22tirnanog18>	faillock
T 1708465788 18<22tirnanog18>	see if that prints anything.
T 1708465800 18<26HumbleGuy18>	It says valid
T 1708465819 18<22tirnanog18>	but doesn't show any user as being locked out?
T 1708465826 18<26HumbleGuy18>	No
T 1708465839 18<22tirnanog18>	not that then.
T 1708465842 18<26HumbleGuy18>	Do you still have the history? What did I do
T 1708465845 18<26HumbleGuy18>	I hate this
T 1708465875 18<22tirnanog18>	we don't know what you did. if you want for .profile to be reviewed, you can pastebin it however.
T 1708465895 18<22tirnanog18>	pacman -S --needed openbsd-netcat && nc termbin.com 9999 < ~/.profile
T 1708465925 18<22tirnanog18>	well
T 1708465933 18<22tirnanog18>	pacman will need root privs so do that separately.
T 1708465944 18<22tirnanog18>	point is, you can use nc to pastebin your personal ~/.profile
T 1708465972 18<26HumbleGuy18>	https://0x0.st/H5-c.txt
T 1708466016 18<22tirnanog18>	that syntax is perfectly legit.
T 1708466025 18<22tirnanog18>	I don't know what your issue is then.
T 1708466043 18<26HumbleGuy18>	I edited /etc/environment
T 1708466101 18<28bprompt18>	hmmm this is a stretch, if one "sudo" to edit the .profile, that may change the owner or its permissions
T 1708466112 18<26HumbleGuy18>	Its just export PATH="~/. local/bin:$PATH"
T 1708466125 18<26HumbleGuy18>	I didn't use sudo
T 1708466131 18<22tirnanog18>	that's not valid pam_environment syntax. get rid of it.
T 1708466148 18<22tirnanog18>	pam_env, even
T 1708466167 18<22tirnanog18>	(/etc/environment is also not processed by a shell)
T 1708466187 18<28bprompt18>	HumbleGuy: maybe with -> PATH="$HOME/. local/bin:$PATH"
T 1708466192 18<22tirnanog18>	please undo whatever other silly changes like that are that may have been made. ~/.profile is fine.
T 1708466210 18<22tirnanog18>	no. just get rid of it.
T 1708466225 18<26HumbleGuy18>	It still doesn't allow me to log jn tf
T 1708466245 18<26HumbleGuy18>	Do i also remove.profile?
T 1708466278 18<22tirnanog18>	the syntax is fine. if you want to rule it out for your own peace of mind, just rename it to something else.
T 1708466286 18<22tirnanog18>	like .profile.bak
T 1708466332 18<26HumbleGuy18>	Oh so after i removed .profile it allowed me to log in
T 1708466347 18<26HumbleGuy18>	Tf
T 1708466350 18<22tirnanog18>	in that case, can you also share ~/.bashrc?
T 1708466353 18<28bprompt18>	heheh
T 1708466354 18<22tirnanog18>	something doesn't add up.
T 1708466369 18<25greycat18>	... are people STILL looking for that Grail even after my speech?
T 1708466379 18<28bprompt18>	I'm guessing, and this is a stretch, it may just have been permissions change upon the editing to .profile
T 1708466393 18<27Soliton18>	i think they just didn't manage to specify the full path correctly.
T 1708466422 18<27Soliton18>	and then did all kinds of other nonsense to do it differently.
T 1708466442 18<22tirnanog18>	greycat: look on the bright side. it wasn't that long ago they were contemplating the imaginary sourcing of ~/.bashrc from environment.d context
T 1708466453 18<26HumbleGuy5718>	https://0x0.st/H5-2.txt
T 1708466454 18<25greycat18>	STOP trying to set your environment using system resources like /etc/environment.  It's a dead end.  It will not work.  Configure your GUI LAUNCHER to run the FULL PATH of the script.
T 1708466460 18<22tirnanog18>	there's also imaginary syntax in /etc/environment which has hopefully gone by now.
T 1708466512 18<26HumbleGuy5718>	greycat i tried that before and full path is just not doing anything
T 1708466518 18<26HumbleGuy5718>	maybe something like exec
T 1708466524 18<27Soliton18>	what is the full path?
T 1708466529 18<26HumbleGuy5718>	or wait, I could dirrectly insert
T 1708466535 18<22tirnanog18>	HumbleGuy57: ok. well, short of the file not being readable, I have no idea what happened there. it was valid sh syntax.
T 1708466545 18<25greycat18>	If the script needs to run commands that are not in a default location (like /usr/bin or /usr/local/bin) then either set PATH *inside* that script, or use full command paths inside the script.
T 1708466556 18<27Soliton18>	note that a full path does start with / not with ~/ or something.
T 1708466556 18<26HumbleGuy5718>	Soliton ~/.local/bin/orar-vineri
T 1708466561 18<26HumbleGuy5718>	that is full path
T 1708466564 18<27Soliton18>	nonsense...
T 1708466566 18<27larryv18>	:-/
T 1708466579 18<25greycat18>	That's a piece of shell syntax that might EXPAND to a full path.
T 1708466595 18<25greycat18>	But if you use that in a place that doesn't do tilde expansion, then it won't expand.
T 1708466677 18<26HumbleGuy5718>	i just tried the full /home/.. path and still nothing
T 1708466688 18<26HumbleGuy5718>	it reads values only from /usr/bin
T 1708466699 18<25greycat18>	... what "values" are you talking about?
T 1708466712 18<26HumbleGuy5718>	the executable*
T 1708466722 18<25greycat18>	also, "it reads" implies "it executed", so that's a positive
T 1708466766 18<27Soliton18>	i think they're just wildly guessing.
T 1708466766 18<26HumbleGuy5718>	yes
T 1708466782 18<25greycat18>	So when you say "and still nothing", you actually mean that the script executed, but ran into an error when it tried to run one specific command?
T 1708466886 18<26HumbleGuy5718>	I meant it didnt execute, but I tried writing full path again and it works...
T 1708466898 18<26HumbleGuy5718>	I assume the GUI is buggy af and didnt save
T 1708466941 18<25greycat18>	Yeah, right, the GUI must be buggy.  There's no way it could have been user error.
T 1708466968 18<27Soliton18>	humble af
T 1708466995 18<26HumbleGuy5718>	;9
T 1708467051 18<26HumbleGuy5718>	i apologize for confusion
T 1708467093 18<22tirnanog18>	unrelated but export PATH="~/.local/bin:$PATH" is wrong. I understand that it's commented out, but the syntax is wrong. the tilde would not be expanded there.
T 1708467112 18<22tirnanog18>	($HOME would work)
T 1708467122 18<25ormaaj18>	tirnanog: nope. bash is stupid.
T 1708467126 18<22tirnanog18>	oh, really.
T 1708467128 18<25ormaaj18>	yep
T 1708467130 18<25greycat18>	$HOME would work if this is a shell command.  Not in /etc/environment.
T 1708467135 18<25ormaaj18>	stupid/insane
T 1708467150 18<22tirnanog18>	ormaaj: explain then?
T 1708467166 18<25greycat18>	# PATH="~/x:$PATH"; declare -p PATH
T 1708467167 18<25shbot18>	greycat: declare -x PATH="~/x:/usr/bin:/bin"
T 1708467180 18<22tirnanog18>	what exactly am I getting wrong?
T 1708467188 18<25greycat18>	# export PATH="~/x:$PATH"; declare -p PATH
T 1708467189 18<25shbot18>	greycat: declare -x PATH="~/x:/usr/bin:/bin"
T 1708467198 18<25greycat18>	I don't think you're wrong.
T 1708467199 18<22tirnanog18>	nothing. ok.
T 1708467324 18<26HumbleGuy5718>	what is happening
T 1708467428 18<27larryv18>	that is what i've been wondering for the last 100 minutes or so
T 1708467456 18<25ormaaj18>	# mkdir tmp; printf '#!/usr/bin/env bash\necho hi' >~/tmp/durr; chmod u+x ~/tmp/durr; PATH+=:\~/tmp bash +O sourcepath -c durr
T 1708467457 18<25shbot18>	ormaaj: hi
T 1708467561 18<25ormaaj18>	I guess we are not sourcing here so that part is irrelevant but I normally disable that anyway
T 1708467691 18<26HumbleGuy18>	ormaaj: where did you learn this scripting skills? How do I go your path
T 1708467717 18<27userdocss18>	chatgpt
T 1708467754 18<22tirnanog18>	don't. just don't.
T 1708467764 18<25greycat18>	ormaaj is not the role model you should follow
T 1708467778 18<25ormaaj18>	don't go ormaaj's path :o
T 1708467793 18<28emanuele618>	don't  cd ~ormaaj
T 1708467816 18<22tirnanog18>	I was thinking of chatgpt but now you mention it ... :D
T 1708467842 18<29Angels18>	Oh no..
T 1708467847 18<29Angels18>	Not again..
T 1708467849 18<25greycat18>	So, I believe you're saying that a literal ~ inside PATH will be expanded by bash when searching for commands, not that X="~/Y" will expand the tilde.
T 1708467858 18<25ormaaj18>	yes
T 1708467862 18<29Angels18>	I adore LLMs are prohibited in some chats like #php.
T 1708467871 18<29Angels18>	Thank you, #php.
T 1708467904 18<25ormaaj18>	bash basically has a custom execp (that certainly will disagree with that of libc)
T 1708467990 18<22tirnanog18>	yet another misfeature. damn and blast.
T 1708468019 18<25ormaaj18>	spoiler - Chet doesn't care. Surprise.
T 1708468035 18<22tirnanog18>	right. of course.
T 1708468091 18<27larryv18>	# echo 'echo hi' >foo; chmod +x foo; PATH='~'; foo
T 1708468092 18<25shbot18>	larryv: hi
T 1708468096 18<27larryv18>	# echo 'echo hi' >foo; chmod +x foo; PATH='~' foo
T 1708468098 18<25shbot18>	larryv: hi
T 1708468110 18<27larryv18>	# echo 'echo hi' >foo; chmod +x foo; set -o posix; PATH='~' foo
T 1708468111 18<25shbot18>	larryv: bash: foo: command not found
T 1708468132 18<25ormaaj18>	ahahaha
T 1708468171 18<27larryv18>	oops, thought this was the shbot PM. but was gonna drop that in here anyway, so it worked out
T 1708468187 18<27JAA18>	Nice
T 1708468196 18<22tirnanog18>	not even remotely nice.
T 1708468488 18<27larryv18>	i guess that's #19? i like the features that are only documented by way of POSIX mode turning them off https://www.gnu.org/software/bash/manual/html_node/Bash-POSIX-Mode.html
T 1708468545 18<25ormaaj18>	yeah I didn't even know posix mode affected it
T 1708468828 18<27userdocss18>	tirnanog: copilot autocomplete is an adventure.
T 1708468935 18<22tirnanog18>	a curious mispelling of aberration, perhaps.
T 1708469208 18<27userdocss18>	it's ok, it's are learning from my code, you have nothing to fear.
T 1708469252 18<25ormaaj18>	kurahaupo:
T 1708469260 18<25ormaaj18>	(ins)ormaaj 10 (586072) 0 ~/doc/programs/zsh-code $ zsh --emulate ksh /proc/self/fd/9 9<<\EOF
T 1708469260 18<25ormaaj18>	function f { typeset -n x=$1; print -r -- "${| typeset IFS=$'\U2022'; printf -v REPLY '%s ' "${!x}" "${x[*]}";}"; }
T 1708469260 18<25ormaaj18>	function _m { typeset -a a=({a..c}{1..3}); f a; }; _m "$@"
T 1708469260 18<25ormaaj18>	EOF
T 1708469260 18<25ormaaj18>	a a1•a2•a3•b1•b2•b3•c1•c2•c3
T 1708470151 18<25ormaaj18>	greycat jelly
T 1708473217 19*	Now talking on 22#bash
T 1708473217 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1708473217 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1708479700 18<26lockywolf18>	Is there some straightforward way to exit a script with meaningful error codes? Like  exit $EAGAIN , where EAGAIN is whatever EAGAIN is on current system?
T 1708480016 18<20arraybolt318>	if a subcommand fails and you know it's because of an EAGAIN, you could store its return value in a variable and then exit with that?
T 1708480030 18<20arraybolt318>	er, a command you ran within your script
T 1708480061 18<20arraybolt318>	I'm not used to errors like that being *process* return values though. Those are more like C error codes, no?
T 1708480084 18<20arraybolt318>	usually you define what error codes mean in your documentation and then stick to whatever those meanings are
T 1708480119 18<20arraybolt318>	usually something like 0 = success, 1 = partial failure, 2 = total failure, 127 = severe initialization error, etc. document all those so that people who use your script or program know what they mean
T 1708480136 18<27larryv18>	they are errno values, yes. lockywolf is conflating them with exit values.
T 1708480550 18<22pj18>	I don't know of a pure-bash way but you can get them from another language such as perl and then use it in a bash exit code.
T 1708480619 18<27larryv18>	i'm not even sure why you'd want to do that. the script probably cannot reliably determine which errno applies to any particular problem
T 1708480708 18<22pj18>	indeed, any other calling script owuld need a similar mechanism to know what the returned value means.
T 1708480757 18<26lockywolf18>	I know the difference between error codes and errnos. And I am aware that error codes are not standardized beyond 0=success. But using errno statuses as exit codes is better than nothing. At least some kind of standard.
T 1708480792 18<27larryv18>	not really
T 1708480800 18<26lockywolf18>	Also, dcron uses the exit status of EAGAIN to restart failed tasks, so I am not the first one to consider this.
T 1708480806 18<22pj18>	Honestly if you want your error numbers to match those in error.h then just look up the ones you want in your errno.h and document them as exit codes for your script.
T 1708480808 18<27larryv18>	using the errno.h values is no better than making up and documenting your own exit values
T 1708480868 18<27larryv18>	it's feasible for a real program to do this. not a shell script
T 1708480973 18<27larryv18>	any given utility it calls probably fails with an exit status of 1, providing no information
T 1708480997 18<22tirnanog18>	the numbers aren't portable anyway.
T 1708481011 18<22tirnanog18>	they're just magic numbers.
T 1708481029 18<27JAA18>	Just implement an errno.h parser. ;-)
T 1708481587 18<22pj18>	if you must, and you have perl on your system you can do this: errno () { perl -MErrno -le 'print ${$Errno::{$ARGV[0]}}' "$1"; }
T 1708481631 18<20twkm18>	i'm surprised no mentionn of moreutils.
T 1708481657 18<27JanC18>	I was just about to mention it  :)
T 1708481665 18<29nightstrike18>	is there an easy to do a grep -v with context? I need to remove a matching line, one line after, and two lines before
T 1708481665 18<22pj18>	no idea how to do it with moreutils
T 1708481682 18<29nightstrike18>	or sed or awk or whatever
T 1708481689 18<29nightstrike18>	or native bash :)
T 1708481691 18<20twkm18>	use awk or perl or ... not grep.
T 1708481703 18<20twkm18>	bash can do it too, but slowly.
T 1708481910 18<27JanC18>	https://manpages.org/errno from moreutils
T 1708481930 18<29nightstrike18>	I was trying something like `./program | grep XX -C1 | grep -v -f -`
T 1708481942 18<29nightstrike18>	(I'll fix the C1 when I get something working)
T 1708481956 18<26lockywolf18>	twkm: thanks!
T 1708481962 18<26lockywolf18>	errno is fairly brilliant
T 1708482007 18<26lockywolf18>	I am using sponge and ts from it quite a lot.
T 1708482025 18<26lockywolf18>	ts has a leak somewhere, and sometimes hangs, but is still useful
T 1708482390 18*	20bent_fingers mourns for all those electrons who sacrificied their lives in the making of bash
T 1708482426 18<20bent_fingers18>	how many bytes of code were thrown away!?
T 1708482530 18<20bent_fingers18>	we've all got nuclear blood on our hands
T 1708482569 18<26lockywolf18>	bash is a nice tool
T 1708482580 18<20bent_fingers18>	have you ever used it?
T 1708482656 18<20bent_fingers18>	once you go bash you never go back
T 1708482715 18<20bent_fingers18>	i doubt anyone has ever really used bash
T 1708482863 18<19golu818>	Have you guys had experienced with Eshell?
T 1708483088 18<25kurahaupo18>	lockywolf: you can't simply exit with an errno value, you'll wind up conflicting with different expected usage. In any case the semantics of an entire program are much more nuanced than a single syscall: for example, ENOENT would be quite unhelpful if you don't know which file path caused it. If you're just looking for "something more standardized", look at #include <sysexits.h>
T 1708483348 18<26lockywolf18>	kurahaupo: thank you!
T 1708483369 18<20twkm18>	heh, sendmail to the rescue.
T 1708483399 18<20twkm18>	golu8: i usually start a full shell rather than emacs' eshell.
T 1708483406 18<25kurahaupo18>	exit codes 126 thru 160-ish are consistently used by shells to indicate either failure to launch a program or that it died due to a signal; if you used 127 as "initialisation error" you'd probably confuse people. Codes 64-80 are defined by sysexits.h (though few new programs use them, on account of posix specifying that standard utilities must use 0/1/2, and everyone else just copying that).
T 1708483537 18<25kurahaupo18>	Exit code 255 often means "the programmer didn't read the man page for "exit" and assumed they could write exit(-1), d'oh!"
T 1708483917 18<20bent_fingers18>	if you stand for bash you stand for all shells
T 1708483925 18<20bent_fingers18>	except for powershell
T 1708483960 18<20twkm18>	it isn't a posix shell but it is a lot closer than cmd.
T 1708484176 18<29nightstrike18>	I'm not getting closer...   `./program |& sed -e'1N;$!N;/\n.*match/,+2d;!P;D'`
T 1708484268 18<29nightstrike18>	if only grep -A1 -B2 -v match worked
T 1708484610 18<29nightstrike18>	ok, so...  `sed -e '/match/,+1d'` deletes the match and the next two...   `sed -e 'N;/match/!P;D'` deletes the match and the one before....   just gotta combine these somehow
T 1708484681 18<29nightstrike18>	ah, and I'm backwards.. I need 2 prev and 1 after
T 1708484896 18<25ormaaj18>	those generally aren't useful without labels and loops
T 1708484909 18<25ormaaj18>	if you need loops quit using sed
T 1708485138 18<25ormaaj18>	unless you're isabella and need a cube simulator.
T 1708485169 18<25ormaaj18>	sed is evidently the best tool for that
T 1708485194 18<22tirnanog18>	just use ed like a chad.
T 1708485202 18<22tirnanog18>	printf %s\\n 'g/match/-2,+1d' ,p  | ed -s <(./program)
T 1708485244 18<22tirnanog18>	or <(./program 2>&1) going by your use of |&
T 1708485304 18<22tirnanog18>	# printf %s\\n 'g/^5$/-2,+1d' ,p  | ed -s <(printf %s\\n {1..10}) | xargs
T 1708485306 18<25shbot18>	tirnanog: 1 2 7 8 9 10
T 1708485471 18<25kurahaupo18>	nightstrike: what do you expect !P to do?
T 1708485492 18<29nightstrike18>	no idea, I was copying SO answers :P
T 1708485520 18<25ormaaj18>	Can ex do programmatic replacements without injecting a string into an expression?
T 1708485533 18<29nightstrike18>	I'm down a rabbit hole currently with /begin/,/end/ matching now, though I would need /begin/ to restart when it hits a new /begin/ without hitting an /end/ yet
T 1708485562 18<29nightstrike18>	ormaaj: what's a cube simulator?
T 1708485573 18<25kurahaupo18>	nightstrike: have you read the manual for sed?
T 1708485583 18<25kurahaupo18>	"man sed"
T 1708485719 18<25ormaaj18>	https://github.com/izabera/cube
T 1708485742 18<25kurahaupo18>	nightstrike: any time you have a two-address command, it operates as a bistable ("flip flop"), turning on when the first condition is met, then turning off after the second condition is met
T 1708485757 18<25kurahaupo18>	ormaaj: yep, that's awesome
T 1708485827 18<25kurahaupo18>	ormaaj: next challenge: write a single regex to match a decimal number that's a multiple of seven?
T 1708485936 18<25ormaaj18>	!dephyer
T 1708485936 18<29greybot18>	# seq 9 | sort -R | tee >({ tr \\n ' '; echo; } >&2) | sed -Ee 'y/zwixuvoenrf/02654718935/;s/th?|51|s8?//;s/(.).*/\1     /' | tr \\n ' '; echo
T 1708485938 18<25shbot18>	greybot: nine three eight seven six one two four five
T 1708485938 18<25shbot18>	greybot: 9      3      8      7      6      1      2      4      5
T 1708486364 18<29nvz18>	o.O
T 1708486621 18<25ormaaj18>	I could have done a better job with the pipes
T 1708486697 18<20bent_fingers18>	# printf "%s " {1..100} | sed 's/[0-9]/echo/g'
T 1708486698 18<25shbot18>	bent_fingers: echo echo echo echo echo echo echo echo echo echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echo\
T 1708486698 18<25shbot18>	bent_fingers: echo echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho echoecho\
T 1708486698 18<25shbot18>	bent_fingers:  echoecho echoecho echoecho echoecho echoecho echoecho echoechoecho
T 1708486753 18<27larryv18>	k
T 1708486783 18<27JAA18>	Huh. I guess it only pastes for more than 4 messages?
T 1708486799 18<27JAA18>	The backslashes are a nice touch.
T 1708486842 18<20bent_fingers18>	something had to hold them up
T 1708486850 18<27larryv18>	# printf %s\\n {1..4}
T 1708486852 18<25shbot18>	larryv: 1
T 1708486852 18<25shbot18>	larryv: 2
T 1708486852 18<25shbot18>	larryv: etc... ( http://paste.wooledge.org/28734 )
T 1708486869 18<27JAA18>	Er, I meant 4 or more.
T 1708486897 18<22tirnanog18>	it counts lines, not 'messages'.
T 1708486913 18<22tirnanog18>	therein lies the problem in this instance.
T 1708486924 18<27JAA18>	Does it? So producing one very long line of output will just spam the channel for a long time?
T 1708486954 18<20bent_fingers18>	"the problem doesn't lie within bent_fingers" - tirnanog
T 1708486986 18<22tirnanog18>	interesting use of quotation marks there.
T 1708487021 18*	20bent_fingers adds his newly received panegyric to his resume
T 1708487103 18<27JAA18>	tirnanog: Nope, it does count messages after splitting lines.
T 1708487113 18<27JAA18>	# for i in {1..500}; do printf %s\  echo; done
T 1708487116 18<25shbot18>	JAA: echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo \
T 1708487116 18<25shbot18>	JAA: echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo echo \
T 1708487116 18<25shbot18>	JAA: etc... ( http://paste.wooledge.org/28739 )
T 1708487118 18<22tirnanog18>	ffs
T 1708487124 18<22tirnanog18>	is this really necessary?
T 1708487126 18<28emanuele618>	i knew that
T 1708487142 18<20bent_fingers18>	yours is better than mine 😔
T 1708487153 18<20bent_fingers18>	proper spacing
T 1708487182 18*	20bent_fingers vows to avenge this defeat
T 1708487184 18<27larryv18>	doesn't really do the same thing.
T 1708487191 18<22tirnanog18>	time to update my filters.
T 1708487241 18<27JAA18>	Is disproving incorrect claims necessary? Yeah, I think so.
T 1708487278 18<22tirnanog18>	plonk
T 1708487332 18<28emanuele618>	plunk
T 1708487349 18<27JAA18>	plönk
T 1708487411 18<28emanuele618>	プロンク
T 1708487468 18<29nvz18>	ormaaj: I am still confused
T 1708487537 18*	29nvz doesn't understand what just happened back there
T 1708487566 18<28emanuele618>	if you are wondering how  one two three  etc got generated that is shbot's seq
T 1708487576 18<28emanuele618>	# seq 1 9 | paste -s -
T 1708487577 18<25shbot18>	emanuele6: one     two     three   four    five    six     seven   eight   nine
T 1708487587 18<29nvz18>	yes, that part did confuse me the most
T 1708487590 18<28emanuele618>	it outputs works instead of decimal
T 1708487601 18<28emanuele618>	s/works/words/;s/decimal/&s/
T 1708487639 18<29nvz18>	but the whole bit of it totally confounded me.. I'm finding myself questioning reality after that :P
T 1708487703 18<29nvz18>	things like that are why I stay away from perl, now I'm suddenly afraid of bash.. cause I have little understanding about what happened there :P
T 1708487737 18<29nvz18>	that was black magic to me
T 1708487756 18<20bent_fingers18>	someone's a witch
T 1708487790 18<29nvz18>	yeah, I think I need to go get the towns people and we need to burn us a witch
T 1708487797 18*	20bent_fingers removes black, wide-brimmed conical hat
T 1708487828 18<27JAA18>	There are some fun quirks in shbot where it doesn't do what you'd normally expect. :-)
T 1708487874 18<27JAA18>	# yes | head -1
T 1708487875 18<25shbot18>	JAA: n
T 1708487905 18<28emanuele618>	# <<< '[hi]' rev
T 1708487907 18<25shbot18>	emanuele6: [ih]
T 1708488002 18<28emanuele618>	also during april 1st UTC, it replaces anywhere in the output certain keywords (e.g. zzz, cat, cow) with the corresponding emoji
T 1708488097 18<27JAA18>	Oh, right!
T 1708488180 18<27JAA18>	Also smileys etc.
T 1708489977 18<19brancher18>	Damn shellcheck is nice!
T 1708490082 18<20tanath18>	add this and it's nicer https://github.com/itspriddle/vim-shellcheck
T 1708490115 18<19han-solo18>	!beer
T 1708490127 18*	19brancher beers han-solo
T 1708490140 18<19brancher18>	tanath yeah I use VSC
T 1708490175 18<20tanath18>	still nicer :P
T 1708490203 18<27larryv18>	brancher: https://github.com/vscode-shellcheck/vscode-shellcheck
T 1708490206 18<19brancher18>	tanath there is not much in my code as I code pretty consistent and read a lot about the code. This is just the finish in touch for me
T 1708490234 18<19brancher18>	larryv whats different about my installed version ?
T 1708490278 18<19brancher18>	what feels stange is that those modules are always so old :P
T 1708490282 18<19brancher18>	strange
T 1708490330 18<20tanath18>	still works though
T 1708490340 18<19brancher18>	yap
T 1708490344 18<19brancher18>	with most
T 1708490360 18<19brancher18>	but no-one ever wants to update them when they don't anymore
T 1708490401 18<19brancher18>	anyways.Whats wrong these days with foo="${otherFoo[@]}" ?
T 1708490409 18<20tanath18>	sometimes they don't need any more updates though. i'm iffy about stuff that hasn't been updated in a long time too, but i tried it and it still works
T 1708490452 18<19brancher18>	indeed I like to write code that doesn't need updates, and I do, also on PHP
T 1708490478 18<27larryv18>	brancher: there's nothing *wrong* with it, strictly speaking, but it is generally a bug.
T 1708490510 18<27larryv18>	the misconception being that foo will end up being array with the same contents as otherFoo
T 1708490514 18<27larryv18>	*an array
T 1708490588 18<19brancher18>	larryv ah ok, I like those bugs when they are consistent. I  also do things like... put a string in a foreach and it just runs once... put an array in it and it does the same job
T 1708490604 18<19brancher18>	comma seperated strings...
T 1708490636 18<19brancher18>	larryv yes but printable and reusable
T 1708490642 18<27larryv18>	i don't really know what you're talking about.
T 1708490666 18<19brancher18>	easy parsing extendable too!
T 1708490697 18<27larryv18>	anyway foo=${bar[@]} sets foo to the expansion of bar with each element separated by a space. generally not what is intended
T 1708490723 18<27larryv18>	# bar=(a b c); foo1=${bar[@]}; foo2=("${bar[@]}"); declare -p foo1 foo2
T 1708490725 18<25shbot18>	larryv: declare -- foo1="a b c"
T 1708490725 18<25shbot18>	larryv: declare -a foo2=([0]="a" [1]="b" [2]="c")
T 1708490785 18<19brancher18>	larryv and those strings are great!
T 1708490797 18<19brancher18>	shellcheck is not really curly minded
T 1708490811 18<27larryv18>	storing arrays as strings is not great.
T 1708491004 18<19brancher18>	I did not say I stored arrays in there, I needed the strings like that after generating those arrays
T 1708491356 18<26tykling18>	if I run a command over ssh and press control-c how can I ensure that the command doesn't keep running on the remote host after my ssh is stopped by ctrl-c?
T 1708491395 18<28martylake18>	Is it possible to expand aliases when pressing space ?
T 1708491404 18<26tykling18>	I run bash on the local and on the remote but since the command is a python script this might not even be a bash question, so apologies in advance :)
T 1708491494 18<28martylake18>	I know I can expand aliases with a shortcut, I just want to expand it always so I wonder if I could do `bind '" ": alias-expand-line && insert-space'`
T 1708491599 18<19brancher18>	lol when you create avariabe foo_args then shellcheck thinks you are expanding an array because of ar
T 1708491608 18<19brancher18>	variable
T 1708492036 18<26tykling18>	ssh -t -t seems to do the trick :)
T 1708492590 18<25ormaaj18>	!forget dephyer
T 1708492590 18<29greybot18>	OK, ormaaj
T 1708492602 18<25ormaaj18>	!learn dephyer # seq 9 | sort -R | sed -Ee 'h;y/zwixuvoenrf/02654718935/;s/th?|51|s8?//;s/(.).*/\1/;G' | paste -sd ' ' - -
T 1708492602 18<29greybot18>	OK, ormaaj
T 1708493450 18<19brancher18>	ormaaj never forget!
T 1708493459 18<19brancher18>	l8er!
T 1708501390 18<20isabella18>	ormaaj: there's zero loops in my cube.sed
T 1708501444 18<20isabella18>	basically no repeated operations at all
T 1708501459 18<20isabella18>	closest thing to that is s/foo/bar/g
T 1708501525 18<20isabella18>	ah no i was wrong!  i'm sorry!  i loop over the moves in the string, but each move has nothing to repeat
T 1708501759 18<25ormaaj18>	:o
T 1708507893 19*	Now talking on 22#bash
T 1708507893 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1708507893 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1708508320 19*	Now talking on 22#bash
T 1708508320 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1708508320 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1708510927 18<28rlikon18>	greets
T 1708510970 18<28rlikon18>	is it possible to output to stdout when something expects a file?
T 1708511016 18<27Earnestly18>	/dev/stdout is typically available
T 1708511051 18<28rlikon18>	no such a dev
T 1708511256 18<27Soliton18>	>(cat)
T 1708511313 18<28rlikon18>	not working
T 1708511333 18<28rlikon18>	by the way, program in question: pdftotext
T 1708511337 18<27Soliton18>	# echo foo > file; cp file >(cat)
T 1708511338 18<25shbot18>	Soliton: foo
T 1708511374 18<27Soliton18>	if the program wants to seek in the file or something then it's not going to work.
T 1708511393 18<28rlikon18>	it somehow expects a file
T 1708511439 18<28rlikon18>	tried this $(>(cat)), but no go
T 1708511488 18<27Earnestly18>	pdftotext supports - for both input and output, > If text-file is not specified, pdftotext converts file.pdf to file.txt.  If text-file is ´-', the text is sent to stdout.  If PDF-file is ´-', it reads the PDF file from stdin.
T 1708511552 18<29sixwheeledbeast18>	pdftotext file.pdf -
T 1708511566 18<27Soliton18>	pdftotext file.pdf >(cat)  works fine here.
T 1708511608 18<27Earnestly18>	pdftotext - - < in.pdf > out.txt
T 1708511917 18<27Earnestly18>	Or pdftotext - - < in.pdf # output is written to stdout
T 1708512767 18<25ormaaj18>	udevd actually doesn't create the dev/fd and /dev/std* symlinks for you. You need something that does it after mounting devfs. I do it with a script that handles miscellaneous things that I haven't gotten around to relocating someplace better yet.
T 1708512934 18<28rlikon18>	Earnestly: it's not working at all tried 'pdftotext - - -options -f1 -l2 < file.pdf
T 1708512936 18<25ormaaj18>	some systemd thing surely handles it for cookie-cutter linuxes.
T 1708512948 18<28rlikon18>	and 'pdftotext - - -options -f1 -l2 ;< file.pdf'
T 1708512959 18<28rlikon18>	and 'pdftotext  -options -f1 -l2 - - < file.pdf'
T 1708512976 18<28rlikon18>	the previous one was an error.
T 1708513012 18<27Soliton18>	!doesntwork
T 1708513012 18<29greybot18>	Saying something "doesn't work" helps neither you or us. Explain the result you *want* or *expect*, what you are *doing* and *how* it is failing. Copy/paste the commands you use and the errors they produce. Consider set -x to get more information on what is happening.
T 1708513178 18<27Soliton18>	do you literally write -options?
T 1708513188 18<28rlikon18>	woah! pasted the commands not working
T 1708513204 18<28rlikon18>	Soliton: no, any combination of options
T 1708513217 18<28rlikon18>	it's was an example of where to place the '- -'
T 1708514636 18<27Earnestly18>	rlikon: The pdftotext synopsis is 'pdftotext [options] PDF-file [text-file]'. This means the options are placed before the pdf-file and optional text-file
T 1708514731 18<27Earnestly18>	Also the options like -f are written as '-f number' not '-fnumber' (compared to pr(1), e.g. -e[char][gap]). This means -f1 and -f 1 are not necessarily the same thing, although most option parsing libs don't mind
T 1708515772 18<27Soliton18>	rlikon: i still have no idea what exactly you called and if it worked or if not what error you got etc.
T 1708516191 18<26delay18>	Let's say that I'm doing something like this "cd myfolder && some_command && other_command". Now, I'd like to stop before "some_command" if "c --version" is different from something
T 1708516204 18<26delay18>	now I know I can save c --version in a variable
T 1708516212 18<26delay18>	with $(c --version)
T 1708516274 18<26delay18>	I'm not sure how to execute a block of code
T 1708516279 18<26delay18>	in this case
T 1708516380 18<25ormaaj18>	cd myfolder && [[ $(c --version) != something ]] && x && y
T 1708516426 18<26delay18>	you're saying there's no need to explicitly exit because that condition will fail?
T 1708516469 18<25ormaaj18>	the remainder of the and-list will short-circuit if any command returns nonzero.
T 1708516650 18<26delay18>	what if this is part of a make target's command?
T 1708516662 18<26delay18>	I'm doing it in that case and $(c --version) is empty
T 1708516764 18<26delay18>	isn't $(c --version) executed in a subshell?
T 1708516795 18<25ormaaj18>	If we're talking about bash yes.
T 1708517467 18<28rlikon18>	Soliton: so this works : pdftotext - - < file.pdf
T 1708517479 18<28rlikon18>	but, where, how to place options?
T 1708517559 18<27Soliton18>	pdftotext -f 1 -l 2 file.pdf -
T 1708517644 18<28rlikon18>	Soliton: mm.. now it works.
T 1708517667 18<28rlikon18>	perhaps pebak
T 1708517704 18<29Angels18>	We can see all variables starting with name like: "${!var@}"
T 1708517725 18<29Angels18>	Is it possible to have that var comming from another varialble like: "${!${ref}@}"
T 1708517736 18<25ormaaj18>	no
T 1708517745 18<29Angels18>	# echo "${!{ref}@}" # Bad subst.
T 1708517746 18<25shbot18>	Angels: bash: ${!{ref}@}: bad substitution
T 1708517768 18<29Angels18>	# echo "${!${ref}@}" # Bad subst v2.
T 1708517769 18<25shbot18>	Angels: bash: ${!${ref}@}: bad substitution
T 1708517770 18<25ormaaj18>	!${$
T 1708517770 18<29greybot18>	The correct syntax for parameter expansion is ${varMODIFIER} not ${$varMODIFIER}. Remove that second $.
T 1708517811 18<29Angels18>	ormaaj, it must be hardcoded then?
T 1708517829 18<29Angels18>	Or is it those times one would use eval?
T 1708517880 18<25ormaaj18>	namerefs are used for variable name indirection. see typeset -n
T 1708517933 18<29Angels18>	I know that thank you, but the issue is that the nameref is stored in a string variable.
T 1708517956 18<25ormaaj18>	They are dereferenced recursively
T 1708517965 18<29Angels18>	I know that too.
T 1708518002 18<29Angels18>	The task is too see all variables named starting from a string and the name comes from namref.
T 1708518034 18<29Angels18>	Similar to ${!varName@}, but the varName itself is a string variable.
T 1708518070 18<25ormaaj18>	why do you need that?
T 1708518090 18<29Angels18>	This is the task I have now.
T 1708518105 18<25ormaaj18>	Use an associative array.
T 1708518145 18<29Angels18>	The nameref itself points to an associative array.
T 1708518149 18<25ormaaj18>	Then you can easily loop over the indices
T 1708518161 18<29Angels18>	Why do you keep telling me 2+2=4?
T 1708518174 18<29Angels18>	If it's impossible, then tell it's impossible.
T 1708518187 18<25ormaaj18>	no you're hunting for a collection of variables named by a prefix. That is what the "${!var@} operator does.
T 1708518204 18<29Angels18>	Yes, and that "var" in your example comes from a string.
T 1708518206 18<29Angels18>	That's the issue.
T 1708518218 18<25ormaaj18>	you're simply taking the wrong approach
T 1708518229 18<29Angels18>	And you are a prophet?
T 1708518241 18<29Angels18>	I regret I asked you. Thank you. Forget it.
T 1708518694 22*	26ChanServ gives channel operator status to 18ormaaj
T 1708518762 22*	26ormaaj sets ban on 18*!~Angels@user/Angels
T 1708518763 22*	26ormaaj has kicked 18Angels from 22#bash (24Artfaith)
T 1708518764 22*	26ormaaj removes channel operator status from 18ormaaj
T 1708519389 18<25OMGOMG18>	ormaaj: touchy today?
T 1708519411 18<25ormaaj18>	nope
T 1708519441 18<25OMGOMG18>	i'd say they were fairly polite
T 1708519468 18<25ormaaj18>	it's a known troll and ban evader.
T 1708519514 18<25OMGOMG18>	i sure didn't know that
T 1708519579 18<27Earnestly18>	And nothing will be learned
T 1708519701 18<27Earnestly18>	ormaaj: Thank you, btw. It's rare #bash bans even the most extremely disruptive
T 1708519767 18<28rlikon18>	among all the things to do in life, you gotta be bored to the bottom to troll about a particular use of vars.
T 1708519849 18<19Sparkles18>	\o/
T 1708519859 18<19Sparkles18>	Is here anyone around?
T 1708519871 18<19Sparkles18>	Woah! 800 members!
T 1708519915 18<25OMGOMG18>	that's odd, should be over a thousand
T 1708519982 18<27Soliton18>	!ask
T 1708519982 18<29greybot18>	If you have a question, please just ask it. Don't look for topic experts. Don't ask to ask. Don't PM! Don't ask if people are awake, or in the mood to help. Just ask the question straight out, and be patient waiting for an answer. http://mywiki.wooledge.org/NetEtiquette
T 1708520057 18<19Sparkles18>	What if I don't have a question?
T 1708520187 18<28rlikon18>	is it possible to rescrict some bash operations within some workspace?
T 1708520193 18<28rlikon18>	'delimit'
T 1708520226 18<28rlikon18>	some inadvertently commands can be dangerous.
T 1708520267 18<27Earnestly18>	What is a "workspace" in this context? (And do bash "operations" include only the bash language, or commands it typically exists to execute?) You're using fairly alien language to the topic
T 1708520320 18<28rlikon18>	Earnestly: any dir where the files are contained, 'cd dir_topicA'
T 1708520356 18<28rlikon18>	my concern are operations with for loop or find ... -exec with the use of 'echo' and '>'
T 1708520378 18<27Earnestly18>	Make use of UNIX's DAC based file permissions
T 1708520385 18<24geirha18>	question is a bit vague, but the answer is likely no
T 1708520395 18<24geirha18>	oops, was scrolled up a bit
T 1708520402 18<28rlikon18>	geirha: ok, it was a curiosity only.
T 1708520407 18<27Earnestly18>	And/or selinux (or grsecurity's RBAC stuff perhaps)
T 1708520444 18<27Earnestly18>	But in general, permissions are fine for this, and little utilised
T 1708520458 18<28rlikon18>	if by mistake recursively echo > and '/' are mixed in some command.
T 1708520488 18<27Earnestly18>	I honestly don't know what you mean by 'recursively echo > and /'
T 1708520492 18<28rlikon18>	or going fast rather than /path/to/exec it's written '/ path/to/exec'
T 1708520517 18<27Earnestly18>	You can't do anything about that without finely defined security contexts at the kernel level
T 1708520555 18<28rlikon18>	actually I am tempted to try it on a throwable vm
T 1708520568 18<24geirha18>	best you can do is get into the habit of running find with -print or -ls before you switch to using -exec
T 1708520609 18<24geirha18>	good old-fashion dryrun
T 1708520610 18<27Earnestly18>	I kind of wish gnu find didn't assume pwd if path isn't present
T 1708520653 18<27koollman18>	even before that, best you can do is have backups :)
T 1708520703 18<28rlikon18>	geirha: thanks for the tips
T 1708521229 18<24Aryan18>	how to replace a character or word in a variable?
T 1708521238 18<24Aryan18>	like 'foo' to be 'f00'
T 1708521304 18<27Soliton18>	var=${var//foo/f00}
T 1708521420 18<24Aryan18>	var=foo; echo ${var/oo/00}
T 1708521425 18<24Aryan18>	# var=foo; echo ${var/oo/00}
T 1708521426 18<25shbot18>	Aryan: f00
T 1708521439 18<24Aryan18>	why used two slashes there?
T 1708521453 18<27koollman18>	two slashes to replace all matches, not just the first
T 1708521504 18<24Aryan18>	koollman, ++
T 1708521569 18<24Aryan18>	and can you give some links to 'assignin and alternating variables at the same time' -- the thing you did earlier...
T 1708521637 18<27Soliton18>	what are alternating variables?
T 1708521651 18<24Aryan18>	modifying...
T 1708521669 18<27Soliton18>	assigning usually modifies? not sure what you're asking.
T 1708521755 18<24Aryan18>	i you didn't do 'var=foo; var=${var//foo/f00}.
T 1708521802 18<24Aryan18>	Oh, sorry.
T 1708521834 18<24Aryan18>	# var=${var//foo/f00}; echo $var
T 1708521836 18<25shbot18>	Aryan: no output
T 1708521845 18<24Aryan18>	I thought you were assigining too.
T 1708521860 18<27koollman18>	bot has no memory of previous variables :)
T 1708521874 18<24Aryan18>	i know
T 1708521881 18<24Aryan18>	never mind
T 1708521927 18<24Aryan18>	thanks!
T 1708521982 18<28rlikon18>	question about cut,paste and justfied rendered text.
T 1708522983 18<28rlikon18>	some files with justifed text in columns, (must be spaces + tab)
T 1708523007 18<28rlikon18>	cut -fN gets it right.
T 1708523383 18<28rlikon18>	I see, as long as there's one tab, even sourrounded by spaces, default 'cut -fN' will parse as columns.
T 1708523683 18<24geirha18>	default delimiter is tab, so yes, those spaces are considered part of the fields, not delimiters
T 1708529323 18<28rlikon18>	is it possible to do multiple redirects?
T 1708529355 18<28rlikon18>	one pipe to two seds, then pipe them again?
T 1708529389 18<28rlikon18>	two redirects that the final pipe sees them as separate files
T 1708529398 18<27Soliton18>	if you want to duplicate data you could use tee.
T 1708530419 19*	Now talking on 22#bash
T 1708530419 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1708530419 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1708532209 18<28rlikon18>	lol, the solution was : xargs -n2 > file
T 1708532221 18<28rlikon18>	*<
T 1708532629 18<27Soliton18>	very rare that the xargs protocol fits a problem.
T 1708532646 18<28llua18>	then the description of the problem was incredibly misleading.
T 1708532712 18<27JAA18>	!b1
T 1708532712 18<29greybot18>	bashphorism 1: the questioner's first description of the problem/question will be misleading.
T 1708533331 18<27Earnestly18>	a | { tee >(b) >(c) ...; } | d
T 1708533403 18<27Earnestly18>	I guess bash doesn't need the command group
T 1708533458 18<27Earnestly18>	And if a's output isn't wanted, > /dev/null tee
T 1708533482 18<27JAA18>	Now all you need to do is portably control the buffering. :-)
T 1708536605 18<28apteryx18>	hi!  is there some guideline somewhere suggesting parsing args as '--long-option optional-value' vs '--long-option=optional-value' ?  Both are handled by getopt, but is this encouraged practice?
T 1708536772 18<26lopid18>	maybe https://www.gnu.org/software/libc/manual/html_node/Argument-Syntax.html
T 1708537082 18<27Soliton18>	an option shouldn't have an optional argument. if you must do that then the latter is the only sane way.
T 1708537327 18<22tirnanog18>	keep in mind that getopt is a non-standard utility. to make matters worse, there are two different programs named getopt. see https://mywiki.wooledge.org/ComplexOptionParsing#util-linux.27s_special_getopt
T 1708537399 18<22tirnanog18>	also worth reading:
T 1708537401 18<22tirnanog18>	!faq 35
T 1708537402 18<29greybot18>	https://mywiki.wooledge.org/BashFAQ/035 -- How can I handle command-line options and arguments in my script easily?
T 1708537430 18<22tirnanog18>	(don't confuse getopt with getopts)
T 1708538820 18<28rlikon18>	this is what xorgs solves rather effortlessly --> https://dpaste.com/5H7N8P62V
T 1708538936 18<22tirnanog18>	?
T 1708538945 18<28rlikon18>	*xargs
T 1708538962 18<22tirnanog18>	no?
T 1708539030 18<28rlikon18>	well, 'columns' incapable, 'paste -  - < ...' intercalates, fmt similar limitation to 'columns', awk does it but verbosely.
T 1708539032 18<22tirnanog18>	you can use paste - - or column -t if you have it.
T 1708539046 18<22tirnanog18>	not sure what any of that has to do with xargs.
T 1708539206 18<22tirnanog18>	maybe you mean xargs -L. it mangles its input, though.
T 1708542157 22*	26ChanServ gives channel operator status to 18llua
T 1708542160 22*	26llua sets ban on 18*!~Artfaith@user/voxel
T 1708542171 22*	26llua removes channel operator status from 18llua
T 1708542329 18<25ormaaj18>	!cookie > isabella
T 1708542329 18<29greybot18>	isabella: 🍪
T 1708542376 18<20isabella18>	🤔
T 1708542387 18<20bent_fingers18>	isabella: 🍪🍪
T 1708542428 18<20isabella18>	you guys are screwing with my diet
T 1708542433 18<20isabella18>	how do i log this on my fitness pal
T 1708542511 18<20bent_fingers18>	# echo '🍪' >> fitness-pal.txt
T 1708542513 18<25ormaaj18>	I think that's < 5 calories which is allowed to be labeled as zero in my locale, so, freebie
T 1708542513 18<25shbot18>	bent_fingers: no output
T 1708542617 18<25ormaaj18>	(to know the actual calorie count, therefore, you just multiply the servings-per-container by 5. so 1 cookie in container * 1000 servings = ... nevermind)
T 1708542633 18<20isabella18>	< 5 means either really really small or made of something like konjac
T 1708542699 18<25ormaaj18>	that's actually how they do it, which is why zero calorie foods always have some oddly specific implausibly large number of servings
T 1708544281 19*	Now talking on 22#bash
T 1708544281 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1708544281 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1708547344 18<20bent_fingers18>	GNU says of `cksum`, "For the cksum command, the --check option supports auto-detecting the digest algorithm to use, when presented with checksum information in the --tag output format. "
T 1708547363 18<20bent_fingers18>	--tag is used by default
T 1708547374 18<20bent_fingers18>	but i can't get auto-detection to work
T 1708547398 18<24N0ZYC18>	openssl has some nice hashing (checksum) features also
T 1708547400 18<20bent_fingers18>	this works: `sha256sum -c SHA256SUMS`
T 1708547415 18<20bent_fingers18>	this does not: `cksum --check SHA256SUMS`
T 1708547423 18<20twkm18>	those sums are not tagged.
T 1708547430 18<20bent_fingers18>	erring with "cksum: SHA256SUMS: no properly formatted checksum lines found"
T 1708547441 18<20twkm18>	see.
T 1708547469 18<20twkm18>	you might read the docs so you can recognize when files have tagged sums.
T 1708547598 18<20bent_fingers18>	i think i should run `cksum --tag SHA256SUMS` then
T 1708547604 18<20bent_fingers18>	but what do i do with the output?
T 1708547617 18<20bent_fingers18>	prepend it to SHA256SUMS?
T 1708547669 18<20twkm18>	ahh, so no reading of docs.  well, keep guessing perhaps some day you'll hit on it.
T 1708547749 18<20bent_fingers18>	of course i read it, my first post cited them
T 1708547758 18<27larryv18>	bent_fingers: store it somewhere that doesn't modify the file you just checksummed, which would change its checksum.
T 1708548397 18<22tirnanog18>	it's gnu. one cannot simply read the man page.
T 1708548543 18<27larryv18>	bent_fingers: note that tagged output is only the default if you use cksum -a to select a modern algo. also note that ''cksum --tag SHA256SUMS'' checksums your checksum file (in the legacy format, no less), which is probably not what you were going for.
T 1708548553 18<22tirnanog18>	anyway, the tagged format is describe by its info. it defaults to tagged output only for "non legacy" algorithms.
T 1708548571 18<20bent_fingers18>	i read that
T 1708548593 18<20bent_fingers18>	currently working with sha256, which i assumed was non-legacy
T 1708548683 18<27larryv18>	none of your example commands select sha256.
T 1708549459 18<27larryv18>	example with MD5 (demonstration only): http://paste.wooledge.org/28771
T 1708549680 18<20bent_fingers18>	yeah, i just figured that's how it works...not what i was hoping for
T 1708549689 18<20bent_fingers18>	thanks anyways
T 1708549719 18<27Earnestly18>	coreutils cksum is radically different in recent versions
T 1708549731 18<27Earnestly18>	Where in fact, --tag is the default
T 1708549812 18<20bent_fingers18>	i thoght i could write a script that could use as input: 1) SUMFILE, 2) SUMFILE.GPG, 3) some.iso
T 1708549815 18<27larryv18>	only if you select a modern algo
T 1708549820 18<20bent_fingers18>	for example, from here: http://cdimage.ubuntu.com/lubuntu/releases/23.10/release/
T 1708549853 18<20bent_fingers18>	and have the script work in a generalized way, i.e., with cksum only, rather than each of the separate sums: mda,sha,etc.
T 1708550053 18<20bent_fingers18>	so instead of `sha256sum -c SHA256SUMS` i could `cksum -c "$1"`
T 1708550056 18<20bent_fingers18>	something like that
T 1708550095 18<27larryv18>	what is $1 supposed to be there
T 1708550178 18<20bent_fingers18>	whatever hashsummed file is provided with an iso
T 1708550250 18<20bent_fingers18>	in the end, i could have a script called `cs` (for checksum) and simply run `cs $1`
T 1708550304 18<20bent_fingers18>	instead of `sha256sum -c SHA256SUMS` and `md5sum -c ...` and `sha512sum -c ...`
T 1708550378 18<27larryv18>	i don't understand. cksum -c can do what you want, if the checksum file contains tagged output
T 1708550382 18<27larryv18>	https://paste.wooledge.org/28772
T 1708553966 19*	Now talking on 22#bash
T 1708553966 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1708553966 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1708554077 19*	Now talking on 22#bash
T 1708554077 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1708554077 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1708554288 18<28justsomeguy18>	There used to be a shopt option that effects how scope works in bash, but I can't find it anymore. Does anyone remember what I'm talking about? My search queries aren't bringing anything up.
T 1708554307 18<28justsomeguy18>	I think it enabled lexical scope as an experimental feature.
T 1708554543 18<27larryv18>	maybe localvar_inherit or localvar_unset? those tweak scoping-related behavior, but i wouldn't say either of them "enables" lexical scope. https://www.gnu.org/software/bash/manual/html_node/The-Shopt-Builtin.html
T 1708554621 18<22tirnanog18>	indeed. there is no lexical scoping.
T 1708554767 18<28apteryx18>	lopid: OK
T 1708569574 18<25MisterMinister18>	Greeting and Salutations! Is there a most favorite method to get PID of a few background processes please?  e.g. `foo|bar & foo|bar &`
T 1708569681 18<27larryv18>	save them yourself. e.g., pids=(); foo & pids+=("$!"); bar & pids+=("$!")
T 1708569889 18<25MisterMinister18>	recall it didn't work in every case, I'll try it again. Thanks Larryv
T 1708570884 18<28llua18>	there are few silver bullets in shell programming, so yeah, that makes sense.
T 1708588222 18<29Ecko18>	How do you deal with having to enclose things 3 layers deep in quotes?  my command fails because I single quoted user and sleep
T 1708588222 18<29Ecko18>	watch 'mysql -e "select * from information_schema.processlist where user = 'user' and command != 'sleep' order by TIME desc"'
T 1708588321 18<24geirha18>	watch -x mysql -e "select * ... where user = 'user' ..."
T 1708588346 18<24geirha18>	removing one shell from the mix means one less layer of shell quoting
T 1708588727 18<27JAA18>	More generally, %q to the rescue.
T 1708588889 18<20arraybolt318>	# echo "This string has \"lots 'and lots \"and lots!\" of quotes.\'\""
T 1708588892 18<25shbot18>	arraybolt3: This string has "lots 'and lots "and lots!" of quotes.\'"
T 1708588901 18<20arraybolt318>	# echo "This string has \"lots 'and lots \"and lots!\" of quotes.'\""
T 1708588903 18<25shbot18>	arraybolt3: This string has "lots 'and lots "and lots!" of quotes.'"
T 1708588912 18<27JAA18>	I once had to exec a `bash -c` in a container on a remote host. That was fun to get right...
T 1708588923 18<20arraybolt318>	oh I bet
T 1708588951 18<20arraybolt318>	# bash -c "echo \"This is a \\\"deeply quoted\\\" string.\""
T 1708588952 18<25shbot18>	arraybolt3: This is a "deeply quoted" string.
T 1708589000 18<20arraybolt318>	# bash -c "bash -c \"bash -c \\\"echo \\\\\\\"heya!\\\\\\\"\\\"\""
T 1708589001 18<25shbot18>	arraybolt3: heya!
T 1708589005 18<29Ecko18>	ah, that did the trick, thanks geirha
T 1708589019 18<27JAA18>	It's more fun when you need to also escape some $ signs at various levels. :-)
T 1708589034 18<24Nintendo18>	JAA, I have done that but also via XML payload in the snow uphill both ways.
T 1708589048 18<27JAA18>	:-)
T 1708589490 18<25test6318>	JAA what is the meaning of %q ?
T 1708589723 18<27JAA18>	test63: %q in printf quotes the argument for shell injection purposes.
T 1708589752 18<25test6318>	ah. I just found that in the bash manual. I'm not familiar with that stuff.
T 1708589800 18<27JAA18>	It's also useful for clear unambiguous printing.
T 1708589808 18<27JAA18>	# printf %q "$IFS"
T 1708589809 18<25shbot18>	JAA: $' \t\n'
T 1708589818 18<25test6318>	I don't even know what shell injection is
T 1708589961 18<24Nintendo18>	There's also ${s@Q}.  Search for “parameter transformation”, because the man page doesn't contain the string you would want it to have.
T 1708590002 18<27JAA18>	# cmd=(echo $'ohai"with\'quotes'); "${cmd[@]}"; bash -c "$(printf '%q ' "${cmd[@]}")"
T 1708590003 18<25shbot18>	JAA: ohai"with'quotes
T 1708590003 18<25shbot18>	JAA: ohai"with'quotes
T 1708590171 18<27JAA18>	Yeah, @Q is a valid alternative these days. %q is the much (MUCH) older method.
T 1708590234 18<27JAA18>	@Q was added in 4.4. %q has existed since the dawn of time.
T 1708590287 18<22pj18>	If you have to support age old bash then by all means use %q, but I do find @Q to be easier to use personally.
T 1708590336 18<27JAA18>	Agreed
T 1708590345 18<27JAA18>	I sadly do have some ancient systems here. :-|
T 1708590398 18<22pj18>	yep, tis the nature of the beast with bash.  Sometimes you can target newer bash sometimes you can't, sometimes you're stuck targetting POSIX sh (yuck).
T 1708590524 18<20fdan3618>	i get this error
T 1708590524 18<20fdan3618>	nimbus_beacon_node: /lib64/libm.so.6: version `GLIBC_2.29' not found (required by nimbus_beacon_node)
T 1708590532 18<20fdan3618>	how to find the glibc version and how to update it?
T 1708590585 18<22pj18>	fdan36: that's not a bash question but it basically means that the program you're trying to run was built with a newer glibc than the one on the system you're trying to run it on.
T 1708590587 18<27JAA18>	!nabq
T 1708590587 18<29greybot18>	Not a #bash question. You might want to ask in a channel where it's actually on-topic. You can use "/msg alis list KEYWORDS" to search for suitable channels
T 1708590608 18<20fdan3618>	sure
T 1708590617 18<22pj18>	fdan36: ask for help in your OS or distribution-specific channel, they will be able to help you more with this issue.
T 1708590622 18<20fdan3618>	pj can i get help on how to find the existing glibc version
T 1708590639 18<27JAA18>	That will also be OS/distro-specific.
T 1708590707 18<24geirha18>	in debian/ubuntu the package is libc6
T 1708590804 18<22pj18>	at the end of the day you are highly unlikely to be able to upgrade your glibc version without installing a different or newer distribution.  You will probably need to find a different solution to your problem, and again your OS/distro-specific channel will have the proper solution for you.
T 1708590868 18<24geirha18>	such as running it in a container or vm
T 1708590953 18<22pj18>	or getting a package built specifically for your distro
T 1708591070 18<27JAA18>	(Flashbacks to trying to get containers with a modern libc to run on a host system with an older libseccomp and running into all kinds of fun errors like GPG verification failing.)
T 1708591147 18<29andre144k18>	hello all - is there an option to gie a timeout while checking:   if [ -d "/mnt/foobar/folder" ]
T 1708591155 18<29andre144k18>	to give
T 1708591216 18<22pj18>	yeah, not sure that containers like to play well in that scenario.
T 1708591224 18<22pj18>	a proper VM would work.
T 1708591249 18<24geirha18>	retries=10 ; while ! [[ -d /mnt/foobar/folder ]] ; do ((retries-- > 0)) || { printf >&2 'Timed out waiting for folder\n' ; exit 1 ; } ; sleep 1 ; done ; ls -ld /mnt/foobar/folder
T 1708591291 18<27JAA18>	It was a particular error that broke lots of stuff a couple years ago due to glibc starting to use faccessat2 and that not being whitelisted in libseccomp. But yeah, can happen for other things, too.
T 1708591371 18<27JAA18>	andre144k: Do you mean the -d check takes a long time (e.g. slow network file system) or waiting for the directory to show up? (The latter is what geirha's code covers.)
T 1708591389 18<22pj18>	don't know much about that one, but I do know that glibc tends not to play well with parrallel installs and so I wouldn't think it would work well in a container either.
T 1708591504 18<27JAA18>	It's been mostly fine for me apart from that one. I've ran three Debian releases + sid inside containers on the same host system at various times.
T 1708591504 18<22pj18>	there's also inotifywait
T 1708591565 18<27JAA18>	It only really breaks if a syscall is needed that isn't getting passed through (yet) by the containerisation. That's when you need to update Docker/Podman/whatever.
T 1708591588 18*	22pj nods
T 1708591592 18<27JAA18>	Or you perform some black magic to add those syscalls manually.
T 1708591627 18<29andre144k18>	JAA yes, a very slow, or broken nfs eg
T 1708591802 18<22pj18>	andre144k: I would look at inotifywait, then, it has a -t (timeout) option.
T 1708591890 18<24geirha18>	IIRC, inotifywait won't get any events if the dir is created remotely
T 1708591912 18<29andre144k18>	man test:  GNU coreutils v8.4   -   no timeout option
T 1708591912 18<28emanuele618>	if timeout 1 [ -d "/mnt/foobar/folder" ]   should just work
T 1708591933 18<29andre144k18>	okay ill try
T 1708591941 18<27JAA18>	I was just about to ask whether wrapping it in a timeout works, or whether the subprocess would then be stuck on I/O.
T 1708591982 18<27JAA18>	Not sure how that works with NFS et al.
T 1708591991 18<22pj18>	yeah, I'm not entirely sure that inotifywait won't stick on IO to be honest, but I think it has a good chance of working.
T 1708592292 18<22pj18>	I get the feeling it will work because it uses an event-driven API.
T 1708592363 18<29andre144k18>	emanuele6 thank you "timeout"  this seems to be best solution
T 1708592403 18<29andre144k18>	it works perfectly in current stuation
T 1708592615 18<27JAA18>	Good to know :-)
T 1708594190 18<24geirha18>	pj: but the events are generated from syscalls like open(2) and close(2), so when a file is created on a remote system, the inotify events only appear on that remote system
T 1708594685 18<27Earnestly18>	Would have to include a proxy that forwards the events
T 1708594701 18<27Earnestly18>	(Or probably sshfs?)
T 1708595110 18<24geirha18>	I have my doubts that nfs would add a forwarding of inotify events
T 1708595121 18<24geirha18>	like, how would it deal with systems that don't have inotify?
T 1708595934 18<27Earnestly18>	By include a proxy, I mean write a script that does that
T 1708595958 18<27Earnestly18>	E.g. pipe output from inotify through socat back to the origin ._.
T 1708595982 18<27Earnestly18>	Or scrape the output from the ssh session itself
T 1708597548 18<22pj18>	geirha: makes sense
T 1708598692 18<28rlikon18>	greets
T 1708598706 18<28rlikon18>	sed, awk, grep got their channels, but not 'datamash'
T 1708601930 18<29andre144k18>	i mounted a nfs folder via follow options:    rw,bg,soft,rsize=32768,wsize=32768,vers=4,intr,timeo=200,tcp,async
T 1708602056 18<29andre144k18>	when i disconnect cable, without umounting before umounting, shutdown will take very long on this mashine.  is there maybe a better way to mount nfs volumes?
T 1708602185 18<24geirha18>	how to configure nfs is a bit beyond the scope of this channel. Try your os channel
T 1708602384 18<29andre144k18>	good idea - thank you
T 1708603660 18<22hightower318>	Hey stupid problem, in a script I interpolate a variable inside a line that calls sed:    sed -i "s/VAL=.*/VAL=$MYVAL/"
T 1708603670 18<22hightower318>	so if the variable contained an /, it breaks sed invocation
T 1708603687 18<22hightower318>	I tried $(MYVAL@Q}, but that only added quotes, didn't help
T 1708603695 18<22hightower318>	any quick ideas/solutions?
T 1708603772 18<24geirha18>	best solution is to not use sed
T 1708603780 18<27Earnestly18>	hightower3: You can't use sed like that reliably, so just don't
T 1708603820 18<22hightower318>	so what should I use for this -- for an in-place edit of a line in text, matched by a regex
T 1708603822 18<27Earnestly18>	hightower3: And to try help your thinking, @Q is quoting for bash, and since bash is not sed (nor is it specifically sed's s command), it doesn't reason that it'd help you
T 1708603851 18<24geirha18>	If you're editing a config file, just provide a complete config file instead of editing this and that line of an existing one
T 1708603883 18<22hightower318>	I can't provide a complete file because it's building over time, and it depends on the fact that I modify some lines, and not replace or re-create it
T 1708603905 18<27Earnestly18>	hightower3: Besides what geirha suggests you have awk. But a word about in-place editting. You don't want to do in-place editting and nor does sed -i do in-place editing
T 1708603933 18<27Earnestly18>	awk is fine because you can pass your value in via environment variable which
T 1708603936 18<22hightower318>	well, I guess worst case, I can grep out the line, then >> the new line into it. It will mess up the order but well...
T 1708603967 18<22hightower318>	yeah or awk... well, ok, thanks for suggestions
T 1708603998 18<24geirha18>	sounds like an overly complicated setup
T 1708604009 18<27Earnestly18>	myval=$MYVAL awk 'index($1, "VAL=") == 1 {print "VAL=" ENVIRON["myval"]}' # Uses index() instead of regex, because it doesn't appear to need regex
T 1708604042 18<27Earnestly18>	Create a new file, config.new and then if awk succeeds, mv config.new config. Avoid in-place where ever you can
T 1708604051 18<27Earnestly18>	hightower3: See https://backreference.org/2011/01/29/in-place-editing-of-files/index.html
T 1708604061 18<24geirha18>	missing a print for the remaining lines there though
T 1708604073 18<27Earnestly18>	Oh right, yeah add that
T 1708604102 18<27Earnestly18>	myval=$MYVAL awk 'index($1, "VAL=") == 1 {print "VAL=" ENVIRON["myval"]; next}; 1'
T 1708604148 18<22hightower318>	oh btw, I just realized I could have used perl as well, I just randomly used 'sed' and then wondered, could have used anything else, doh
T 1708604151 18<27Earnestly18>	hightower3: If this config is json, use jq. If it's yaml use something else
T 1708604174 18<27Earnestly18>	hightower3: How would you use perl to allow arbitrary values in regex?
T 1708604190 18<22hightower318>	same as above, by refering to env vars
T 1708604231 18<27Earnestly18>	But how would it not interpret the regex characters in the value?
T 1708604256 18<27Earnestly18>	You'd have to quote everything?
T 1708604258 18<22hightower318>	because perl doesn't interpolate vals before executing the line.. it would work exactly for the same reason why the above awk line works
T 1708604263 18<22hightower318>	but also,
T 1708604289 18<22hightower318>	perl has another facility at disposal, which is to automatically quote all "special" chars, something to do with Q I think... let me remind myself
T 1708604293 18<27Earnestly18>	But you /are/ interpolating within perl. Your sed examples interpolates twice
T 1708604301 18<27Soliton18>	it wasn't regex in sed either.
T 1708604324 18<27Soliton18>	in perl you can use \Q but no idea how that applies here.
T 1708604327 18<27Earnestly18>	Once from the shell, second in the s command. In perl without stuff like \Q you're still interpolating a variable inside a DSL, i.e. perl's s//
T 1708604333 18<22hightower318>	oh jezus
T 1708604342 18<27Earnestly18>	hightower3: Come on, this is basic code injection 101
T 1708604349 18<22hightower318>	ok thanks for help
T 1708604412 18<27Earnestly18>	I do like "interpolate" having a definition of "to corrupt"
T 1708606547 19*	Now talking on 22#bash
T 1708606547 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1708606547 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1708606631 19*	Now talking on 22#bash
T 1708606631 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1708606631 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1708606895 18<29andre144k18>	nfs solution:  timeo=120
T 1708609034 18<22samjiman18>	Hi, all
T 1708609145 18<19zxd18>	how to sort this  from smaller to bigger:  2006  2004-02  2004-02-33       (  2006 means 2006-01-01   )
T 1708609164 18<19zxd18>	2004-02  ( means 2004-02-01 )
T 1708609181 18<19zxd18>	I ment  2004-02-28
T 1708609196 18<19zxd18>	not 2004-02-33
T 1708609200 18<22samjiman18>	So sort from earlier date to latest date?
T 1708609205 18<19zxd18>	yes
T 1708609205 18<22samjiman18>	*earliest
T 1708609210 18<19zxd18>	efficiently
T 1708609238 18<29djph18>	'sort' ?
T 1708609258 18<29djph18>	noting, of course, "2004-02" would probably come before "2004-02-28" since it's shorter
T 1708609262 18<19zxd18>	I tried sort but how do I deal with the  '-'
T 1708609286 18<29djph18>	you don't
T 1708609335 18<29djph18>	I mean "2004" comes before 2006, so it doesn't matter that "2004-" is longer, it's still first ...
T 1708609375 18<19zxd18>	what if it's  2004-02-28  2004-02-24
T 1708609394 18<22samjiman18>	You need to be able to sort by year, then by month, then by day
T 1708609408 18<29djph18>	then 24 comes before 28 ...
T 1708609443 18<29djph18>	ISO dates are laid out to nicely sort like that ...
T 1708609446 18<27Soliton18>	i mean it sorts fine lexicographically, no? what exactly is the issue?
T 1708609513 18<29djph18>	'sup Soliton ?
T 1708609532 18<19zxd18>	djph: so sort does it automatically  sort the dates?   what switches
T 1708609549 18<27Soliton18>	# printf '%s\n' 2006  2004-02  2004-02-28 | sort
T 1708609550 18<25shbot18>	Soliton: 2004-02
T 1708609550 18<25shbot18>	Soliton: 2004-02-28
T 1708609551 18<25shbot18>	Soliton: 2006
T 1708609567 18<29djph18>	zxd: ... I guess you haven't actually run your list of ISO dates through 'sort'
T 1708609638 18<19zxd18>	this dosen't work  :  printf '%s\n' 2009-02  2004-02-28  2004-02-21 | sort
T 1708609651 18<29djph18>	!doesntwork > zxd
T 1708609652 18<29greybot18>	zxd: Saying something "doesn't work" helps neither you or us. Explain the result you *want* or *expect*, what you are *doing* and *how* it is failing. Copy/paste the commands you use and the errors they produce. Consider set -x to get more information on what is happening.
T 1708609655 18<19zxd18>	wait it does
T 1708610132 18<29djph18>	zxd: so you're good now?
T 1708610258 18<19zxd18>	djph: Yes thanks all  ,   if I want only the first entry after all is sorted   :  printf '%s\n' 2009-02 2004-02-28  2009-02 2004-02-21  | sort | { read var ; echo $var ;}     this is ok ?
T 1708610301 18<29djph18>	why not just use head(1) to get the "first line" ?
T 1708610340 18<19zxd18>	maybe  piping to a subshell is faster? since I am not opening a new command ?
T 1708610367 18<27Earnestly18>	zxd: I hope you're not creating a pipeline inside a fast for/while loop
T 1708610373 18<29djph18>	what?
T 1708610389 18<22tirnanog18>	however, var won't persist there, unless lastpipe is in effect. whether that matters or not is another matter.
T 1708610469 18<27Earnestly18>	  printf "%s\n" 2009-02 2004-02-28  2009-02 2004-02-21 | sort | head -n 1 ran
T 1708610471 18<27Earnestly18>	    1.06 ± 0.37 times faster than printf "%s\n" 2009-02 2004-02-28  2009-02 2004-02-21 | sort | { read -r var; printf "%s" "$var"; }
T 1708610476 18<27Earnestly18>	zxd: No difference
T 1708610493 18<19zxd18>	:)
T 1708610627 18<27Earnestly18>	zxd: When you're working with pipelines, try to arrange the elements to produce one long persistent pipeline that reads all input and produces all output. Don't continuously bring up and tear them down; each program runs in parallel and the cost of bring up is amortised quickly. The slowest thing you can do in a shell is repeatidly fork commands
T 1708610661 18<27Earnestly18>	(I'm sure some bits of the bash runtime are also slow too)
T 1708610692 18<27Earnestly18>	zxd: By the time sort(1) for example has initialised and even handled the inputs, head will long since be waiting for input
T 1708610945 18<25Mo_18>	Hi, this works:    ssh srv 'sed -n "s/PRETTY_NAME=\"\([^\"]*\)\"/\1/p" /etc/os-release'   Now if I need to put that sed into "" like the following, how would I escape that correctly?
T 1708610953 18<25Mo_18>	 ssh srv "echo Version: ; 'sed -n "s/PRETTY_NAME=\"\([^\"]*\)\"/\1/p" /etc/os-release'"
T 1708610960 18<28rlikon18>	odd issue while piping. sed can't see as a complete output
T 1708610985 18<28rlikon18>	grep foo | sed 'something'
T 1708610987 18<19zxd18>	Earnestly: noted
T 1708611027 18<27Earnestly18>	Mo_: os-release is designed to be dottable (. / source)
T 1708611044 18<27Earnestly18>	!buffering > rlikon
T 1708611051 18<27Earnestly18>	!buffer
T 1708611062 18<25Mo_18>	Earnestly: Good point. But I like to learn quoting :)
T 1708611095 18<28rlikon18>	Earnestly: sorry, my bad forgot 's/this/that/g' <-- the G there
T 1708611114 18<27Earnestly18>	Mo_: There's not much to learn, ssh is broken by design. It swallows all of your arguments and squashes it down into a single string, passing it as a single argument to sh -c
T 1708611136 18<27Earnestly18>	!ssh > Mo_
T 1708611136 18<29greybot18>	Mo_: Secure SHell (#openssh, http://mywiki.wooledge.org/CategorySsh). To run rm "$localVar" remotely, use: printf 'rm %q\n' "$localVar" | ssh user@host bash
T 1708611166 18<25Mo_18>	Ok, it works and looks good:  ssh srv "echo Version: ; . /etc/os-release ; echo \$PRETTY_NAME"
T 1708611193 18<27Earnestly18>	Or cmd=(foo bar baz); "${cmd[*]@Q}"
T 1708611261 18<27Earnestly18>	Mo_: ssh srv 'if . /etc/os-release; then printf "Version: %s\n" "$PRETTY_NAME"; fi'
T 1708611299 18<27Earnestly18>	Mo_: Don't use echo and quote expansions so that they don't wordsplit and potential file glob expansion
T 1708611308 18<27Earnestly18>	A pretty name could well include characters like []
T 1708611359 18<27Earnestly18>	Mo_: Use ' literal quotes if want a string to be literal
T 1708611793 18<24rak18>	In the case of a redirection with a potential clobber, e.g., 'cmd >f', where is the ordering of operations between executing `cmd` and creating/writing `f` defined? I've checked REDIRECTION in bash(1), the redirection section for POSIX shells https://pubs.opengroup.org/onlinepubs/9699919799.2018edition/utilities/V3_chap02.html#tag_18_07 , and §3.6 (Redirections) of the bash manual and don't see it
T 1708611796 18<24rak18>	specified anywhere
T 1708611966 18<24rak18>	It seems to be that 'f' is created *before* cmd is run so that, e.g., running 'ls > f' in an empty directory ends up in the file 'f' containing the line 'f'. I am looking to see if this must always be the case, or if a shell is free to buffer stdout before creating the redirection's target file and writing to it.
T 1708611971 18<27Earnestly18>	rak: See '2.3 Token Recognition' in that document
T 1708611985 18<27Earnestly18>	rak: Yes, redirections are created before command execution
T 1708612105 18<27Earnestly18>	Hm, token recognotion doesn't cover it, sorry. See https://pubs.opengroup.org/onlinepubs/9699919799.2018edition/utilities/V3_chap02.html#tag_18_10_02
T 1708612167 18<24iconoclast_hero18>	ubuntu 22.04 $ man column:  The column command is part of the util-linux package which can be downloaded from Linux Kernel Archive <https://www.kernel.org/pub/linux/utils/util-linux/>. util-linux 2.37.2
T 1708612167 18<24iconoclast_hero18>	vs. https://man7.org/linux/man-pages/man1/column.1.html
T 1708612219 18<24iconoclast_hero18>	I don't know if this is really a #bash question, but I don't seem to have " -C, --table-column properties           Define one column by comma separated list of column   attributes. This option can be used more than once, every use..."
T 1708612237 18<27Earnestly18>	iconoclast_hero: It's in a recent release
T 1708612252 18<24iconoclast_hero18>	so, i saw it is a different version number but ...
T 1708612262 18<24iconoclast_hero18>	2.37 vs. 2.39?
T 1708612278 18<24iconoclast_hero18>	i wasn't sure if that big of a feature would be added in such a (to me) small version change.
T 1708612303 18<27Earnestly18>	37 is almost 3 years old
T 1708612307 18<24iconoclast_hero18>	ok.
T 1708612332 18<24iconoclast_hero18>	so can i easily upgrade util-linux or am i going to f everything up?
T 1708612385 18<24iconoclast_hero18>	nevermind.
T 1708612389 18<24iconoclast_hero18>	there's a channel for that.
T 1708612660 18<24rak18>	Earnestly: Thanks! I managed to thread my way through the POSIX spec from the grammar you linked to and figured it out
T 1708614223 18<24iconoclast_hero18>	am i missing something here?
T 1708614223 18<24iconoclast_hero18>	$ \mpc playlist -f \(%position%\)~%artist%~%title% |column --table -s "~" -o " | " -C name=\(POS\) -C name=Artist,noextreme -C name=Title,hide |head -10
T 1708614261 18<24iconoclast_hero18>	the -C hide is supposed to suppress the third column, "Title", no?
T 1708614329 18<24iconoclast_hero18>	adding -H Title suppresses it.
T 1708614458 18<24iconoclast_hero18>	oh, i'm on column/util-linux 2.40RC whatever
T 1708614485 18<24iconoclast_hero18>	RC1-126-7ca98
T 1708623317 19*	Now talking on 22#bash
T 1708623317 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1708623317 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1708625676 18<29trev18>	hi folks, would anyone be willing to code review a little script i wrote today? it parses all tmux pane contents for strings that resemble a file/file path and then tries to resolve the file. I use it to pipe to fzf and open the files in vim. https://github.com/trevarj/config.nvim/blob/master/scripts/tmux_file_paths.sh
T 1708625703 18<28selckin18>	!check
T 1708625703 18<28checkbot18>	selckin: Looks good to me
T 1708625731 18<22tirnanog18>	https://raw.githubusercontent.com/trevarj/config.nvim/master/scripts/tmux_file_paths.sh
T 1708625733 18<22tirnanog18>	!check
T 1708625733 18<28checkbot18>	tirnanog: Looks good to me
T 1708625743 18<22tirnanog18>	hmm.
T 1708625792 18<22tirnanog18>	I thought it might complain about for pane in $panes, at least.
T 1708625870 18<29trev18>	why'd you think that?
T 1708625874 18<22tirnanog18>	!drlwf > trev
T 1708625875 18<29greybot18>	trev: https://mywiki.wooledge.org/DontReadLinesWithFor ... "for" is for iterating arguments/arrays, not strings. Never do: for x in $(cat file), or for x in $var; instead, use a glob (*.txt), an array ("${hosts[@]}") or a while-read loop. See also https://mywiki.wooledge.org/BashPitfalls#pf1
T 1708625889 18<29trev18>	ah
T 1708625918 18<29trev18>	yeah that would be nice if it caught that
T 1708625981 18<22tirnanog18>	you could just iterate over the lines directly but if you'd rather continue to assign to a variable for the time being, you can do something like: mapfile -t panes < <(tmux ...); for pane in "${panes[@]}" ...
T 1708626066 18<29trev18>	would that be more efficient? right now the script is pretty slow, depending on how much tmux history i have
T 1708626096 18<22tirnanog18>	it will not be more or less efficient to any degree that is noticeable.
T 1708626099 18<27JAA18>	`for pane in $panes` will only do the first pane, too.
T 1708626128 18<29trev18>	JAA: somehow it is doing them all
T 1708626140 18<27JAA18>	Oh wait, I misread, I thought it already was an array, yeah.
T 1708626166 18<27JAA18>	Agreed with mapfile aka readarray.
T 1708626173 18<22tirnanog18>	not assigning to an var to begin with would be slightly more efficient because you then benefit from the asynchronous operation of a pipeline.
T 1708626281 18<27JAA18>	Weird that ShellCheck doesn't flag it as SC2046.
T 1708626368 18<29trev18>	tirnanog: so just `for x in $([tmux cmd]..)` ?
T 1708626387 18<29trev18>	JAA: maybe i will file an issue if i get some time
T 1708626401 18<22tirnanog18>	no. that's still reading lines with for, and carries with it the same attendant risks as described by pf1.
T 1708626406 18<27JAA18>	I can't remember when quoting is and isn't necessary, but I'd add quotes on the -n and -f checks near the end.
T 1708626409 18<27JAA18>	!qefs
T 1708626409 18<29greybot18>	"$Quote" "$Every" "$Fucking" "$Substitution"
T 1708626414 18<27JAA18>	:-)
T 1708626442 18<22tirnanog18>	(which was linked to earlier)
T 1708626499 18<27JAA18>	My only other nit is naming script variables in upper case. That should normally be done only for shell and environment variables.
T 1708626521 18<22tirnanog18>	trev: either use arrays or do this: https://termbin.com/5ivy
T 1708626544 18<27JAA18>	The 'expand ~' bit also looks a bit suspicious; what if there is a ~ somewhere in the path?
T 1708626564 18<29trev18>	in newer bash you don't need IFS right? isn't there readline?
T 1708626579 18<29trev18>	JAA: shouldn't it only strip from the front?
T 1708626582 18<22tirnanog18>	maybe_path doesn't sound like something that should be trimmed
T 1708626588 18<22tirnanog18>	that's why I have specified IFS=
T 1708626606 18<22tirnanog18>	not sure what you mean by readline.
T 1708626616 18<22tirnanog18>	I guess you need to read faq 1 as well as pf 1.
T 1708626619 18<22tirnanog18>	!faq 1 > trev
T 1708626619 18<29greybot18>	trev: https://mywiki.wooledge.org/BashFAQ/001 -- How can I read a file (data stream, variable) line-by-line (and/or field-by-field)?
T 1708626635 18<29trev18>	ah nevermind, i was thinking of readarray
T 1708626651 18<22tirnanog18>	ah. that's a synonym of mapfile.
T 1708626794 18<29trev18>	lol yeah..time to make my head spin
T 1708627093 18<29trev18>	thanks for the help
T 1708630546 19*	Now talking on 22#bash
T 1708630546 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1708630546 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1708631263 19*	Now talking on 22#bash
T 1708631263 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1708631263 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1708631930 19*	Now talking on 22#bash
T 1708631930 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1708631930 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1708631977 18<29nasum18>	it is easy to set up a while loop to do something every x seconds, but do i set up the while loop if there has X to be done very certain seconds and Y and Z at some different time intervals?
T 1708632024 18<26yitz18>	nasum: set up a systemd-timer unit for X, for Y and for Z
T 1708632783 19*	Now talking on 22#bash
T 1708632783 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1708632783 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1708632966 19*	Now talking on 22#bash
T 1708632966 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1708632966 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1708633023 18<25ormaaj18>	fizzbuzz loop
T 1708633459 18<27JAA18>	Set up a loop that runs every second (by a variable `sleep`), check mod to run commands. Cry if a loop iteration takes more than a second.
T 1708633800 18<25ormaaj18>	polyrhythms are easy. Find the least common divisor and use it as a clock interval. Works for all rational dubsteps.
T 1708633914 18<27JAA18>	# for ((i=0;i<8;++i)); do sleep 0.$(( 1000000 - 10#${EPOCHREALTIME#*.} )); ((EPOCHSECONDS%3==0))&&printf fizz; ((EPOCHSECONDS%5==0))&&printf buzz; ((EPOCHSECONDS%3==0||EPOCHSECONDS%5==0))&&echo; done | paste - - - -
T 1708633921 18<25shbot18>	JAA: no output within the time limit
T 1708633925 18<27JAA18>	Booo
T 1708634035 18<27JAA18>	Was the time limit changed? I thought it was 10 seconds.
T 1708634048 18<25ormaaj18>	nah it's always been 3
T 1708634058 18<28akoana18>	ormaaj: hmm, least common divisor? not greatest common divisor?
T 1708634077 18<27JAA18>	# sleep 4; echo ormaaj: nope
T 1708634082 18<25shbot18>	JAA: ormaaj: nope
T 1708634088 18<25ormaaj18>	10 is long :O
T 1708634115 18<27JAA18>	Maybe shbot was just slow and that's why I misremember.
T 1708634146 18<27larryv18>	# sleep 5; echo hi
T 1708634152 18<25shbot18>	larryv: no output within the time limit
T 1708634276 18<25ormaaj18>	gcd rite
T 1708634287 18<28akoana18>	:)
T 1708634444 18<27JAA18>	I think this is the limit: https://gitlab.com/geirha/shbot/-/blob/0a0719765f9f85bb6bae5e74a69691e953567f36/runqemu#L23
T 1708634478 18<27JAA18>	So 6-ish seconds including the VM launching etc.
T 1708634629 18<19han-solo18>	/4/4
T 1708635078 18<29nasum18>	i can get the loop to tick every second but how do i arrange tasks to run every 5 seconds every 10 seconds in that loop that ticks every second
T 1708635131 18<24N0ZYC18>	count to 5
T 1708635591 18<27JAA18>	Copy-paste faile above, I blame GitLab: https://gitlab.com/geirha/shbot/-/blob/0a0719765f9f85bb6bae5e74a69691e953567f36/limitcmd.pl#L23
T 1708635598 18<27JAA18>	fail, even
T 1708661368 18<28emanuele618>	i just realised that with function substitutions you can use   ${| unset -v var;}     instead of really_unset(){ unset "$@";}; really_unset -v var   :o
T 1708661459 18<25ormaaj18>	moo
T 1708661591 18<25ormaaj18>	have you tried zsh namerefs yet? These make bash pretty much obsolete.
T 1708661725 18<28emanuele618>	no
T 1708661946 18<25ormaaj18>	emanuele6: yes, that is massively problematic because it can alter behavior when you call a function from it.
T 1708662006 18<25ormaaj18>	bash should never have used that mechanism for unpeeling locals. It should be a separate option.
T 1708662024 18<25ormaaj18>	like, obviously.
T 1708662043 18<25ormaaj18>	typical bash insanity
T 1708662100 18<25ormaaj18>	also ksh has some interesting new build stuff
T 1708662422 18<28emanuele618>	i meant "no, i have not tried them"
T 1708662522 18<25ormaaj18>	I know :)
T 1708663577 18<25ormaaj18>	https://bpa.st/raw/S43UK
T 1708663914 18<28emanuele618>	bash wins :)
T 1708664494 18<28emanuele618>	bash locals work like ash/dash locals
T 1708664521 18<28emanuele618>	hmm i wonder if readonly locals in dash work like bash
T 1708664555 18<28emanuele618>	actually i am not even sure   unset var   works like bash in dash
T 1708664698 18<28emanuele618>	hmm, in dash   unset -v var   works like in bash, but also in called functions, so like when you have the localvar_unset shopt on in bash 5.2
T 1708664767 18<28emanuele618>	so i cannot test if  really_unset -v var  can delete local readonlies because you cannot use really_unset in dash
T 1708664887 18<28emanuele618>	oops, i am misremembering you cannot delete local readonlies in bash either; the quirk of local readonlies in bash is that you can shadow them with another local
T 1708664955 18<28emanuele618>	in dash you cannot shadow local readonlies :o
T 1708665002 18<28emanuele618>	# x=out; a () { local x=in; readonly x; b () { local x=shadow; echo "$x" ;}; b; echo "$x" ;}; a; echo "$x"
T 1708665004 18<25shbot18>	emanuele6: shadow
T 1708665004 18<25shbot18>	emanuele6: in
T 1708665004 18<25shbot18>	emanuele6: out
T 1708665007 18<28emanuele618>	d# x=out; a () { local x=in; readonly x; b () { local x=shadow; echo "$x" ;}; b; echo "$x" ;}; a; echo "$x"
T 1708665008 18<25shbot18>	emanuele6: dash: 1: local: x: is read only
T 1708665027 18<28emanuele618>	# readonly x=out; a () { local x=in; b () { local x=shadow; echo "$x" ;}; b; echo "$x" ;}; a; echo "$x"
T 1708665030 18<25shbot18>	emanuele6: bash: local: x: readonly variable
T 1708665030 18<25shbot18>	emanuele6: bash: local: x: readonly variable
T 1708665030 18<25shbot18>	emanuele6: etc... ( http://paste.wooledge.org/28800 )
T 1708665048 18<28emanuele618>	in bash you can shadow readonlies as long as they are not global readonlies
T 1708665112 18<28emanuele618>	another difference is that trying to declare a (global) readonly local is a fatal error in dash, while in bash it just makes local fail and print a warning
T 1708665216 18<28emanuele618>	i wonder if anything interesting happens if you use    declare -gr x   to make x a global readonly while there are locals shadowing it
T 1708665533 18<25ormaaj18>	I never use them anyway
T 1708666104 18<28emanuele618>	nothing interesting happens :/
T 1708666182 18<25danza18>	hi all
T 1708666183 18<25danza18>	someone here wrote how to map a command to a signal via bash ... do not recall ... it would be handy to map functions to Ctrl-D when one has to type them often
T 1708666391 18<28emanuele618>	!forget readonly
T 1708666391 18<29greybot18>	OK, emanuele6
T 1708666401 18<20bent_fingers18>	you can't use readline?
T 1708666440 18<20bent_fingers18>	press a keybinding and the signal does what signals do
T 1708666444 18<28emanuele618>	!learn readonly Variables marked readonly (declare -r) are intended to be used with a restricted shell, to stop you from trivially changing PATH to escape the restrictions (etc.). They were never intended to be widely used in scripts. Global readonly variables cannot be shadowed by local variables.
T 1708666444 18<29greybot18>	OK, emanuele6
T 1708666500 18<20bent_fingers18>	i don't use readonly
T 1708666528 18<28emanuele618>	it was saying that  local var  is inherits the readonly attribute from the global scope which is wrong; maybe it used to be true in earlier versions, or maybe greycat just mixed up readonly with export
T 1708666617 18<28emanuele618>	^D as a readline binding only works if your prompt is not empty
T 1708666654 18<28emanuele618>	if it's empty, the terminal interprets it and reports that it is at end of file to bash
T 1708666696 18<28emanuele618>	maybe bash only enables raw mode when the terminal is not empty, and disables it when it becomes empty
T 1708666844 18<28emanuele618>	hmm, no it is always in raw mode
T 1708666882 18<25danza18>	yeah so i would ^D on empty prompt to rerun a command, but forgot how to override the signal handler
T 1708666918 18<28emanuele618>	something in bash handles ^D (0x4) from the terminal before sending it to readline i guess
T 1708666941 18<25danza18>	nevermind it is not important
T 1708666945 18<28emanuele618>	danza: ^D is not a signal; normally in a cooked terminal it is a binding that flushes what you have currently typed in to the terminal file
T 1708667000 18<28emanuele618>	^D with nothing typed in, flushes nothing, but still wakes up readers; and if a reader wakes up reading nothing, it interprets that as "there is nothing left to read"
T 1708667044 18<28emanuele618>	^C (SIGINT) and ^\ (SIGQUIT) are signals for example, but ^D is not
T 1708667087 18<28emanuele618>	to disable ^D you just put the terminal in raw mode, but it is already in raw mode in an interactive bash prompt
T 1708667138 18<28emanuele618>	something in bash is handling it before readline can handle it if the prompt is empty
T 1708667190 18<22mute18>	danza: help bind
T 1708667329 18<28emanuele618>	it seems there is no way to make that not handle ^D before readline
T 1708667355 18<25danza18>	thanks mute. I would bind to ^\ then emanuele6, seems to do nothing in my shell
T 1708667357 18<28emanuele618>	but if you change the eof character of the terminal then that does not happen
T 1708667400 18<28emanuele618>	e.g. if you run   stty eof $'\ct'    then ^D with an empty prompt does not exit, and instead runs the readline binding
T 1708667424 18<28emanuele618>	but then you have to press ^T instead of ^D when running anything :/
T 1708667436 18<28emanuele618>	danza: hmm, why ^\?
T 1708667437 18<22mute18>	i would probably not mess with stty.  i use to and it always ends in tears.
T 1708667441 18<28emanuele618>	you can bind any key
T 1708667459 18<25danza18>	yeah good point
T 1708667483 18<28emanuele618>	so why ^\? :)
T 1708667499 18<25danza18>	yeah good point, i would bind something else
T 1708667719 18<28emanuele618>	oh, you were telling me that ^\ does not do anything in your shell
T 1708667734 18<28emanuele618>	^\ and ^C are terminal bindings not bash bindings
T 1708667766 18<28emanuele618>	when you are running a command you can use them to kill the foreground processes with that SIGQUIT/SIGINT
T 1708667812 18<28emanuele618>	if you run a program that does not exit immediately e.g.  cat    and then press  ^\  you should see that it dies
T 1708667837 18<28emanuele618>	and you will probably also see a message that says   Quit (core dumped)
T 1708667904 18<28emanuele618>	^\ is used to stop processes, so it is kind of like ^C, but it uses a different signal number, and generates a coredump of the program as if it crashed
T 1708667947 18<25danza18>	i see, nice
T 1708668604 18<22rkta18>	Is there an FAQ entry about launching a long running background job from a script? I want the script to exit after starting the job.
T 1708668844 18<28emanuele618>	you cannot start a job from a script; you could do it declaring a function in your bashrc or calling the script as   . myscript   instead of just   myscript
T 1708668875 18<28emanuele618>	the code needs to run in the interactive shell to add a job
T 1708668888 18<22rkta18>	s/job/task
T 1708668905 18<28emanuele618>	then i do not understand the question
T 1708668941 18<28emanuele618>	to run something in the background you just use &
T 1708668954 18<22rkta18>	I want to start a long running command from a script. I did not mean a job in the sense of job control.
T 1708669041 18<28emanuele618>	& runs a command in the background   cmd &
T 1708669065 18<22rkta18>	With & alone the script does not exit.
T 1708669075 18<28emanuele618>	what do you mean?
T 1708669086 18<28emanuele618>	to exit you use exit
T 1708669193 18<22rkta18>	I take that back. Too early in the morning... Anyways, is there an FAQ entry? I don't trust StackOverflow.
T 1708673243 18<24geirha18>	heh, someone discovered asort https://old.reddit.com/r/bash/comments/1axonee/how_to_sort_arrays_natively_in_bash/
T 1708674359 18<25ormaaj18>	\o/
T 1708674489 18<25ormaaj18>	:3
T 1708674552 18<25ormaaj18>	mew
T 1708680363 18<24depesz18>	hi. is there a way to view history of commands ran in other terminal? they haven't been written to bash_history because this bash hasn't exited yet, and histappend was not set.
T 1708680551 18<24depesz18>	geirha: i'm on bash 5.2.21, and enable -p doesn't show asort. any idea as to why?
T 1708680781 18<28emanuele618>	enable -p shows the builtins that are currently loaded, so just the default ones by default
T 1708680799 18<28emanuele618>	you would not see asort there unless you enable it. with enable asort
T 1708680821 18<28emanuele618>	but iirc asort is not installed by default
T 1708680861 18<24depesz18>	ah. ok. looks like i don't have it.
T 1708680885 18<24depesz18>	they way geirha wrote it seemed to me that asort is well known, broadly available. doesn'
T 1708680891 18<24depesz18>	doesn't look like this from my place in debian :)
T 1708680896 18<25ormaaj18>	all of the "examples" are installed if they're enabled in the build, generally.
T 1708680907 18<28emanuele618>	it is not a good idea to use it anyway, i remember it had some memory leaks, and maybe it even crashed for some inputs
T 1708680923 18<28emanuele618>	ormaaj: not all, some are blacklisted in the makefile
T 1708680938 18<28emanuele618>	e.g. necho
T 1708680948 18<28emanuele618>	and asort :D
T 1708680963 18<28emanuele618>	those --> OTHERPROG = necho hello cat pushd asort
T 1708680981 18<25ormaaj18>	I have both
T 1708681005 18<28emanuele618>	did you install them manually?
T 1708681043 18<25ormaaj18>	no
T 1708681098 18<25ormaaj18>	I have my own blacklist for skipping over the useless loadables and "greylist" for renaming some crappy ones with function wrappers.
T 1708681299 18<25ormaaj18>	like head
T 1708681312 18<28emanuele618>	the makefile does install OTHERPROG in any configuration
T 1708681312 18<25ormaaj18>	piece of crap
T 1708681322 18<28emanuele618>	s/does/& not/
T 1708681356 18<25ormaaj18>	(the  -c is for "not crap)
T 1708681366 18<28emanuele618>	# enable asort; a=( z y x ); asort -i a a; typeset -p a
T 1708681368 18<25shbot18>	emanuele6: declare -a a=([0]="-3472328296227680305" [1]="4049355305727046445" [2]="1")
T 1708681372 18<25ormaaj18>	(the  -c is for "not crap")
T 1708681379 18<28emanuele618>	# enable asort; typeset a=(z y x) b c=1; asort -i b a; asort -i c a
T 1708681380 18<25shbot18>	emanuele6: no output
T 1708681386 18<28emanuele618>	# enable asort; typeset a=(z y x) b c=1; asort -i b a; asort -i c a; typeset -p a b c
T 1708681388 18<25shbot18>	emanuele6: declare -a a=([0]="z" [1]="y" [2]="x")
T 1708681388 18<25shbot18>	emanuele6: declare -a b
T 1708681388 18<25shbot18>	emanuele6: declare -a c=([0]="2" [1]="1" [2]="0")
T 1708681434 18<28emanuele618>	i sent a patch for those bugs, and other internal bugs in asort, 11 months ago, but it was ignored :/
T 1708681456 18<25ormaaj18>	WTF
T 1708681464 18<25ormaaj18>	>:(
T 1708681540 18<28emanuele618>	if you use it in a function you have to remember to declare the local with  arrname=()   instead of just arrname or it will not find it
T 1708681566 18<25ormaaj18>	I will just find your patchs and apply them
T 1708681639 18<24Aryan18>	is there any tool to recursively run the commands behind the pipe, so I could understand what each portion of pipe does?
T 1708681641 18<24Aryan18>	EXEC=$(grep -e '^Exec=.*' "${HERE}"/*.desktop | head -n 1 | cut -d "=" -f 2 | cut -d " " -f 1)
T 1708681690 18<25ormaaj18>	recursively?
T 1708681729 18<25ormaaj18>	What the commands in the pipeline actually do has no impact on the way the redirections are set up.
T 1708681766 18<24Aryan18>	I mean it executes grep -e '^Exec=.*' "${HERE}"/*.desktop, shows the output, then "grep -e '^Exec=.*' "${HERE}"/*.desktop | head -n 1" , so on
T 1708681833 18<25ormaaj18>	You can use tee but the output will be in a random order unless you aggregate the results.
T 1708681914 18<25ormaaj18>	You should replace the head and cut with sed anyway
T 1708682065 18<25ormaaj18>	or awk
T 1708682085 18<25ormaaj18>	(the entire thing can be replaced with awk)
T 1708682183 18<28emanuele618>	the entire awk can be replaced by cut head and grep
T 1708682195 18<25ormaaj18>	gross tho
T 1708682279 18<28emanuele618>	hmm, what is the point of head -n1 if you are checking multiple files that all have Exec=?
T 1708682300 18<28emanuele618>	i just looked at that query; i think you can replace the entire thing with just one gnu grep command :D
T 1708682304 18<24Aryan18>	emanuele6, ask him: https://github.com/AppImage/AppImageKit/blob/master/resources/AppRun
T 1708682319 18<24Aryan18>	emanuele6, really?
T 1708682322 18<28emanuele618>	yes
T 1708682333 18<24Aryan18>	thank you ormaaj for the tee
T 1708682349 18<28emanuele618>	Aryan: grep -om1 -- '^Exec=\K[^ ]*' "${HERE}"/*.desktop
T 1708682352 18<28emanuele618>	err
T 1708682357 18<28emanuele618>	  grep -Pom1 -- '^Exec=\K[^ ]*' "${HERE}"/*.desktop
T 1708682376 18<24Aryan18>	dammn
T 1708682425 18<24Aryan18>	awsome! :D
T 1708682433 18<28emanuele618>	yes!
T 1708682482 18<25ormaaj18>	can't use -- with grep
T 1708682510 18<28emanuele618>	?
T 1708682527 18<28emanuele618>	why not?
T 1708682535 18<25ormaaj18>	--  will be treated as the pattern. grep doesn't accept --
T 1708682549 18<28emanuele618>	lol, no
T 1708682558 18<28emanuele618>	# grep -m1 -- . .bashrc
T 1708682559 18<25shbot18>	emanuele6: # disable history expansion
T 1708682654 18<25ormaaj18>	why does that work?
T 1708682672 18<28emanuele618>	why would that not work?
T 1708682707 18<28emanuele618>	the first positional argument is patterns, and the other arguments are file when you don't use -e
T 1708682728 18<28emanuele618>	like sed
T 1708682744 18<28emanuele618>	except for sed is commands instead of just patterns
T 1708682778 18<25ormaaj18>	heh I thought the manual said it doesn't work
T 1708682784 18<24Aryan18>	so what causes it to not print the Exec=? how does the regex do that?
T 1708682812 18<24Aryan18>	you do this with \K?
T 1708682836 18<28emanuele618>	foo\K is short for  (?<=foo)
T 1708682856 18<28emanuele618>	it's a lookbehind assertion; there must be foo before the match, but foo is not part of the match
T 1708682885 18<24Aryan18>	ok I get it, wow. awsome.
T 1708682905 18<28emanuele618>	aw
T 1708682910 18<24Aryan18>	pretty handy
T 1708683022 18<25ormaaj18>	(?^=foo) for look up assertion.
T 1708683199 18<28emanuele618>	(?😎=foo) for look cool assertion
T 1708683847 18<25ormaaj18>	what is the point of -e then?'
T 1708684089 18<28emanuele618>	same as sed; it is more convenient to write   -e foo -e bar   instead of   $'foo\nbar'
T 1708684154 18<25ormaaj18>	hm? why would you have more than one?
T 1708684165 18<25ormaaj18>	they do totally different things
T 1708684200 18<25ormaaj18>	multiple -e's in sed allow you to run another expression against the same input line
T 1708684255 18<28emanuele618>	sed $'cmd\ncmd' also lets you do that
T 1708684309 18<28emanuele618>	hmm, i use grep with multiple patterns very often
T 1708684855 18<27balrog_18>	hi, I have an issue with a rather large sample of data I'd like to create b2sums for. After a long time investigating the issue I had about missing samples in my script, I encircled the error here. I think b2sum has issues with those wired filenames. https://0x0.st/H5Op.txt
T 1708684970 18<25ormaaj18>	newline in a pattern in grep turns into an or?
T 1708685071 18<28emanuele618>	yes
T 1708685102 18<28emanuele618>	-e foo -e bar  prints line that match "foo" or match "bar"   -e $'foo\nbar'  is the same
T 1708685127 18<27balrog_18>	to be more precise http://0x0.st/H5OO.txt that's a bug in b2sum?
T 1708685135 18<27Earnestly18>	ormaaj: foo\nbar == -e foo -e bar
T 1708685146 18<25ormaaj18>	:o
T 1708685165 18<27Earnestly18>	ormaaj: how -f works too, with newline separation
T 1708685210 18<27Earnestly18>	balrog_: It doesn't have an issue, what happens is if you have a weird filename it'll prefix the checksum with \ that indicates it's using an escaping scheme to represent it
T 1708685219 18<28emanuele618>	balrog_: the "\"? that is correct; sum programs use a leading \ to indicate that \\ \n \r in the path are special
T 1708685316 18<27balrog_18>	oh, so in my follow up scripts I was searching for
T 1708685355 18<27balrog_18>	sed 's|\([a-z0-9]*\).*$|\1|g' - this way I wanted to extract the b2sum and strip the filenames. I have to correct it then
T 1708685385 18<27Earnestly18>	balrog_: You can safely extract the first field without such complexity, but you must check if the first character is \ and handle it
T 1708685462 18<25ormaaj18>	I didn't know that
T 1708685522 18<25ormaaj18>	I would just use -z
T 1708685606 18<25ormaaj18>	or switch to rhash
T 1708685610 18<27balrog_18>	<Earnestly> I guess you are correct, that was the first solution to that came to my mind displaying the first field without the ":" b2sum inserts. Can you give me an example please, without just adding '\' to the sed thing as a possibility outside the group? I don't even know how to write the sed rule for the *possibility* of a matching "\" right after "$"
T 1708685704 18<27balrog_18>	sample output here https://0x0.st/H5Op.txt , I do have 670000~ files in total
T 1708685708 18<25ormaaj18>	ugh -z is so much better.
T 1708685719 18<27Earnestly18>	balrog_: awk '{if(substr($1, 1, 1) == "\\") print substr($1, 2); else print $1}'
T 1708685853 18<27Earnestly18>	balrog_: And as ormaaj suggests, -z won't include the \. Generally nul termination is correct when working with filenames/paths. E.g. gawk -v RS='\0' '{print $1}'
T 1708685893 18<27balrog_18>	<Earnestly> this doesn't replace my sed followup script I think, any way to do it all in one command from "\hash: filename" or "hash: filename" to "hash"?
T 1708685905 18<27balrog_18>	ok
T 1708685928 18<27Earnestly18>	Actually, don't need that substr, can: awk 'index($1, "/") == 1 {print substr($1, 2); next} {print $1}'
T 1708685943 18<27Earnestly18>	balrog_: I think the solution you need is to stop using sed
T 1708685970 18<25ormaaj18>	sed -z also handy
T 1708685972 18<27Earnestly18>	balrog_: The format does not include a : btw
T 1708685994 18<27balrog_18>	<ormaaj> rhash anyhow has lower collision resistence and worse performance? I need to run the script on armv7h 32bit cpu
T 1708686035 18<27Earnestly18>	balrog_: If you can recreate the data, use -z instead. You might also want to use b3sum if performance is a concern as it is /significantly/ faster
T 1708686039 18<27Earnestly18>	b2sum's defaults are a bit silly
T 1708686062 18<27balrog_18>	<Earnestly> you are right, no Idea why I had the : in mind/where it's  from
T 1708686076 18<27Earnestly18>	balrog_: Btw, including <nick> in your reply makes it seems like you're quoting people
T 1708686120 18<27Earnestly18>	ormaaj: b3sum has no -z but it does have --no-names which obviates the need to remove the filename afterwards
T 1708686206 18<25ormaaj18>	I don't see why rhash would be different given same algo
T 1708686260 18<27balrog_18>	just to complete my whole issue: After made sure with rmlint (filesize/atime check by default I guess) there are no duplicates in my sample, I use find/b2sum for the above output and generate a sumsonly file. Doing "cat file|sort > file.sorted" && "cat file.sorted |sort -uc" I can be sure there are no collisions?
T 1708686355 18<27Earnestly18>	balrog_: b3sum --no-names | sort | uniq -d
T 1708686388 18<27Earnestly18>	balrog_: But rmlint already does this, it even has b2sum support
T 1708686402 18<27Earnestly18>	I think
T 1708686422 18<27Earnestly18>	Yeah blake2b and blake2bp
T 1708686518 18<27balrog_18>	https://bpa.st/VJQGQ
T 1708686563 18<27Earnestly18>	In fact, if all you're doing is rolling b2sum over your files and you want to list duplicates: find . -type f -exec b2sum {} + | sort -k1,1 | awk 'seen[$1]++'
T 1708686572 18<27Earnestly18>	Sorry, doesn't need sort there
T 1708686586 18<27Earnestly18>	find . -type f -exec b2sum {} + | awk 'seen[$1]++'
T 1708686592 18<27Earnestly18>	!euo > balrog_
T 1708686592 18<29greybot18>	balrog_: The so-called unofficial bash strict mode (set -euo pipefail) is overhyped nonsense. See https://lists.gnu.org/archive/html/help-bash/2020-04/msg00049.html and https://mywiki.wooledge.org/BashFAQ/105
T 1708686614 18<27balrog_18>	<Earnestly>, no I do need this file later on, comparing a local dataset with a remote one, using comm
T 1708686623 18<27Earnestly18>	balrog_: You might also want to consider just learning and using borgbackup (or anything that uses content-addressable storage)
T 1708686633 18<25ormaaj18>	I don't have a b3sum command
T 1708686674 18<27Earnestly18>	balrog_: Why are you calling b2sum for each file you find? That must be painfully slow
T 1708686709 18<28emanuele618>	inb4sum command
T 1708686898 18<27Earnestly18>	ormaaj: You have to go a bit out of your way to get it if distro doesn't provide: https://github.com/BLAKE3-team/BLAKE3
T 1708686925 18<27balrog_18>	<Earnestly> isn't this covered by "pipefail"? I had a lot of situations where I've had minor bugs/uncatched errors in my scripts where "set -euo pipefail" saved me a lot of time, extending it to -euxo pipefail when needed to investigate. What would you use instead?
T 1708686935 18<27Earnestly18>	ormaaj: It's basically the same as blake2 but they use 7 rounds instead of 10
T 1708686955 18<27Earnestly18>	balrog_: Error checking
T 1708686965 18<25ormaaj18>	we have a blake3 library but no utility associated
T 1708687117 18<27Earnestly18>	balrog_: Or ideally read the links in that response
T 1708688087 18<27balrog_18>	<Earnestly> good to know. I see your point and had unexpected results in scripts like https://bpa.st/2NRH2 leading me to add a some tests. An error here leads to being stuck in kernelpanic/initramfs shell
T 1708688481 18<27Earnestly18>	balrog_: For a laugh, opinionated rewrite: https://0x0.st/H5On.sh - I'm not really sure what your goals are so this may be meaningless
T 1708688488 18<27balrog_18>	<Earnestly> will check blake3 out later, 7 instead of 10 only applies for blake2s, but I'm using blake2b I guess on my 64bit-arm/desktop? It seems to add a lot speed as more threads you have. Can't wait to see the results
T 1708688546 18<27Earnestly18>	ormaaj: Btw, do you know that GNU cksum(1) is quite similar to rhash now? I.e. check the manpage: https://0x0.st/H5O5.txt
T 1708688756 18<27Earnestly18>	balrog_: 2b is 12 rounds, 2s is 10
T 1708688763 18<27Earnestly18>	https://datatracker.ietf.org/doc/html/rfc7693#section-2.1
T 1708688849 18<27balrog_18>	<Earnestly> very nice, ty :) having a big set of data on my pc and other sets on different machines. (I can't/don't know how to use rmlint via ssh). I basicly have three buckets of data: Bad, unviewed, good. Bad and good are local. Unviewed are remote, talking about terrabytes. I want to delete the dups in remote "unviewed" datasets by using those b2sum lists and "comm" program in bash
T 1708696020 19*	Now talking on 22#bash
T 1708696020 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1708696020 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1708696162 18<28rlikon18>	nvm
T 1708696166 18<28rlikon18>	solved
T 1708696321 19*	Now talking on 22#bash
T 1708696321 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1708696321 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1708696899 18<19maccampus18>	 My Mac went into recoverymode & i noticed zsh was changed to bash. is Bash still the standard sh in recovery mode ? Why ?
T 1708697004 18<29phy172918>	!os
T 1708697004 18<29greybot18>	Take it to your OS channel. Your issue is specific to your Operating System or Distribution.
T 1708697430 18<22tirnanog18>	if that environment drops you in as root, it's probably because the login shell for the root user is defined as /bin/sh.
T 1708697732 18<25Lynx-18>	Hello tirnanog
T 1708697785 18<22tirnanog18>	good day.
T 1708697787 18<25Lynx-18>	I just wanted to thank you for your suggestion from ages ago
T 1708697789 18<25Lynx-18>	https://github.com/lynxthecat/adblock-lean/blob/9de4b1ba855a76306ec977146d61e22e4af8d963/adblock-lean#L308
T 1708697800 18<22tirnanog18>	oh, I remember that.
T 1708697828 18<25Lynx-18>	Yes, it saved quite a bit of memory. Now a user reported using huge 220K blocklist on 64MB router.
T 1708697834 18<22tirnanog18>	splendid.
T 1708697922 18<26lopid18>	marvellous
T 1708698655 18<29Masklin18>	I'm having a meltdown. I have two files containing newline-separated number strings, length 1-10. I want to see how many strings are shared between the two.
T 1708698666 18<29Masklin18>	I thought grep -F would match whole lines, but I get no matches?
T 1708698740 18<29Masklin18>	Uh
T 1708698768 18<28llua18>	man comm
T 1708698791 18<28selckin18>	cat a b | sort | uniq -c | sort -n
T 1708698793 18<22tirnanog18>	# grep -cxFf <(printf %s\\n {1..20}) <(printf %s\\n {10..15})
T 1708698794 18<25shbot18>	tirnanog: 6
T 1708698808 18<22tirnanog18>	grep is fine. just have to know how to use it.
T 1708698931 18<22tirnanog18>	although, I didn't specify the operands in the order I intendeed. -f needles haystack, basically.
T 1708698965 18<27Earnestly18>	(grep also doesn't need inputs to be sorted, which is nice)
T 1708699216 18<22tirnanog18>	if you were not using -f, of course you'd get no matches.
T 1708699235 18<22tirnanog18>	(but it's generally sensible to show what you are doing when asking such questions)
T 1708699302 18<29Masklin18>	[1-9][0-9]{1,10}
T 1708699304 18<29Masklin18>	What am I missing?
T 1708699307 18<29Masklin18>	I'm going crazy
T 1708699319 18<29Masklin18>	This should match two or more digits, the first one of which is never zero.
T 1708699323 18<29Masklin18>	Does it not???
T 1708699332 18<22tirnanog18>	you don't need a number-matching pattern. it has no bearing on the stated goal.
T 1708699334 18<29Masklin18>	This is grep.
T 1708699351 18<22tirnanog18>	you are asking for the count of the intersection of lines.
T 1708699359 18<29Masklin18>	Oh you mean I should diff?
T 1708699385 18<22tirnanog18>	I'm not sure how a working example employing grep and "grep is fine" translates as "you should use diff".
T 1708699421 18<22tirnanog18>	grep -cxFf file1 file2
T 1708699459 18<22tirnanog18>	preferably with the shorter of the two files being "file1" there, but it's not a requirement.
T 1708699987 18<22tirnanog18>	by the way, -F does not instruct grep to match whole lines. it's -x that has that particular effect.
T 1708700449 18<22Riviera18>	maybe one should collect option combinations that form words.
T 1708700499 18<22Riviera18>	like grep -Fixe or rsync -Pavian (which is German for baboon:P)
T 1708700596 18<22tirnanog18>	it's a good idea but I can't in this instance.
T 1708700792 18<22tirnanog18>	the notion reminds me of a document I read a few days ago in which one author of a library was criticising another, similar, one on the basis of its lack of "huffmanization"; the common case not being reflected by the defaults and requiring too many rote options.
T 1708700936 18<22tirnanog18>	gentoo is a good example. upgrading is easy. just run emerge -uaDNv @world. couldn't be simpler! oh, but go back and repeat with --with-bdeps=y if one's later emerge --depclean/c phase fails because ... reasons.
T 1708701108 18<22tirnanog18>	-DuaN works there, I suppose.
T 1708702331 18<28emanuele618>	geirha: ah, thank you. i didn't notice
T 1708703333 18<25Momentum18>	Hi
T 1708703375 18<25Momentum18>	is there anything wrong about this bit to include the git branch in PS1?
T 1708703377 18<25Momentum18>	https://sprunge.us/Kf4vna?sh
T 1708703425 18<25Momentum18>	sometimes when i use the up arrow to look at the commands history some commands get stuck
T 1708703496 18<28emanuele618>	Momentum: yes, you should print the colour codes between \1 and \2 or bash will think they occupy space in the terminal
T 1708703497 18<22tirnanog18>	you haven't escaped the non-printing characters. also, it has to be done in a particular way for functions called by PS1.
T 1708703499 18<22tirnanog18>	!faq fancy
T 1708703500 18<29greybot18>	https://mywiki.wooledge.org/BashFAQ/053 -- I have a fancy prompt with colors, and now bash doesn't seem to know how wide my terminal is.  Lines wrap around incorrectly.
T 1708703535 18<28emanuele618>	with echo -e the codes for \1 and \2 are \01 and \02
T 1708703620 18<25Momentum18>	ah! interesting
T 1708703624 18<25Momentum18>	thank you let me try that
T 1708704265 18<25Momentum18>	solved the original problem but now the space after the $ disappears when i go through the history
T 1708704374 18<27Soliton18>	not sure why you think you solved anything then.
T 1708704396 18<27Soliton18>	you need to tell bash what parts of the prompt do not move the cursor.
T 1708704457 18<27Soliton18>	if you do not do it properly then it does not know where the cursor is and the prompt will get messed up.
T 1708704508 18<25Momentum18>	okay
T 1708704539 18<25Momentum18>	i think this idea of evaluating the function in the PS1 variable is messing it up
T 1708704602 18<27Soliton18>	for dynamic strings in the prompt you do need to use \01 and \02 as mentioned in the faq.
T 1708704656 18<25Momentum18>	well i did that i think
T 1708704658 18<25Momentum18>	https://sprunge.us/yhuwPn?sh
T 1708704731 18<27Soliton18>	what is the last " " supposed to do?
T 1708704760 18<25Momentum18>	to add a space between the branch name and the $
T 1708704767 18<27Soliton18>	printf will repeat the format string if you give more arguments than required.
T 1708704784 18<27Soliton18>	just put it in the format then.
T 1708704805 18<25Momentum18>	if i put it in the format and there's not git repo initialized it would be an additional space
T 1708704812 18<27Soliton18>	printf '\001%s\002%s\001%s\002 ' "$blue" "$branch" "$reset"
T 1708704819 18<25Momentum18>	AH!
T 1708704829 18<25Momentum18>	pfft i forgot how printf works
T 1708704859 18<25Momentum18>	yeah this is perfect
T 1708704861 18<25Momentum18>	thank you so much
T 1708704887 18<27Soliton18>	you're welcome.
T 1708704888 18<25Momentum18>	i thought by format you meant i add it in the PS1
T 1708704899 18<25Momentum18>	evaluation
T 1708704903 18<25Momentum18>	but yeah that's good
T 1708704949 18<27Soliton18>	you could add the color formatting in PS1 directly and use \[\] since that'll look fine even if the function prints nothing.
T 1708704982 18<25Momentum18>	oh
T 1708704995 18<27Soliton18>	you'd just have superfluous escape codes in there if there is no branch.
T 1708705015 18<25Momentum18>	i kinda tried that but i don't remember what went wrong
T 1708705034 18<25Momentum18>	this looks clean enough to me though so
T 1708705287 18<27Soliton18>	well calling tput all the time is not so great. if you put the color in PS1 you'd just call it once when building PS1.
T 1708705323 18<27Soliton18>	or you could cache tput output in a global variable.
T 1708705369 18<25Momentum18>	aah i see
T 1708705381 18<25Momentum18>	i will do that
T 1708705858 18<29cart_18>	Is there a bash command that I can use to make another program execute and quit after a certain timeout?
T 1708705883 18<26lopid18>	there are various 'timeout' implementations
T 1708705893 18<26lopid18>	!timeout
T 1708705893 18<29greybot18>	http://mywiki.wooledge.org/BashFAQ/068 -- How do I run a command, and have it abort (timeout) after N seconds?
T 1708707335 18<24flower_18>	Earnestly: one more question about process management in the realm of non-session-manager (NSM), which starts a audio application, gets it's pid and stops the application by using SIGTERM. Now there is a terminal application which will reexecute itself into a xterm. When that application announces itself to the NSM server with a pid (which it got using getpid() ), that pid differs from the process started
T 1708707341 18<24flower_18>	by the NSM server. Now I did a little test and used getppid() instead of getpid() and the server now gets the expected pid. I assume, that is the pid of the terminal in which the application was launched, and so the NSM server sends SIGTERM to the terminal, when it wants to stop the application. It it a safe way to handle a application which is started in a terminal in this situation?
T 1708707386 18<25Inline18>	ppid and pid,hmmm
T 1708707407 18<24flower_18>	https://www.man7.org/linux/man-pages/man2/getpid.2.html
T 1708707429 18<25Inline18>	uncatchable signals and signals that have to be handled hmmmm
T 1708707462 18<25Inline18>	async safe and thread safe signals
T 1708707468 18<25Inline18>	oh man
T 1708707479 18<24flower_18>	normally the server launched a application and knows it's pid. But now there is a terminal as extra layer so to say
T 1708707521 18<24flower_18>	I assume that terminal is the parent of the application which is started in that terminal
T 1708707571 18<24flower_18>	I think here it is started in the terminal: https://github.com/jpcima/adljack/blob/master/sources/jackmain.cc#L260
T 1708708182 18<27phox18>	hey, wondering if there's a "not putting conditionals inside of config files" tidy way to make stuff like ~/.bash_profile and friends conditional, specifically I want to have a macOS terminal profile get me a different bash environment than I normally have... the farthest it more or less lets me go is executing a command when the shell starts (which is pretty janky as last I checked it was an input race ugh)
T 1708708188 18<27phox18>	... but maybe specify an alternate config as a parameter to bash -l there?
T 1708708274 18<22tirnanog18>	if you are only concerned with Terminal.app, alternative parameters could be reasonable.
T 1708708296 18<27phox18>	yeah that's the only way I care about getting into this shell configuration
T 1708708331 18<22tirnanog18>	it lets you configure a program to run. uncheck "Run inside shell", presumably.
T 1708708338 18<27phox18>	yeah
T 1708708410 18<27phox18>	so just create an alternative ~/.bash_profile and pass it via whatever option and call it good I guess?
T 1708708429 18<27phox18>	just wanting to avoid finding out later on that there's something janky and problematic about how I did this :P
T 1708708501 18<22tirnanog18>	I just gave it a try. doesn't work as I expect. hmm.
T 1708708565 18<27phox18>	seems to work for me?
T 1708708583 18<27phox18>	the command is a /path/to/other/bash -l
T 1708708602 18<22tirnanog18>	yes. but I can't get it to work with --rcfile for some reason.
T 1708708605 18<22tirnanog18>	trying to figure out how it's being parsed.
T 1708708640 18<27phox18>	ah yeah I didn't try that part yet
T 1708708657 18<22tirnanog18>	huh. it's order-sensitive. didn't know that.
T 1708708658 18<27phox18>	(part of the thing was also using an alternate bash binary so that works)
T 1708708685 18<22tirnanog18>	/other/bash --rcfile /path/to/file -il works
T 1708708707 18<27phox18>	ah right -i so it doesn't go "ha you're not a tty"
T 1708708716 18<27phox18>	forgot about that
T 1708708758 18<22tirnanog18>	this is what I did initially:
T 1708708776 18<22tirnanog18>	# bash -il --rcfile /dev/null |& head -n1
T 1708708779 18<25shbot18>	tirnanog: bash: --: invalid option
T 1708708787 18<22tirnanog18>	can't put --rcfile there.
T 1708708798 18<27phox18>	mm, good find heh
T 1708708868 18<22tirnanog18>	I don't use long options much, as you may have surmised :D
T 1708708975 18<27phox18>	same
T 1708709163 18<27phox18>	related question, I have ulimit -u in my .bash_profile and of course if I `bash -l` within the shell it complains it can't set it because it's one-time (even though the value is the same it still tries), is there a tidy way to make that go away?  I guess I could just put a conditional that checks the current value and doesn't try to increase it if it's already increased
T 1708709258 18<22tirnanog18>	perhaps check $SHLVL
T 1708709435 18<27phox18>	ahh that's a point
T 1708709475 18<27phox18>	lol I used to have more of that in my head, now I just make my variable expansions and conditionals safe and consider that enough :)
T 1708709500 18<20bent_fingers18>	i don't have anything in my head :(
T 1708709874 18<25fdan18>	hi there, do we have a global bashrc file for all remote users
T 1708709914 18<27phox18>	can you explain what you're trying to do so we understand the terminology more clearly?
T 1708709957 18<25fdan18>	hey we used to have aliases set for all users for eg
T 1708709958 18<25fdan18>	if i login as my user and type ubu, it would do a sudo su -l ubuntu
T 1708709964 18<27Earnestly18>	!dotfiles
T 1708709964 18<29greybot18>	Set up your environment (PATH, LANG, EDITOR, ...) in ~/.bash_profile. Set up your bash shell (PS1, functions, shopts, ...) in ~/.bashrc. Then source .bashrc from .bash_profile. See <http://mywiki.wooledge.org/DotFiles>. For GUI logins, SEE YOUR DOCUMENTATION or ask your OS channel because they're all different and we don't know.
T 1708709969 18<25fdan18>	or if i do ec2, it would do a sudo su -l ec2-user
T 1708710003 18<27phox18>	it should be the ones in /etc (see documentation as linked above), so maybe they were overwritten, or permissions snafu, or...
T 1708710070 18<27phox18>	`man bash` discusses the order they're loaded in and when and why (different between login and non-login shells; others are assumed to inherit environment from a login shell in concept)
T 1708710104 18<27Soliton18>	if you want system wide commands then just write a script and put it somewhere in PATH.
T 1708710139 18<25fdan18>	Soliton i want the aliases to be available to all users when they ssh
T 1708710151 18<22tirnanog18>	whether there is a system-wide bashrc depends on whether your package maintainer decided to define SYS_BASHRC at the time of building bash. by default is is unset. quite a few operating systems have an /etc/profile (for login shells) that source from /etc/profile.d/*.sh, so that couldb e another way to do it.
T 1708710153 18<27Soliton18>	because you want to make it complicated or why?
T 1708710165 18<27Soliton18>	!aliases
T 1708710166 18<29greybot18>	Aliases suck. They don't work in scripts. They can't take arguments. They have special evil magical powers that break all expectations. See http://mywiki.wooledge.org/BashFAQ/080 for starters.
T 1708710166 18<22tirnanog18>	or you could do what Soliton said and create scripts.
T 1708710260 18*	26ormooj like aliases
T 1708710271 18<22tirnanog18>	you mentioned ubuntu so an /etc/profile.d/ snippet that checks for an interactive shell would suffice: if [[ $- == *i* ]]; then alias foo=bar; fi
T 1708710274 18<25fdan18>	tirnanog i dont see anything in *.sh in /etc/profile.d
T 1708710293 18<22tirnanog18>	there's a solution for things not existing, though, which is to create them.
T 1708710308 18<25fdan18>	when i do which ubu, it says the aliases
T 1708710312 18<27phox18>	tirnanog: ahh weird it's not using my .bash_profile =/
T 1708710318 18<25fdan18>	but how do i find where exactly is the aliases are present
T 1708710383 18<22tirnanog18>	fdan: BASH_XTRACEFD=1 PS4='+$BASH_SOURCE:$LINENO: ' bash -ixlc '' | grep '\balias\b'
T 1708710392 18<25fdan18>	ok i see it in ~/.bashrc
T 1708710397 18<26ormooj18>	Aliases make the cthuhlu happy. ~~(~.~)~~
T 1708710404 18<25fdan18>	other users are also able to use the aliases, how is it possible?
T 1708710413 18<22tirnanog18>	I already told you how to do it.
T 1708710436 18<22tirnanog18>	"an /etc/profile.d/ snippet that checks for an interactive shell would suffice: if [[ $- == *i* ]]; then alias foo=bar; fi"
T 1708710497 18<25fdan18>	tirnanog when i cd to /etc/profile.d and then do grep -i 'ubu' .
T 1708710501 18<25fdan18>	i dont see any result
T 1708710504 18<22tirnanog18>	it doesn't matter what is there.
T 1708710508 18<22tirnanog18>	what matters is what you want.
T 1708710521 18<22tirnanog18>	call it /etc/profile.d/local-aliases.sh or something.
T 1708710594 18<25fdan18>	no i dont find any occurences
T 1708710604 18<25fdan18>	for eg: when i do grep -r 'ubu' .
T 1708710604 18<22tirnanog18>	occurences of what?
T 1708710606 18<27phox18>	tirnanog: ugh it looks like --rcfile only works if it's not a login shell?  booo  heh
T 1708710610 18<22tirnanog18>	what is grep even supposed to prove?
T 1708710619 18<22tirnanog18>	I'm literally telling you how to custome system-wide login shells.
T 1708710636 18<25fdan18>	i was expecting alias ubu='sudo su -l ubuntu'
T 1708710649 18<25fdan18>	i was expecting to see this somewhere inside /etc/profile.d?
T 1708710651 18<22tirnanog18>	I also told you how to trace to find where existing aliases are defined.
T 1708710653 18<22tirnanog18>	already.
T 1708710660 18<26ormooj18>	phox: really? :o
T 1708710665 18<22tirnanog18>	it's very frustrating that you are not (seemingly) acknowledging my responses.
T 1708710674 18<25fdan18>	yes tirnanog, i got that, but my question is how other users are able to have it in their own ~/.bashrc
T 1708710694 18<27phox18>	ormooj: documentation seems to agree and I'm using --rcfile ~/.bash_profile_other and it's still sourcing ~/.bash_profile
T 1708710698 18<22tirnanog18>	fdan: I don't understand the question. other users can have it in their own ~/.bashrc by ... editing their ~/.bashrc?
T 1708710708 18<22tirnanog18>	fdan: but you're asking for system-wide aliases
T 1708710737 18<22tirnanog18>	fdan: I'm telling you that creating a sourceable file under /etc/profile.d is one way to achieve that.
T 1708710737 18<25fdan18>	tirnanog so we have an image, and everyone is able to ssh to the instance and then everyone is able to just type ubu
T 1708710747 18<27phox18>	i.e. --rcfile only has an effect when it would have read .bashrc instead of .bash_profile
T 1708710747 18<22tirnanog18>	fdan: ok. and?
T 1708710748 18<25fdan18>	which switches user to ubuntu user
T 1708710762 18<22tirnanog18>	fdan: what does "type ubu" say it is?
T 1708710772 18<27phox18>	so maybe there's no option for overriding the interactive login shell config paths?!
T 1708710793 18<25fdan18>	tirnanog ubu is aliased to `sudo su -l ubuntu`
T 1708710808 18<22tirnanog18>	fdan: again, I told you how to trace where aliases are defined. do I need to write it out again?
T 1708710808 18<26ormooj18>	# exec -- bash --rcfile /proc/self/fd/3 -lc exit 3<<<'echo moo'
T 1708710814 18<25shbot18>	ormooj: no output within the time limit
T 1708710818 18<22tirnanog18>	fdan: BASH_XTRACEFD=1 PS4='+$BASH_SOURCE:$LINENO: ' bash -ixlc '' | grep '\balias\b'
T 1708710821 18<26ormooj18>	D:
T 1708710849 18<25fdan18>	tirnanog my question is simple, how is it available to all users?
T 1708710864 18<22tirnanog18>	don't ask me. RUN A TRACE.
T 1708710867 18<25fdan18>	lets say i want to configure a system wide aliases, how do i do that
T 1708710874 18<22tirnanog18>	christ almighty.
T 1708710881 18<27phox18>	^
T 1708710891 18<22tirnanog18>	do you think I'm going to give a different answer the second, third, fourth time you ask the question?
T 1708710905 18<22tirnanog18>	to know where existing aliases are defined, run a trace.
T 1708710915 18<22tirnanog18>	to define aliases system-wide, consider /etc/profile.d/.
T 1708710919 18<25fdan18>	how to run a trace?
T 1708710923 18<22tirnanog18>	this can't be real.
T 1708710928 18<26ormooj18>	lol
T 1708710949 18<27phox18>	further to the dotfiles blurb, wouldn't it make more sense to also create a .profile and then source .bashrc and then .profile from .bash_profile, to keep the other PATH and whatever stuff portable to other shells (if you use them)?  :P
T 1708710958 18<27phox18>	fdan: scroll up, it was explained
T 1708710969 18<22tirnanog18>	walking away. this is too much.
T 1708710993 18<26ormooj18>	!cookie > tirnanog
T 1708710993 18<29greybot18>	tirnanog: 🍪
T 1708711005 18<27phox18>	tirnanog: srsly though, any idea if I can override login shell init?  looks like --rcfile only affects non-login shells and I'm not seeing another option unless I'm blind here lol
T 1708711019 18<27phox18>	I will actually do as I am told too (within reason, ahem)
T 1708711076 18<26ormooj18>	phox well there's --profile , so
T 1708711089 18<27phox18>	only that, but I want to feed it an alternative
T 1708711107 18<24bxsx18>	x="$(find .)"; echo $x gives me an empty output and I have to use the -print option..why?
T 1708711114 18<27phox18>	oh wait derp, I read that as --noprofile
T 1708711117 18*	27phox checks docs
T 1708711160 18<27phox18>	ormooj: I don't seem to have that, I'm on 5.2 or something
T 1708711163 18<26ormooj18>	nevermind I thought --noprofile might trigger it
T 1708711181 18<27phox18>	oh there's --init-file
T 1708711185 18<27phox18>	that might be it, let's see
T 1708711217 18<27phox18>	nope wth, wonder if that's an alias for rcfile
T 1708711226 18<27phox18>	oh of course it is, fallthrough description duh
T 1708711266 18<26ormooj18>	BASH_INIT is another but it also has stupid limitations
T 1708711291 18<27Soliton18>	bxsx: what does  type find  output?
T 1708711332 18<26ormooj18>	I'll see about polishing my bash-based bash and put it on github or something maybe. bash's interactive mode is utterly broken and useless really. The ultimate solution is to just discard it.
T 1708711358 18<27phox18>	heh
T 1708711370 18<27phox18>	yeah making crap like that go away long term would be amazing
T 1708711372 18<26ormooj18>	it requires bash 5.3
T 1708711381 18<27phox18>	I can probably have that soon idk
T 1708711388 18<20bent_fingers18>	phox: you can make stuff go away with ^Z
T 1708711397 18<20bent_fingers18>	perhaps you missed my lecture
T 1708711401 18<24bxsx18>	Soliton: find is hashed (/usr/bin/find) and find is /usr/bin/find
T 1708711414 18<24bxsx18>	Soliton: I tested it on 2 envs
T 1708711440 18<27Soliton18>	# x="$(find .)"; echo $x
T 1708711441 18<25shbot18>	Soliton: . ./.mkshrc ./.bashrc
T 1708711445 18<27phox18>	bent_fingers: I like to sigtstp first
T 1708711448 18<27phox18>	it's more fun that way
T 1708711456 18<27Soliton18>	you have a weird find then.
T 1708711497 18<24bxsx18>	find (GNU findutils) 4.8.0; Features enabled: D_TYPE O_NOFOLLOW(enabled) LEAF_OPTIMISATION FTS(FTS_CWDFD) CBO(level=2)
T 1708711519 18<27Soliton18>	# find --version
T 1708711521 18<25shbot18>	Soliton: find (GNU findutils) 4.7.0-git
T 1708711521 18<25shbot18>	Soliton: Copyright (C) 2017 Free Software Foundation, Inc.
T 1708711521 18<25shbot18>	Soliton: etc... ( http://paste.wooledge.org/28806 )
T 1708711556 18<27Soliton18>	unless they changed GNU find a lot that is not how it works.
T 1708711577 18<24bxsx18>	well, i'm surprised too
T 1708711608 18<27Soliton18>	i have find 4.9.0 here and it works normally as well.
T 1708711732 18<24bxsx18>	ok, it's working fine
T 1708711734 18<24bxsx18>	my fault
T 1708711756 18<26ormooj18>	~~(~.~)~~
T 1708711757 18<24bxsx18>	Soliton: -quit :P
T 1708711761 18<20bent_fingers18>	where's the documentation for C-S and C-Q?
T 1708711775 18<20bent_fingers18>	ctrl-s says it's bound to forward search
T 1708711784 18<20bent_fingers18>	i'm looking for the pause or freeze function
T 1708711883 18<26ormooj18>	bent_fingers: the info page is more complete than the manual with regards to interactive features.
T 1708711930 18<20bent_fingers18>	good point, i prefer the html version though, thanks
T 1708711954 18<27phox18>	while the content is useful, it is a known fact that nobody likes GNU Info
T 1708711998 18<26ormooj18>	it's called infopage regardless of output format
T 1708712067 18<20bent_fingers18>	it's not in there
T 1708712082 18<20bent_fingers18>	i think this is a terminal thing
T 1708712094 18<26ormooj18>	I doubt it says anything other than listing the default bindings
T 1708712300 18<27Soliton18>	if flow control is enabled then ^S will stop output. that's a feature of the terminal.
T 1708712383 18<27balrog_18>	I wrote a script with some improvements by Earnestly https://bpa.st/3W3NQ : it returns a file with nul separated "b2hash filename" pairs. I'd now like to have a method getting the filename by hash. `awk -v 'RS=\0' "/^$hash/ {print \$2}" filename` however fails whenever the filename contains spaces. Any suggestions?
T 1708712418 18<22tirnanog18>	phox: no means is apparent to me.
T 1708712428 18<20bent_fingers18>	Soliton: yeah, i see
T 1708712476 18<22tirnanog18>	phox: what effect do you require of it? perhaps sourcing /etc/profile from your rcfile would suffice?
T 1708712567 18<26ormooj18>	balrog_: There is no point in post-processing command output to substitute in nul delimiters. You must use the built-in -z option or it's useless.
T 1708712600 18<27phox18>	tirnanog: different environment, so far I just went and added conditionals to .bash_profile which is working for me
T 1708712618 18<27phox18>	just interesting that you can only override one config file search and not the other
T 1708712657 18<22tirnanog18>	phox: yeah.
T 1708712671 18<22tirnanog18>	it's bash. hope springs infernal.
T 1708712685 18<27phox18>	anyways at least the thing works
T 1708712757 18<27phox18>	thanks again for all the help :D
T 1708712923 18<27Earnestly18>	balrog_: If you don't like borg, look into restic
T 1708712931 18<27balrog_18>	ormooj I don't know what you want to say - my above command snippet works, but for some data like "1234 path-to-dir/long spaced file name\0ffff path-to-dir/another file" looking for "1234" it returns only "path-to-dir/long" and not "path-to-dir/long spaced file name" as I want it to.
T 1708713001 18<27Earnestly18>	balrog_: Don't use code injection like dumping $hash into awk like that
T 1708713004 18<27Earnestly18>	!inject
T 1708713004 18<29greybot18>	Injecting data into a type of code is always wrong. Convert your data into code that represents that data before injecting it. This is called quoting or escaping. See ![language]quote (eg. !bashquote !jsonquote !htmlquote !mysqlquote !requote !urlquote)
T 1708713038 18<27Earnestly18>	E.g. hash=$hash awk 'index($0, hash) == 1' # also avoids regex entirely
T 1708713078 18<27Earnestly18>	(Because you don't actually want regex interpretation of the content of $hash)
T 1708713092 18<27Earnestly18>	index($0, ENVIRON["hash"]) == 1 # sorry
T 1708713114 18<27JAA18>	`awk -v hash="$hash" ...`
T 1708713124 18<20tanath18>	i understand escaping, but that bot quote is hard to understand
T 1708713128 18<27Earnestly18>	JAA: Nah
T 1708713145 18<27phox18>	tanath: +1
T 1708713146 18<26ormooj18>	balrog_: The entire point in using nul as a delimiter is to facilitate arbitrary names in pathnames. (and a solution that involves injecting output into a command is even worse than useless)
T 1708713166 18<27Earnestly18>	JAA: I wouldn't want the values of shell variables to be interpreted as awk values
T 1708713193 18<27phox18>	tanath: also "before injecting it" so you should use injection anyways :D
T 1708713206 18<27Earnestly18>	balrog_: To emphasis what ormooj wrote, nul separation is the /only/ correct way to delimit filenames, it is correct by definition of what a filename is
T 1708713225 18<27JAA18>	Earnestly: Oh, does it not always treat them as strings?
T 1708713232 18<27Earnestly18>	phox: You have to if you use openssh or dropbear `ssh command'
T 1708713251 18<27Earnestly18>	JAA: It treams them like awk variables, so \n means newline and not \n
T 1708713317 18<27JAA18>	Earnestly: Ah, huh, TIL.
T 1708713335 18<26ormooj18>	Well, it's not the only way, there are many ways, it is one good way. But all such solutions only work when the command producing the output is written to write output unambiguously. You can't fix up a broken command with shell hacks.
T 1708713348 18<27Earnestly18>	# awk -v foo='a\nb' 'BEGIN {printf "%s", foo}' | od -cAn
T 1708713350 18<25shbot18>	Earnestly:    a  \n   b
T 1708713359 18<27Earnestly18>	ormooj: It is the only correct way
T 1708713367 18<27JAA18>	Yeah, that's the exact test I just did as well. :-)
T 1708713376 18<27JAA18>	Like, to the letter. lol
T 1708713377 18<27Earnestly18>	Or I suppose it's the only minimally correct way, I guess
T 1708713392 18<27balrog_18>	Earnestly, will look into restic, ty. https://bpa.st/3W3NQ is the new script, took yours and adjusted it abit for my needs (no more regex I think?). I somehow attempted to output the *full* filename out of the given data... so there is no easy solution and I should "learn" awk syntax you say like "index($0, ENVIRON["hash"]) == 1"(I don't understand this)
T 1708713395 18<27Earnestly18>	I'm not interested in stupid shit like converting everything to a custom encoding like base64
T 1708713412 18<26ormooj18>	Another method is to output a "netstring". They are actually pretty ok.
T 1708713422 18<27Earnestly18>	ormooj: netstrings require nul too
T 1708713440 18<27Earnestly18>	Or does it
T 1708713462 18<27Earnestly18>	ormooj: I'm thinking of a djb thing sorry
T 1708713471 18<26ormooj18>	I don't think so. a pathname wouldn't contain a nul anyway so.
T 1708713478 18<26ormooj18>	yeah, the djb thing.
T 1708713554 18<27Earnestly18>	ormooj: It just uses , as an optional sanity check sentinel. I remember implementing this in bash but in the context of scgi which uses nul to separate key and value, hence my confusion
T 1708713591 18<27Earnestly18>	ormooj: https://0x0.st/H5te.txt (turning scgi into cgi, wiping out all the benefits \o/)
T 1708713593 18<27balrog_18>	<ormooj> nul is required, as "b2sum" misbehaved without -z option :/ my sample of mixed windows/unix files has all sort of "unusual" characters as filenames, I try to catch them *all* this way
T 1708713681 18<27Earnestly18>	balrog_: Windows is different, but under unix a filename is defined as literally any sequence of bytes in any order that cannot contain NUL or /
T 1708713713 18<27Earnestly18>	Hence, / for separating filenames in a path is correct, and NUL for separating filenames or paths is correct. It's not merely preference
T 1708713774 18<28emanuele618>	# printf -v x x%.s {1..256}; pathchk -- "$x"
T 1708713776 18<25shbot18>	emanuele6: pathchk: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx: File name too long
T 1708713776 18<27balrog_18>	<Earnestly> just wanted to say some user data was created under ntfs and later/currently stored under ext4. Will change to btrfs later. Changing the filenames would be the easiest way, but that's not an option
T 1708713802 18<27Earnestly18>	There's no need to change filenames, just understand the datatype and do it properly, it's not hard
T 1708713845 18<27Earnestly18>	At least, I think it's not so hard once you accept the reality of the situation
T 1708714055 18<24flower_18>	Earnestly: saw my process management question?
T 1708714109 18<27Earnestly18>	ormooj: I was remember djb's qmail "data structure" which was something called string0 iirc. The "structure" was single bytes written to a file such that if it was interrupted during the right it could still easily recover it (unlike say json)
T 1708714144 18<27Earnestly18>	flower_: Yeah but it kind of washed over me. I sort of just abandon investigation if pidfiles come into play and things which spawn terminals, etc.
T 1708714200 18<27Earnestly18>	ormooj: https://blog.plover.com/prog/erlang-race-condition-2.html nice little article
T 1708714212 18<26ormooj18>	I mostly like that you get the field widths up front, so it works without delimiters and is efficient. You can read an array with a single read per element without over-consuming or hunting for a delmiter.
T 1708714238 18<27Earnestly18>	I hadn't thought of that, yeah really nice
T 1708714250 18<24flower_18>	Earnestly: ok, no problem. Anyway, when the application (launched in the terminal) announced using getpid(), the pid was unexpected to the NSM server, using getppid() not. Hm
T 1708714268 18<27Earnestly18>	ormooj: I the old 'Fish' book talks about a C joke that most C programs read bytes and do nothing with them
T 1708714296 18<27Earnestly18>	flower_: The ppid would be the terminal itself, usually, unless there's even more forking around
T 1708714324 18<27Earnestly18>	pstree should help, or you can make your own PPID chaser back to PID1
T 1708714449 18<24flower_18>	Earnestly: that's what I was assuming indeed. So the question is probably, does it hurt to kill the parent by SIGTERM, e.g. the terminal, of the application. Itt seems to work fine, also when the application quits itself.
T 1708714457 18<24flower_18>	will check pstree
T 1708714549 18<27Earnestly18>	flower_: Make sure your own script responds by signalling its own children too, i.e. trap 'kill 0' EXIT (bash). You can try and send the same signal or just term, whichever
T 1708714625 18<26ormooj18>	well, not single read. There has to be a delimiter between the length and value, so it's n + 2 reads per element where n is the number of bytes in the length mod the radix used for the length representation which is probably 10 normally.
T 1708714719 18<26ormooj18>	it's an efficiency win if the values aren't itsy bitsy.
T 1708714734 18<27Soliton18>	flower_: why do you need to deal with this at all? either the client tells you a PID and that's what you deal with or you use the PID you got when starting the client. any other shenanigans the client does are on them to handle surely.
T 1708714841 18<26ormooj18>	you could use fixed-width length fields, at a small cost in space usage and max field length limit
T 1708714997 18<27Earnestly18>	ormooj: About your radix, just for reasonability here, a radix of 6 would mean a million bytes long, 15 would be a quadrillion...
T 1708715098 18<27Earnestly18>	ormooj: memchr(buf, ':', 10); is probably reasonable
T 1708715122 18<27Earnestly18>	I'd probably just limit it to 5 and error out telling users their string is too long
T 1708715155 18<27balrog_18>	!bashquote
T 1708715155 18<29greybot18>	Prepare literal data for injection into bash code: printf %q "$data". Eg. ssh host bash <<< "$(printf 'rm %q' "$localvar")"
T 1708715217 18<26ormooj18>	balrog_: that's different. that is for the specific situation where you're escaping strings for use by the shell. You must already have the data read into bash for that to be useful.
T 1708715227 18<27Earnestly18>	ormooj: (6* sorry, 6 is 1M string. 5 would be a 100kB)
T 1708715332 18<27balrog_18>	<ormooj> yea, it's more hope. Just struggling / researching right now how to read in/process the data into pairs
T 1708715543 18<26ormooj18>	I don't know lvm. I must learn this. :(
T 1708715592 18<22Riviera18>	why
T 1708715742 18<26ormooj18>	to use, for things. I'm switching my root volume to xfs and moving it to an SSD, because btrfs is slow and stupid, and kind of want the flexibility to mutate the partitioning.
T 1708715808 18<22Riviera18>	so just do the thing
T 1708715813 18<22Riviera18>	no need to "learn" anything
T 1708715822 18<22Riviera18>	but ok, thanks for answering :)
T 1708715857 18<26ormooj18>	:|
T 1708715864 18<26ormooj18>	moo
T 1708716117 18<26ormooj18>	might try bcachefs eventually but probably wait for a few release cycles to shoot myself with that
T 1708716160 18<27balrog_18>	<ormooj> to my knowledge btrfs is just *very* slow (compared to xfs/ext4) for specific data samples, like databases. For other purposes btrfs has some nice features, like automatic defrag, deduplication and/or compression
T 1708716249 18<27balrog_18>	my root volume on my desktop is ext4 or xfs, while home is btrfs - cow as main reason
T 1708717978 18<20Tadgy18>	shopt -s extglob; foo="Bar Baz   <   <barbaz>"; echo "X${foo%*( )<*>}X"  # Anyone know why the spaces after the < aren't removed despite the extglob?
T 1708718031 18<27larryv18>	% does shortest match
T 1708718058 18<20Tadgy18>	That's not the issue.
T 1708718062 18<27larryv18>	# foo="Bar Baz   <   <barbaz>"; echo "X${foo%*( )<*>}X"; echo "X${foo%%*( )<*>}X"
T 1708718063 18<25shbot18>	larryv: XBar Baz   <   X
T 1708718063 18<25shbot18>	larryv: XBar BazX
T 1708718074 18<20Tadgy18>	I don't want the first < removed.
T 1708718122 18<20Tadgy18>	The extglob *( ) should match any number of spaces before the <*> glob....
T 1708718125 18<20Tadgy18>	It doesn't...
T 1708718158 18<27Soliton18>	it should match the least amount of spaces which is zero.
T 1708718183 18<20Tadgy18>	Sure, but it should also match *any* number of spaces.
T 1708718192 18<20Tadgy18>	Try it with + and it's the same.
T 1708718198 18<27Soliton18>	yes, the least amount of any is zero.
T 1708718230 18<27Soliton18>	it's not the same with +. that matches one space.
T 1708718255 18<20Tadgy18>	Matches one or more occurrences of the given patterns
T 1708718261 18<20Tadgy18>	"or more"
T 1708718270 18<20Tadgy18>	Not exactly one.
T 1708718273 18<27Soliton18>	and the least amount of one or more is one.
T 1708718320 18<20Tadgy18>	So, how do you say "any spaces before <*>" but after < ?
T 1708718358 18<27Soliton18>	well, put the < in there.
T 1708718403 18<27larryv18>	# foo="Bar Baz   <   <barbaz>"; echo "X${foo%<*( )<*>}<X"
T 1708718405 18<25shbot18>	larryv: XBar Baz   <X
T 1708718442 18<20Tadgy18>	The first < may or may not be a < though - could be any char - I just tested with < because it matched the <*>
T 1708718466 18<27Soliton18>	perhaps figure out the complete goal first then.
T 1708718475 18<27larryv18>	could have said that earlier.
T 1708718565 18<20Tadgy18>	Soliton: That's the only goal.
T 1708718578 18<27balrog_18>	I found a solution (second link/script) for my issue. Please feel free to rate/improve. https://bpa.st/SR34S https://bpa.st/GTJHG
T 1708718759 18<20Tadgy18>	So, +( ) isn't a "greedy" match in extglob?  It'll only match the shortest of "one or more" occurances?
T 1708718760 18<27Soliton18>	why are you looking in different fields? the hash is in the first field.
T 1708718784 18<27larryv18>	Tadgy: as already noted, it depends on whether you use % or %%.
T 1708718871 18<20Tadgy18>	OK, thanks.
T 1708718880 18<27larryv18>	# foo='Bar Baz   <   <barbaz>'; printf %s\\n "X${foo%%+( )<!(*<*)>}X"
T 1708718881 18<25shbot18>	larryv: XBar Baz   <X
T 1708718882 18<27Soliton18>	i don't understand why it's not just $1 == search_hash.
T 1708718886 18<27larryv18>	# foo='Bar Baz   <   <barbaz>'; printf %s\\n "X${foo%%+( )<*([!<])>}X"
T 1708718887 18<25shbot18>	larryv: XBar Baz   <X
T 1708719173 18<27Soliton18>	# printf '%s  %s\0' hash1 '  file  1  ' hash2 file2 | hash=hash1 awk -v 'RS=\0' '$1 == ENVIRON["hash"] {print substr($0,length($1)+3)}'
T 1708719174 18<25shbot18>	Soliton:   file  1
T 1708719185 18<27balrog_18>	<Soliton> the hash most likely is not in the first field. The first field looks like 'b2sumhash1  somedir/some filename+with)spaces and $ymb0ls\0' I think - in case I got "field" right here.
T 1708719216 18<27Soliton18>	most likely?? you don't know the format you're parsing?
T 1708719264 18<27Soliton18>	is  b2sumhash1  is the hash then that is the first field there, no?
T 1708719275 18<27balrog_18>	I do, I just do not know the exact meaning of "field" - the data is harvested by the first script/link.
T 1708719304 18<27Soliton18>	you're using awk. awk splits input lines into fields. $1 is the first field etc.
T 1708719339 18<27balrog_18>	yea, but I chose \0 as delim, so each hash/filename pair is a seperate field?
T 1708719375 18<27Soliton18>	each pair is a line. your lines just end in \0 not \n.
T 1708719412 18<27Soliton18>	or rather record is what awk calls it.
T 1708719422 18<27Soliton18>	RS being the record separator.
T 1708719423 18<27balrog_18>	okay, so each hash is a field then.
T 1708719440 18<27balrog_18>	each hash is in the first field then*
T 1708719447 18<27Soliton18>	each record consists of: <hash>  <path>
T 1708719470 18<27Soliton18>	so first field is the hash and the rest is the path.
T 1708719514 18<27Soliton18>	so for the path you don't try to cobble together the fields but look into $0 which is the record.
T 1708719522 18<27balrog_18>	it's generated by `find "${dir}" -type f -exec b2sum -z {} +|sort -z`
T 1708720189 19*	Now talking on 22#bash
T 1708720189 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1708720189 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1708720292 18<27Earnestly18>	balrog_: To be clear, that format which b2sum prints (along with all the other *sum utils) is: [hash][type][space][filename]. [type] is almost always "text" which is a space so it appears as '[hash] [space][filename]'
T 1708720330 18<27Earnestly18>	Sorry, [hash][space][type][filename]
T 1708720406 18<20twkm18>	hmm.
T 1708720413 18<27Earnestly18>	That means you extract the filename reliably from awk's $0 by using substr($0, length($1) + 3)
T 1708720467 18<27Earnestly18>	(According to that format, anyway)
T 1708720629 18<27Earnestly18>	# for a in oawk nawk; do printf '%s\0' a b | "$a" -v RS='\0' 'END {printf " %s: [%s]", $0, ARGV[0]}'; done # I forget how these handle unspecified use of RS
T 1708720631 18<25shbot18>	Earnestly: oawk: syntax error near line 1
T 1708720631 18<25shbot18>	Earnestly: oawk: bailing out near line 1
T 1708720631 18<25shbot18>	Earnestly: etc... ( http://paste.wooledge.org/28808 )
T 1708720651 18<27Earnestly18>	Yeah, both dislike it
T 1708720982 18<26ba1r0g18>	Soliton: this is how you did suggest it? https://bpa.st/37KAA
T 1708721177 18<27Earnestly18>	ba1r0g: (Do change progname to the name you want to give your script, e.g. hash2file or file-lookup, etc.)
T 1708721644 18<27Earnestly18>	balrog_: Consider https://0x0.st/H5vR.txt
T 1708721677 18<27Earnestly18>	balrog_: https://0x0.st/H5v7.sh missed the shebang
T 1708722020 18<27Earnestly18>	Next step would be to allow multiple hashes to be used at once and have the script output files with nul separation. Ideally also provide a hardcoded db path so you don't have to specify it every time with a flag like -d to let the user provide an alternative
T 1708722287 18<26zxfx18>	yo
T 1708722621 18<26ormooj18>	Earnestly: Another solution - two channels. One stream is an array of fixed-width offsets and another for data. That is both efficient and adds support for random access!
T 1708722735 18<27Earnestly18>	ba1r0g: That next step might look like this: https://0x0.st/H5wH.sh
T 1708722760 18<26ormooj18>	If one channel is bi-directional you could even ask for a specific offset or range of elements
T 1708722803 18<26ormooj18>	find does not support a %n-like thing D:
T 1708722806 18<27Earnestly18>	ormooj: I like that sort of approach, it suits C quite well too
T 1708722877 18<27Earnestly18>	ormooj: I did something like that for a basic xml parser, it stored offsets to elements in a fixed buffer. Had a bug though so when I fed it a file and /immediately/ ^C'd it, it already created a 4G file :(
T 1708722910 18<27Earnestly18>	Instead of all this memcpy nonsense, just store a pointer and length
T 1708722947 18<27Earnestly18>	(It didn't support arbitrarily sized documents)
T 1708723148 18<26ormooj18>	ooh could work nicely with linux O_DIRECT pipes too
T 1708723480 18<26ormooj18>	emanuele6 showed me those ^^. I think I knew about them but didn't know they were so easy.
T 1708737176 18<28MagicMike18>	https://i.redd.it/tofgpybli7x41.jpg
T 1708738044 18<19Sparkles18>	MagicMike, I would not call that a "real" hacker on the left, too.
T 1708738070 18<19Sparkles18>	There's a term "script kiddie" or "skiddie" you sure know I believe, too.
T 1708738307 18<28MagicMike18>	Sparkles, isnt the def of a skiddie someone that literally only writes Bash scripts (hence word script in skiddie)
T 1708738353 18<19Sparkles18>	I am sorry, but I will refrain answering this.
T 1708738353 18<28MagicMike18>	like someone that can only run someone elses program from Bash but has no idea how programming works because they only know Bash
T 1708738464 18<19Sparkles18>	I am not sure how Bash is ever remotely related to it here.
T 1708739505 18<19Sparkles18>	> When the hacker's system crashes in Windows, as with all typical Windows crashes, Heckman said the user would be prompted to send the error details — including the malicious code — to Microsoft. The funny thing is that many say yes, according to Heckman.
T 1708739529 18<19Sparkles18>	/ https://www.zdnet.com/article/hackers-accidentally-give-microsoft-their-code/
T 1708739650 18<19Sparkles18>	It's interesting that this article author's last post on this website was in 2015 and the most of their most recent posts there are "HTTP 401 Gone": https://www.zdnet.com/article/hackers-accidentally-give-microsoft-their-code/
T 1708739674 18<19Sparkles18>	er: https://www.zdnet.com/meet-the-team/josh-taylor/
T 1708772561 19*	Now talking on 22#bash
T 1708772561 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1708772561 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1708772790 18<27balrog_18>	<Sparkles> do you know whether is there an analogy from .bash_profile to .zprofile in terms of execution? I did change my login shell to zsh and use .zshrc and .xprofile for env right now. Internet also mentions .zshenv, I'm confused
T 1708773242 18<27Earnestly18>	`man zsh' and read the STARTUP/SHUTDOWN FILES section
T 1708783594 18<20TKD_tower18>	difference between /pathto/dir vs /pathto/dir/ ?
T 1708783630 18<26lopid18>	the /
T 1708783637 18<20TKD_tower18>	and
T 1708783646 18<26lopid18>	one came first
T 1708783653 18<20TKD_tower18>	wdym
T 1708783661 18<26lopid18>	you said the one without before the one with
T 1708783707 18<20TKD_tower18>	...
T 1708783910 18<19Arumes18>	  Let's say you want to move a file to the folder "dir".
T 1708783928 18<19Arumes18>	If you do mv myfile dir/, it'll move the file to dir/myfile if the folder exists. If the folder does not exist, you get an error message.
T 1708783954 18<19Arumes18>	If you do mv myfile dir, it'll rename the the file myfile to its new name "dir.
T 1708783995 18<28selckin18>	mkdir -p dir && mv file dir/
T 1708784013 18<22tirnanog18>	what's the question, though?
T 1708784070 18<19Arumes18>	The question is if there's a difference. And I try to explain that the asnwer is "yes" and give an example when that final / can really matter.
T 1708784114 18<22tirnanog18>	yes, indeed. the circumstances matter.
T 1708784158 18<22tirnanog18>	there are ways to go about avoiding an unwanted outcome, though. selckin mentioned one. GNU mv has -T, which is sometimes useful.
T 1708784256 18<27Earnestly18>	TKD_tower: See path_resolution(7) for an explanation and where a trailing / might matter
T 1708784279 18<27Earnestly18>	It even has a section called 'Trailing Slashes'
T 1708784532 18<28greatgatsby_18>	not sure where else to ask this, I'm looking for a way to update the checksum for a file in a SHA256SUMS file that contains hashes for multiple files.  Right now I'm using a tac/awk/sponge one-liner after appending the updated checksum, but I'm still looking for a less hacky solution
T 1708785171 18<27Earnestly18>	greatgatsby_: Do you have the original checksum?
T 1708785207 18<22tirnanog18>	I would say that using sponge is not ideal. tail end of pf 13 explains why.
T 1708785214 18<22tirnanog18>	!pf 13
T 1708785214 18<29greybot18>	https://mywiki.wooledge.org/BashPitfalls#pf13 -- Don't do this! -- cat file | sed s/foo/bar/ > file
T 1708785390 18<27Earnestly18>	greatgatsby_: Something like: newhash="$hash" file="$foo" awk 'substr($0, length($1)+3) == ENVIRON["file"] {printf "%s %s%s\n", ENVIRON["newhash"], substr($2, 1, 1), ENVIRON["file"]; next}; 1' < SHA256SUMS > SHA256SUMS.new; ...; mv -f SHA256SUMS.new SHA256SUMS # Don't use sponge, replace ... with sanity checks. You can clean up the repeated ENVIRONs in a BEGIN block to keep it tidy.
T 1708785429 18<27Earnestly18>	greatgatsby_: *sum format is: [hash] [type][filename]. type can be ' ', 'U' or '^'. Usually it's always ' '
T 1708785483 18<27Earnestly18>	greatgatsby_: If the filename has \ \n \r or such then the filename is c-style escaped and the hash is prefixed with \ to indicate this. This doesn't account for that but something to keep in mind
T 1708785529 18<28greatgatsby_18>	tirnanog: thanks, wasn't aware of that risk using sponge.  I think in this case I'm ok - the data is easily regenerated
T 1708785564 18<27Earnestly18>	greatgatsby_: A better strategy is to just forget that sponge exists
T 1708785573 18<27Earnestly18>	Like set -e and all the other class of bad ideas
T 1708785577 18<27Earnestly18>	classes*
T 1708785609 18<27Earnestly18>	greatgatsby_: See https://backreference.org/2011/01/29/in-place-editing-of-files/index.html for why using mv is always better
T 1708786640 18<28greatgatsby_18>	Earnestly: thanks, really good read
T 1708788546 19*	Now talking on 22#bash
T 1708788546 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1708788546 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1708788585 18<27Earnestly18>	I suppose you could use: while read -r line; do ... with $line and have bash trim the leading and trailing IFS chars
T 1708788723 19*	Now talking on 22#bash
T 1708788723 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1708788723 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1708788751 18<25kurahaupo18>	Hint: what is $#
T 1708788772 18<24iconoclast_hero18>	number of arguments of last command?
T 1708788778 18<27Earnestly18>	# var=foobar; echo "${#var}"
T 1708788780 18<25shbot18>	Earnestly: 6
T 1708788782 18<25kurahaupo18>	Yes.
T 1708788801 18<25kurahaupo18>	Number of args passed in
T 1708788802 18<24iconoclast_hero18>	so it's string length?
T 1708788806 18<27Earnestly18>	awk 'NF {$1=$1; printf "%s\t%s\n", length($0), $0}' < README | sort -k 1,1n | cut -f 2-
T 1708788808 18<25kurahaupo18>	Bingo
T 1708788818 18<27koollman18>	I wonder if someone could create the right LC_COLLATE to just sort by length. all symbols being equals :)
T 1708788840 18<24iconoclast_hero18>	ok, but the thing I'm confused about is WHERE did this variable '$REPLY' come from?
T 1708788851 18<24iconoclast_hero18>	which is probably a reserved variable?
T 1708788860 18<27Earnestly18>	iconoclast_hero: `help read'
T 1708788862 18<25kurahaupo18>	However, if you merely want to sort, counting doesn't have to be decimal. Unary works just fine
T 1708788896 18<25kurahaupo18>	iconoclast_hero: for example: sed -e 'h; s/./x/g; x; G; s/\n/+/' < file | sort | cut -d+ -f2-
T 1708788898 18<27Earnestly18>	iconoclast_hero: REPLY is a bit special in that works as though you did: IFS= read -r REPLY without needing to use IFS=
T 1708788972 18<27Earnestly18>	kurahaupo: But that doesn't sort by line length
T 1708788982 18<25kurahaupo18>	Earnestly: are you sure?
T 1708788997 18<27Earnestly18>	kurahaupo: Yes, it replaces the content of each line with 'x's
T 1708789022 18<25kurahaupo18>	And what is the sort order of those?
T 1708789043 18<27Earnestly18>	kurahaupo: Whatever sort applies to it via dictionary order, certainly not length
T 1708789053 18<27Earnestly18>	https://0x0.st/H5GN.txt
T 1708789068 18<25kurahaupo18>	Earnestly: what is the sort order of 'x' vs 'xx'?
T 1708789073 18<27koollman18>	if all lines are made of the same symbol, that would be by length
T 1708789080 18<24iconoclast_hero18>	i'm watching the back and forth here, but i've got the answers i needed...
T 1708789086 18<27koollman18>	(that was why I commented on LC_COLLATE)
T 1708789115 18<24iconoclast_hero18>	if it matters, i'm trying to find extraneous-length fields in the artist and title fields of my tagged music so they | sort --table better.
T 1708789116 18*	25kurahaupo belatedly throws in LC_ALL=C sort
T 1708789123 18<27Earnestly18>	kurahaupo: That doesn't fix it either
T 1708789136 18<27Earnestly18>	kurahaupo: https://0x0.st/H5Gc.txt
T 1708789165 18<27Earnestly18>	Nice idea though, but you'd probably need a special COLLATE as koollman is suggesting
T 1708789181 18<22tirnanog18>	kurahaupo: it's correct. field splitting mechanics do not apply to bash in the absence of a name given to read.
T 1708789227 18<25kurahaupo18>	Hmm. I need to check sed G
T 1708789237 18<22tirnanog18>	so, "IFS= read -r", alone, is a meme.
T 1708789239 18<27Earnestly18>	kurahaupo: Hm, it should work though, but I guess you're not deleting the line when replacing it in the sed?
T 1708789255 18<27Earnestly18>	kurahaupo: So you just get: original_contentxxxxxxxxxxxxxxxx
T 1708789262 18<27Earnestly18>	And that's why it's breaking
T 1708789272 18<25kurahaupo18>	I intended "append hold space to current line"
T 1708789287 18<27Earnestly18>	kurahaupo: Uee g
T 1708789290 18<27Earnestly18>	Use*
T 1708789308 18<25kurahaupo18>	Isn't that "replace the current line with the hold space"?
T 1708789326 18<25kurahaupo18>	I mean, use it if it works
T 1708789332 18<27Earnestly18>	kurahaupo: > Replace the contents of the pattern space by the contents of the hold space
T 1708789356 18<25kurahaupo18>	Yeah that's not what's needed
T 1708789378 18<27Earnestly18>	kurahaupo: Perhaps sed -e 's/./x/g; h; s/\n/+/'
T 1708789413 18<27Earnestly18>	kurahaupo: Actually, why not just: sed 's/./x/g'
T 1708789426 18<27Earnestly18>	Or I suppose you want to recover the original text
T 1708789472 18<25kurahaupo18>	Save pattern space to hold space, replace each char with x, append hold space to pattern space, replace embedded newline with something other than x (and which precedes it lexicographically)
T 1708789504 18<27Earnestly18>	kurahaupo: sed 'h; s/./x/g; G; s/\n/+/'
T 1708789531 18<27Earnestly18>	The x command was putting the xxxxx's on the wrong side of the line
T 1708789543 18<25kurahaupo18>	I'm puzzled with G isn't working
T 1708789557 18<25kurahaupo18>	Ooh
T 1708789558 18<27Earnestly18>	It is working, it was the x
T 1708789574 18<25Lynx-18>	https://github.com/lynxthecat/cake-autorate/blob/036ccf57786d4bccc69e1044da8eab87c3357ee1/cake-autorate.sh#L1581 <-- can this function be sped up in any way?
T 1708789576 18<27Earnestly18>	Should have clocked that after seeing xxxxxx's in output
T 1708789633 18<25kurahaupo18>	That'll teach me for writing code blind
T 1708789643 18<25kurahaupo18>	Without any means to test it
T 1708789682 18<27Earnestly18>	Lynx-: Maybe ((alpha*(value - prev_ewma)) / 1000000) + prev_ewma
T 1708789686 18<25kurahaupo18>	iconoclast_hero: for example: sed -e 'h; s/./x/g; G; s/\n/+/' < file | sort | cut -d+ -f2- # fixed now
T 1708789755 18<27Earnestly18>	Lynx-: Also don't use local -n
T 1708789789 18<27Earnestly18>	In general, avoid indirection
T 1708789794 18<25kurahaupo18>	Earnestly: I'm dearly wishing for "direct references" rather than "symbolic references"
T 1708789856 18<27Earnestly18>	Lynx-: Otherwise nope, unless you redesign away from programming-language-style to more functional/tacit pipelines, it'd be difficult to change that function in any way. You're stuck with bash's performance
T 1708789906 18<27Earnestly18>	Better would be to use python, which is much more suited to this style of coding, or lua
T 1708789931 18<25kurahaupo18>	Or Perl, or even *choke* PHP
T 1708789937 18<27Earnestly18>	Hmm
T 1708789938 18<25Lynx-18>	Thanks for your help. Would function caching work here?
T 1708789960 18<25Lynx-18>	Since function will often be called with same inputs
T 1708789983 18<25kurahaupo18>	Lynx-: you're under the misapprehension that the Bash "function" keyword actually means something with a return value
T 1708789998 18<27Earnestly18>	You could memoise the results, cache[inputs] = output. If inputs in cache, use cache[inputs]
T 1708790012 18<25Lynx-18>	Earnestly that's what I was thinking. Would it help here do you think?
T 1708790017 18<25kurahaupo18>	Lynx-: most of the cost is in the argument passing and the 'local' commands
T 1708790022 18<27Earnestly18>	Try and see
T 1708790024 18<25Lynx-18>	This is called at about maybe 40Hz or so
T 1708790051 18<22tirnanog18>	brutal.
T 1708790052 18<27Earnestly18>	Yeah, I'd remove local as well
T 1708790052 18<25kurahaupo18>	Lynx-: at 40 Hz - do you mean the function or the whole script?
T 1708790060 18<25Lynx-18>	function
T 1708790073 18<27Earnestly18>	And I'd probably tell the cpu sorry for having to run bash scripts so often
T 1708790090 18<25Lynx-18>	on my router it's circa 15%
T 1708790098 18<22tirnanog18>	kurahaupo: I didn't hear back from you as to the opengroup discussion. the impression I got from the ensuing stalemate is that Chet will probably never be amenable to such a thing.
T 1708790109 18<24iconoclast_hero18>	props on using circa
T 1708790112 18<22tirnanog18>	kurahaupo: but doesn't ksh93 have them?
T 1708790113 18<27Earnestly18>	If I was absolutely stuck with this design I might even consider running a long running calc daemon with its own in and out fifos and send inputs that way
T 1708790123 18<24iconoclast_hero18>	people usually look at me funny when i say ca. 15%
T 1708790126 18<27Earnestly18>	Lynx-: That's really ugly just for such a basic calc
T 1708790154 18<25Lynx-18>	Earnestly how would the calc concept work. This seems interesting.
T 1708790181 18<27Earnestly18>	A program that can do math quickly, read input from stdin, write output on stdout
T 1708790189 18<25Lynx-18>	ah
T 1708790225 18<27Earnestly18>	run it < in.fifo > out.fifo & print calc > in.fifo; read -r result < out.fifo, etc.
T 1708790257 18<27Earnestly18>	fifos act as buffered queues
T 1708790287 18<25kurahaupo18>	Lynx-: set numeval='ewma = (alpha*value+(1000000-alpha)*prev_ewma)/1000000' and then simple write ((numeval)) to set ewma to the new value
T 1708790347 18<27Earnestly18>	With '... ((alpha*(value - prev_ewma)) / 1000000) + prev_ewma' as possible simplification
T 1708790410 18<25Lynx-18>	kurahaupo oh this is totally new to me - is there a name or example about this online I can check?
T 1708790421 18<25kurahaupo18>	Lynx-: but even on my ancient 800 MHz core duo CPU, Bash can invoke thousands of functions per second; it's the external commands that grind it to a crawl
T 1708790452 18<25kurahaupo18>	I suspect your bottleneck is elsewhere
T 1708790455 18<27Earnestly18>	Lynx-: This is sort of what I have in mind: https://0x0.st/H5Gw.png
T 1708790482 18<25kurahaupo18>	tirnanog: yeah and yes respectively
T 1708790521 18<27Earnestly18>	I should fix exec-with-pipe to allow arguments for the command
T 1708790532 18<25kurahaupo18>	Chet doesn't really seem to have any vision for keeping Bash relevant, and yet he keeps adding adhoc new features
T 1708790577 18<22tirnanog18>	kurahaupo: what did you make of Robert's recent response to you. was he just being a stick in the mud or did he have a point?
T 1708790624 18<22tirnanog18>	and yes, agreed.
T 1708790651 18<22tirnanog18>	on as adhoc a basis as adhoc can be.
T 1708790652 18<25Lynx-18>	Earnestly I just got your simplification - can't believe I missed that
T 1708790800 18<22tirnanog18>	Lynx-: LESS=+/^ARITHMETIC man bash # there's a note to the effect of the rules of C being observed for arithmetic evaluation
T 1708790834 18<22tirnanog18>	so, (( a = 1 )) will perform an assignment, as well as being true.
T 1708790836 18<25kurahaupo18>	tirnanog: I haven't check my "list" email folder in the last 30 hours
T 1708790871 18<22tirnanog18>	kurahaupo: ah. well it wasn't that recent. I only skimmed it. seemed to be getting on his high horse as to how such a thing could never work properly in the shell.
T 1708790904 18<25Lynx-18>	<kurahaupo> Lynx-: set numeval='ewma = (alpha*value+(1000000-alpha)*prev_ewma)/1000000' and then simple write ((numeval)) to set ewma to the new value <-- how does this work?
T 1708790918 18<25kurahaupo18>	tirnanog:  This is apropos  lexical local?
T 1708790924 18<22tirnanog18>	Lynx-: see above please.
T 1708790927 18<22tirnanog18>	kurahaupo: yeah
T 1708791004 18<25kurahaupo18>	tirnanog: there are some weird corner cases that need to be dealt with, but absolutely it can be made to work. The point is (partly) that the "broken" bits only hurt code that uses the new features
T 1708791023 18<20TKD_tower18>	Arumes: i was afk
T 1708791026 18<22tirnanog18>	kurahaupo: I see.
T 1708791042 18<20TKD_tower18>	also ty
T 1708791063 18<20TKD_tower18>	for others too
T 1708791086 18<22tirnanog18>	Lynx-: related to that section of the manual is https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_04
T 1708791200 18<25Lynx-18>	OK I got it
T 1708791206 18<25Lynx-18>	why would that be faster?
T 1708791224 18<22tirnanog18>	I think the idea was to avoid the overhead of function calling, variable localisation etc.
T 1708791273 18<25Lynx-18>	ahhh
T 1708791280 18<22tirnanog18>	and, since the assignment can be performed in the arithmetic context, maybe that turns out to be a win also. (I don't know)
T 1708791327 18<25kurahaupo18>	tirnanog: I'm guessing there are people commenting on my proposal who don't actually understand how "local" works in Perl, which is to say, it temporarily pushes a new value onto an individual valuable, with a deferred pop
T 1708791341 18<22tirnanog18>	kurahaupo: right. yes.
T 1708791350 18<22tirnanog18>	kurahaupo: ignorance of prior art abounds in general.
T 1708791358 18<25Lynx-18>	tirnanog with such a calculation performed circa 40Hz would you guess memoise would speed up?
T 1708791379 18<27Earnestly18>	Measure it
T 1708791382 18<27Earnestly18>	hyperfine(1)
T 1708791388 18<25kurahaupo18>	Which is pretty much indistinguishable from how local works in Bash
T 1708791396 18<22tirnanog18>	Lynx-: I would think so. either way, it sounds like ... yes, that. should be straightforward to implement and measure.
T 1708791417 18<27Earnestly18>	Turn it into a small script, supply it with inputs from a generator, see what happens
T 1708791428 18<25Lynx-18>	is there a template for doing that - associative array?
T 1708791429 18<22tirnanog18>	using real world inputs, preferably.
T 1708791447 18<27Earnestly18>	Lynx-: I did pretty much write it, yeah with associative
T 1708791456 18<25kurahaupo18>	Lynx-: why do you think that function is the bottleneck?
T 1708791459 18<27Earnestly18>	index on inputs
T 1708791472 18<27Earnestly18>	kurahaupo: True, if it wasn't measured already, how
T 1708791478 18<24cheater18>	what whitespace does bash use normally to separate parameters?
T 1708791481 18<25Lynx-18>	kurahaupo I just thought I'd try and speed it up because it's called by multiple processes so regularly
T 1708791482 18<24cheater18>	arguments
T 1708791541 18<25kurahaupo18>	Lynx-: the main way to speed it up is not to call a function at all, but rather to evaluate it in-line where required.
T 1708791548 18<25Lynx-18>	[15:53:18] <Earnestly> You could memoise the results, cache[inputs] = output. If inputs in cache, use cache[inputs] <-- can I delete the first element in associative array easily to avoid it growing too much?
T 1708791561 18<25Lynx-18>	kurahaupo yeah, got that - I'm going to implement that for sure
T 1708791590 18<27Earnestly18>	Lynx-: Now you want to implement an LRU cache on top of it? The problem is, bash is already slow and the more conditionals you use everywhere the worse it gets. You'd almost be better off making this function an alias... :x
T 1708791623 18<25kurahaupo18>	Eww! 🤮
T 1708791628 18<27Earnestly18>	But it is fast
T 1708791634 18<25kurahaupo18>	Indeed
T 1708791654 18<24cheater18>	how do you print out an array to see exactly what's in it? something with declare but i forgot
T 1708791668 18<25kurahaupo18>	cheater: declare -p name
T 1708791670 18<22tirnanog18>	cheater: blank (space or tab), or the characters of IFS, depending on the exact context.
T 1708791694 18<24cheater18>	thanks kurahaupo
T 1708791700 18<24cheater18>	tirnanog: i mean in a normal command line
T 1708791704 18<22tirnanog18>	blank then
T 1708791706 18<27Earnestly18>	alias ewma_iteration='(( ewma = (($2*($1 - ewma)) / 1000000) + ewma ))'
T 1708791709 18<24cheater18>	how do we know it's only space or tab?
T 1708791713 18<25kurahaupo18>	cheater: if you already have an idea that "declare" is the command to use, try "help declare"
T 1708791722 18<24cheater18>	hmm right thanks kurahaupo
T 1708791728 18<24cheater18>	that was lazy of me hehe
T 1708791736 18<25kurahaupo18>	Earnestly: with $2 inside an alias?
T 1708791739 18<22tirnanog18>	cheater: because the documentation says so. LESS='+/Simple Command' man bash
T 1708791740 18<24cheater18>	i'm writing that parser from the other day
T 1708791761 18<22tirnanog18>	cheater: also, the POSIX sh documentation should contain a formal grammer if you want to go deeper.
T 1708791764 18<22tirnanog18>	grammar*
T 1708791798 18<24cheater18>	ty
T 1708791804 18*	25kurahaupo doesn't like grammers, they're too small. Kilogrammers are better
T 1708791815 18<27Earnestly18>	kurahaupo: Hm, possibly
T 1708791845 18<27Earnestly18>	Possibly not though
T 1708791851 18<22tirnanog18>	cheater: note that "blank" has a definition just above that in the bash man page.
T 1708791870 18<27Earnestly18>	kurahaupo: The idea being using set -- before calling it
T 1708791885 18<24cheater18>	yeah i found it thanks :)
T 1708791890 18<24cheater18>	appreciated :)
T 1708791893 18<25Lynx-18>	Earnestly how would that work in terms of the calls to alias set against what I have now e.g.: https://github.com/lynxthecat/cake-autorate/blob/036ccf57786d4bccc69e1044da8eab87c3357ee1/cake-autorate.sh#L713
T 1708791936 18<25kurahaupo18>	Earnestly: true, but recall that ewma is local -n in the function
T 1708792087 19*	Now talking on 22#bash
T 1708792087 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1708792087 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1708792148 18<27Earnestly18>	kurahaupo: I'm sort of mentally blanking that out
T 1708792207 18<27Earnestly18>	Lynx-: set -- "${dl_owd_us}" "${dl_alpha}" "dl_owd_baselines_us[${reflector}]"; thealias
T 1708792286 18<25Lynx-18>	and with that dl_owd_baselines_us[${reflector}] will get updated?
T 1708792357 18<27Earnestly18>	Lynx-: No you'll have to rework things to not need -n/indirection
T 1708792391 18<27Earnestly18>	And I don't know if set+alias is faster or slower than func calls
T 1708792500 18<25kurahaupo18>	Lynx-: line 249 change «#!/usr/bin/env bash» to «#!$BASH» since by that point you actually know where THIS Bash is located
T 1708792514 18<25kurahaupo18>	(keep the indenting, of course)
T 1708792532 18<25kurahaupo18>	!env2
T 1708792541 18<25kurahaupo18>	!#!env2
T 1708792679 18<25Lynx-18>	Earnestly or kurahaupo do you understand why the difference noted here: https://forum.openwrt.org/t/cake-w-adaptive-bandwidth/135379/2063?u=lynx
T 1708792694 18<25Lynx-18>	see my post then the next post on different system
T 1708792736 18<25Lynx-18>	I was trying to remember why: https://github.com/lynxthecat/cake-autorate/blob/036ccf57786d4bccc69e1044da8eab87c3357ee1/cake-autorate.sh#L1587
T 1708792746 18<25Lynx-18>	then I remembered that on some systems it seemed necessary
T 1708792772 18<27Earnestly18>	Lynx-: Please learn lua and use luajit
T 1708792858 18<25Lynx-18>	using passed by reference array value inside arithmetic expansion to update the value based an old value
T 1708792879 18<25Lynx-18>	that seems to fail for a small number of specific systems
T 1708793055 18<25kurahaupo18>	Lynx-: in general, scripts installed on your own machines should use the direct path to the interpreter, not env. As for the oddball reference stuff, write (( $3 = ($2 * alpha + $3 * (100000-alpha))/100000 ))
T 1708793087 18<25kurahaupo18>	Errr, $1 for the last
T 1708793107 18<25Lynx-18>	ahh
T 1708793109 18<25kurahaupo18>	Lynx-: (( $3 = ($2 * alpha + $1 * (100000-alpha))/100000 ))
T 1708793121 18<25Lynx-18>	using alias style?
T 1708793150 18<25kurahaupo18>	That has to be inside a function for the $1 etc to work
T 1708793209 18<25kurahaupo18>	(check that I have the params in the right order)
T 1708793242 18<25kurahaupo18>	Lynx-: afaik "logger" is an external program; that might be what's slowing down your script
T 1708793335 18<25Lynx-18>	alias ewma_iteration='(( $3 = (($2*($1 - $3)) / 1000000) + $3 ))';  set -- "${dl_owd_us}" "${dl_alpha}" "dl_owd_baselines_us[${reflector}]"; thealias <-- would this work?
T 1708793531 18<27Earnestly18>	Lynx-: https://0x0.st/H5Dn.txt
T 1708793576 18<27Earnestly18>	20,000 pairs of random numbers
T 1708793609 18<27Earnestly18>	So I can suggest the set + alias is a bit crap
T 1708793612 18<25Lynx-18>	excellent analysis
T 1708793618 18<27Earnestly18>	Lynx-: You can do this shit too
T 1708793649 18<27Earnestly18>	Lynx-: How many places to you call this ewma_iteration?
T 1708793702 18<25Lynx-18>	about 3 I think
T 1708793735 18<25kurahaupo18>	Earnestly it's mentioned 9 times in the code, including the definition, so I assume 8 invocations
T 1708793766 18<25Lynx-18>	well there is some redundancy since it depends on which ping binary user runs - fping, iputils-ping or tsping
T 1708793802 18<25Lynx-18>	so I think 2 invocations for any running instance of cake-autorate for given ping binary
T 1708793901 18<27Earnestly18>	Lynx-: memoisation is more expensive than just doing the calc
T 1708793911 18<25Lynx-18>	ahh, good to know
T 1708793911 18<27Earnestly18>	1.2x slower
T 1708793932 18<27Earnestly18>	Because the shell is a slow language and you should not use it
T 1708793942 18<27Earnestly18>	openwrt comes with lua, use that instead. Start porting to it
T 1708793951 18<25Lynx-18>	openwrt has ditched lua now
T 1708793974 18<25Lynx-18>	a port was made to lua but it was actually found to be really hard to get it to work well
T 1708793976 18<27Earnestly18>	Lynx-: I don't think you've even measured the performance of this, and isolated hotspots considering you couldn't even make small test cases and compare them
T 1708793992 18<27Earnestly18>	Lynx-: Well luci is still lua
T 1708794032 18<25Lynx-18>	Yes, my skills are limited. I appreciate your input.
T 1708794048 18<25kurahaupo18>	Does openwrt have perl or python? Or awk?
T 1708794049 18<27Earnestly18>	You must measure
T 1708794055 18<27Earnestly18>	kurahaupo: It can, it's linux after all
T 1708794061 18<27Earnestly18>	But I don't think so by default
T 1708794064 18<25Lynx-18>	kurahaupo yes perl/python/awk all available
T 1708794087 18<25Lynx-18>	but many considerations like space for small routers
T 1708794109 18<25kurahaupo18>	My main router at home is a Ubiquiti EdgeMAX which comes with Perl installed
T 1708794118 18<22tirnanog18>	hence lua being an excellent suggestion.
T 1708794131 18<25Lynx-18>	bash on many devices seems to work just fine. lua failed miserably but maybe the coders
T 1708794135 18*	25kurahaupo danced a little jig on discovering that
T 1708794155 18<27Earnestly18>	Lynx-: I use openwrt, and tbh the code is pretty scary. luci seems fine though
T 1708794180 18<25Lynx-18>	heh. well.... you are obviously an expert
T 1708794200 18<25Lynx-18>	I like bash, even if I'm crap at it.
T 1708794230 18<27Earnestly18>	kurahaupo: You can stick openwrt on that (if you mean edgerouter x)
T 1708794239 18<27Earnestly18>	Lynx-: lua is very similar
T 1708794247 18<25Lynx-18>	evedn ony devices from like 2013 the bash implementation has been pretty much fine.. but it seems fun to try to speed up things, and yes I need to get better at working out how to profile aspects of the code
T 1708794253 18<27Earnestly18>	It uses 'tables' as its central data structure, which is basically a giant dict
T 1708794275 18<25Lynx-18>	I guess I need to find bash programmers who are personally affected by bufferbloat on 4G/5G/Starlink
T 1708794295 18<27Earnestly18>	bash is fine, so is the shell, for many purposes. But bash /itself/ is crap; any shell is crap when not calling highly optimised, high performance utilities
T 1708794323 18<27Earnestly18>	You need to design your shell scripts to take advantage of these tools, and do so in a way that avoids constantly forking them
T 1708794330 18<22tirnanog18>	it's better at playing the role of a coordinator, so to speak.
T 1708794348 18<27Earnestly18>	It's unrivalled in a way, imo
T 1708794373 18<27Earnestly18>	The best shell is basically just |
T 1708794431 18<27Earnestly18>	And tbh, dash is also very much faster than bash. It's a little embarassing
T 1708794485 18<25Lynx-18>	https://0x0.st/H5Dn.txt <-- the alias + inline works pretty well doesn't it?
T 1708794488 18<27Earnestly18>	Lynx-: You'll like lua, you code bash very much like lua: https://learnxinyminutes.com/docs/lua/
T 1708794522 18<25Lynx-18>	Earnestly port already exists here: https://github.com/sqm-autorate/sqm-autorate/
T 1708794525 18<27Earnestly18>	Lynx-: The 'inline' in that means you include the variable names as-is. To use such an alias in real code would mean making sure the variables are set before calling it
T 1708794538 18<25Lynx-18>	ah, I see
T 1708794545 18<27Earnestly18>	alias f='echo "$foo"' for example, would need foo=yourstring set before calling f
T 1708794573 18<25Lynx-18>	so ultimately inline is going to win out
T 1708794607 18<27Earnestly18>	It's the benchmark for everything else to meet
T 1708794636 18<27Earnestly18>	Oh for fucks sake, why is this lua port implementing function "currying" in lua
T 1708794667 18<27Earnestly18>	I mean it can return a function, but still. Keep it simple
T 1708794678 18<25Lynx-18>	well that was a team of like 5 people
T 1708794696 18<25Lynx-18>	and it just got abandoned for bugs and stuff
T 1708794721 18<25Lynx-18>	the bash implementation uses like 15-20% on fairly bog-standard router
T 1708794729 18<27Earnestly18>	:(
T 1708794746 18<25Lynx-18>	well ok, but in my case I don't mind - my router has CPU to spare
T 1708794763 18<25kurahaupo18>	Why would Lua need "porting" from Linux to Linux, when just the CPU changes?
T 1708794808 18<27Earnestly18>	tirnanog: The nicest thing about lua vs. python is that you can do multi-assigns like: a, b, c = whatever and not have it whine at you because you had too many or too few results from 'whatever'. a, b = 1, 2, 3 # 3 here is just discarded
T 1708794818 18<27Earnestly18>	kurahaupo: I think the port was from the bash script to lua
T 1708794852 18<22tirnanog18>	Earnestly: great. like just like in perl.
T 1708794868 18<27Earnestly18>	~ lua -e 'a, b, c = 1, 2; print(a, b, c)'
T 1708794870 18<27Earnestly18>	1       2       nil
T 1708794889 18<27Earnestly18>	tirnanog: Yeah I don't get python's design here. You have to use a "capture" like a, b, *c and c becomes a list
T 1708794903 18<25kurahaupo18>	Earnestly: yes it's the EdgeRouter-X-SPF
T 1708794926 18<27Earnestly18>	kurahaupo: Yeah openwrt should be able to install to that just using its own firmware update web uio
T 1708794950 18<27Earnestly18>	Hm
T 1708794950 18<22tirnanog18>	Earnestly: I've never been able to get along with python, for whatever reason. I don't even python code written by others easy to read.
T 1708794955 18<22tirnanog18>	even find, rather.
T 1708794960 18<27Earnestly18>	kurahaupo: Note quite, apparently https://openwrt.org/toh/ubiquiti/edgerouter_x_er-x_ka
T 1708794993 18<27Earnestly18>	tirnanog: This is more or less all I've done: https://0x0.st/H5kK.bin (and that pdf/epub progress count thing I showed you)
T 1708795007 18<25kurahaupo18>	Earnestly: that's an experiment for another day (or when I get a spare one), because it's currently critical for other household members' remote working
T 1708795032 18<27Earnestly18>	kurahaupo: Yeah, just nice to know it won't become ewaste
T 1708795045 18<27Earnestly18>	(A lot of ubiquiti stuff is)
T 1708795050 18<27Earnestly18>	ewaste that is
T 1708795072 18<22tirnanog18>	Earnestly: what's the utility of this SimpleNameSpace thing here?
T 1708795088 18<27Earnestly18>	tirnanog: Gives me a namespace, so I can put stuff inside it without polluting global
T 1708795094 18<25kurahaupo18>	The -SPF variant has an additional SPF socket (for a fibre upstream, which I don't have) and PoE output
T 1708795113 18<27Earnestly18>	tirnanog: It's basically a class with a few __methods__ added like __repr__
T 1708795116 18<22tirnanog18>	Earnestly: what does it do that a dict doesn't?
T 1708795130 18<27Earnestly18>	tirnanog: It is basically a dict
T 1708795145 18<22tirnanog18>	Earnestly: is it just for reasons of syntax?
T 1708795189 18<27Earnestly18>	tirnanog: Well, it's "the way" to do it. The implementation of simplenamespace for python is in its C codebase
T 1708795229 18<27Earnestly18>	tirnanog: Someone suggested that it's basically this if it were written in python: https://0x0.st/H5kZ.bin
T 1708795232 18<22tirnanog18>	Earnestly: ok, but what's the selling point? why and when would I reach for it over a dict?
T 1708795378 18<27Earnestly18>	tirnanog: That more or less comes down to dicts vs. namespaces, where namespaces can sometimes be implemented using dicts. But namespaces get all the other bits, subclassing, lookups, scoping, etc. But simplenamespace, is just basically a pretty dict
T 1708795413 18<22tirnanog18>	pretty because of dot notation, I take it.
T 1708795417 18<27Earnestly18>	tirnanog: You can even take a dict and turn it into a SimpleNamespace(**d)
T 1708795428 18<27Earnestly18>	tirnanog: Yes, and not having to quote so much
T 1708795431 18<22tirnanog18>	ah.
T 1708795438 18<22tirnanog18>	right, I see.
T 1708795489 18<27Earnestly18>	(And variable scoping)
T 1708795507 18<22tirnanog18>	Earnestly: I hung out in #python for a bit but all they ever seem to talk about is 'AI'. was boring.
T 1708795607 18<27Earnestly18>	I don't see python losing its thrown in data science, some of the good ones will find R or Julia or Chapel but most will get their stuff done just fine with what python has to offer
T 1708795613 18<27Earnestly18>	throne*
T 1708795615 18<22tirnanog18>	yes.
T 1708795876 18<27Earnestly18>	tirnanog: python is working towards a jit, that will be nice
T 1708795894 18<27Earnestly18>	https://github.com/python/cpython/pull/113465
T 1708795913 18<27Earnestly18>	(Cringe message though)
T 1708796008 18<27Earnestly18>	https://tonybaloney.github.io/posts/python-gets-a-jit.html (probably more useful)
T 1708796049 18<22tirnanog18>	creative writing? don't give up the day job, mate.
T 1708796059 18<22tirnanog18>	anyway, yeah - I heard something about this.
T 1708796477 18<24iconoclast_hero18>	(hopefully) quick regex question... https://regex101.com/r/SMzu1r/6
T 1708796477 18<24iconoclast_hero18>	I want grep to highlight just the file name, so what in bash parm. sub. would be "${VAR##*/}" and with the regex, i've got the file name in the second capture group but i don't know what i can do with it from there
T 1708796567 18<22tirnanog18>	well, ${VAR##pattern} isn't regex, for a start.
T 1708796669 18<24iconoclast_hero18>	"so what **in bash parm. sub.** would be "${VAR##*/}" "
T 1708796681 18<27Earnestly18>	iconoclast_hero: These are paths, you don't need regex at all
T 1708796705 18<27Earnestly18>	Split over / into the individual paths, you're done
T 1708796755 18<27Earnestly18>	If /a/b/c splits into files[a, b, c] then you can get the 3rd element with files[2] = c
T 1708796788 18<24iconoclast_hero18>	does that assume a certain number of nests in the file tree?
T 1708796800 18<24iconoclast_hero18>	because they're not the same.
T 1708796822 18<27Earnestly18>	You don't need regex for that either, these are paths. They have a well defined format
T 1708796857 18<24iconoclast_hero18>	ok, the regex question is something i still want an answer to so i can learn something about regex, but let's follow this first.
T 1708796885 18<27Earnestly18>	Yeah but this is PCRE, it's not really ontopic
T 1708796890 18<27Earnestly18>	(I don't really know PCRE either)
T 1708796905 18<27Earnestly18>	Other than non-capturing groups with (? ._.
T 1708796936 18<24iconoclast_hero18>	oh...  well...i want to use grep...whatever regex grep uses... i started with grep -E but it looks like regex101 doesn't have that
T 1708796966 18<27Earnestly18>	I also tend to avoid regex as much as possible just because it's slower than string matching (i.e. grep -F)
T 1708796973 18<27Earnestly18>	iconoclast_hero: -E is ERE
T 1708796980 18<24iconoclast_hero18>	yes
T 1708796983 18<22tirnanog18>	GNU grep supports -P (usually).
T 1708796987 18<24iconoclast_hero18>	yes.
T 1708796999 18<24iconoclast_hero18>	while read -r line; do i="${line/ : player: played /: }"; echo "$i"|grep -P "(?<=\/)(.*?)(?=\/)\/(.*?)(?=\")"; done <<< $(mpd.played)
T 1708797005 18<27Earnestly18>	But yeah, for paths you absolutely do not need regex
T 1708797048 18<24iconoclast_hero18>	i mean there are other ways to highlight that file name
T 1708797067 18<27Earnestly18>	iconoclast_hero: Show me mpd.played and what you want
T 1708797090 18<24iconoclast_hero18>	Feb 24 12:43 : player: played "Stevie Ray Vaughan/Stevie Ray Vaughan and Double Trouble -- The Complete Epic Recordings Collection (2014)/Stevie Ray Vaughan and Double Trouble -- Soul to Soul (1985)/Stevie Ray Vaughan and Double Trouble -- 10 - Life Without You.flac"
T 1708797090 18<24iconoclast_hero18>	Feb 24 12:47 : player: played "Van Morrison/Van Morrison with Georgie Fame & Friends -- How Long Has This Been Going On (1995) (mp3)/Van Morrison -- 02 - The New Symphony Sid.mp3"
T 1708797097 18<24iconoclast_hero18>	that's the format.
T 1708797099 18<27Earnestly18>	iconoclast_hero: mpd.played is a command, right?
T 1708797102 18<24iconoclast_hero18>	yes.
T 1708797151 18<27Earnestly18>	That's good, so you can drop ever using <<< "$(mpd.played)". You'd use < <(mpd.played) instead, although I think you can avoid that here too
T 1708797173 18<24iconoclast_hero18>	it's tail -500 /var/log/mpd.log or thereabouts.
T 1708797228 18<27Earnestly18>	iconoclast_hero: How does it handle " inside the filename? Curious mostly, not going to use that
T 1708797301 18<24iconoclast_hero18>	it doesn't.  that would probably result in something that displayed incorrectly, but this is just for my quick evaluation of the playlist/library
T 1708797315 18<27Earnestly18>	iconoclast_hero: So " just appears as a normal character?
T 1708797363 18<24iconoclast_hero18>	if you're asking about " occurring in a file name, $ find. "*\"*flac"|wc -l
T 1708797363 18<24iconoclast_hero18>	400
T 1708797367 18<27Earnestly18>	iconoclast_hero: And you want to highlight the filename?
T 1708797380 18<24iconoclast_hero18>	yes with grep --color=auto
T 1708797389 18<24iconoclast_hero18>	or maybe --color=always
T 1708797401 18<24iconoclast_hero18>	no, the latter.
T 1708797413 18<24iconoclast_hero18>	but i can use tput...
T 1708797501 18<27Earnestly18>	iconoclast_hero: https://0x0.st/H5kO.png
T 1708797533 18<27Earnestly18>	iconoclast_hero: Split on /, select last field, add colour, print it
T 1708797584 18<24iconoclast_hero18>	i definitely see the adding color ; printing part
T 1708797599 18<24iconoclast_hero18>	OFS is ? Field Separator?
T 1708797602 18<27Earnestly18>	iconoclast_hero: If you want to do this in bash you can read each line into an array delimited by / then access and update the last element using slicing
T 1708797610 18<27Earnestly18>	iconoclast_hero: output field separator, yeah
T 1708797621 18<27Earnestly18>	Default is space
T 1708797645 18<24iconoclast_hero18>	-F /  and -v are doing?
T 1708797677 18<24iconoclast_hero18>	oh that's also field separator
T 1708797684 18<24iconoclast_hero18>	the IFS i guess
T 1708797820 18<27Earnestly18>	iconoclast_hero: With just bash, https://0x0.st/H5k4.png -F is FS field separator
T 1708797848 18<27Earnestly18>	You can tidy it up to not include the quotes etc. but it'd look a bit crowded on a single line
T 1708797878 18<27Earnestly18>	iconoclast_hero: I'd use awk though, bash for this might be a bit slow
T 1708797885 18<24iconoclast_hero18>	awk field separator is / and define variable OFS=/ and then '{ }' is telling it what to do with that.
T 1708797885 18<24iconoclast_hero18>	once inside there, I see that you're defining $NF against itself wrapped in the escape codes (?) for highlighting the file
T 1708797917 18<24iconoclast_hero18>	but i don't see where you get $NF from nor do I see how you get the match after the last /
T 1708797919 18<27Earnestly18>	iconoclast_hero: NF is the number of fields, say 4. $NF is like $4
T 1708797930 18<27Earnestly18>	NF is a variable that awk synthesises for you
T 1708797941 18<24iconoclast_hero18>	that's what i suspected
T 1708797960 18<24iconoclast_hero18>	so $NF always prints last field.
T 1708797995 18<27Earnestly18>	But the principle is the same, split over / and access the last element. arr = line.split('/'); arr[-1] = ... arr[-1] ...; print(arr.join('/'))
T 1708798003 18<27Earnestly18>	iconoclast_hero: Yep
T 1708798017 18<27Earnestly18>	You can assign to it as well
T 1708798040 18<27Earnestly18>	# printf '/a/b/c/d' | awk -F / 'NF = 2'
T 1708798041 18<25shbot18>	Earnestly:  a
T 1708798048 18<27Earnestly18>	# printf '/a/b/c/d' | awk -F / 'NF = 4'
T 1708798050 18<25shbot18>	Earnestly:  a b c
T 1708798057 18<27Earnestly18>	# printf '/a/b/c/d' | awk -F / -v OFS=/ 'NF = 4'
T 1708798059 18<25shbot18>	Earnestly: /a/b/c
T 1708798136 18<27Earnestly18>	iconoclast_hero: awk is: pattern {action}.  pattern is boolean. If no pattern, default is true. If no {action} default is 'print', 'print' without arguments is the same as 'print $0'. That's pretty much all you need to understand the structure of an awk program
T 1708798299 18<24iconoclast_hero18>	ok.
T 1708798405 18<24iconoclast_hero18>	so above is the action to define the FS as / and what I assume to be a defined awk variable OFS that it then uses in the action?
T 1708798429 18<24iconoclast_hero18>	which since it isn't listed is print $0
T 1708798436 18<24iconoclast_hero18>	the action is print $0
T 1708798445 18<24iconoclast_hero18>	err...
T 1708823390 19*	Now talking on 22#bash
T 1708823390 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1708823390 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1708823730 18<24iconoclast_hero18>	i'm reading something to verify that my heuristically-defined understanding of "pipe" dating back to the Clinton Presidency
T 1708823742 18<27larryv18>	!pf 63 > iconoclast_hero
T 1708823742 18<29greybot18>	iconoclast_hero: https://mywiki.wooledge.org/BashPitfalls#pf63 -- Don't do this! -- while … done <<< "$(foo)"
T 1708823766 18<24iconoclast_hero18>	well...
T 1708823768 18<25ormaaj18>	Bash has 3 asynchronous pipe-making gizmos - pipelines, procsubs, and coprocs. Plus one synchronous one - command substitutions. (soon to be two kinds)
T 1708823788 18<24iconoclast_hero18>	i'm a bit more curious about this parallel forking with pipes.
T 1708823844 18<24cheater18>	rate my parser https://github.com/cheater/prompt/blob/master/prompt
T 1708823863 18<25ormaaj18>	!check
T 1708823864 18<28checkbot18>	cheater: Line 202: Argument mixes string and array. Use * or separate argument. Line 547: Want to escape a single quote? echo 'This is how it'\''s done'. Line 568: Check exit code directly with e.g. 'if ! mycmd;', not indirectly with $?. See https://shellcheck.net/?id=cb23864 for all 13 issues.
T 1708823883 18<24iconoclast_hero18>	is understanding what a named pipe is critical at this juncture?
T 1708823910 18<27larryv18>	!fifo
T 1708823910 18<29greybot18>	http://mywiki.wooledge.org/NamedPipes
T 1708823911 18<22tirnanog18>	mkfifo, essentially.
T 1708823927 18<25ormaaj18>	not really.
T 1708823948 18<25ormaaj18>	named pipes are almost never necessary in bash.
T 1708823987 18<24iconoclast_hero18>	ok, i'm sold on not using <<<$(...)
T 1708823993 18<24iconoclast_hero18>	k
T 1708824004 18<24cheater18>	lol all of those results are stupid
T 1708824017 18<24cheater18>	mayyyyybe the first one
T 1708824021 18<24cheater18>	anyways
T 1708824030 18<24cheater18>	what do you think of the code?
T 1708824194 18<24cheater18>	btw, fuckin hell... https://www.baeldung.com/linux/bash-case-relational-operators
T 1708824214 18<24cheater18>	now, i ain't saying it's wrong
T 1708824221 18<24cheater18>	i'm just saying it's perverted and against nature
T 1708824449 18<22tirnanog18>	bail-dung
T 1708824453 18<22tirnanog18>	it's wrong, unsurprisingly.
T 1708824469 18<22tirnanog18>	  [0-80])
T 1708824471 18<22tirnanog18>	   echo "the number is between 0 and 80";;
T 1708824473 18<22tirnanog18>	wrong. very wrong.
T 1708824499 18<22tirnanog18>	has all the hallmarks of 'AI' generated nonsense.
T 1708824542 18<22tirnanog18>	though it's not as bad as that one somebody mentioned recently which contains imaginary syntax.
T 1708824699 18<22Riviera18>	tirnanog: uhm, that's what the text says :)
T 1708824714 18<22Riviera18>	"However, the above solution won’t work as the case statement isn’t capable of handling a character range. [0-80] is a character group and the numbers between […] are treated as separate characters by Bash. To compare numeric values, we can use the pipe operator (|), AND operator (&&), and ternary operator among others.
T 1708824719 18<22Riviera18>	"
T 1708824732 18<22tirnanog18>	I sit corrected then.
T 1708824748 18<22tirnanog18>	weird way of going about it, though.
T 1708824806 18<22Riviera18>	when i write stuff like that i add comments like "# broken"
T 1708824856 18<22Riviera18>	similar to how linguists prefix non-grammatical / artificial examples with an asterisk, like *thirnanog
T 1708824972 18<22tirnanog18>	however:
T 1708824989 18<22tirnanog18>	  [8-9]|[1-9][0-9]|100)
T 1708824991 18<22tirnanog18>	   echo ">=81<=100"
T 1708825015 18<22tirnanog18>	it goes off the rails anyway.
T 1708825097 18<22tirnanog18>	and this time, it doesn't mention that it's broken :D
T 1708825100 18<22Riviera18>	hehe
T 1708825127 18<22Riviera18>	true, i did not read that far :)
T 1708825171 18<22tirnanog18>	it does not seem organic in nature. but it's hard to say.
T 1708825493 18<24cheater18>	no one gonna say anything about my code? :(
T 1708825508 18<25ormaaj18>	cheater: the single quote warnings are usually pretty pointless unless you have no clue what they do. :/
T 1708825543 18<24cheater18>	that's such a weird sentence
T 1708825671 18<24cheater18>	ormaaj: did you mean "have a clue"?
T 1708825727 18<25ormaaj18>	I don't think so :o
T 1708825740 18<25ormaaj18>	have a clue = warnings unnecessary
T 1708825800 18<25ormaaj18>	 $ zsh -c 'function function for for do do case case in esac done for for'; echo "$?"
T 1708825801 18<25ormaaj18>	0
T 1708825806 18<25ormaaj18>	:S
T 1708825914 18<29phy172918>	parsers hate this one nick
T 1708826529 18<25ormaaj18>	I assume that includes some zshisms because I have no idea why that's valid
T 1708826620 18<25ormaaj18>	ksh mode appears to enforce { after function like ksh93
T 1708826807 18<25ormaaj18>	# function function for for do case case in esac done; \function; echo "$?"
T 1708826809 18<25shbot18>	ormaaj: 0
T 1708827216 18<25ormaaj18>	Oh no there's more
T 1708827225 18<25ormaaj18>	# for for do select select do case case in esac done done; echo "$?"
T 1708827226 18<25shbot18>	ormaaj: 0
T 1708827230 18<25ormaaj18>	:D
T 1708827322 18<27GTAXL18>	is there a way to find the directory the script itself is stored on disk in, not necessarily what directory it was executed from?
T 1708827391 18<29phy172918>	!faq location
T 1708827391 18<29greybot18>	https://mywiki.wooledge.org/BashFAQ/028 -- How do I determine the location of my script?  I want to read some config files from the same place.
T 1708827392 18<25ormaaj18>	The former yes. The latter I don't think is possible.
T 1708827408 18<29phy172918>	The script might not be on disk at all
T 1708827411 18<25ormaaj18>	what does executed from mean?
T 1708827419 18<29phy172918>	PWD
T 1708827425 18<25ormaaj18>	mh :/
T 1708827539 18<27GTAXL18>	if the script is called from a crontab, where does cron execute it from, a home dir or the directory the script is in? I want to set a variable of the directory the script is in
T 1708827584 18<25ormaaj18>	I would assume cron doesn't alter its pwd
T 1708827588 18<29phy172918>	depends on which cron you have but many let you set the current dir
T 1708827619 18<25ormaaj18>	`env -C dir` otherwise
T 1708827704 18<25ormaaj18>	Best if your scripts aren't sensitive to PWD
T 1708827863 18<25ormaaj18>	Is there a BASH_SOURCE thing in zsh?
T 1708828089 18<25ormaaj18>	There are hardly even any arrays defined by the shell
T 1708828178 18<27GTAXL18>	realpath $(dirname $0)
T 1708828181 18<27GTAXL18>	gave me what I wanted
T 1708828190 18<27GTAXL18>	lots of googling
T 1708828236 18<25ormaaj18>	it's not really what you want.
T 1708828266 18<27GTAXL18>	it gave me the output I wanted
T 1708828349 18<27GTAXL18>	I made a test script as /root/test/test.sh but executed it in the home directory
T 1708828359 18<27GTAXL18>	the output, The script is located in: /root/test
T 1708828423 18<25ormaaj18>	just don't use it for anything important
T 1708828435 18<27GTAXL18>	how would you do it?
T 1708828969 18<25ormaaj18>	err well "depends". Ideally my scripts are in a known location. E.g. my bashrc uses several libraries. It finds them by querying fstab for the filesystem associated with the current root directory, then it finds the mountpoint of a subvolume containing my scripts that are in a known location relative to that subvolume.
T 1708828982 18<25ormaaj18>	\source "$(\findmnt -umlnfo target -O subvol=/vol/dotfiles "PARTLABEL=$(\findmnt -uslnfo partlabel -T /)")/common/home/shell/functions"
T 1708829354 18<25ormaaj18>	That faq doesn't even discuss the most reliable option - replace /bin/sh with a wrapper that tells you where the script is. :D
T 1708829890 18<26lolok18>	i have a long running program cmd1; it spits out a bunch of diagnostic to stdout and then hangs. i want to process its stdout with cmd2, but cmd2 wont start processing until its hit eof, and since cmd1 will hang, cmd2 will block on read. doing `cmd1 | head -n $N | cmd2` works if i can guess how much data i will get. doing `cmd1 | ( cat & sleep $N ; kill $! ) | cmd2` will work if i know how long cmd1 will run. is there some way i can know when a pipe is blocking
T 1708829891 18<26lolok18>	and give sigpipe or something?
T 1708830005 18<26lolok18>	i guess that probably wont work but idk
T 1708830076 18<25ormaaj18>	lolok: If there is nothing to indicate where the output ends then there's nothing you can do.
T 1708830264 18<25ormaaj18>	lolok: If the "hang" is in a known location or you know of a particular unique state that indicates where you wan to stop, then you could attach a debugger and use it to trigger an action on a breakpoint or other condition.
T 1708830277 18<26lolok18>	i can probably settle for a timeout, but it would be much better to timeout after some time of nothing in the pipe, rather than the start of the program
T 1708830592 18<26lolok18>	and a while loop... maybe... i might just rubber duck this...
T 1708830603 18<25ormaaj18>	I would run it through ltrace first and see if it stops on a predictable function call.
T 1708830629 18<25ormaaj18>	A timeout is easy. Use read -t
T 1708830845 18<25ormaaj18>	There aren't really that many things that can cause a program to just stop without being caught in a loop that don't involve waiting on a system call too
T 1708831571 18<26lolok18>	actually i just noticed it does print something predictable as the last line so i can sed or grep for that
T 1708831586 18<26lolok18>	yea i know what its waiting for but thats a whole can of worms
T 1708831617 18<26lolok18>	cmd1 is not so simple as it may appear
T 1708831769 18<26lolok18>	yea `cmd1 | sed /"$marker"/q | cmd2` works
T 1708832277 18<28llua18>	code injection is bad mkay.
T 1708832334 18<26lolok18>	if i intended to deploy any of this i would deserve to be shot
T 1708833529 18<28emanuele618>	how ba-a-a-ad could it be?
T 1708833695 18<26lolok18>	basically code golf
T 1708838523 18<26sphertext_18>	hmm socat is very interesting. if i'm not mistaken, it implements the concept of pipe and fd redirections, as well as extending it to network connections
T 1708839369 18<28emanuele618>	hmm
T 1708840018 18<28emanuele618>	basically dd, but for networks
T 1708840093 18<20arraybolt318>	I regularly use socat, it burns me up though that it can only handle one connection at a time.
T 1708840115 18<28emanuele618>	what?
T 1708840121 18<20arraybolt318>	I'm using it to brute-force my way through a crazy port forwarding scenario - it works *iff* only one connection needs made to the port in question.
T 1708840153 18<28emanuele618>	you can connect multiple things with the fork flag
T 1708840163 18<20arraybolt318>	orly, nice
T 1708840275 18<20arraybolt318>	hmm, but confusing
T 1708840286 18<20arraybolt318>	I never did figure out how socat's syntax works and just used an example they had
T 1708840414 18<28emanuele618>	hey, at least in socat syntax you don't index array with  array⚡number
T 1708840428 18<20arraybolt318>	hey!
T 1708840455 18<28emanuele618>	ehi
T 1708854466 18<29trev18>	hi, requesting another bash code review from the bash wizards, if it's ok. It's a rofi/dmenu alternative: https://github.com/trevarj/dotfiles/blob/master/sxhkd/.config/sxhkd/bin/tmenu
T 1708854726 18<25ormaaj18>	cthuhlu reviewing... ~~(~.~)~~
T 1708854923 18<25ormaaj18>	what? :o
T 1708854951 18<29trev18>	please don't eat my soul cthuhlu
T 1708855056 18<24geirha18>	will that regex handle the Exec= line being before the Name= line?
T 1708855171 18<29trev18>	no, sadly. the previous iteration used awk which would handle that and also filter out applications that are NoDisplay=true or Terminal=true. My regex-fu stinks though and this felt good enough and is much faster
T 1708855182 18<29trev18>	before i had to do caching of the entries which felt yucky
T 1708855225 18<25ormaaj18>	I need a json formatter
T 1708855241 18<24geirha18>	also, why isn't it looking through XDG_DATA_HOME (~/.local/share)?
T 1708855294 18<29trev18>	nice catch. i should add that in there
T 1708855329 18<29trev18>	i don't have anything in there, that's probably why
T 1708855380 18<24geirha18>	I'd go through "${XDG_DATA_HOME:-~/.local/share}" and "$XDG_DATA_DIRS", but the latter is colon separated list like PATH so you'll need to split it first
T 1708855444 18<29trev18>	ok
T 1708855503 18<24geirha18>	ormaaj: jq
T 1708855534 18<24geirha18>	or python3 -mjson.tool
T 1708855551 18<27Earnestly18>	I'd probably suggest ignoring XDG_DATA_DIRS, I have some reasons which are a bit much for an irc response; I would even not bother checking if XDG_DATA_HOME is absolute, simply `datadir=${XDG_DATA_HOME:-$HOME/.local/share}/progname' is enough
T 1708855646 18<27Earnestly18>	(XDG_DATA_DIRS are paths to search /in addition to/ XDG_DATA_HOME. But no one uses it and it's a bit of an awkward entry into the spec, which itself is a very awkward collection of ideas that weren't very well thought through)
T 1708855768 18<24geirha18>	well it does include directories with desktop entries here, that trev's ripgrep would miss
T 1708855782 18<27Earnestly18>	trev: Why not support multi selection btw?
T 1708855815 18<24geirha18>	or actually, since they're searching through entire /usr I gues they will find them after all. Anyway, should avoid needlessly searching through a bunch of dirs
T 1708855844 18<27Earnestly18>	I just kind of hope XDG_DATA_DIRS gets forgotten about and I encourge people to just not support it
T 1708855899 18<24geirha18>	certainly seems like gnome uses it actively
T 1708855946 18<27Earnestly18>	Yeah, it does
T 1708855974 18<27Earnestly18>	I imagine KDE does too, since XBDS is historically their internal-use-only spec
T 1708856006 18<27Earnestly18>	People have somewhat incorrectly latched onto it for other stuff but it is better than nothing and better than littering HOME with dotfiles so I'm not complaining much
T 1708856019 18<29trev18>	Earnestly: you're right, multi-select would work
T 1708856040 18<27Earnestly18>	geirha: But imagine how beautiful the symmetry would have been if they just put FHS under .local, mirroring /usr/local
T 1708856066 18<27Earnestly18>	You get multi-arch for free, everything just works, make PREFIX=.local install just works, etc.
T 1708856116 18<27Earnestly18>	trev: But you would have to loop. I'd also suggest getting rid of functions here, they exist to be called /once/
T 1708856126 18<29trev18>	another good point
T 1708856130 18<27Earnestly18>	Hm lets see
T 1708856264 18<27Earnestly18>	trev: I'll leave some notes, so at some point I'll give you a paste
T 1708856287 18<29trev18>	Earnestly: thanks! please be earnest
T 1708856592 18<27Earnestly18>	trev: This rg command doesn't work for me btw
T 1708856596 18<27Earnestly18>	Just exists 1
T 1708856598 18<27Earnestly18>	exits*
T 1708856633 18<29trev18>	which version?
T 1708856654 18<29trev18>	14.1 for me
T 1708856671 18<27Earnestly18>	Same
T 1708856682 18<27Earnestly18>	The regex is wrong, seemingly
T 1708856711 18<27Earnestly18>	Ah nevermind
T 1708857055 18<27Earnestly18>	trev: Is it meant to be quite limited btw? I get about 9 results with rg out of 103 .desktop entries
T 1708857157 18<29trev18>	Earnestly: not intentionally...shows me a good amount
T 1708857263 18<27Earnestly18>	trev: 78 unique. Anyway, you're just after the Name= after [Desktop Entry] if it also contains an Exec=? (There is also Hidden= you might want to care about)
T 1708882893 19*	Now talking on 22#bash
T 1708882893 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1708882893 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709072158 19*	Now talking on 22#bash
T 1709072158 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709072158 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709072359 18<22Al2O318>	the ${f%.foo}.bar did the trick TY again
T 1709073894 18<22clarkk18>	Why does this command ignore `grep -v`?   ping -DO 8.8.8.8 | stdbuf -oL awk -F "[][]" "/^\[/{print strftime(\"%Y-%m-%d %H:%M:%S\", \$2), \$3; next} 1" | stdbuf -oL grep -v "bytes from" > network-ping.txt
T 1709073968 18<22clarkk18>	Actually this may be the wrong channel for this. Not sure. Let me know if so
T 1709074073 18<25ormaaj18>	Maybe because stdbuf does absolutely nothing. Still have never seen an example where it makes any difference at all. :o)
T 1709074101 18<27JAA18>	It does make a difference with GNU grep at least.
T 1709074123 18<27JAA18>	(Although you can probably achieve the same thing with --line-buffered.)
T 1709074141 18<25ormaaj18>	yeah those options seem to work much better.
T 1709074173 18<25ormaaj18>	and sed -u generally works
T 1709074182 18<27JAA18>	I don't think stdbuf works at all for mawk. You need `-W interactive` there instead.
T 1709074244 18<27JAA18>	I think I've also seen an effect on GNU's tail.
T 1709074261 18<27JAA18>	For -f with multiple files IIRC.
T 1709074273 18<28emanuele618>	stdbuf only works for non-statically linked programs that use glibc
T 1709074304 18<28emanuele618>	and only for things that use stdio functions to read/write; not if the program uses something else to print
T 1709074340 18<28emanuele618>	ormaaj: you can use it to change the buffering of bash (for printf/echo)
T 1709074366 18<28emanuele618>	but it generally works on most tools, at least if they are written in C, use stdio, and are not built statically
T 1709074425 18<27JAA18>	That makes sense, yeah.
T 1709074456 18<27larryv18>	clarkk: you can probably augment the awk script to get the same effect as grep -v. as an aside, single quotes would REALLY help you there.
T 1709074575 18<28emanuele618>	# type stdbuf
T 1709074576 18<25shbot18>	emanuele6: bash: type: stdbuf: not found
T 1709074589 18<28emanuele618>	hmm, shbot does not have it
T 1709074593 18<20cappy18>	http://www.pixelbeat.org/programming/stdio_buffering/
T 1709074610 18<28emanuele618>	ormaaj: try   stdbuf -o0 bash -c '{ enable fdflags; fdflags -s+direct 1; printf abcdef;} | while dd status=none count=1; do printf \\n; done' | sed '/f/q'    vs without stdbuf -o0
T 1709074637 18<25ormaaj18>	Oh heh it says gnu tee screws with the buffering itself. Funny I'm usually using tee when I want to change how things buffer
T 1709074661 18<22clarkk18>	actually, I pasted the wrong command, due to all the troubleshooting I've already done. This is it. tee won't work without stdbuf  `ping -DO 8.8.8.8 | stdbuf -oL awk -F "[][]" "/^\[/{print strftime(\"%Y-%m-%d %H:%M:%S\", \$2), \$3; next} 1" | tee -a network-ping.txt`
T 1709074760 18<25ormaaj18>	that sucks. Normally the exact time you want to control is is when you need to split some output into multiple channels, and tee is like pretty much the main way to do that
T 1709074926 18<22clarkk18>	larryv, do you mean like this, using single quotes?  ping -DO 8.8.8.8 | stdbuf -oL awk -F '[][]' '/^\[/{print strftime("%Y-%m-%d %H:%M:%S", $2), $3; next} 1' | tee -a network-ping.txt
T 1709074926 18<25ormaaj18>	:o interesting
T 1709074990 18<22clarkk18>	larryv, if I try to add in the filter, it breaks tee.  ping -DO 8.8.8.8 | stdbuf -oL awk -F '[][]' '/^\[/{if($3 !~ /bytes from /) print strftime("%Y-%m-%d %H:%M:%S", $2), $3; next} 1' | tee -a network-ping.txt
T 1709075096 18<25ormaaj18>	emanuele6: why does the direct pipe matter in that case?
T 1709075260 18<22clarkk18>	emanuele6, sorry, I didn't see your message. That returns bash: line 1: enable: fdflags: not a shell builtin
T 1709075451 18<28emanuele618>	ormaaj: with a direct pipe every write() is boxed in a packet, and every read() only reads one packet. if it were not a direct pipe, write()s would just accumulate in the pipe's buffer, and when a process read()s the pipe, the kernel will just give it as much data from the buffer as it can. so it would not show the difference
T 1709075485 18<28emanuele618>	clarkk: well, it sounds like you don't have fdflags
T 1709075553 18<22clarkk18>	emanuele6, I can't find it in the apt repo, on debian 12
T 1709075601 18<28emanuele618>	it should be the bash-builtins package if you want it
T 1709075626 18<25ormaaj18>	Many distros don't bother to include them or have bash configured to use them by default.
T 1709075636 18<28emanuele618>	another way to see the difference more explicitly without a direct pipe is  strace -qqefd=1 -ewrite stdbuf -o0 bash -c 'printf abc' >/dev/null    vs without  stdbuf -o0
T 1709075745 18<28emanuele618>	with -o0 bash (or any other compatible program) writes one character at the time, with -o10  in chunk of 10 character, with -oL up to a newline (except if the line is too long), etc
T 1709075795 18<28emanuele618>	note that i have noticed some time ago that bash printf is "bugged", and always flushes the buffer after a newline even if the buffering is not -oL, so maybe use  /bin/printf  to see how it is actually supposed to work
T 1709076214 18<25ormaaj18>	Does it have a separate effect on the read and write ends or does setting the flag on either end affect functions on both ends?
T 1709076239 18<28emanuele618>	it affects both ends
T 1709076314 18<28emanuele618>	well, really it does not actually
T 1709076331 18<25ormaaj18>	:O
T 1709076349 18<28emanuele618>	but if you set on the write end, it seems to be enough
T 1709076350 18<25ormaaj18>	!coffee
T 1709076350 18<29greybot18>	c[_]
T 1709076473 18<28emanuele618>	# enable fdflags; (sleep 1; printf x; printf y) | (fdflags -s+direct 0; sleep 2; dd count=1)
T 1709076476 18<25shbot18>	emanuele6: xy0+1 records in
T 1709076476 18<25shbot18>	emanuele6: 0+1 records out
T 1709076476 18<25shbot18>	emanuele6: 2 bytes copied, 0.00692369 s, 0.3 kB/s
T 1709076507 18<28emanuele618>	setting it on the read end does nothing; the only one that matters is the write end i think
T 1709076715 18<28emanuele618>	afaics if you set direct on a write end after there is already some data on the pipe, the pipe does not start behaving like a direct pipe until it gets emptied
T 1709077191 18<28emanuele618>	and if you have a direct pipe already, but you open a second write end to that pipe that does not have O_DIRECT, if you write with the non-direct end first, and then the direct end; the packet contains what was written by the non-direct end followed by what was written by the direct end
T 1709077243 18<28emanuele618>	if you write the other way around, the packet only contains what was written by the direct end, but the next packet will be prefixed by what was written by the non-direct end
T 1709077282 18<28emanuele618>	and if the read end reads while the pipe only contains stuff written by the non-direct end, it still returns and reads the stuff written by the non-direct end
T 1709077329 18<28emanuele618>	so probably O_DIRECT makes write() inject some magic end of packet marker in the pipe, that is why it only matters on the write end
T 1709082580 19*	Now talking on 22#bash
T 1709082580 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709082580 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709082583 18<22pj18>	okay
T 1709082622 18<28emanuele618>	the first substitution command always only expands literal code of your script, so it is always safe as long as you only expand those values before the next substitution
T 1709082692 18<22pj18>	okay, yeah this is completely out of my league, heh.
T 1709082694 18<25ormaaj18>	(where "their arguments" is the entire remainder of the script)
T 1709082766 18<28emanuele618>	like this https://0x0.st/HRj_.txt
T 1709082805 18<28emanuele618>	err,  importas -ui c c   https://0x0.st/HRjL.txt
T 1709082898 18<25ormaaj18>	:O
T 1709083232 18<25ormaaj18>	double multisubstitute cute
T 1709164962 19*	Now talking on 22#bash
T 1709164962 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709164962 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709164978 18<24bxsx18>	It would be very nice if I break the loop on the first occurrence, but I don't it, well, still not that bad..
T 1709165065 18<24bxsx18>	larryv: any real difference between setting the flag to 1 or true?
T 1709165078 18<27larryv18>	why bother with a flag? just use the loop variable
T 1709165086 18<24bxsx18>	ahhhhhh
T 1709165096 18<24bxsx18>	it's not cleared after the loop?
T 1709165114 18<27larryv18>	no
T 1709165115 18<27larryv18>	# shopt -s nullglob; f=; for f in .*; do :; done; declare -p f
T 1709165117 18<25shbot18>	larryv: declare -- f=".mkshrc"
T 1709165123 18<27larryv18>	# shopt -s nullglob; f=; for f in foo*; do :; done; declare -p f
T 1709165124 18<25shbot18>	larryv: declare -- f=""
T 1709165176 18<27larryv18>	it's not cleared before the loop either, which is why you have to do it yourself
T 1709165190 18<27larryv18>	# shopt -s nullglob; f=x; for f in foo*; do :; done; declare -p f
T 1709165191 18<25shbot18>	larryv: declare -- f="x"
T 1709165197 18<24bxsx18>	I see
T 1709165220 18<24bxsx18>	no, the nullglob makes a lot of sense
T 1709165299 18<24bxsx18>	s/no/now
T 1709165368 18<24bxsx18>	larryv: thanks
T 1709165377 18<27larryv18>	np
T 1709165458 18<24bxsx18>	I guess in the final solution it would the [[ -z $f ]] or should I use declare -p for that (I'm assuming you used that only to demo the output now?)
T 1709165496 18<27larryv18>	yeah, that was just for show. you would do something like if [[ -z $f ]]; then echo oh no; exit 1; fi
T 1709165582 20*	Disconnected (20)
T 1709165736 19*	Now talking on 22#bash
T 1709165736 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709165736 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709171987 18<19sphertext18>	i've tested the code for the mac osx -exec bug in the find utility on 10.14 and it's still broken. even tho the wiki claims it's been fixed after 10.8 https://mywiki.wooledge.org/UsingFind#Nasty_OS_X_bug
T 1709172054 18<19sphertext18>	wait no
T 1709172116 18<19sphertext18>	well i tried copy pasting the commands in a script instead of writing them by hands and i got the correct outcome
T 1709172130 18<19sphertext18>	so i made a mistake the first time
T 1709172512 18<19sphertext18>	ok i found the problem. it's unrelated to the mac osx bug
T 1709172945 18<24alguien18>	how do i terminate the pipe (only) as soon as one part fails?
T 1709172981 18<24alguien18>	i can get get the error code of the failing part with `set -o pipefail`, but it still seems to execute the rest of the pipe
T 1709173422 18<22tirnanog18>	that's how they work; they are fully asynchronous in nature. the question is: why is it a problem in your case? a program attempting to read from its end of a closed pipe will encounter EOF, whereas a program attempting to write to its end of a closed pipe will receieve SIGPIPE.
T 1709173428 18<22tirnanog18>	alguien: ^
T 1709173511 18<24alguien18>	hm, maybe it isn't a problem then, thanks
T 1709173571 18<22tirnanog18>	as a silly little example, if you run seq 1 1000000 | head -n1, it will get nowhere near writing one million lines.
T 1709173625 18*	24alguien nods
T 1709173661 18<22tirnanog18>	https://termbin.com/v4d3u
T 1709173746 18<22tirnanog18>	also, try man 7 pipe. if you don't have it: https://www.man7.org/linux/man-pages/man7/pipe.7.html
T 1709173753 18<24alguien18>	Prob was I tested with find nonexistent | echo yes, and I always got yes
T 1709173762 18<24alguien18>	but that's not equivalent to what i'm doing
T 1709173778 18<22tirnanog18>	I don't know what you expected to happen there. echo doesn't read anything.
T 1709173782 18<24alguien18>	my real RHS is read, and it will just not read anything
T 1709173789 18<22tirnanog18>	for example?
T 1709173799 18<22tirnanog18>	this sounds like !faq disappear, honestly.
T 1709173808 18<24alguien18>	!faq disappear
T 1709173808 18<29greybot18>	https://mywiki.wooledge.org/BashFAQ/024 -- I set variables in a loop that's in a pipeline. Why do they disappear after the loop terminates? Or, why can't I pipe data to read?
T 1709173824 18<24alguien18>	nah, that was an earlier topic :)
T 1709173831 18<22tirnanog18>	what then?
T 1709173849 18<22cornfeedhobo18>	can someone suggest a good way to do a non-regex search-and-replace within a file?
T 1709173851 18<24alguien18>	you answered my question
T 1709173877 18<24alguien18>	cornfeedhobo, non-interactive vi
T 1709173896 18<22tirnanog18>	perl is very good at it.
T 1709173898 18<22tirnanog18>	https://mywiki.wooledge.org/BashFAQ/021#Just_Tell_Me_What_To_Do
T 1709173905 18<22cornfeedhobo18>	na, vi is too heavy. i need it to work in build container.
T 1709173911 18<22tirnanog18>	thanks to its quotemeta (\Q) functionality.
T 1709173926 18<22cornfeedhobo18>	perl is also an option that is commonly offered, but also not well suited to portability
T 1709173932 18<22tirnanog18>	awk then.
T 1709173944 18<24alguien18>	ed is posix
T 1709173951 18<22tirnanog18>	actually, it's awkward in awk (ha).
T 1709173953 18<24alguien18>	but i think it's complicated
T 1709173966 18<22cornfeedhobo18>	yeah, awk makes it difficult
T 1709173967 18<22tirnanog18>	"non-regex" was a component of the question.
T 1709173975 18<24alguien18>	sed has a switch i think, but i don' think it's posix
T 1709173980 18<22cornfeedhobo18>	it's really this non-regex that makes it hard
T 1709173997 18<22cornfeedhobo18>	which is surprising somewhat... like why isn't there a common tool or flag for this
T 1709174008 18<22tirnanog18>	well, how about bash then. it won't be as fast, but you can do line=${line//"$literal"/...} easily enough.
T 1709174016 18<22cornfeedhobo18>	but i also haven't had to deal with this before, so there's that :p
T 1709174019 18<19sphertext18>	re: the current question.. i had this idea but idk how to take it from here. the last echo could be substituted with kill, but idk how to choose a process id
T 1709174021 18<19sphertext18>	# set -o pipefail; echo f | grep b  | { ! [[ "$?" -eq 0 ]] && echo b ; }
T 1709174023 18<25shbot18>	sphertext: no output
T 1709174025 18<22tirnanog18>	not actually a literal but treating the content of the var literally there.
T 1709174026 18<24alguien18>	cornfeedhobo, agreed
T 1709174074 18<19sphertext18>	# set -o pipefail; echo "f" | grep b | { ! [[ "$?" -eq 0 ]] && echo g ; }
T 1709174076 18<25shbot18>	sphertext: no output
T 1709174076 18<22cornfeedhobo18>	yeah, i could read in the entire file and do the replace with native bash
T 1709174083 18<19sphertext18>	dunno why it's not working
T 1709174109 18<22tirnanog18>	# printf 'foo baboon bar baboon\n' > input; needle=baboon; while read -r; do REPLY=${REPLY//"$needle"/orangutan}; printf '%s\n' "$REPLY"; done < input > output; cat output
T 1709174111 18<25shbot18>	tirnanog: foo orangutan bar orangutan
T 1709174120 18<19sphertext18>	oh the `set-o pipefail` doesn't register
T 1709174134 18<19sphertext18>	if you run `set -o pipefail` as a separate command, then it will work
T 1709174136 18<22tirnanog18>	follow it up with a conditional mv and there you go.
T 1709174138 18<22cornfeedhobo18>	yeah, that's probably what i'll do, since the files aren't ever going to be that large
T 1709174142 18<22tirnanog18>	right. perfect then.
T 1709174183 18<22cornfeedhobo18>	thanks for the sounding board. I thought I was limited in my options, but needed a sanity check
T 1709174238 18<24alguien18>	cornfeedhobo, surely you're still missing a simple utility that would be able to do that?
T 1709174264 18<24alguien18>	sphertext, what will and what doesn't?
T 1709174284 18<22tirnanog18>	sphertext: it's not clear what you even expect $? to be there. it's a brand new subshell, it will have whatever value the parent shell had before it forked.
T 1709174305 18<22tirnanog18>	# false; true | true | echo "$?"
T 1709174308 18<25shbot18>	tirnanog: 1
T 1709174309 18<19sphertext18>	how do you `set -o` ?
T 1709174315 18<19sphertext18>	in one line
T 1709174321 18<22tirnanog18>	whatever it is you think you're doing there, it probably needs rethinking.
T 1709174330 18<19sphertext18>	i think it works
T 1709174341 18<19sphertext18>	but i don't know how to `set -o pipefail` in the same line
T 1709174350 18<22tirnanog18>	no it doesn't.
T 1709174356 18<22tirnanog18>	see above.
T 1709174356 18<22cornfeedhobo18>	alguien: it sounds like one doesn't exist, other than bash itself. to be fair, i probably should have asked in ##workingset
T 1709174393 18<24alguien18>	have to add that channel to autojoins i always forget its name
T 1709174400 18<19sphertext18>	if you run `set -o pipefail` and then ` false | { ! [[ "$?" -eq 0 ]] && echo failed ; }` you will get the outcome
T 1709174403 18<22tirnanog18>	if you want to know the exit status from a given portion of a pipline, issue the pipeline *first* then use PIPESTATUS.
T 1709174404 18<24alguien18>	i always think it's #posixset
T 1709174410 18<22tirnanog18>	no you bloody won't.
T 1709174423 18<19sphertext18>	why is it printing "failed" then?
T 1709174469 18<22tirnanog18>	# true | false; declare -p PIPESTATUS
T 1709174471 18<25shbot18>	tirnanog: declare -a PIPESTATUS=([0]="0" [1]="1")
T 1709174482 18<22tirnanog18>	that's how you get the status from a particular part of a pipeline.
T 1709174545 18<19sphertext18>	i ran the command `false | { ! [[ "$?" -eq 0 ]] && echo failed ; }` on my machine and it printed `failed`, i can show you the screen shot. but i'm getting unreliable results now, idk why
T 1709174557 18<22tirnanog18>	because you're not listening. that's why.
T 1709174618 18<22tirnanog18>	as I said earlier, the value of $? will initially be whatever it was when the parent shell forked, within all of the subshells implied by the pipeline.
T 1709174644 18<19sphertext18>	so it doesn't get updated by whatever happens in the pipe?
T 1709174646 18<22tirnanog18>	so doing foo | [[ "$?" -eq .. ]] in any capacity is nonsense code. all you're doing is testing the vaue of the _parent's_ copy of $? there.
T 1709174652 18<22tirnanog18>	just don't do this. it's completely wrong.
T 1709174678 18<22tirnanog18>	the value of $? will be meaningful after the pipeline has concluded execution.
T 1709174686 18<22tirnanog18>	that's where pipefail has a clear effect.
T 1709174701 18<22tirnanog18>	but just use PIPESTATUS if you need the exit status of anything but the final component of the pipeline.
T 1709174704 18<19sphertext18>	ok so it just gets inherited from the parent shell and won't be updated until the pipe finishes
T 1709174712 18<22tirnanog18>	it's not even that.
T 1709174727 18<22tirnanog18>	you have to understand that every single portion of a pipeline implies its on subshell.
T 1709174747 18<22tirnanog18>	if you do "foo | bar", there are two subshells. if you do "foo | bar | baz" there are three subshells.
T 1709174756 18<22tirnanog18>	all of them inherit the execution environment of the parent initially.
T 1709174778 18<19sphertext18>	ok i get it
T 1709174778 18<22tirnanog18>	each will manipulate $? in its own right. but each subshell will eventually die and the changes it makes are immaterial.
T 1709174791 18<22tirnanog18>	it is how the parent shell sets $? (and PIPESTATUS) that you care about.
T 1709174808 18<19sphertext18>	so all the subshells of a pipe are spawned by the original parent shell? they're not sub-subshells
T 1709174828 18<22tirnanog18>	yes. I mean, you could make more still.
T 1709174866 18<22tirnanog18>	# echo "parent = $$; left subshell = $BASHPID" >&2 | echo "parent = $$; right subshell = $BASHPID" >&2
T 1709174868 18<25shbot18>	tirnanog: parent = 44; right subshell = 52
T 1709174868 18<25shbot18>	tirnanog: parent = 44; left subshell = 51
T 1709174875 18<22tirnanog18>	those are pid numbers.
T 1709174895 18<26lockywolf18>	sphertext: you can pipe into a subshell
T 1709174955 18<22tirnanog18>	so all you have to ask yourself is "do I need anything other than the exit status of the right-most part of the pipeline". if the answer is no, you don't need pipefail, nor PIPESTATUS. if yes, then they have a use.
T 1709175006 18<22tirnanog18>	(pipefail can also have side effects if over-used or used blithely - it's often perfectly normal to expect for the 'left-most' parts to fail)
T 1709175016 18<22tirnanog18>	feeding something through head is a great example.
T 1709175079 18<22tirnanog18>	as with anything, it depends on the exact use case, though.'
T 1709175096 18<19sphertext18>	so you need to do a check of PIPESTATUS in every element of the pipe if you want to interrupt it whenever one element fails
T 1709175113 18<19sphertext18>	also, how do you interrupt it after the test shows an element has failed?
T 1709175125 18<22tirnanog18>	well, if you genuinely consider any element failing to be an error, pipefail will do that.
T 1709175137 18<19sphertext18>	do you kill the parent shell?
T 1709175140 18<22tirnanog18>	but be careful with it. it's one of those things that may look neat at first, but it's often not appropriate.
T 1709175146 18<19sphertext18>	so that it stops executing the rest of the pipe
T 1709175165 18<22tirnanog18>	PIPESTATUS lets you just examine any of its exit status values and do as you place.
T 1709175222 18<22tirnanog18>	there is no such thing as "stop executing the rest of the pipe". disavoid yourself of this notion immediately. you can expect for programs to terminate sooner than they otherwise might have, perhaps.
T 1709175237 18<22tirnanog18>	consider the seq | head example given earlier: https://termbin.com/v4d3u
T 1709175256 18<22tirnanog18>	you can stop neither seq nor head running there, but seq does finish quite early, owing to the pipe error.
T 1709175264 18<22tirnanog18>	er, disavow, even.
T 1709175277 18<26lockywolf18>	what about   echo test0 | ( set -e ; cat - ; ls /fail ; echo test1   | (cat - ; echo test2 ; ) )
T 1709175293 18<26lockywolf18>	the pipe will terminate after ls /fail
T 1709175299 18<22tirnanog18>	if you think it's important that programs execute strictly sequentially, you shouldn't even be using a pipe.
T 1709175307 18<22tirnanog18>	because pipes are async. always.
T 1709175329 18<22tirnanog18>	but that's what makes them so amazing.
T 1709175419 18<22tirnanog18>	you don't "interrupt". you just exit the subshell in question.
T 1709175438 18<22tirnanog18>	stop reading. close your end of the pipe.
T 1709175438 18<19sphertext18>	`false | { ! [[ ${PIPESTATUS[${#PIPESTATUS[@]}-1]} -eq 0 ]] && killpipe ; }`
T 1709175447 18<19sphertext18>	so this is not possible, nor recommended?
T 1709175448 18<22tirnanog18>	no. this is complete nonsense.
T 1709175461 18<22tirnanog18>	if you don't want to consume any more data, stop reading and exit!
T 1709175485 18<22tirnanog18>	please look at the earlier paste and try to understand what's going on there.
T 1709175496 18<22tirnanog18>	seq gets a broken pipe eventually and that is _fine_
T 1709175503 18<22tirnanog18>	head closed its end of the pipe.
T 1709175521 18<22tirnanog18>	because it exited after reading one line.
T 1709175545 18<22tirnanog18>	also, man 7 pipe (please)
T 1709175609 18<22tirnanog18>	you check PIPESTATUS only when the entire pipeline is don.
T 1709175618 18<22tirnanog18>	if it is needed at all.
T 1709175755 18<22tirnanog18>	at best, a writer may be able to fill up the pipe buffer (16 x page size on Linux, by default - so 64 KiB on x86_64). at that point, if the reading end is closed, it will get a signal. that's what you see happening with seq in the paste. it never gets to actually write 1 million numbers.
T 1709175805 18<22tirnanog18>	which is a good thing, of course. it would be silly if it were allowed to go all the way to the end.
T 1709175828 18<22tirnanog18>	anyway, this is explained in pipe(7).
T 1709176122 18<22tirnanog18>	I should add: there are certain, specific cases in which cleaning up after tasks can be useful. but they should be dealt with as and when they arise. most of the time, there is no need to bring homebrew process management into it (and even then, a simple trap can be a solution).
T 1709178712 18<25ormaaj18>	sphertext: Stupid thing about bash # 3 trillion and one - it forcibly calls wait when the command of the last pipe element completes, and no sooner. Therefore PIPESTATUS is not accessible from that command AND the forced wait will block further execution until all of the subshells are waited on. So it is impossible to access statuses from any command that can read from the pipe. Bash doesn't even
T 1709178712 18<25ormaaj18>	give you their pids.
T 1709178746 18<25ormaaj18>	 $ shopt -s lastpipe; function pp { exec -- getpid -E p print -rf '%-2s %s\n' -u "$2" -- "$1" \$p; }; ${| local -; set +m; { pp 0a 3 | pp 1 4 | printf '%-2s %s\n' 0b "${ jobs -p; }" 3 "$BASHPID"; } 3>&1 4>&1; }
T 1709178746 18<25ormaaj18>	0b 3642770
T 1709178747 18<25ormaaj18>	3  3375217
T 1709178747 18<25ormaaj18>	1  3642771
T 1709178747 18<25ormaaj18>	0a 3642770
T 1709178793 18<25ormaaj18>	you can get the pid of the first element from jobs, but the ones in the middle are inaccessible.
T 1709178806 18<25ormaaj18>	basically pipelines suck.
T 1709179408 18<28emanuele618>	>:(
T 1709179624 18<25ormaaj18>	Almost like it's written by one whose Cranium Has Emptyness Throughout
T 1709180769 18*	25ormaaj is mean D:
T 1709180781 18<28emanuele618>	not by someone with an Outstanding Roasted Mixture Awesome Arabica Jar
T 1709180948 18<29cult18>	Is it possible to use ${@} properly in an alias or does it cause problems? Ideally I want to use something like alias foo='echo "${@:-bar}"' but bar is always printed with or without args
T 1709180972 18<28emanuele618>	aliases just replace text
T 1709180974 18<25ormaaj18>	it can be done
T 1709180992 18<25ormaaj18>	ha wow
T 1709181008 18<28emanuele618>	you could define a function in the alias and call that immediately; that is the usual technique for when you need to accept arguments
T 1709181063 18<28emanuele618>	'f () { something "$@"; echo hi ;}; f'    e.g. in git aliases
T 1709181064 18<29cult18>	Hmm yes I had a function initially but I was wondering why doing it this way results in the weird behaviour. I'd expect just "bar" if no args and a list of args otherwise. But "foo 1 2 3" will print "bar 1 2 3"
T 1709181138 18<28emanuele618>	i don't remember what @:- does in bash; i know it is unspecified in standard sh
T 1709181163 18<28emanuele618>	# a=(1 2 3); set -- "${@:-foo}"; echo -E set -- "${@@Q}"
T 1709181164 18<25shbot18>	emanuele6: set -- 'foo'
T 1709181168 18<28emanuele618>	# a=(); set -- "${@:-foo}"; echo -E set -- "${@@Q}"
T 1709181169 18<25shbot18>	emanuele6: set -- 'foo'
T 1709181184 18<25ormaaj18>	it's lame :(. Takes the overall result and flattens it, and expands the alternate if the resulting string is empty.
T 1709181187 18<28emanuele618>	it just always expands to foo, it ieems
T 1709181192 18<28emanuele618>	oh, oops
T 1709181201 18<28emanuele618>	# set -- 1 2 3; set -- "${@:-foo}"; echo -E set -- "${@@Q}"
T 1709181202 18<25shbot18>	emanuele6: set -- '1' '2' '3'
T 1709181206 18<28emanuele618>	# set --; set -- "${@:-foo}"; echo -E set -- "${@@Q}"
T 1709181207 18<25shbot18>	emanuele6: set -- 'foo'
T 1709181224 18<28emanuele618>	so it expands to 'foo' if there are no arguments; that is what it does
T 1709181240 18<27larryv18>	# set ''; set -- "${@:-foo}"; echo -E set -- "${@@Q}"
T 1709181241 18<25shbot18>	larryv: set -- 'foo'
T 1709181246 18<25ormaaj18>	It's really like [[ $@ ]]
T 1709181251 18<28emanuele618>	oh, it is like  ${!@}
T 1709181280 18<28emanuele618>	if the concatenation of the arguments is empty, it expands to 'foo'
T 1709181285 18<25ormaaj18>	yep
T 1709181300 18<29cult18>	It seems to do that even if there are arguments though, or is that because I'm using it in an alias?
T 1709181303 18<28emanuele618>	# IFS=; set '' a; set -- "${@:-foo}"; echo -E set -- "${@@Q}"
T 1709181305 18<25shbot18>	emanuele6: set -- '' 'a'
T 1709181309 18<28emanuele618>	# IFS=; set '' ''; set -- "${@:-foo}"; echo -E set -- "${@@Q}"
T 1709181311 18<25shbot18>	emanuele6: set -- '' ''
T 1709181319 18<29cult18>	As I said "foo 1 2 3" will output "bar 1 2 3" when I would expect just "1 2 3"
T 1709181329 18<28emanuele618>	and it is @, not *, so it is never empty if there are more than two arguments
T 1709181356 18<25ormaaj18>	Not a very useful behavior IMO
T 1709181410 18<28emanuele618>	cult: that is not what "${@:-foo}" does; if you want to expand something else if there are no arguments, you would use something like    "${1-foo}" "${@:2}"
T 1709181415 18<25ormaaj18>	(it's so unuseful it could probably be changed since nobody uses it, at least not if they know what it actually does)
T 1709181479 18<25ormaaj18>	!ormaajrotate
T 1709181479 18<29greybot18>	# f() { echo "${@:2}"; ${!1+f $(($1+1)) "${!#}" "${@:2:$#-2}"}; }; f 3 {a..c}
T 1709181481 18<25shbot18>	greybot: a b c
T 1709181481 18<25shbot18>	greybot: c a b
T 1709181481 18<25shbot18>	greybot: b c a
T 1709181735 18<28emanuele618>	cult: if you are saying you don't understand why your alias prints   bar 1 2 3    it is because the alias just replaces the text in the command
T 1709181750 18<28emanuele618>	i said it earlier
T 1709181788 18<28emanuele618>	foo 1 2 3    will run    echo "${@:-bar}" 1 2 3   because that is what is in the foo alias
T 1709181828 18<27JAA18>	Aliases are insanely stupid.
T 1709181836 18<28emanuele618>	evidently your shell does not have any non-empty arguments, so it expands bar
T 1709181845 18<28emanuele618>	JAA: no u >:(
T 1709181855 18<27larryv18>	D:
T 1709181863 18<28emanuele618>	# set --; echo "${@:-bar}" 1 2 3
T 1709181864 18<25shbot18>	emanuele6: bar 1 2 3
T 1709181868 18<28emanuele618>	# set -- foo bar; echo "${@:-bar}" 1 2 3
T 1709181870 18<25shbot18>	emanuele6: foo bar 1 2 3
T 1709181876 18<27JAA18>	:-)
T 1709181878 18<28emanuele618>	# set -- zzz yyy; echo "${@:-bar}" 1 2 3
T 1709181879 18<25shbot18>	emanuele6: zzz yyy 1 2 3
T 1709181895 18<28emanuele618>	# set -- zzz yyy; f () { echo "${@:-bar}";}; f 1 2 3
T 1709181896 18<25shbot18>	emanuele6: 1 2 3
T 1709181917 18<27JAA18>	TIL (or rather, realised) what that function trick is about though. Thanks, I hate it.
T 1709181972 18<28emanuele618>	with a function, or an alias that defines a function and calls it, the arguments are 1 2 3, but "${@:-bar}" is still wrong; you want  "${1-bar}" "${@:2}"
T 1709182014 18<28emanuele618>	JAA: if bash embraced eval, and dynamic scoping like tcl, we would have an apply builtin, and we would not need this :D
T 1709182028 18*	27JAA slaps emanuele6 around a bit with a large trout
T 1709182054 18<28emanuele618>	hmm, i thought of a cool use for "${@:-}" earlier
T 1709182078 18<28emanuele618>	it is "$*", but it ignores IFS, and always uses space
T 1709182090 18<28emanuele618>	could be useful in a pinch
T 1709182129 18<27JAA18>	Hmm, yeah
T 1709182194 18<28emanuele618>	ormaaj: now, you can't change this behaviour because we would notice muhahaha
T 1709182206 18<29cult18>	emanuele6: thank you that makes sense now!
T 1709182218 18<27JAA18>	Well, it'd still be multiple values though, not one, unless you remove the quotes.
T 1709182227 18<27JAA18>	If you have args, that is.
T 1709182256 18<28emanuele618>	if you don't have arguments, or have an empty argument "${@:-}" expands to '' which is correct
T 1709182279 18<28emanuele618>	and if you have more than one argument, the delimiter is space, so it is still correct because the result is non-empty
T 1709182298 18<27JAA18>	# set -- 1 2 3; printf '%q ' "${@:-}"
T 1709182300 18<25shbot18>	JAA: 1 2 3
T 1709182310 18<27JAA18>	That's three args, not 1\ 2\ 3.
T 1709182313 18<28emanuele618>	what the heck
T 1709182322 18<28emanuele618>	then what does it do?
T 1709182332 18<28emanuele618>	# set -- 1 2 3; printf '%q ' "${@:+baz}"
T 1709182334 18<25shbot18>	emanuele6: baz
T 1709182334 18<27JAA18>	Same as "$@", no?
T 1709182367 18<28emanuele618>	so it is the same as "$@" if [[ $@ ]] ? wow
T 1709182378 18<28emanuele618>	that does not make any sense
T 1709182412 18<27JAA18>	Seems reasonable enough to me.
T 1709182433 18<27JAA18>	Just like "${@/foo/bar}" expands to multiple words with the replacement.
T 1709182476 18<27JAA18>	It's just a bit whack to combine arrays and a default value.
T 1709182483 18<27JAA18>	Or array-ish, whatever.
T 1709182521 18<28emanuele618>	but it checks $@ as a string and returns multiple values; if ' '.join(args): yield from expand(word) else: yield from args   :/
T 1709182586 18<28emanuele618>	it does not check whether $@ is empty, it checks if the $@ is empty or the arguments concatenated by space are a non-empty string
T 1709182592 18<27JAA18>	Too bad you can't return another array like "${@:-(a b c)}". :-D
T 1709182606 18<28emanuele618>	well, because it is quoted
T 1709182686 18<27JAA18>	# set -- '' ''; printf '%q ' "${@:-}"
T 1709182688 18<25shbot18>	JAA: '' ''
T 1709182700 18<27JAA18>	# set -- ' '; printf '<%q> ' "${@:-}"
T 1709182702 18<25shbot18>	JAA: <\ >
T 1709182712 18<28emanuele618>	hmm, i don't remember if in quoted -WORD context, it is a string expansion or not
T 1709182713 18<27JAA18>	Seems to behave as expected to me.
T 1709182761 18<28emanuele618>	# a=('a b' c d); echo -E set -- "${PWD+${a[@]@Q}}"
T 1709182762 18<25shbot18>	emanuele6: set -- 'a b' 'c' 'd'
T 1709182768 18<28emanuele618>	JAA: you totally can do that
T 1709182782 18<27JAA18>	Hah
T 1709182795 18<27JAA18>	Yeah, makes sense.
T 1709182806 18<28emanuele618>	D:
T 1709182825 18<28emanuele618>	too JAA everything makes sense :o
T 1709182836 18<27JAA18>	lol
T 1709182837 18<28emanuele618>	ooo
T 1709182855 18<28emanuele618>	with a glob you normally have to choose if you want to quote the expansion or the glob
T 1709182905 18<28emanuele618>	because "${PWD-*}"  will quote the glob, so you can only use the glob if you don't quote the expansion ${PWD-*}  which is not very useful except for +
T 1709182933 18<28emanuele618>	but array expansions are special and they expand to multiple words even when the expansion is quoted, so you can do it
T 1709182967 18<27JAA18>	Hmm, right
T 1709183056 18<27JAA18>	"${PWD}"${PWD:-*}
T 1709183077 18<27JAA18>	Er, no, that makes no sense.
T 1709183081 18<28emanuele618>	that expands PWD twice
T 1709183085 18<27JAA18>	Yeah
T 1709183101 18<28emanuele618>	once quoted and the other time not quoted
T 1709183115 18<27JAA18>	Wouldn't it be nice if you could do ${PWD@Q-*}?
T 1709183204 18<28emanuele618>	nah, you can just use   ${|[[ $PWD ]] && REPLY=*;}
T 1709183219 18<27JAA18>	Naturally
T 1709183234 18<28emanuele618>	anyway that and even ${PWD+*}  are not great anyway because they will not work correctly with IFS=*
T 1709183240 18<27JAA18>	I'm not sure yet whether I love or hate those.
T 1709183523 18<28emanuele618>	s/[&][&]/||/
T 1709183644 18<27JAA18>	Does this actually work?
T 1709183648 18<27JAA18>	Does [[ set REPLY?
T 1709183654 18<28emanuele618>	no?
T 1709183670 18<28emanuele618>	the only things that set REPLY are select and read afaik
T 1709183689 18<28emanuele618>	some loadables too, i think, but i don't remember which ones
T 1709183698 18<27JAA18>	Oh, you mean as a replacement of the second part in my silly thing above, right.
T 1709183725 18<27JAA18>	So it'd expand to nothing if PWD is set and to the glob expansion if not.
T 1709183755 18<28emanuele618>	yes, but that, like ${PWD+*} is actually expanded as if it were  x=*; ... $x
T 1709183762 18<28emanuele618>	so if IFS contains * it will not work
T 1709183789 18<28emanuele618>	and there is no workaround except setting IFS to ''
T 1709183828 18<27JAA18>	Hmm
T 1709183907 18<25ormaaj18>	# shopt -s expand_aliases; eval set function f { t } \; set -- '"${@/*/&=& }"' \; alias '"${@:1:3}"' '"u=${*%%=*}"' '"t=echo \"\$@\";"' \; eval u \; f moo
T 1709183909 18<25shbot18>	ormaaj: moo
T 1709184037 18<28emanuele618>	with an apply builtin   (possible implementation   apply () { eval 'shift; '"$1";} ), you could write your gitalias as just   "apply 'something "$@"; somethingelse'"
T 1709184050 18<28emanuele618>	also it would make aliases more nicer to use
T 1709184061 18<28emanuele618>	s/more //
T 1709184100 18<28emanuele618>	aliases can be nicer than functions because they can be bypassed easily with just a \
T 1709184115 18<27JAA18>	That is true, yeah.
T 1709184206 18<28emanuele618>	hmm, i wonder
T 1709184235 18<28emanuele618>	k# alias foo='echo hi'; eval 'function zzz { foo;}'; zzz; declare -f zzz
T 1709184236 18<25shbot18>	emanuele6: hi
T 1709184236 18<25shbot18>	emanuele6: ksh: declare: not found [No such file or directory]
T 1709184242 18<28emanuele618>	k# alias foo='echo hi'; eval 'function zzz { foo;}'; zzz; typeset -f zzz
T 1709184243 18<25shbot18>	emanuele6: hi
T 1709184243 18<25shbot18>	emanuele6: function zzz { foo;}
T 1709184246 18<28emanuele618>	hehe
T 1709184300 18<28emanuele618>	ksh93 showing functiondeclaration+terminator instead of serialised code is a bit lame
T 1709184310 18<28emanuele618>	k# alias foo='echo hi'; eval 'if :; then function zzz { foo;} end'; zzz; typeset -f zzz
T 1709184312 18<25shbot18>	emanuele6: ksh: eval: syntax error: `end' unexpected
T 1709184312 18<25shbot18>	emanuele6: ksh: zzz: not found [No such file or directory]
T 1709184314 18<28emanuele618>	err
T 1709184316 18<25ormaaj18>	yea :(
T 1709184322 18<28emanuele618>	k# alias foo='echo hi'; eval 'if :; then function zzz { foo;} fi'; zzz; typeset -f zzz
T 1709184323 18<25shbot18>	emanuele6: hi
T 1709184323 18<25shbot18>	emanuele6: function zzz { foo;} fi
T 1709184363 18<28emanuele618>	it does not only mean that you get nonsense like fi or esac or ;; or } if the function is defined in a conditional; but it also means that aliases in typeset -f are not expanded
T 1709184387 18<25ormaaj18>	 $ ksh -c 'function f { :; }; typeset -fp f'
T 1709184387 18<25ormaaj18>	function f
T 1709184387 18<25ormaaj18>	{       :
T 1709184387 18<25ormaaj18>	}
T 1709184389 18<28emanuele618>	but bash's declare -f sucks too \:
T 1709184395 18<28emanuele618>	oh, wow
T 1709184401 18<28emanuele618>	k# alias foo='echo hi'; eval 'if :; then function zzz { foo;} fi'; typeset -pf zzz
T 1709184402 18<25shbot18>	emanuele6: function zzz { foo;} fi
T 1709184405 18<28emanuele618>	hmm
T 1709184420 18<28emanuele618>	oh, i thought you were running that on shbot
T 1709184695 18<25ormaaj18>	!meta ormaajrotate
T 1709184695 18<29greybot18>	ormaaj 1366207861(2013-04-17) learn # f() { echo "${@:2}"; ${!1+f $(($1+1)) "${!#}" "${@:2:$#-2}"}; }; f 3 {a..c}
T 1709184710 18<25ormaaj18>	I should get rid of the field splitting :(
T 1709185204 18<28emanuele618>	local - IFS=;set -f
T 1709185228 18<28emanuele618>	err IFS=' ' in this case, and quoting 'f'
T 1709185250 18<28emanuele618>	or "$FUNCNAME" instead of f
T 1709208830 18<29Mo18>	Hi, what is the best way to pipe a big script via ssh ? Currently I have a big string right after  ssh myserver ... with lots of escapes. Can I use a HERE document for that?
T 1709208871 18<28emanuele618>	moo
T 1709208975 18<29Mo18>	for machine in myserver;do ssh $machine "echo \"select \\\* from v\\\$version;\" \\\|sqlplus foo/foo123@foo 2>&1|grep -m2 -e \"^Version\" -e \"^Oracle\"";done
T 1709209000 18<29Mo18>	Just as an example. The complete command is far bigger.
T 1709209088 18<24Nintendo18>	If you have ssh, you also have scp, right?  (If you don't want to use scp, a little ${s@Q} might help with the escape madness.)
T 1709209141 18<28emanuele618>	hmm, is that command correct? that would not expand $version, i doubt it is supposed to be an environment variable on the repote
T 1709209149 18<28emanuele618>	# echo "echo \"select \\\* from v\\\$version;\"
T 1709209155 18<25shbot18>	emanuele6: Missing terminating quote, bracket or keyword
T 1709209156 18<28emanuele618>	# echo "echo \"select \\\* from v\\\$version;\""
T 1709209158 18<25shbot18>	emanuele6: echo "select \\* from v\$version;"
T 1709209177 18<28emanuele618>	it does not expand $version; there are an odd number of \ before $
T 1709209192 18<28emanuele618>	s/repote/remote/
T 1709209217 18<29Mo18>	I would like to have that as multi-line script without the awful escapes.
T 1709209236 18<29Mo18>	HERE doc sounds it could do it?
T 1709209268 18<28emanuele618>	is $version a sql macro or similar?
T 1709209285 18<28selckin18>	yea, pipe that to ssh cat << EOF blbla  | ssh foo
T 1709209296 18<28emanuele618>	anyway, you could use a here document; yes    ssh foo << 'EOF'
T 1709209306 18<28emanuele618>	selckin: em, 'EOF' not EOF
T 1709209329 18<28selckin18>	blalbla is also wrong
T 1709209332 18<28selckin18>	suprise
T 1709209348 18<28emanuele618>	they said they don't want to deal with awful escapes, not introduce awfuler escapes
T 1709209469 18<28emanuele618>	but if you want to expand that $version on the local, and your example was wrong, than you cannot just ssh<<'EOF'
T 1709209544 18<28emanuele618>	you could use two heredocs; one for the bash code, and one for the sql code
T 1709209637 18<28emanuele618>	ssh -- "$machine" bash <<'SH' 3<<SQL    and then in SH you use   </dev/fd/3   instead of echo |
T 1709209779 18<28emanuele618>	or <&3; or use stdin for the sql, and fd3 for the sh so you don't need any redirection  ssh -- "$machine" bash /dev/fd/3 3<<'SH' <<SQL
T 1709210689 18<25fdan18>	 sudo -H -u ec2-user nohup forever_running_process > nohup.out 2>&1 &
T 1709210689 18<25fdan18>	there is a script which we run by doing the above command
T 1709210690 18<25fdan18>	now this creates 2 processes one with sudo and a child process without sudo.
T 1709210690 18<25fdan18>	when we want to kill a process? which PID should we use. i know the way the command is started is not nice.
T 1709211227 18<27wwilliam18>	!echo
T 1709211227 18<29greybot18>	echo outputs a string. echo has many portability problems, and should never be used with option flags. Consider printf instead: printf 'name: %s\n' "$name". https://wiki.bash-hackers.org/commands/builtin/echo | https://cfajohnson.com/shell/cus-faq.html#Q0b | http://www.in-ulm.de/~mascheck/various/echo+printf | https://pubs.opengroup.org/onlinepubs/9699919799/utilities/echo.html
T 1709211744 18<25fdan18>	when we want to kill a process? which PID should we use. i know the way the command is started is not nice.
T 1709211865 18<27colo18>	eh? the PID of the process is unique...
T 1709211882 18<25fdan18>	[18:14:49] <fdan>  sudo -H -u ec2-user nohup forever_running_process > nohup.out 2>&1 &
T 1709211883 18<25fdan18>	[18:14:49] <fdan> there is a script which we run by doing the above command
T 1709211883 18<25fdan18>	[18:14:49] <fdan> now this creates 2 processes one with sudo and a child process without sudo.
T 1709211884 18<25fdan18>	[18:14:49] <fdan> when we want to kill a process? which PID should we use. i know the way the command is started is not nice.
T 1709211928 18<27colo18>	ah. I would kill the child process below sudo.
T 1709211949 18<25fdan18>	why not the sudo process?
T 1709212081 18<25fdan18>	geirha can you help me here
T 1709212098 18<27Soliton18>	you can kill the sudo process as well. you didn't really say what the goal is.
T 1709212133 18<25fdan18>	we are trying to run a process as a ec2-user
T 1709212168 18<25fdan18>	this creates 2 processes
T 1709212223 18<27Soliton18>	you're asking about kill.
T 1709212377 18<27colo18>	fdan: so you use sudo as root to switch to another user?
T 1709212425 18<25fdan18>	yes
T 1709212447 18<27colo18>	you are better off using `setpriv` for that
T 1709212454 18<27colo18>	(on Linux, at least)
T 1709212532 20*	Disconnected (20)
T 1709212551 19*	Now talking on 22#bash
T 1709212551 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709212551 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709212577 18<28emanuele618>	D:
T 1709212591 18<24geirha18>	something something systemd
T 1709213224 18<25fdan18>	if i start a process like this - sudo -H -u ec2-user nohup forever_running_process > nohup.out 2>&1 &
T 1709213225 18<25fdan18>	which process should i kill? the parent or the child process
T 1709213540 18<27colo18>	I would kill forever_running_process
T 1709213542 18<27Soliton18>	presumably you want to kill forever_running_process so the child.
T 1709213993 19*	Now talking on 22#bash
T 1709213993 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709213993 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709214149 18<25fdan18>	Soliton why not the parent process?
T 1709214162 18<25fdan18>	since we start with the Sudo, i think killing the parent would be much better right?
T 1709214320 18<25fdan18>	if we kill the parent process, will it not kill the child process too?
T 1709214502 18<27colo18>	the parent sudo will also terminate once the child exits. if you kill sudo, it will forwardthe signal to its children, and you have the ~ same effect.
T 1709214887 18<25fdan18>	we are observing an issue where the parent(sudo) process gets killed but the child process doesnt get killed or takes more time
T 1709215025 18<27colo18>	well, why do you not just kill the child process then? :)
T 1709215050 18<27JanC18>	nohup is sudo's child process...
T 1709215088 18<27colo18>	I mean the process that all this ill-fated attempt at managing a service is eventually all about
T 1709215136 18<27JanC18>	if that was an attempt at managing a service, then why use nohup?  that only makes it harder...
T 1709215222 18<27colo18>	I never implied that it was a particularly good attempt ;)
T 1709215333 18<27JanC18>	I wasn't telling that you particularly, it's fdan who should probably go read some documentation about what nohup does
T 1709215958 18<25fdan18>	Janc we wanted to have the logs
T 1709215994 18<27JanC18>	nohup has nothing to do with logs
T 1709216088 18<25fdan18>	we are running the process in background
T 1709216094 18<25fdan18>	we store the logs in nohup.out
T 1709216163 19*	Now talking on 22#bash
T 1709216163 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709216163 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709216256 18<27colo18>	have you considered to use systemd-run instead of nohup?
T 1709216385 18<27JanC18>	or just configure a service that you can start whenever you want to, especially if you need it more than once
T 1709216798 18<25fdan18>	colo not yet, since its a small service, we didnt plan
T 1709216819 18<25fdan18>	colo do we get the logs using systemd?
T 1709217927 18<27colo18>	fdan: yes, all streams of the child process are preserved in the resulting unit's journal
T 1709218625 18<26volga62918>	Hello Everyone, how to incorporate. index  with in for loop https://paste.centos.org/view/e32f5ddc
T 1709218775 18<26volga62918>	 opt_array is find out if domain already present in db
T 1709219761 18<27Soliton18>	just use the index? not sure what the issue is.
T 1709219854 18<27Soliton18>	weird code anyway so hard to tell what the goal is.
T 1709220346 18<26volga62918>	Index is domain group ID, logic is simple if domain not found in db, I am adding new entry with group ID ( index ). Issue that can't increment group ID in for loop I tried group_id=$(($idx+1)), but that only ones and not for each domain from the list
T 1709220429 18<27Soliton18>	i didn't understand much.
T 1709220465 18<27Soliton18>	# declare -A opt; while IFS=, read -r c; do opt+=([${c%%,*}]=${c#*,}); done <<< $'0,a\n1,b\n2,c'; idx=1 end=${#opt[@]}; for ((i=$idx; i<=$end; i++)); do printf "Key %s Value %s\n" "$i" "${opt[$i]}"; done
T 1709220466 18<25shbot18>	Soliton: Key 1 Value b
T 1709220466 18<25shbot18>	Soliton: Key 2 Value c
T 1709220466 18<25shbot18>	Soliton: Key 3 Value
T 1709220509 18<27Soliton18>	it's weird to set IFS and then not use it.
T 1709220536 18<27Soliton18>	the end check should be < not <=.
T 1709220577 18<26volga62918>	ok let me test
T 1709220621 18<27Soliton18>	no idea what the relationship between db and the file is or what any of the data looks like anyway.
T 1709221528 18<26volga62918>	file contain list domain,ip address which need to insert. DB contain domain,ip,attrs columns. I am pulling last entry as start index, end index is array count.
T 1709222230 18<27Soliton18>	so the index is not a number?
T 1709222284 18<27Soliton18>	this is still confusing. show an actual issue with actual data.
T 1709222310 18<26volga62918>	index is number attr column in db
T 1709222346 18<27Soliton18>	but domain is surely not a number?
T 1709222357 18<26volga62918>	yes
T 1709222360 18<26volga62918>	domain.com
T 1709222368 18<26volga62918>	as example
T 1709222369 18<27Soliton18>	so i have no idea what you're trying to do.
T 1709222433 18<27Soliton18>	declare -A is an assoc array and apparently the keys are domain names. what do you expect to do with some index number?
T 1709222440 18<29djph18>	Soliton: it's okay, neither do they!
T 1709222507 18<27Soliton18>	if your index corresponds to some line in that file then remove the assoc array and look at that line.
T 1709222539 18<26volga62918>	index is attr column in db where in script it should  increment by one  to get next attr number
T 1709222569 18<27Soliton18>	i have no idea what an attr number is.
T 1709222590 18<26volga62918>	right now last entry is 15 in db
T 1709222596 18<26volga62918>	that attr
T 1709222621 18<26volga62918>	I am pulling that number as start index
T 1709222627 18<27Soliton18>	and what does that have to do with the file?
T 1709222751 18<26volga62918>	file contain list domains to insert into db, when script located list of domains which not present in db, PSQL do insert (domain,ip,attr) value  ($domain,$ip,$i);
T 1709222803 18<26volga62918>	$i is number index incremented by one from start index
T 1709222861 18<27Soliton18>	so you just want to increment the index you got from the DB?
T 1709222870 18<26volga62918>	yes
T 1709222875 18<26volga62918>	inside the loop
T 1709222883 18<26volga62918>	to get next number
T 1709222889 18<27Soliton18>	idx=$((idx+1))
T 1709222948 18<26volga62918>	Yes, I tried that, it increment only first run through domain array
T 1709222956 18<26volga62918>	Let me try again
T 1709222977 18<27Soliton18>	so some code you didn't show does something you don't expect.
T 1709223046 18<24ano18>	# echo MOVIE - TXT FILES STARTED WITH \"MOVIE\" AREN\'T TXT FILES > f.txt; file -i f.txt
T 1709223047 18<25shbot18>	ano: f.txt: video/x-sgi-movie; charset=us-ascii
T 1709223880 18<26volga62918>	Soliton thank you for all help, script is working here the whole think https://paste.centos.org/view/77f831c9
T 1709224027 18<27Soliton18>	still weird why you set IFS. it does nothing.
T 1709224051 18<27Soliton18>	i would remove the array since it seems useless.
T 1709224081 18<27Soliton18>	i assume you're aware that you're doing sql injection and know it is safe.
T 1709224310 18<26volga62918>	yes
T 1709224328 18<26volga62918>	localhost only and by me only
T 1709224382 18<26volga62918>	yes I just set so it in this case IFS is not splitting
T 1709224397 18<26volga62918>	I will remove it
T 1709224412 18<26volga62918>	that because I tried -a array to test
T 1709224480 18<27Soliton18>	no real point in an array that you use a single time.
T 1709224498 18<27Soliton18>	just wasting time writing to and reading from the array.
T 1709224509 18<26volga62918>	correct
T 1709224636 18<27Soliton18>	btw, the way to make sure that sql injection is safe is thinking about what the data that you inject can be. it has nothing to do with your user or localhost.
T 1709225753 18<25kurahaupo18>	!pipe
T 1709225753 18<29greybot18>	(Anonymous) pipes use the | character to connect the standard output of one command to the standard input of another. Each command is executed in a subshell (but see !subshell, !lastpipe, !faq 24).
T 1709225775 18<25kurahaupo18>	!notapipe
T 1709225931 18<25kurahaupo18>	!learn notapipe "Pipe" is not a catch-all term for feeding a file into a program. On the contrary, it specifically means connecting the output of one program as the input of another program, both of which run concurrently. The word you're probably looking for is "redirect".
T 1709225931 18<29greybot18>	OK, kurahaupo
T 1709225947 18<25kurahaupo18>	!notapipe
T 1709225947 18<29greybot18>	"Pipe" is not a catch-all term for feeding a file into a program. On the contrary, it specifically means connecting the output of one program as the input of another program, both of which run concurrently. The word you're probably looking for is "redirect".
T 1709226066 18<25Inline18>	 pipe it but instead of letting the sdinput catch it redirect it
T 1709226072 18<25Inline18>	|> file
T 1709226095 18<25Inline18>	hmmm
T 1709227654 18<25kurahaupo18>	Inline: So what do you think is in "file"  after you go: echo foxfog |>file tr fgox ienl
T 1709227755 18<25kurahaupo18>	# echo foxfog |>file tr fgox ienl ; cat file
T 1709227757 18<25shbot18>	kurahaupo: inline
T 1709230358 18<25ormaaj18>	:o   10:46:05  <-- │ pgas (~pgas@user/pgas) has quit (Ping timeout: 250 seconds)
T 1709235320 18<19Guest145718>	hello, i'm new here
T 1709235335 18<19Guest145718>	is this the right place to ask for help and support for the bash terminal?
T 1709235405 18<25ormaaj18>	oh let's just say yes
T 1709235408 18<27Soliton18>	!bashis
T 1709235408 18<29greybot18>	Bash is a shell. That's a program which can do simple math, logic, I/O and run other programs. It's NOT a terminal, it's not a kernel, it doesn't manage the system's authentication or environment, it's not your OS and it's not X, KDE or Gnome.
T 1709235490 18<25ormaaj18>	bash manages my system's authentication and environment tho.
T 1709235571 18<25ormaaj18>	mh nevermind.
T 1709235882 18<19Guest145718>	greybot, oh ok, my bad, it's a shell
T 1709235888 18<19Guest145718>	run on a TERMINAL ENUMLATOR
T 1709235901 18<19Guest145718>	your right, i just need to get my terms correct
T 1709235925 18<19Guest145718>	but is this the correct place to ask for help regarding the bash shell?
T 1709235933 18<27Soliton18>	yes
T 1709235959 18<22Riviera18>	many people here use bash,
T 1709235976 18<22Riviera18>	so perhaps, yes,
T 1709235984 18<22Riviera18>	somebody might be able to help
T 1709236075 18<19Guest145718>	cool
T 1709236086 18<19Guest145718>	thank you, when i need help with the bash shell i will definately ask here
T 1709236145 18<19Guest145718>	i wanted to learn irc and come here to ask questions regarding the bash shell because i was told that i was less likely to run into "skiddies" on irc then discord, matrix, reddit, stackexchange, xmpp, and bash forums seem to be dead :(
T 1709236363 22*	26ChanServ gives channel operator status to 18llua
T 1709236369 22*	26llua removes ban on 18*!~Artfaith@user/voxel
T 1709236374 22*	26llua removes channel operator status from 18llua
T 1709254781 19*	Now talking on 22#bash
T 1709254781 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709254781 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709257045 18<22phogg18>	yargs? like this? https://www.npmjs.com/package/yargs
T 1709257227 18<28emanuele618>	zargs
T 1709257319 18<27larryv18>	zargs! https://zsh.sourceforge.io/Doc/Release/User-Contributions.html#index-zargs
T 1709259181 18<25xmoforf18>	is there a way to do this in more pure bash: find /path/to/files -type f -name "*.txt" | your_program
T 1709259210 18<28llua18>	why
T 1709259253 18<25xmoforf18>	seems better if i can avoid usinf find
T 1709259260 18<22tirnanog18>	it isn't.
T 1709259263 18<28llua18>	find is going to be faster than bash
T 1709259284 18<28emanuele618>	vroom
T 1709259288 18<22tirnanog18>	it can be done but it will be cumbersome and slow.
T 1709259392 18<26yitz18>	starglob! globstar?
T 1709259393 18<22tirnanog18>	the results of pathname expansion undergo collation, and that can really end up hurting for globstar.
T 1709259408 18<20twkm18>	plus it might exceed ARG_MAX.
T 1709259611 18<22tirnanog18>	for argument's sake: { shopt -s globstar; for f in **/*; do test -f "$f" && printf '%s\n' "$f"; done; } | your_program. it is much worse than find and not equivalent, in fact. dotglob would make it equivalent, except that bash will still sort (very slowly) and find will not.
T 1709259679 18<22tirnanog18>	rather, more like: [[ -f $f && $f == *.txt ]]
T 1709259682 18<22tirnanog18>	just use find, seriously.
T 1709259749 18<22tirnanog18>	what you have there is not even a non-standard usage of find.
T 1709259840 18<25xmoforf18>	great thank you
T 1709259849 18<25xmoforf18>	i will use find
T 1709259925 18<22tirnanog18>	even if you had wanted to sort, bash would still be the worst tool for doing so. I cannot over-emphasise how bad globstar performance is.
T 1709259953 18<22tirnanog18>	you might not notice if treading relatively few pathnames but find blows it out of the water at even moderate scale.
T 1709260359 18<20twkm18>	plus lack of newline safety.
T 1709260403 18<22tirnanog18>	heh. I was just thinking of that while finishing the washing up.
T 1709261410 18<27JAA18>	# echo {a..b}{a..b}
T 1709261411 18<25shbot18>	JAA: aa ab ba bb
T 1709261459 18<27JAA18>	Any neat tricks to revert the order of the iteration, i.e. get 'aa ba ab bb' in this case?
T 1709261622 18<28emanuele618>	yes
T 1709261624 18<28emanuele618>	# eval echo '{a..b}'{a..b}
T 1709261625 18<25shbot18>	emanuele6: aa ba ab bb
T 1709261787 18<27JAA18>	Heh, what could possibly go wrong? :-)
T 1709261884 18<27JAA18>	# echo {b..a}{b..a} | rev
T 1709261885 18<25shbot18>	JAA: bb ab ba aa
T 1709261886 18<27JAA18>	But meh
T 1709261894 18<27JAA18>	Ah yes
T 1709261895 18<27JAA18>	:-)
T 1709264041 18<25ormaaj18>	Invert your expectation about being able to do x with y surprise disappointment becomes a thing of the past. Can I do x? Lol no. With y? Ha!
T 1709264440 18*	25ormaaj looking for awesome arabica jar.
T 1709268522 18<28emanuele618>	can i do z?
T 1709268996 18<28emanuele618>	with w?
T 1709269622 18<27JAA18>	:-)
T 1709269802 18<26sphertext_18>	anyone knows if possible to use the macos CMD key in keybindings for terminal programs? for example I'd like to use CMD+` to move to the next gnu screen window. but I don't know how to definite it in the `keybinding` command
T 1709269877 18<26sphertext_18>	it's not clear what exactly bash registers when i use CMD as a modifier key
T 1709269996 18<27larryv18>	sphertext_: no, you cannot do this.
T 1709270044 18<26sphertext_18>	annoying. do ppl on windows keyboard have the same problem with their WIN key?
T 1709270062 18<27larryv18>	it's not about the keyboard, it's about the terminal emulator
T 1709270257 18<26sphertext_18>	yeah, i know the terminal emulator sends the keys to the programs, and it can also translate them to something else
T 1709270260 18<20twkm18>	your terminal might be able to send ^An when cmd+` is pressed.
T 1709270285 18<26sphertext_18>	but does CMD have a direct correspondent, like all other keys?
T 1709270297 18<20twkm18>	(or whatever your escape is set to)
T 1709270300 18<27larryv18>	Apple Terminal does not provide a means to use Command to send sequences
T 1709270302 18<20twkm18>	nope.
T 1709270389 18<26sphertext_18>	so what's the canonical key set? alpha numerical etc, alt, and an escape (usually ctrl)?
T 1709270390 18<20twkm18>	modifiers make sense to graphical programs like the terminal emulator, but not to bash.  bash typically will receive a sequence of characters, e.g., \e` rather than a single compound character.
T 1709270441 18<26sphertext_18>	hmmm
T 1709270491 18<26sphertext_18>	so i need to configure my emulator to send a sequence of characters when I press cmd+` and then use that sequence in the keybind command
T 1709270560 18<26sphertext_18>	but gnu screen allows `keybind C-k ...`, so it does allow describing the modifier
T 1709270564 18<27larryv18>	i'm like 90% sure that Apple Terminal does not support doing this, and i'm only hedging because i'm not on the latest macOS. i'm not sure how many times i have to repeat myself
T 1709270607 18<26sphertext_18>	i'm not even using apple terminal. i'm using iterm2
T 1709270624 18<27larryv18>	that would have been helpful to know from the beginning.
T 1709270660 18<27larryv18>	the point stands. whatever iTerm2 lets you do, you can do.
T 1709270669 18<26sphertext_18>	 i'm trying to understand how bash programs interface with emulators
T 1709270674 18<20twkm18>	bash doesn't change your window, screen does.  send it your escape character (default is ^A) followed by n (or space or ^N) to switch to the next window.
T 1709270765 18<22tirnanog18>	alacritty can do this.
T 1709270769 18<27larryv18>	sphertext_: this suggests that iTerm2 lets you define key mappings using Command https://iterm2.com/documentation-preferences-profiles-keys.html
T 1709270784 18<22tirnanog18>	and yes, Terminal.app almost certainly won't let you do this.
T 1709270815 18<27larryv18>	you want one of the "Send [whatever]" actions, depending on what sequence you decide to go with
T 1709270824 18<26sphertext_18>	how come in `keybinding C-n` we can specify the ctrl modifier, but not the cmd modifier?
T 1709270841 18<22tirnanog18>	because it's not based like alacritty, possibly.
T 1709270867 18<26sphertext_18>	that's a screen command
T 1709270894 18<22tirnanog18>	oh. derp. anyway, it's too removed to even know what a Cmd key is.
T 1709270901 18<27larryv18>	that's not really referring a key combination per se. it's a character
T 1709270918 18<27larryv18>	*referring to
T 1709270923 18<20twkm18>	^N means a single byte value, \x1e.  which is what pressing control+n also produces.
T 1709270960 18<26sphertext_18>	"Screen does not understand the prefix C- to mean control, although this notation is used in this manual for readability. Please use thecaret notation (^A instead of C-a) as arguments"
T 1709270967 18<20twkm18>	iterm2 likely doesn't know screen is running so whatever you map will be sent to whatever is running.
T 1709271087 18<20twkm18>	duh, not 1e, 0e.
T 1709271171 18<26sphertext_18>	why control+n produces a single byte value, but not cmd+`?
T 1709271181 18<26sphertext_18>	is it a convention?
T 1709271208 18<20twkm18>	cmd didn't exist when control characters came about.
T 1709271257 18<26sphertext_18>	control characters = byte values that are not uhmm.. for human-readable text?
T 1709271293 18<20twkm18>	they were to control devices, originally and still some these days.
T 1709271325 18<20twkm18>	and to control communications, which is almost totally gone these days.
T 1709271342 18<27larryv18>	https://en.wikipedia.org/wiki/ASCII#Control_characters
T 1709271591 18<26sphertext_18>	so i can configure my terminal emulator to send \x0e when i press cmd+` and then i would be able to bind it as C-n in the screen configuration file?
T 1709271636 18<26sphertext_18>	where is the association between C+[something] and the control byte values that screen recognises?
T 1709271654 18<22tirnanog18>	or just configure it to send \x01n so it happens directly.
T 1709271680 18<26sphertext_18>	why doesn't screen just use the byte value, instead of the intermediary C+[something] notation?
T 1709271681 18<20twkm18>	provided your escape is the default ^A (aka \x01).
T 1709271704 18<20twkm18>	because you type n's a lot but you don't want to switch windows as a result.
T 1709271762 18<26sphertext_18>	i mean why is the command `keybind C-n next` instead of `keybind \x0e next`?
T 1709271803 18<20twkm18>	50 years ago a hex notation was much less common.
T 1709271817 18<27larryv18>	arguably C-n is easier to understand. also bind accepts an octal representation
T 1709271842 18<20twkm18>	and 50 years ago octal was quite common.
T 1709271917 18<26sphertext_18>	"ASCII reserves the first 32 code points (numbers 0–31 decimal) and the last one (number 127 decimal) for control characters. "
T 1709271934 18<26sphertext_18>	this means not all C+[key] on the keyboard result in a control character?
T 1709271945 18<20twkm18>	correct.
T 1709271962 18<26sphertext_18>	how do i know which ones send a control byte value?
T 1709271970 18<26sphertext_18>	or what the byte is
T 1709272152 18<26sphertext_18>	are control sequences and extension of the control characters? they seem to be different things
T 1709272157 18<20twkm18>	the keymap defines which send what, but generally the ascii value of the letter pressed & 0x1f is the resulting control value.
T 1709272250 18<20twkm18>	symbols too but typically specific ones, e.g., control+[ produces 0x1b but control+{ likely doesn't produce anything.
T 1709272321 18<26sphertext_18>	there should be like a terminal command where you can press control+[something] and it displays the byte value registered
T 1709272324 18<22tirnanog18>	also, cat -v helps. lnext can also help to obtain the raw value (issue C-v first and see stty -a also).
T 1709272381 18<26sphertext_18>	what is lnext?
T 1709272399 18<25hleneto18>	on X, xev can tell you something.
T 1709272474 18<22tirnanog18>	you can also do this in bash: printf '0x%02x\n' "'^A" # do not enter ^A literally there, press C-a instead
T 1709272539 18<22tirnanog18>	lnext is useful if you want to enter something like C-c, which would otherwise be handled specially by the tty (again, see stty -a).
T 1709272589 18<26sphertext_18>	but is it a terminal command? i don't have this program
T 1709272616 18<22tirnanog18>	what program?
T 1709272619 18<26sphertext_18>	lnext
T 1709272624 18<22tirnanog18>	please see stty -a
T 1709272629 18<22tirnanog18>	(for the third time)
T 1709272645 18<22tirnanog18>	"lnext = ^V"
T 1709272651 18<20twkm18>	the character to type so that the next character typed is taken literally not as a control.
T 1709272654 18<22tirnanog18>	so, try C-v, then C-c, for example.
T 1709272706 18<26sphertext_18>	so those cchars in stty -a are hijacked by bash
T 1709272719 18<22tirnanog18>	it will bypass the normal handling of C-c (to send SIGINT to the foregrand process group) and you'll get the actual raw value instead.
T 1709272724 18<26sphertext_18>	i suppose they can't be used directly for binding in another program, unless you issue lnext first?
T 1709272728 18<22tirnanog18>	it has nothing to do with bash.
T 1709272750 18<22tirnanog18>	you should avoid anything shown by stty -a, yes.
T 1709272821 18<26sphertext_18>	so i can use your printf command to discover the byte value of any control+[something] (if such a byte value is sent). but make sure to issue lnext (^V) beforehand
T 1709272857 18<22tirnanog18>	you don't always need lnext, but it's handy when you do.
T 1709272882 18<26sphertext_18>	and then i can configure my emulator to send the byte value that I want for any other key press, including ones using the CMD modifier
T 1709272893 18<22tirnanog18>	yes.
T 1709272893 18<26sphertext_18>	that way i can emulate pressing control
T 1709272951 18<26sphertext_18>	so the default byte values sent by control+[something] are some kind of convention, that both my emulator and e.g screen abide by?
T 1709272976 18<26sphertext_18>	because I imagine I could also configure my emulator to issue a non-standard byte value when I press control+[something]
T 1709273003 18<22tirnanog18>	if it's sufficiently flexible, yes.
T 1709273014 18<22tirnanog18>	I think ever Terminal.app can cover that particular case.
T 1709273022 18<22tirnanog18>	(it can't handle Cmd though)
T 1709273087 18<22tirnanog18>	I can only speak for alacritty, where this works: keybindings = [ { key = "=", mods = "Command", chars = "\u0001n" } ]
T 1709273100 18<27larryv18>	could even send more than one byte.
T 1709273102 18<22tirnanog18>	having to use the \u notation is a TOML format thing.
T 1709273152 18<22tirnanog18>	that's C-a followed by n, then.
T 1709273178 18<20twkm18>	which is screen default for next window.
T 1709273506 18<22tirnanog18>	by the way, lnext means literal next and I believe it only works with the standard line discipline. brief overview here: https://en.wikipedia.org/wiki/Line_discipline. be sure to check out the first referenced link also.
T 1709273518 18<22tirnanog18>	basically, this is tty stuff.
T 1709273586 18<22tirnanog18>	(first referenced from that same wikipedia article I mean)
T 1709274015 18<26sphertext_18>	looks pretty esoteric
T 1709274356 18<22tirnanog18>	if you run cat, you can actually get a better idea of how that discipline works, without the line editing capabilities of your shell getting in the way.
T 1709274388 18<22tirnanog18>	for example, issuing ^R (C-r) does, indeed, reprint the input line, as indicated by stty -a.
T 1709274471 18<22tirnanog18>	and ^T will, indeed, give you a status readout.
T 1709274648 18<26sphertext_18>	i just wish there was a table which showed the conventional association between control+[something] and its byte value (if there is one)
T 1709274665 18<26sphertext_18>	without having to press each one of them individually to find out
T 1709274690 18<20osse18>	sphertext_: man ascii
T 1709274692 18<26sphertext_18>	I'm also trying to figure out how "control sequences" relates to all this
T 1709274695 18<20osse18>	Ctrl-X is always X - 64
T 1709274716 18<27larryv18>	or: https://en.wikipedia.org/wiki/ASCII#Control_code_chart
T 1709274806 18<26sphertext_18>	oh nice
T 1709278705 18<26sphertext_18>	"A control character is a character that, in isolation, has some control function, such as carriage return (CR). Escape sequences, by contrast, consist of one or more escape characters which change the interpretation of subsequent characters. "
T 1709278994 18<26sphertext_18>	more on control character vs. escape sequence https://en.wikipedia.org/wiki/Escape_character#Control_character
T 1709279364 18<20osse18>	this jives witrh my understanding of the concept
T 1709279425 18<26sphertext_18>	so by convention, when you press control+J, a terminal emulator will send the _control character_ for line feed (which is a byte value). separately, there is also the _escape sequence_ `\n`, which resolves to the same _control character_ for line feed.
T 1709279450 18<25ormaaj18>	I don't know what a control function is
T 1709279492 18<20osse18>	could have said "has some function" I suppose
T 1709279501 18<25ormaaj18>	carriage return does absolutely nothing in a shell script. It's an ordinary character like any other.
T 1709279539 18<26sphertext_18>	ormaaj ?
T 1709279544 18<26sphertext_18>	are you replying to someone else or
T 1709279602 18<25ormaaj18>	The quoted text. That's really true in most languages. CR normally has no function.
T 1709279704 18<25ormaaj18>	the only place it may have some context-specific meaning is in languages whose parsers interpret CRLF as a substitute for LF.
T 1709279740 18<26sphertext_18>	oh the quote is just from wikipedia
T 1709279745 18<25ormaaj18>	yes
T 1709279843 18<26sphertext_18>	don't most languages interpret <CR> as line feed?
T 1709279854 18<25ormaaj18>	no
T 1709280010 18<27JAA18>	Ancient Mac OS stuff would, I suppose.
T 1709280075 18<26sphertext_18>	I don't understand, doesn't pressing <CR> when editing a text file insert the byte value for line feed?
T 1709280079 18<27JAA18>	Don't know when they made the switch exactly, but it was a long time ago.
T 1709280089 18<20osse18>	going from os9 to x
T 1709280116 18<27JAA18>	Ah yeah, so 20-ish years ago. Sounds about right.
T 1709280122 18<28emanuele618>	to type a carriage return, you use ^V^M
T 1709280128 18<28emanuele618>	$ ^M
T 1709280130 18<28emanuele618>	bash: $'\r': command not found
T 1709280153 18<28emanuele618>	i had to press enter after ^V^M to run that
T 1709280174 18<27JAA18>	'When editing a text file' implies an editor is involved, which might indeed do such a transformation.
T 1709280182 18<26sphertext_18>	when you press Enter, what do you input exactly?
T 1709280226 18<28emanuele618>	or a line editor like readline :D but really it is handled by the terminal, so ^V^M will work even when you just run cat with the terminal as stdin
T 1709280315 18<28emanuele618>	$ HISTFILE=/dev/null strace -qqqqefd=0 -eread bash --norc --noprofile
T 1709280315 18<26sphertext_18>	in vim, when you want to create a key mapping that involves pressing the enter key, you write it as <cr>
T 1709280317 18<28emanuele618>	bash-5.2$ read(0, "\r", 1)                        = 1
T 1709280343 18<26sphertext_18>	and i've never used a text editor in which pressing the Enter key didn't move to the next line
T 1709280347 18<22pj18>	sphertext_: Enter is a control key, corresponding to ^M, but can be independently trapped by most computer languages.  What it actually does varies depending on which program you're using and it's settings.
T 1709280355 18<28emanuele618>	bash-5.2$ read(0, "\26", 1)                       = 1
T 1709280357 18<28emanuele618>	read(0, "\r", 1)                        = 1
T 1709280359 18<28emanuele618>	that is ^V^M
T 1709280393 18<28emanuele618>	that is only happening because bash is running the terminal in raw mode; so it interprets ^V^M itself
T 1709280394 18<25ormaaj18>	I don't think characters interpreted by the tty driver can be considered within the scope of the language. The shell parser never sees it
T 1709280405 18<28emanuele618>	and Return/Enter actually sends \r in this mode
T 1709280420 18<28emanuele618>	but if you try with cat in standard cooked mode, you will see that enter/return
T 1709280426 18<26sphertext_18>	are there non-graphical ASCII characters which are  not control characters?
T 1709280426 18<28emanuele618>	will send \n
T 1709280435 18<28emanuele618>	$ strace -qqqqefd=0 -eread cat
T 1709280437 18<28emanuele618>	read(0,
T 1709280439 18<28emanuele618>	"\n", 131072)                   = 1
T 1709280444 18<28emanuele618>	and ^V^M or ^V<enter> sends "\r"
T 1709280452 18<28emanuele618>	read(0, ^M"\r", 131072)                   = 1
T 1709280470 18<28emanuele618>	i had to press ^D to flush the terminal, you can also press enter, but then cat reads \r\n
T 1709280483 18<25ormaaj18>	sure that makes sense
T 1709280539 18<28emanuele618>	i mean, what does not make sense? in #bash, everything always makes sense B)
T 1709280682 18<25ormaaj18>	read corrupting data randomly for non-C encodings when IFS is empty.
T 1709280705 18<28emanuele618>	makes sense
T 1709280713 18<25ormaaj18>	nonsense
T 1709280836 18<25ormaaj18>	I think other shells special case empty IFS + nul delimiter for UTF-8. Bash really should too because the normal behavior is useless.
T 1709281953 18<22tirnanog18>	sphertext_: the space character is not a control character.
T 1709281975 18<26sphertext_18>	but I would say it's graphical
T 1709282004 18<27JAA18>	'printable'?
T 1709282021 18<27JAA18>	That's the usual term, anyway.
T 1709282072 18<26sphertext_18>	apart from space, are there other examples of non-graphical ASCII characters which are not control characters?
T 1709282078 18<27JAA18>	In which case, no, ASCII is divided into control characters and printable characters.
T 1709282090 18<26sphertext_18>	great
T 1709282096 18<27JAA18>	0x00 to 0x1F and 0x7F are control characters, 0x20 to 0x7E are printables.
T 1709282136 18<26sphertext_18>	are there control characters which are not ASCII?
T 1709282169 18<26sphertext_18>	I'm thinking of arrow keys
T 1709282170 18<22tirnanog18>	incorrect. 0x20 does not use 'ink'. it is not printable.
T 1709282177 18<26sphertext_18>	do arrow keys send a byte code, or a character, or what? is it ASCII?
T 1709282209 18<22tirnanog18>	oh, I'm probably mixing it up with graph.
T 1709282241 18<27JAA18>	0x20 is special, but yeah, it's considered printable.
T 1709282276 18<28emanuele618>	# if [[ ' ' = [[:print:]] ]] then echo yes; else echo no; fi
T 1709282278 18<27JAA18>	Arrows send an escape sequence IIRC?
T 1709282279 18<25shbot18>	emanuele6: yes
T 1709282282 18<28emanuele618>	# if [[ ' ' = [[:graph:]] ]] then echo yes; else echo no; fi
T 1709282284 18<25shbot18>	emanuele6: no
T 1709282298 18<22tirnanog18>	# [[ " " == [[:print:]] ]] | [[ " " == [[:graph:]] ]]; echo "${PIPESTATUS[*]}"
T 1709282300 18<25shbot18>	tirnanog: 0 1
T 1709282321 18<28emanuele618>	that is 1 in binary
T 1709282329 18<25ormaaj18>	The first 128 unicode code points are the characters that correspond with ascii, so, yes effectively everything has them because everything is unicode.
T 1709282375 18<28emanuele618>	i don't think →↓←↑ are escape codes
T 1709282409 18<28emanuele618>	they are utf-8 sequences, but i don't think those are considered escape sequences
T 1709282472 18<28emanuele618>	the arrow keys should send ←↓→↑ !
T 1709282500 18<27JAA18>	Can't wait to use AltGr+i to move to the right!
T 1709282511 18<28emanuele618>	exactly what i was thinking
T 1709282515 18<25ormaaj18>	hjkl
T 1709282525 18<28emanuele618>	much easier to press than arrowright or alt+f
T 1709282530 18<28emanuele618>	err ctrl+f
T 1709282555 18<28emanuele618>	ew vim mode
T 1709282560 18<28emanuele618>	vi mode
T 1709282579 18<25ormaaj18>	so good
T 1709282607 18<27JAA18>	My layout is extremely annoying. It has ←↓→ but no ↑.
T 1709282612 18<22tirnanog18>	sphertext_: run cat -v (as mentioned earlier), press the arrow keys and see what happens. or use lnext with anything that can tell you what it is (printf, od, hexdump etc).
T 1709282648 18<25ormaaj18>	My login prompt should have username completion
T 1709282651 18<28emanuele618>	JAA: it's altgr+shift+u on my keyboard layout
T 1709282662 18<27JAA18>	Ooh
T 1709282677 18<27JAA18>	That even makes perfect sense since AltGr+u is ↓.
T 1709282705 18<28emanuele618>	i always think that altgr+u is ↑ because up
T 1709282711 18<28emanuele618>	but it is the opposite :/
T 1709282760 18<27JAA18>	The shift key has a big up arrow, so it turns the arrow upwards.
T 1709282783 18<28emanuele618>	also u in vim visual mode converts to lowercase, while U converts to upper case
T 1709282788 18<28emanuele618>	also U is taller than u
T 1709282849 18<26sphertext_18>	^[[D. so from wikipedia, ^[ is an ASCII, non-graphical, control character which is used as an escape character. does this mean ^[[D is an _escape sequence_ consisting of 3 ASCII characters (one non-graphical and two graphical)?
T 1709282867 18<26sphertext_18>	^[[D is what I got when I pressed left-arrow in cat-v
T 1709282892 18<20osse18>	yes
T 1709282913 18<26sphertext_18>	i am terrified that i am starting to actually understand this
T 1709282935 18<22tirnanog18>	sphertext_: another experiment: 1) od -t x1 2) lnext, arrow key 3) enter, C-d (to signify EOF)
T 1709282949 18<22tirnanog18>	that'll mix in the byte for the linefeed but it does the job.
T 1709282993 18<22tirnanog18>	actually, shouldn't even need lnext.
T 1709283060 18<22tirnanog18>	(because od uses the bog standard line discipline, just like cat)
T 1709283219 18<22tirnanog18>	for me that prints "1b  5b  44  0a"
T 1709283222 18<26sphertext_18>	oh this is very nice
T 1709283229 18<26sphertext_18>	i used it with -t c
T 1709283303 18<22tirnanog18>	-t a is also interesting for ascii (both of those can be shortened as -c and -a).
T 1709283336 18<22tirnanog18>	you can mix formats too.
T 1709283354 18<22tirnanog18>	-t x1 -c
T 1709283401 18<26sphertext_18>	and those formats are ways to represent the underlying byte value?
T 1709283402 18<28emanuele618>	iF yOuR od SuPpOrTs -c
T 1709283444 18<22tirnanog18>	oh, it's xsi? alright.
T 1709284014 18<22tirnanog18>	sphertext_: yes.
T 1709284041 18<22tirnanog18>	the -t a ones you can look up directly in the macos ascii man page, iirc.
T 1709284074 18<22tirnanog18>	as well as the hex values, obviously.
T 1709284487 18<26sphertext_18>	weird. default behaviour in iTerm for alt+[up arrow] is ^[[1;9A while in mac's own Terminal it's ^[[A
T 1709284505 18<26sphertext_18>	tho you can definitely configure this in iTerm
T 1709284512 18<26sphertext_18>	(i didn't, that's just the default)
T 1709284532 18<26eoc18>	in posix can one remove trailing path of url to leave base url? echo ${1%/*}
T 1709284610 18<28emanuele618>	in posix, on posix, under posix, by posix
T 1709284827 18<26sphertext_18>	# url="www.website.com/foo/bar/page.html" echo ${url%%/*}
T 1709284829 18<25shbot18>	sphertext_: no output
T 1709284850 18<28emanuele618>	!faq foo=bar
T 1709284850 18<29greybot18>	https://mywiki.wooledge.org/BashFAQ/104 -- Why doesn't foo=bar echo "$foo" print bar?
T 1709284873 18<26sphertext_18>	# url="www.website.com/foo/bar/page.html"; echo ${url%%/*}
T 1709284875 18<25shbot18>	sphertext_: www.website.com
T 1709284885 18<28emanuele618>	that is the least urly url i have ever seen
T 1709284927 18<26sphertext_18>	sounds racist
T 1709284959 18<26sphertext_18>	but yeah dunno how to solve if it has a URI prefix
T 1709285142 18<26eoc18>	hah, very creative sphertext, unfortunately the urls start with http://
T 1709285169 18<26sphertext_18>	you have to do it in 2 steps then
T 1709285242 18<28emanuele618>	great out of the box, in of the posix thinking
T 1709285246 18<26eoc18>	ah okok
T 1709285941 18<22pj18>	sh# url=http://www.example.com/foo/bar/baz.html base=${url#*//} domain=${base%%/*} path=${url#*$domain} base=${url%$path}; echo "$base"
T 1709285942 18<25shbot18>	pj: http://www.example.com
T 1709285954 18<22pj18>	some creative thinking might be able to shorten that.
T 1709288012 18<22meteors18>	I am sourcing a file with variables and creating a new file with the variables expanded. I use this: `source "$FILE_A";eval "cat <<EOF > $FILE_FINAL $(<"$FILE_B") EOF"`. Is there a better way to achieve the same?
T 1709288211 18<24geirha18>	!template
T 1709288211 18<29greybot18>	http://mywiki.wooledge.org/TemplateFiles
T 1709288215 18<27Soliton18>	showing crazy code and then asking how to achieve the same but better is not very useful. explain a goal.
T 1709288303 18<24geirha18>	If you can rely on envsubst (from gettext package) being available, I'd definitely use that
T 1709288502 18<22meteors18>	I 'll try with envsbust, thanks. Sorry for the crazy code, trying to combine a file with variables with another file that I'd like the variables to be expanded. envsubst seems a good fit, ty
T 1709288736 18<24geirha18>	yeah, so then it would look something like  (set -a ; source file_a ; envsubst < file_b > final)
T 1709289174 18<22meteors18>	Yup, works fine, thanks
T 1709289234 18<26chiselfuse18>	in interactive mode, i sometimes want to run a command i have in .xinitrc, i do this by typing:   $(grep ^foo .xinitrc)    to run the command "foo bar baz" found in my .xinitrc.     the problem is that sometimes the command is appended with a comment such as "foo bar baz # comment" and i find that typing  $(grep ^foo .xinitrc)  passes the # and the comment as arguments
T 1709289239 18<26chiselfuse18>	how can i prevent this?
T 1709289319 18<27Soliton18>	if you want to execute shell code then you use eval.
T 1709289320 18<27wyclif18>	You use the awk command to filter out comments
T 1709289346 18<27wyclif18>	Like, here's an example:
T 1709289347 18<26chiselfuse18>	eval works
T 1709289348 18<27wyclif18>	'$(grep ^foo .xinitrc | awk '{sub(/#.*/, "", $0); print $0}')
T 1709289357 18<26chiselfuse18>	i had confused "eval" with "command"
T 1709289373 18<27Soliton18>	and quote properly.
T 1709289387 18<27Soliton18>	eval "$(grep ...)"
T 1709289388 18<27wyclif18>	That removes everything from `#` to the end of the line, removing the comments from the output of `grep`
T 1709289394 18<26chiselfuse18>	wyclif: this is interactive mode, even if this were a cleaner solution it would be a bit ugly to type out
T 1709289417 18<27wyclif18>	Then the modified command is executed using `$()`
T 1709289439 18<27wyclif18>	Yes, it's ugly
T 1709289457 18<27wyclif18>	you could use sed and do something like:
T 1709289460 18<27wyclif18>	`$(grep ^foo .xinitrc | sed 's/#.*//')
T 1709289466 18<27Soliton18>	that it works with unquoted $() is by accident.
T 1709289476 18<27Soliton18>	that is not how you execute code.
T 1709289501 18<27wyclif18>	ignore the opening tick, that was a typo on my part
T 1709289560 18<27Soliton18>	handling one specific syntax part is not going to make it much less by accident.
T 1709289635 18<27wyclif18>	But yes, you should use `eval`
T 1709289643 18<28selckin18>	should just make it a seperate script, and not run things you grep
T 1709289671 18<27wyclif18>	if you want to execute the command obtained from the `.xinitrc` file and handle the comments properly
T 1709289688 18<27wyclif18>	Like maybe:
T 1709289700 18<27wyclif18>	eval "$(grep ^foo .xinitrc | sed 's/#.*//')"
T 1709289728 18<24geirha18>	no point in removing the comment anymore since eval will treat it as a comment
T 1709289736 18<27Soliton18>	# $(echo 'echo "foo bar" #comment')
T 1709289737 18<25shbot18>	Soliton: "foo bar" #comment
T 1709289742 18<27Soliton18>	# eval "$(echo 'echo "foo bar" #comment')"
T 1709289744 18<25shbot18>	Soliton: foo bar
T 1709289883 18<24geirha18>	I guess it's a decent usecase for fzf    eval "$(fzf < ~/.xinitrc)"
T 1709289895 18<27wyclif18>	Yes
T 1709289921 18<27wyclif18>	Everyone should have fzf installed; it's so useful
T 1709289922 18<26chiselfuse18>	geirha: that's a pretty cool idea
T 1709289933 18<26chiselfuse18>	i think i'll write a function in my rc file
T 1709289959 18<26chiselfuse18>	hmm what should i call it
T 1709289968 18<28emanuele618>	can you write it also in my rc file?
T 1709289998 18<26chiselfuse18>	i don't think shell redirection works over network
T 1709290034 18<26chiselfuse18>	echo testing > emanuele6:.bashrc
T 1709290045 18<26chiselfuse18>	oops overwrote the entire file
T 1709290047 18<20sphertext__18>	got so many good ideas for using fzf from this https://www.youtube.com/watch?v=8SqakfCSzQk
T 1709290052 18<26chiselfuse18>	unless it didn't work to begin with
T 1709290172 18<20sphertext__18>	oops this is newer: https://www.youtube.com/watch?v=41JxYe70Xwo
T 1709290191 18<28emanuele618>	hmm, why am i getting the default prompt and  bash: testing: command not found   when i start bash?
T 1709290197 18<26chiselfuse18>	run() { eval "$(fzf < "$1")" }
T 1709290204 18<26chiselfuse18>	do you think this is good?
T 1709290212 18<28emanuele618>	you need a ; before }
T 1709290230 18<26chiselfuse18>	but it works without it, what benefit is there?
T 1709290244 18<28emanuele618>	if it works without it is not bash
T 1709290255 18<28emanuele618>	# run() { eval "$(fzf < "$1")" }
T 1709290261 18<25shbot18>	emanuele6: Missing terminating quote, bracket or keyword
T 1709290276 18<26chiselfuse18>	weird, idk how it worked without it for me
T 1709290311 18<24geirha18>	maybe you have a newline before the }
T 1709290314 18<28emanuele618>	anyway, you would preferably use  eval -- "$(fzf < "$1")"  or  eval " $(fzf < "$1")"   or it will not work correctly if the lines is longer than two characters and starts with -
T 1709290320 18<24geirha18>	run() { eval "$(fzf -q "$2" < "$1")" ; }
T 1709290324 18<24geirha18>	run .xinitrc foo
T 1709290488 18<26chiselfuse18>	emanuele6: i read the manpage for eval about the "--" and i can't understand what it's saying at all
T 1709290504 18<26chiselfuse18>	does eval take any '-' options?
T 1709290511 18<26chiselfuse18>	why would it require -- then
T 1709290528 18<27Soliton18>	# eval --help
T 1709290530 18<25shbot18>	Soliton: eval: eval [arg ...]
T 1709290530 18<25shbot18>	Soliton:     Execute arguments as a shell command.
T 1709290530 18<25shbot18>	Soliton: etc... ( http://paste.wooledge.org/29065 )
T 1709290589 18<27Soliton18>	# eval -a
T 1709290590 18<25shbot18>	Soliton: bash: eval: -a: invalid option
T 1709290590 18<25shbot18>	Soliton: eval: usage: eval [arg ...]
T 1709290616 18<28emanuele618>	if the argument is longer than two characters, and starts with -
T 1709290626 18<26chiselfuse18>	is the manpage eval(1P) relevant here? because i can't find any of this there
T 1709290646 18<27Soliton18>	!man
T 1709290647 18<29greybot18>	bash builtins and keywords do not have separate man-pages, read bash's manual instead or use the help builtin. Rule of thumb: If ''type foo'' says foo is a builtin or keyword, run ''help foo'' or ''man bash'', otherwise try man and/or info.
T 1709290665 18<26chiselfuse18>	what is eval(1P) for then?
T 1709290667 18<26chiselfuse18>	it says it's posix
T 1709290696 18<24ano18>	!posix
T 1709290696 18<29greybot18>	The POSIX standard defines what any modern unix should support. Use just POSIX external commands and options to make portable scripts. See http://shellhaters.org
T 1709290697 18<26chiselfuse18>	APPLICATION USAGE Since eval is not required to recognize the "--" end of options delimiter, in cases where the argument(s) to eval might begin with '-' it is recommended that the first argument is prefixed by a string that will not alter the commands to be executed, such as a <space> character:
T 1709290731 18<28emanuele618>	in bash you can use   eval --   however you cannot use  run() { eval "$(fzf < "$1")" }
T 1709290750 18<28emanuele618>	for a portable function you would use    run() { eval " $(fzf < "$1")" ;}
T 1709290751 18<24geirha18>	anyway, it's not like you have any commands that start with - so you wouldn't select any with fzf in the first place, but still a good idea to add the safeguard
T 1709290769 18<27Soliton18>	emanuele6: why does it need to be longer than two characters when -a already fails?
T 1709290784 18<28emanuele618>	two characters or longer!
T 1709290815 18<28emanuele618>	!cookie > Soliton
T 1709290815 18<29greybot18>	Soliton: 🍪
T 1709291797 18<20sphertext__18>	so if `control+.` is not mapped to a control character, this means I can't use it as a binding in a terminal program
T 1709294290 18<27Soliton18>	there is a good chance your terminal does not produce distinct input for it.
T 1709294348 18<27Soliton18>	in principle it can do whatever it wants of course.
T 1709295156 18<28dumbledoor18>	When I archive a file using `tar czf file`, tar creates an archive with the file nested deeply in a hierarchy of directories instead of saving it at the top level. How to deal with this?
T 1709295219 18<28dumbledoor18>	I backup my "stuffs" directory to google drive and this "stuffs" directory has both files and directories. tar works fine with directories but creates this problem when working with files.
T 1709295253 18<28dumbledoor18>	Should I just use tar and gzip for files and directories respectively?
T 1709295386 18<28dumbledoor18>	tar and gzip for directories and files*
T 1709295483 18<28dumbledoor18>	Note: I am not archiving the stuffs directory itself, because I want to make use of google drive's history feature.
T 1709295508 18<26lopid18>	cd to iot
T 1709295509 18<28APic18>	Maybe You should hardlink the File to singlefilestuffs/File and then tar czvf singlefilestuffs/File
T 1709295510 18<26lopid18>	it
T 1709295560 18<28APic18>	tar czvf singlefilearchive.tgz singlefilestuffs/File even
T 1709295574 18<28APic18>	Or just zip Your single Files    😉
T 1709295602 18<28APic18>	tar always stores Directories by Default, zip not
T 1709295644 18<28APic18>	Remember tar came from „Tape Archiver“
T 1709295648 18<28dumbledoor18>	oops
T 1709295655 18<28dumbledoor18>	you are right lopid
T 1709295675 18<28dumbledoor18>	if I cd to the directory of the file, tar archives it at the top level
T 1709295715 18<28dumbledoor18>	(that's unpredictable tho, i wonder why it works like that)
T 1709295805 18<28dumbledoor18>	(ok it's not unpredictable, i just don't know the right word)
T 1709295811 18<28dumbledoor18>	thanks
T 1709296031 18<29sixwheeledbeast18>	so you can restore it from the tape in the same place.
T 1709296258 18<28dumbledoor18>	sixwheelbeast: Does tar need an extra option to extract at the same place?
T 1709296312 18<29sixwheeledbeast18>	You could use -C to target another directory
T 1709296332 18<29sixwheeledbeast18>	or maybe cd in a subshell
T 1709296357 18<28dumbledoor18>	You mean by default it extracts at the same place? That did not work for me
T 1709296457 18<28dumbledoor18>	It created a home directory at the place instead
T 1709296521 18<27Soliton18>	tar uses the path you give it. if you give it file then it extracts file. if you give it path/to/file then it extracts path/to/file.
T 1709296547 18<27Soliton18>	if you give it an absolute path it might complain.
T 1709296736 18<28dumbledoor18>	I see. It does say tar: Removing leading '/' from member names
T 1709296799 18<25pgas18>	if you only need compression, then just use gzip or xz or the like.
T 1709297096 18<28dumbledoor18>	didn't know about xz. thanks.
T 1709297302 18<24cheater18>	https://hackaday.com/2024/02/29/the-white-house-memory-safety-appeal-is-a-security-red-herring/
T 1709297309 18<28emanuele618>	xz is the xz in .tar.xz; and gzip is the gz in .tar.gz; another popular one is bzip2, that is the bx2 in .tar.bz2
T 1709297318 18<28emanuele618>	s/bx/bz/
T 1709297335 18<24cheater18>	wasn't there another new one too
T 1709297387 18<28emanuele618>	there are many different compression tools
T 1709297410 18<28emanuele618>	gz, xz, and bz2 are probably the most populars
T 1709297432 18<24geirha18>	probably thinking of zstd
T 1709297443 18<28selckin18>	lzma lz4
T 1709297511 18<20osse18>	all of them sound like party drugs
T 1709297538 18<28emanuele618>	oh, yes, archlinux started using zstd for packages some years ago
T 1709297561 18<28emanuele618>	its extension is .zst
T 1709297579 18<24geirha18>	so idiotic
T 1709297587 18<28emanuele618>	either party drugs or party diseases
T 1709297592 18<27colo18>	heh
T 1709297661 18<28emanuele618>	archlinux packages are all compiled with -fno-plt >:(
T 1709297666 18<28emanuele618>	i cannot ltrace them
T 1709298076 19*	Now talking on 22#bash
T 1709298076 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709298076 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709299228 18<27Earnestly18>	> steelman
T 1709299237 18<27Earnestly18>	Ada had so much potential
T 1709299772 18<26chiselfuse18>	https://0x0.st/HRnb.txt
T 1709299777 18<26chiselfuse18>	does this look good?
T 1709299803 18<26chiselfuse18>	i added grep to uncomment commented lines
T 1709299845 18<26chiselfuse18>	hmm somehow uploading it completely screwed indentation
T 1709299950 18<26chiselfuse18>	https://0x0.st/HRnG.txt
T 1709300003 18<26chiselfuse18>	!check
T 1709300004 18<28checkbot18>	chiselfuse: Looks good to me
T 1709300131 18<27Earnestly18>	chiselfuse: If you're using eval you likely don't need to worry about excluding comment characters
T 1709300141 18<27Earnestly18>	As eval, being the shell, understands what they are
T 1709300181 18<27Earnestly18>	I suppose it's just for fzf's sake
T 1709300407 18<28llua18>	lines don't have to start with # to be a comment too
T 1709300468 18<27Earnestly18>	A good point, this doesn't account for line continuations
T 1709300734 18<28emanuele618>	chiselfuse: but ex is a standard program D:
T 1709300797 18<28emanuele618>	i don't understand that grep command; it outputs from the first character that is not #
T 1709300874 18<28emanuele618>	so e.g. for "# foobar", " foobar"   for " # baz", " baz"   for "## boo", " boo"  for " ## boo", " ## boo"
T 1709300899 18<28emanuele618>	you have not quoted $#
T 1709300931 18<28emanuele618>	err   for " # baz", " # baz"   is what i meant to write
T 1709300974 18<28emanuele618>	it is basically like  sed 's/^#*//'   but weirdly written with a GNU grep command
T 1709301056 18<28emanuele618>	well, not exactly, if a line only contains  ####  that grep command outputs nothing, while sed 's/^#*//' would output an empty line, but in that context it does not make much difference
T 1709301169 18<28emanuele618>	s/line only/line is empty, or only/
T 1709301464 18<26chiselfuse18>	emanuele6: what's the correct preprocessing to do in english do you think? get a line that starts with anything that isn't # or whitespace?
T 1709301487 18<26chiselfuse18>	or would there be some edge case there too
T 1709301549 18<28emanuele618>	that grep command is basically  sed 's/^#*//'  but written weirdly
T 1709301557 18<28emanuele618>	you should quote "$#"
T 1709301593 18<26chiselfuse18>	huh?
T 1709301599 18<26chiselfuse18>	emanuele6: what $# do you mean?
T 1709301609 18<28emanuele618>	the one in your code
T 1709301623 18<28emanuele618>	you have    if [ $# -ne 1 ]; then    that is wrong
T 1709301628 18<26chiselfuse18>	oh
T 1709301639 18<28emanuele618>	it should be   [ "$#" -ne 1 ]   or just   [ "$#" != 1 ]
T 1709301649 18<28emanuele618>	but quoted
T 1709301686 18<26chiselfuse18>	is there a way to match any whitespace character in grep or sed?
T 1709301701 18<28emanuele618>	and ex is a standard command  https://pubs.opengroup.org/onlinepubs/9699919799/utilities/ex.html  vi in non-visual mode
T 1709301769 18<28emanuele618>	well, yes, there is [[:space:]] to match any whitespace character defined in the current locale, and [[:blank:]] to match any horizontal whitespace defined in the current locale... you could also specify the whitespace characters manually in a [...]
T 1709301828 18<26chiselfuse18>	do you think that     grep -o '[^#]|[[:space:]].*$'    is okay?
T 1709301837 18<26chiselfuse18>	err
T 1709301843 18<28emanuele618>	how can it be ok?
T 1709301849 18<26chiselfuse18>	grep -o '[^#]|[^[[:space:]]].*$'    is okay?
T 1709301859 18<28emanuele618>	wot
T 1709301888 18<28emanuele618>	i think you mean [^#[:space:]].*$
T 1709301900 18<26chiselfuse18>	i'm trying to say "longest match starting with a character that isn't # or whitespace
T 1709301904 18<28emanuele618>	but i don't understand by what logic that makes sense
T 1709301921 18<26chiselfuse18>	"longest match starting with a character that isn't # or whitespace"
T 1709301925 18<26chiselfuse18>	how would you do it then?
T 1709301955 18<28emanuele618>	that sentence has basically exactly the same meaning as remove all the characters at the start that are whitespace or #
T 1709301965 18<26chiselfuse18>	yea
T 1709301978 18<26chiselfuse18>	what's wrong with it?
T 1709301997 18<28emanuele618>	i said earlier how to convert it?
T 1709302025 18<28emanuele618>	 sed $'s/^[# \t]*//'
T 1709302054 18<26chiselfuse18>	weird my chat log doesn't have the first time you said it
T 1709302055 18<28emanuele618>	i cannot see the value is using [[:space:]] as you are doing instead of just space and tab since using any other whitespace character in bash will result in an error
T 1709305277 19*	Now talking on 22#bash
T 1709305277 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709305277 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709312939 19*	Now talking on 22#bash
T 1709312939 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709312939 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709316253 19*	Now talking on 22#bash
T 1709316253 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709316253 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709345126 19*	Now talking on 22#bash
T 1709345126 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709345126 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709345182 18<25ormaaj18>	tirnanog: do you happen to know if profiles run sandboxed? If yes then I can't use findmnt or mountpoint so all I can really do in that case is [[ $EROOT -ef /usr/bin ]]
T 1709345217 18<25ormaaj18>	sandboxed or otherwise disallow exec like global-scope ebuild code
T 1709345279 18<22tirnanog18>	I don't, sorry. if it helps, the devmanual should explain (I think) whether a given phase is sandboxed. I think anything that isn't an ebuild phase generally isn't but you have to go to to the code to be sure.
T 1709345311 18<22tirnanog18>	or just try it.
T 1709345314 18<25ormaaj18>	ok ty. making such a simple change takes some research :|
T 1709345337 18<22tirnanog18>	yeah, I'm right about the devmanual.
T 1709345347 18<22tirnanog18>	here's an example showing that sandboxing is in effect for src_install: https://devmanual.gentoo.org/ebuild-writing/functions/src_install/index.html
T 1709345357 18<22tirnanog18>	and that it's also root at that point.
T 1709346214 18<25ormaaj18>	I was trying to install mksh-9999 earlier which needs to access a CVS repo which uses ssh, and the PORTAGE user apparently cannot access its own home directory without sandbox error, so that happens to be why I was complaining about openssh earlier.
T 1709346268 18<22tirnanog18>	ah.
T 1709346307 18<22tirnanog18>	the sandbox is a relic from a time where every phase was executed as root and we didn't have namespaces.
T 1709346313 18<22tirnanog18>	it should be put out to pasture, really.
T 1709346326 18<22tirnanog18>	it causes bugs in its own right from time to time.
T 1709346404 18<25ormaaj18>	it needs to read the known_hosts file. My previous hack of just putting the host in portage's file doesn't work anymore, because they must have changed how the sandbox works. So I need a new hack, which will probably be to abuse the KnownHostsCommand to write a hard-coded value for the host key with printf XD
T 1709346423 18<22tirnanog18>	oh dear.
T 1709350303 18<24nicolas1718>	I can use ${f#prefix} and ${f%suffix} to remove a prefix or suffix from a variable value, but is there any easy way to remove *both* a prefix and a suffix? or do I need to use a temporary variable to do # and % steps separately?
T 1709350469 18<27larryv18>	the latter
T 1709350496 18<27larryv18>	depending on what you're doing, you might be able to just reuse the same variable
T 1709356535 19*	Now talking on 22#bash
T 1709356535 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709356535 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709356629 19*	Now talking on 22#bash
T 1709356629 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709356629 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709368583 18<19zxd18>	hi, what's the history behind the need for a    comma    before  closing }   :       { echo foo  ;}
T 1709368620 18<19zxd18>	it looks for '}'  command?
T 1709369144 18<19Artfaith18>	zxd, I am sory, a comma or semicolon?
T 1709369320 18<25ormaaj18>	# {(echo moo)}
T 1709369323 18<25shbot18>	ormaaj: moo
T 1709369647 18<19zxd18>	semicolon
T 1709369818 18<19Artfaith18>	zxd, what do you mean by "history"? Why is it required in the syntax?
T 1709369983 18<28emanuele618>	# if { [[ 1 ]] } then {(echo hi)} fi
T 1709369984 18<25shbot18>	emanuele6: hi
T 1709370029 18<28emanuele618>	you "need" a semicolon for because otherwise } is just the string "}"
T 1709370032 18<28emanuele618>	# echo }
T 1709370033 18<25shbot18>	emanuele6: }
T 1709370064 18<28emanuele618>	it is the same reason why you "need" a semicolon before fi
T 1709370065 18<19Artfaith18>	And just in case, ( :; ) means a subshell.
T 1709370073 18<28emanuele618>	# if true; then echo hi fi
T 1709370079 18<25shbot18>	emanuele6: Missing terminating quote, bracket or keyword
T 1709370081 18<28emanuele618>	# echo hi fi
T 1709370082 18<25shbot18>	emanuele6: hi fi
T 1709370087 18<28emanuele618>	# if true; then echo hi; fi
T 1709370089 18<25shbot18>	emanuele6: hi
T 1709370111 18<25ormaaj18>	# [[(({})||({}))]] && echo moo moo moo
T 1709370112 18<25shbot18>	ormaaj: moo moo moo
T 1709370119 18<19Artfaith18>	# a=1; ( a=2 ); declare -p a;
T 1709370120 18<25shbot18>	Artfaith: declare -- a="1"
T 1709370189 18<28emanuele618>	# for case in case do case in esac done
T 1709370196 18<25shbot18>	emanuele6: Missing terminating quote, bracket or keyword
T 1709370196 18<28emanuele618>	err
T 1709370201 18<28emanuele618>	# for case do case in esac done
T 1709370202 18<25shbot18>	emanuele6: bash: syntax error near unexpected token `esac'
T 1709370210 18<28emanuele618>	# for case do case moo in esac done
T 1709370211 18<25shbot18>	emanuele6: no output
T 1709370213 18<28emanuele618>	:D
T 1709370364 18<28emanuele618>	# for do do if case moo in esac then for voo do case poo in esac done else case do in esac fi done
T 1709370365 18<25shbot18>	emanuele6: no output
T 1709370414 18<25ormaaj18>	# for for do select select do case case in esac done done; echo :\)
T 1709370416 18<25shbot18>	ormaaj: :)
T 1709370608 18<25ormaaj18>	I have an actual headache now. Stupid bash.
T 1709370755 18<28emanuele618>	# until case headache in esac do for for do if case moo in esac then case ormaaj in esac fi done done
T 1709370756 18<25shbot18>	emanuele6: no output
T 1709371297 18<25ormaaj18>	!smiley
T 1709371297 18<29greybot18>	m# case { { ( { ) ( <<< :-\) cat ) }
T 1709371298 18<25shbot18>	greybot: :-)
T 1709371358 18<28emanuele618>	# time TIMEFORMAT=:-\)
T 1709371359 18<25shbot18>	emanuele6: :-)
T 1709371401 18<28emanuele618>	$ strace -qqqqefd=2 -ewrite bash -c 'time TIMEFORMAT=:-\)'
T 1709371403 18<28emanuele618>	write(2, ":-)\n", 4:-)
T 1709371405 18<28emanuele618>	)                    = 4
T 1709371411 18<28emanuele618>	that is how you write to stderr without redirections in bash
T 1709371806 18<25ormaaj18>	# bash+ -c $'${| local -; eval "set -nv\nmoo" ; }' >/dev/null
T 1709371808 18<25shbot18>	ormaaj: moo
T 1709371863 18<28emanuele618>	# bash+ -c $'${| local -; eval "set -nv\:-)" ; }' >/dev/null
T 1709371865 18<25shbot18>	emanuele6: bash+: eval: line 1: syntax error near unexpected token `)'
T 1709371865 18<25shbot18>	emanuele6: bash+: eval: line 1: `set -nv\:-)'
T 1709371868 18<28emanuele618>	# bash+ -c $'${| local -; eval "set -nv\n:-)" ; }' >/dev/null
T 1709371869 18<25shbot18>	emanuele6: :-)
T 1709371869 18<25shbot18>	emanuele6: bash+: eval: line 3: syntax error near unexpected token `)'
T 1709371869 18<25shbot18>	emanuele6: bash+: eval: line 3: `:-)'
T 1709371912 18<28emanuele618>	# read -t0 -p$':-)\n'
T 1709371913 18<25shbot18>	emanuele6: no output
T 1709371922 18<28emanuele618>	:/
T 1709371927 18<25ormaaj18>	ha
T 1709371929 18<28emanuele618>	# read -rN0 -p$':-)\n'
T 1709371931 18<25shbot18>	emanuele6: no output
T 1709371935 18<28emanuele618>	D:
T 1709372347 18<28emanuele618>	time TIMEFORMAT=${str//%/%%}   is the best way to do that
T 1709372509 18<28emanuele618>	# log () { time local TIMEFORMAT=${@//%/%%};}; log hello; log 99% done
T 1709372510 18<25shbot18>	emanuele6: hello
T 1709372510 18<25shbot18>	emanuele6: 99% done
T 1709372941 18<22mosasaur18>	get on with it then
T 1709372990 18<28emanuele618>	00% done
T 1709373065 18<22mosasaur18>	# date
T 1709373066 18<25shbot18>	mosasaur: Sat Mar  2 09:51:05 UTC 2024
T 1709374004 18<25ormaaj18>	hm I forgot - are these the same? `[[ ( -L $x && -d $x ) && $x == foo || -z $moo ]]` and `[[ ( ( -L $x && -d $x ) && $x == foo ) || -z $moo ]]`
T 1709374038 18<25ormaaj18>	They look same... unless I missed a case. The operator precedence isn't actually documented.
T 1709374139 18<25ormaaj18>	Mainly concerned with whether -z moo is evaluated only if the overall previous expression is false
T 1709374541 18<24geirha18>	if they aren't the same, I've probably written a lot of bugs
T 1709374563 18<24geirha18>	removing all the parenthesis should also yield the same logic
T 1709374973 18<24geirha18>	# for a in '' T ; do for b in '' T ; do for c in '' T ; do for d in '' T ; do printf '[[ ( %s && %s ) && %s || %s ]]: ' "${a:-F}" "${b:-F}" "${c:-F}" "${d:-F}" ; if [[ ( $a && $b ) && $c || $d ]] ; then printf 'T\n' ; else printf 'F\n' ; fi ; done done done done
T 1709374975 18<25shbot18>	geirha: [[ ( F && F ) && F || F ]]: F
T 1709374975 18<25shbot18>	geirha: [[ ( F && F ) && F || T ]]: T
T 1709374975 18<25shbot18>	geirha: etc... ( http://paste.wooledge.org/29172 )
T 1709375177 18<24geirha18>	# for a in '' T ; do for b in '' T ; do for c in '' T ; do for d in '' T ; do printf '[[ ( %s && %s ) && %s || %s ]]: ' "${a:-F}" "${b:-F}" "${c:-F}" "${d:-F}" ; if [[ ( $a && $b ) && $c || $d$(printf E>&2) ]] ; then printf 'T\n' ; else printf 'F\n' ; fi ; done done done done
T 1709375179 18<25shbot18>	geirha: [[ ( F && F ) && F || F ]]: EF
T 1709375180 18<25shbot18>	geirha: [[ ( F && F ) && F || T ]]: ET
T 1709375180 18<25shbot18>	geirha: etc... ( http://paste.wooledge.org/29174 )
T 1709375741 18<25ormaaj18>	yay good same!
T 1709375744 18<25ormaaj18>	:)
T 1709378384 18<19zxd18>	if { [[ 1 ]] } then {(echo hi)} fi
T 1709378385 18<19zxd18>	-bash: syntax error near unexpected token `}'
T 1709378800 18<19zxd18>	# if { [[ 1 ]] } then {(echo hi)} fi
T 1709378801 18<25shbot18>	zxd: hi
T 1709378810 18<19zxd18>	why does it work with the bot
T 1709379034 18<28emanuele618>	because the bot has bash 5.2
T 1709379044 18<28emanuele618>	while you evidently do not
T 1709379088 18<28emanuele618>	the only difference is that since bash 5.2 { [[ 1 ]] } is allowed, while in earlier versions you had to use  { [[ 1 ]] ;}
T 1709379100 18<28emanuele618>	51# { if { [[ 1 ]] } then {(echo hi)} fi }
T 1709379101 18<25shbot18>	emanuele6: bash: syntax error near unexpected token `}'
T 1709379106 18<28emanuele618>	51# { if { [[ 1 ]];} then {(echo hi)} fi }
T 1709379107 18<25shbot18>	emanuele6: hi
T 1709379224 18<19zxd18>	and also don't need  ;   after { [[ 1 ]] }   if { [[ 1 ]] };
T 1709379444 18<19zxd18>	what's the difference between using      [[ (foo || foo) && ( foo )  ]] ||  [[ foo ]]     and      [[ (( foo || foo ) && foo ) || foo ]]
T 1709379565 18<19zxd18>	what does   [[ {} ]] && echo a   mean ? why does it work when there is no space between the {  }     and also  [[ {asdasdasdasda} ]] && echo a
T 1709380427 18<29sixwheeledbeast18>	the test [[ will be true as string length is gt 0 and then echo a
T 1709380453 18<29sixwheeledbeast18>	command grouping doesn't do much
T 1709380837 18<19zxd18>	i remember there was a trick with printf    to leave the last space off when printing an array :  printf "%s " "${array[@]}"
T 1709380843 18<19zxd18>	how to get rid of the last space
T 1709381180 18<24geirha18>	printf %s "${array[*]}"
T 1709381295 18<24geirha18>	and make sure IFS starts with a space, of course
T 1709381537 18<27Earnestly18>	zxd: IFS is useful for this, but typically in languages that lack it, the process is usually to put the separator first as a variable which is unset of the first iteration. I.e. for elem in collection {printf "%s%s", sep, elem; sep = ' '}
T 1709381558 18<27Earnestly18>	Or sep = '' whatever the language needs
T 1709381564 18<27Earnestly18>	(Initially that is)
T 1709386868 18<25Lynx-18>	Is it OK to have the output from multiple binaries piped to a single FIFO simultaneously, or will mangling occur?
T 1709387343 18<19zxd18>	51# for for do select select do case case in esac done done; echo :\)
T 1709387345 18<25shbot18>	zxd: bash: syntax error near unexpected token `done'
T 1709387345 18<27Earnestly18>	It is okay, but the order will be based on the order things write to it. I'm not sure if you can call that mangling since it's not going to just randomly disorder things
T 1709387402 18<19zxd18>	this  'for for'  loop is a 5.2 feature ?
T 1709387436 18<27Earnestly18>	for for in do; do echo "$for"; done
T 1709387440 18<27Earnestly18>	# for for in do; do echo "$for"; done
T 1709387442 18<25shbot18>	Earnestly: do
T 1709387452 18<27Earnestly18>	Somewhat self explanatory
T 1709387472 18<19zxd18>	ah
T 1709387491 18<27Earnestly18>	# set -- foo; for for do echo "$for"; done
T 1709387492 18<25shbot18>	Earnestly: foo
T 1709387524 18<27Earnestly18>	for xyz in "$@"; do <=> for xyz do
T 1709387564 18<27Earnestly18>	# help -s for
T 1709387565 18<25shbot18>	Earnestly: for: for NAME [in WORDS ... ] ; do COMMANDS; done
T 1709387773 18<28emanuele618>	51# for for do select select do case case in esac done done; echo :\)
T 1709387774 18<25shbot18>	emanuele6: bash: syntax error near unexpected token `done'
T 1709387777 18<28emanuele618>	51# for for do select select do case case in esac; done done; echo :\)
T 1709387779 18<25shbot18>	emanuele6: :)
T 1709387793 18<28emanuele618>	i think that was a bug
T 1709387856 18<28emanuele618>	need a semicolon before done at the end of a select command body
T 1709387916 18<19zxd18>	m# case { { ( { ) ( <<< :-\) cat ) }
T 1709387917 18<25shbot18>	zxd: :-)
T 1709387927 18<19zxd18>	what is it saying to the bot here what is 'm' ?
T 1709387990 18<28emanuele618>	yes, it looks like the select body was using the wrong type before bash 5.2
T 1709387998 18<28emanuele618>	zxd: it runs mksh instead of bash 5.2
T 1709388001 18<28emanuele618>	# triggers
T 1709388002 18<25shbot18>	emanuele6: Available triggers: +# bash-devel; 1# bash-1.14; 2# bash-2.05b; 32# bash-3.2; 3# bash-3.2; 42# bash-4.2; 43# bash-4.3; 44# bash-4.4; 4# bash-4.4; 50# bash-5.0; 51# bash-5.1; 52# bash-5.2; 5# bash-5.2; # bash-5.2; d# dash-0.5.9; sh# dash-0.5.9; k# ksh 93u+ 2012-08-01; m# mksh R59 2021/01/24; b# bourne; j# bourne(w/job);
T 1709388004 18<27Earnestly18>	# triggers
T 1709388005 18<25shbot18>	Earnestly: Available triggers: +# bash-devel; 1# bash-1.14; 2# bash-2.05b; 32# bash-3.2; 3# bash-3.2; 42# bash-4.2; 43# bash-4.3; 44# bash-4.4; 4# bash-4.4; 50# bash-5.0; 51# bash-5.1; 52# bash-5.2; 5# bash-5.2; # bash-5.2; d# dash-0.5.9; sh# dash-0.5.9; k# ksh 93u+ 2012-08-01; m# mksh R59 2021/01/24; b# bourne; j# bourne(w/job);
T 1709388017 18<28emanuele618>	# triggers
T 1709388018 18<25shbot18>	emanuele6: Available triggers: +# bash-devel; 1# bash-1.14; 2# bash-2.05b; 32# bash-3.2; 3# bash-3.2; 42# bash-4.2; 43# bash-4.3; 44# bash-4.4; 4# bash-4.4; 50# bash-5.0; 51# bash-5.1; 52# bash-5.2; 5# bash-5.2; # bash-5.2; d# dash-0.5.9; sh# dash-0.5.9; k# ksh 93u+ 2012-08-01; m# mksh R59 2021/01/24; b# bourne; j# bourne(w/job);
T 1709388026 18<28emanuele618>	there is no two without three :)
T 1709388058 18<25ormaaj18>	bot is mostly here for my entertainment
T 1709388098 18<28emanuele618>	checkbot: thank you for the entertainment
T 1709388098 18<28checkbot18>	emanuele6: You're welcome! \(=^.^= )/
T 1709388178 18<19zxd18>	checkbot-ai
T 1709388208 18<22militantorc18>	Is there a historical reason for the default of not including command invocations starting with spaces in the bash history?
T 1709388267 18<25ormaaj18>	nope. just a feature.
T 1709388268 18<28emanuele618>	default?
T 1709388273 18<28emanuele618>	that does not happen for me
T 1709388276 18<25ormaaj18>	not default
T 1709388279 18<25Lynx-18>	OK thanks Earnestly
T 1709388405 18<28emanuele618>	it seems you need to set   HISTCONTROL=ignorespace   or at least HISTCONTROL should contain ignorespace as one of its colon separated elements
T 1709388420 18<28emanuele618>	bash does not set it by default; i have it unset
T 1709388450 18<28emanuele618>	if you didn't set it yourself, it probably comes from the system's bash profile
T 1709388482 18<28emanuele618>	or system bashrc
T 1709388484 18<25ormaaj18>	It's supposedly there if you need to do something like type a raw password into a command
T 1709388506 18<25ormaaj18>	99% of the time if I type a password into the wrong place it's because the thing reading it was too slow
T 1709388515 18<28emanuele618>	i usually just copy it and use   "$(xclip -sel c -o)"
T 1709388548 18<22militantorc18>	emanuele6, seems default in my os
T 1709388556 18<28emanuele618>	which is?
T 1709388560 18<22militantorc18>	ubuntu
T 1709388612 18<22militantorc18>	energizer, do other distros don't enable it by default
T 1709388647 18<25ormaaj18>	I've never seen one
T 1709388720 18<22militantorc18>	i need to edit my histcontrol then
T 1709388777 18<25ormaaj18>	you also don't really need commands that start with spaces
T 1709388785 18<22militantorc18>	ormaaj, sometimes due to copy paste
T 1709388795 18<22militantorc18>	i make edits to the command
T 1709388807 18<28emanuele618>	i looked at the debian package for bash, and the default /etc/bash.bashrc /etc/profile don't set HISTCONTROL
T 1709388815 18<22militantorc18>	and then when i key up its not there
T 1709388818 18<22militantorc18>	a bit irritating
T 1709388833 18<22militantorc18>	emanuele6, then its ubuntu default
T 1709388835 18<28emanuele618>	oh, the skel for ~/.bashrc sets it
T 1709388840 18<28emanuele618>	https://sources.debian.org/src/bash/5.2.21-2/debian/skel.bashrc/
T 1709388851 18<22militantorc18>	either way, i changed the flag
T 1709388856 18<28emanuele618>	in your default ~/.bashrc you should have   HISTCONTROL=ignoreboth
T 1709388860 18<25ormaaj18>	I think it's literally only the first space of the command. Leading spaces for multi-line commands don't affect it, or I doubt they do anyway
T 1709388861 18<22militantorc18>	yeah
T 1709388863 18<22militantorc18>	thast wht i had
T 1709388863 18<28emanuele618>	in debian and ubuntu systems
T 1709388867 18<22militantorc18>	i changed to ignoredups
T 1709388883 18<28emanuele618>	but that is not default, it is just the default user configuration installed on debian ubuntu and family
T 1709389001 18<28emanuele618>	i guess it is default because the maintainers of the debian package for bash like ignorespace ¯\_(ツ)_/¯
T 1709389016 18<22militantorc18>	no big deal
T 1709389112 18<25ormaaj18>	is login really slow for anybody else or just me? :(
T 1709389125 18<25ormaaj18>	I have no clue why it takes like several seconds to show a prompt
T 1709389152 18<22militantorc18>	ormaaj, what hardwares
T 1709389154 18<22militantorc18>	and os
T 1709389164 18<24geirha18>	the worse configuration the debian package does is enabling the "source bashrc non-interactive if ssh" fuckery
T 1709389193 18<27Earnestly18>	arch does that as well, I imagine lots of distros copy debian
T 1709389218 18<25ormaaj18>	gentoo does it too. I'll probably file a bug. Just discovered it a few days ago
T 1709389246 18<25ormaaj18>	the bash package doesn't get much attention for some reason
T 1709389363 18<22militantorc18>	what shell does people use these days?
T 1709389389 18<19u0_a37218>	bash ig
T 1709389424 18<28emanuele618>	i use bash
T 1709389524 18<25ormaaj18>	bash is a bad habit
T 1709389566 18<28emanuele618>	bash is the best
T 1709389577 18<28emanuele618>	the bast
T 1709389767 18<25ormaaj18>	login hangs for several seconds on a poll syscall
T 1709389794 18<25ormaaj18>	twice... wtf is it reading
T 1709389980 18<25ormaaj18>	It's network crap. Probably some stupid PAM configuration.
T 1709390052 18<25ormaaj18>	definitely not a feature that I use
T 1709390523 18<25ormaaj18>	the problem is a function in /usr/lib64/libkrb5.so.3.3
T 1709390547 18<25ormaaj18>	yes definitely not thing I use
T 1709390615 18<28emanuele618>	it makes your os kerber
T 1709390805 18<25ormaaj18>	pambase has a kerberos switch. I shall flip it
T 1709390891 18<25ormaaj18>	it will probably complain about missing dependency next time I try to install samba though
T 1709391330 18<25ormaaj18>	Nope. None of this stuff needs that. Nice.
T 1709391405 18<28emanuele618>	my os is kerb enough
T 1709391630 18<25ormaaj18>	kerblesser
T 1709391901 18<28emanuele618>	krb5 is a dependency for mutt on archlinux
T 1709391927 18<25ormaaj18>	weird
T 1709391931 18<28emanuele618>	also openssh, curl, and a bunch of other libraries
T 1709391978 18<25ormaaj18>	yeah but pambase is just a pile of configuration files for pam. It doesn't actually provide anything.
T 1709392023 18<28emanuele618>	pambase is required by pam
T 1709392023 18<25ormaaj18>	you can have stuff installed linking against those libraries without a particular configuration
T 1709392040 18<28emanuele618>	and pam is required by everything basically
T 1709392054 18<25ormaaj18>	yes, but you don't have USE flags :P
T 1709392084 18<28emanuele618>	i cannot even tell archlinux; please build my programs without -fno-plt :(
T 1709392110 18<25ormaaj18>	tell them f-no!
T 1709392168 18<28qkzoo197818>	elif [ ans -eq 2 ]; exit 0   <-- what is wrong with that statement?
T 1709392185 18<25ormaaj18>	ans not a number
T 1709392210 18<25ormaaj18>	of course it doesn't -eq 2
T 1709392246 18<28emanuele618>	also probably missing then
T 1709392267 18<28emanuele618>	otherwise [] is just useless
T 1709392409 18<28qkzoo197818>	Ugh, ya, whoops. forgot the $ before the variable and the then
T 1709392442 18<25ormaaj18>	and quotes!
T 1709392543 18<25ormaaj18>	[[ $ans == 2 ]] is better.
T 1709392807 18<28qkzoo197818>	Good. Good. Thank you @emanuele6 and ormaaj
T 1709392871 18<25ormaaj18>	emanuele0-5 never answer
T 1709393196 18<28qkzoo197818>	Now, I have an : exit 1 which is supposed to completely exit the script, but it just exits the if/then/fi and continues on?
T 1709393214 18<25ormaaj18>	nope
T 1709393235 18<25ormaaj18>	exit exits immediately unless you've nerf'd it with a subshell
T 1709393258 18<28emanuele618>	never nerve an exit
T 1709393280 18<28qkzoo197818>	elif [ $ans == 2 ]; then exit 1; # Anything other than a zero will exit the script.
T 1709393314 18<28emanuele618>	zero?
T 1709393340 18<28emanuele618>	oh, you mean other than  exit 0
T 1709393340 18<25ormaaj18>	I guess they mean that status of test.
T 1709393352 18<28emanuele618>	yeah, so you are running exit in a subshell
T 1709393356 18<28emanuele618>	and you have set -e
T 1709393369 18<25ormaaj18>	ah set -e
T 1709393387 18<28qkzoo197818>	when did I start a subshell?
T 1709393401 18<25ormaaj18>	how would we know?
T 1709393410 18<28emanuele618>	it could be   var=$(myfunctionthatcallsexit)    or   foo | hereicallexit
T 1709393416 18<25ormaaj18>	show code or gtfo
T 1709393443 18<28emanuele618>	gtformaaj 🧀
T 1709393445 18<28qkzoo197818>	I guess I was asking what initiate a subshell,
T 1709393454 18<28emanuele618>	!subshell
T 1709393454 18<29greybot18>	http://mywiki.wooledge.org/SubShell
T 1709393455 18<25ormaaj18>	:)
T 1709393456 18<28qkzoo197818>	what would
T 1709393461 18<28qkzoo197818>	thx
T 1709393586 18<28qkzoo197818>	!subshell
T 1709393586 18<29greybot18>	http://mywiki.wooledge.org/SubShell
T 1709393593 18<28emanuele618>	!subshell
T 1709393593 18<29greybot18>	http://mywiki.wooledge.org/SubShell
T 1709393597 18<28emanuele618>	never two without three
T 1709393606 18<25ormaaj18>	!thanks
T 1709393606 18<29greybot18>	Don't thank me, I'm a bot. Did you mean to thank greycat?
T 1709393672 18<28emanuele618>	!pastebanquine
T 1709393673 18<29greybot18>	Paste is available without ads on https://pastebin.com/r​aw/r
T 1709393673 18<19pasteban18>	Paste is available without ads on https://pastebin.com/raw/r
T 1709393697 18<27userdocss18>	!thanks
T 1709393697 18<29greybot18>	Don't thank me, I'm a bot. Did you mean to thank greycat?
T 1709393702 18<28emanuele618>	!thanks
T 1709393702 18<29greybot18>	Don't thank me, I'm a bot. Did you mean to thank greycat?
T 1709393709 18<28emanuele618>	never two without three!
T 1709393752 18<27userdocss18>	are they getting pinged fromt that?
T 1709393776 18<28emanuele618>	greycat is not online
T 1709393798 18<28emanuele618>	he does not idle
T 1709394105 18<27userdocss18>	cats are know to lurk
T 1709394131 18<27userdocss18>	it's in their nature.
T 1709394911 18<28qkzoo197818>	Can someone explain what this means barny style for me: "$*" is the IFS expansion of all positional parameters, $1 $2 $3 ...
T 1709395164 18<28qkzoo197818>	input field seperator got it
T 1709395208 18<25ormaaj18>	!yw
T 1709395208 18<29greybot18>	You're welcome, human.
T 1709395385 18<24geirha18>	!$*
T 1709395385 18<29greybot18>	The difference between $@ and $*: "$@" (quoted) expands to each positional parameter as its own argument: "$1" "$2" ... while "$*" expands to the single argument "$1c$2c..." where c is the first character of IFS. You almost always want "$@". The same goes for arrays: "${array[@]}" or "${array[*]}". Unquoted $* and $@ are nonsense; DO NOT use
T 1709396137 18<28qkzoo197818>	!help
T 1709396137 18<29greybot18>	I can do: !faq {number|string}, !pf {number|string}, !learn key value, !meta key, !metaurl key, !forget key, !searchkeys string, !factstats, !faqstats, !faqpages, !date, !version. For help with Bash builtins, use "help command" in bash.
T 1709396148 18<28qkzoo197818>	awesome
T 1709396163 18<28qkzoo197818>	learned something new
T 1709396184 18<24geirha18>	!factstats
T 1709396184 18<29greybot18>	Top factoids: pe (3069), guide (2499), nabq (2253), ls (2247), find (2049), help (1837), quotes (1826), varcap (1521), umq (1422), pm (1421)
T 1709396732 18<28emanuele618>	!no
T 1709396732 18<29greybot18>	Don't make shit up
T 1709397127 18<27userdocss18>	!thanks
T 1709397127 18<29greybot18>	Don't thank me, I'm a bot. Did you mean to thank greycat?
T 1709397724 18<28qkzoo197818>	https://pastebin.com/CdnRsZBe <-- it keeps exiting without waiting for input, any advice on what I'm doing wrong?
T 1709397724 18<19pasteban18>	Paste is available without ads on https://pastebin.com/raw/CdnRsZBe
T 1709397725 18<28checkbot18>	qkzoo1978: I think the problem is on line 17. You need spaces around the comparison operator. See 6 issues on https://shellcheck.net/?id=cb97725
T 1709397872 18<24geirha18>	res=yes_no_abort just assigns a string to a variable. Your function is never run
T 1709398407 18<28qkzoo197818>	ok, bash is bizarre. I think I getit though
T 1709398581 18<28qkzoo197818>	Is there an alternative to: yes_no_abort; result=$?        ?
T 1709398592 18<28qkzoo197818>	or is that just how its done
T 1709398615 18<24geirha18>	res=$(yes_no_abort)
T 1709398623 18<28qkzoo197818>	sweet thx
T 1709398748 18<28qkzoo197818>	that seems to return all arguments, even invalid ones
T 1709398850 18<24geirha18>	Your function doesn't take any arguments. You're not making any sense
T 1709398920 18<24geirha18>	Also, make sure you fix the errors shellcheck pointed out. Your script won't work until you do
T 1709398987 18<28qkzoo197818>	yes, I added the -r.  It keeps saying line blah >  [: too many arguments for my if statements
T 1709399110 18<28qkzoo197818>	https://pastebin.com/CdnRsZBe
T 1709399110 18<19pasteban18>	Paste is available without ads on https://pastebin.com/raw/CdnRsZBe
T 1709399134 18<28qkzoo197818>	!checkbot
T 1709399134 18<29greybot18>	checkbot is an IRC frontend for !shellcheck. It responds to !check [url/snippet], and automatically to pastebin links with selected errors (/msg checkbot quiet).
T 1709399141 18<24geirha18>	# [ hi 0 == 0 ]
T 1709399143 18<25shbot18>	geirha: bash: [: too many arguments
T 1709399151 18<24geirha18>	yep, that would do it
T 1709399161 18<28qkzoo197818>	!check https://pastebin.com/CdnRsZBe
T 1709399162 18<19pasteban18>	Paste is available without ads on https://pastebin.com/raw/CdnRsZBe
T 1709399162 18<28checkbot18>	qkzoo1978: Line 18: Double quote to prevent globbing and word splitting. Line 19: Double quote to prevent globbing and word splitting. Line 20: Double quote to prevent globbing and word splitting. See https://shellcheck.net/?id=cb99162
T 1709399190 18<24geirha18>	remove the echo hi, or make it output to stderr instead of stdout
T 1709399196 18<24geirha18>	also fix the quoting
T 1709399245 18<24geirha18>	or better, switch to [[ ]] or case instead of [ ]
T 1709399313 18<28qkzoo197818>	I was going to do that, but it was bugging me that I couldn't figure out something seemingly simple!
T 1709399383 18<24geirha18>	in general it's not a good idea to guess on bash syntax. A lot of bad guesses will happen to be valid syntax, but do something very different than intended
T 1709399415 18<28qkzoo197818>	...just when I think I'm starting to get something....bash...
T 1709399469 18<24geirha18>	bash is 50 years of bad design decisions
T 1709399478 18<28qkzoo197818>	no kidding
T 1709399505 18<24geirha18>	extremely useful, but very easy to get wrong, and it doesn't help that
T 1709399507 18<24geirha18>	!crap
T 1709399507 18<29greybot18>	The overwhelming majority of bash scripts, code, tutorials, and guides on the Internet are crap. Sturgeon was an optimist.
T 1709399556 18<28qkzoo197818>	I should probably teach myself python or something, but at some point, you have to know bash for your python script
T 1709399607 18<24geirha18>	I recommdn you read throug the BashGuide, then peruse BashFAQ and BashPitfalls
T 1709399622 18<28qkzoo197818>	Will I fall asleep reading them
T 1709399625 18<28qkzoo197818>	?
T 1709399631 18<28qkzoo197818>	!bashguide
T 1709399631 18<29greybot18>	http://mywiki.wooledge.org/BashGuide or in PDF: http://s.ntnu.no/bashguide.pdf
T 1709399640 18<28qkzoo197818>	!bashpitfalls
T 1709399657 18<24geirha18>	!pf
T 1709399657 18<29greybot18>	geirha: No matches found at https://mywiki.wooledge.org/BashPitfalls
T 1709399667 18<26goodlings818>	!ls
T 1709399667 18<29greybot18>	DO NOT USE the output of ls in scripts. Its output format is neither portable nor reliable. Use globs instead. See https://mywiki.wooledge.org/ParsingLs
T 1709399682 18<26goodlings818>	!sh
T 1709399682 18<29greybot18>	sh is NOT bash; it is a POSIX shell. To run bash code, your script MUST use a bash shebang, and it MUST be executed directly or with bash (NOT sh myscript). Sometimes /bin/sh symlinks to bash, but you can't rely on this and it will disable many bash features. <http://mywiki.wooledge.org/BashGuide/Practices#Choose_Your_Shell>
T 1709399716 18<28qkzoo197818>	is sh better than bash?
T 1709399747 18<24geirha18>	No, sh is even more painful
T 1709399761 18<28qkzoo197818>	good to know.
T 1709399852 18<28qkzoo197818>	There. Both sites bookmarked.
T 1709400351 18<28qkzoo197818>	also bookmarked shellscript thing. that a new ai tool?
T 1709400405 18<24geirha18>	Just Haskell, not AI
T 1709400745 18<24geirha18>	Hard to spot with an untrained eye, but you can tell by shellcheck not being confidently incorrect like chatgpt
T 1709401247 18<25ormaaj18>	Are you sure? Completely!
T 1709401349 18<28qkzoo197818>	cool tool just the same. it just told me to add || or exit to all my "cd's" in my script
T 1709401360 18<28qkzoo197818>	err || exit
T 1709401411 18<24geirha18>	Yes, that's very important. Valve forgot to do that in their linux installer, which ended up with wiping a couple of unlucky people's homedirs
T 1709401420 18<24geirha18>	*linux installer for steam
T 1709401481 18<24Enissay18>	I am trying to parse a yaml with yq. Using `yq '.foo | keys'  config.yaml` it gives me a list of keys with dash before... I just want to raw key names so I can loop over...
T 1709401543 18<24geirha18>	Sounds like the go implementation of yq. I only really have experience with the saner python implementation
T 1709401604 18<24Enissay18>	There's another tool ? I am using it because it was the first to popup in search
T 1709401610 18<24geirha18>	anyway, try with '.foo | keys[]'
T 1709401635 18<24Enissay18>	geirha: sadly doesnt work, I tried already :x
T 1709401661 18<24Enissay18>	`Error: bad expression, please check expression syntax`
T 1709401684 18<20osse18>	Pipe it to map() or something like that, perhaps? Ie. do the looping within yq
T 1709401722 18<24geirha18>	that's why I don't like the go version. It doesn't use jq syntax
T 1709401823 18<24geirha18>	maybe it'll accept   '.foo | keys | .[]'  ?
T 1709401949 18<20osse18>	Seems to have a bunch of operators that work on keys, at least
T 1709401996 18<24geirha18>	With https://pypi.org/project/yq/    yq -r '.foo | keys[]'    works as expected since it actually uses jq syntax
T 1709402283 18<20osse18>	Doesn't it literally use jq itself undah da h00d?
T 1709402310 18<24geirha18>	Indeed
T 1709402315 18<22phogg18>	there's a version of yaml which is a superset of json, so it well might
T 1709402326 18<24geirha18>	that way you only need to learn one jq syntax, not several dialects
T 1709402351 18<24geirha18>	there's a version of yaml that ISN'T a superset of json?
T 1709402359 18<22phogg18>	yes, yaml v1
T 1709402548 19*	Now talking on 22#bash
T 1709402548 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709402548 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709402550 18<25Lynx-18>	is it obvious why this commit: https://github.com/lynxthecat/cake-autorate/compare/master...testing increases rather than decreases processing time?
T 1709402722 18<24geirha18>	757 line diff. Sorry, but not going to read through that
T 1709402735 18<22phogg18>	geirha: 1.2 support is still unfortunately uncommon. But one day you'll be able to switch between the two schemas in one file and gain the benefits of both.
T 1709403006 18<25Lynx-18>	geirha does this time -v comparison offer any insight? https://pastebin.com/raw/fNFR1qe6
T 1709403031 18<25Lynx-18>	the newer code has about double the numebr of "Voluntary context switches:"
T 1709403391 18<25Lynx-18>	does spreading computation out amongst different backgrounded processes somehow generally reasult in reduced computation?
T 1709403593 18<22phogg18>	no, just parallel
T 1709403635 18<25Lynx-18>	I
T 1709403695 18<25Lynx-18>	I just made a restructure of my bash program that shifted processing from what was previously backgrounded to main, which removed quite a bit of duplication in terms of writes/reads since it obviated having to pass processed data from the backgrounded process to main, but surprisingly it resulted in greater computation. Is there some sort of way I can profile and work out why?
T 1709403756 18<22phogg18>	"greater computation"? Is that more CPU cycles? More wall clock time?
T 1709403878 18<25Lynx-18>	phogg more CPU cycles - https://pastebin.com/raw/fNFR1qe6
T 1709451377 19*	Now talking on 22#bash
T 1709451377 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709451377 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709462396 18<29ZAJDAN18>	hi..I want to use variable during creation of directory in this way 'mkdir /here/daily_$myvar_backup' ..but when the variable is wrapped in underlines _ it does not works
T 1709462734 18<28emanuele618>	it should be   mkdir /here/daily_"$myvar"_backup
T 1709462871 18<29ZAJDAN18>	emanuele6: thank you...works
T 1709463833 18<27xx18>	cd / && find /var/lib/dpkg/info -name '*.md5sums' -exec md5sum --check --quiet {} +
T 1709463842 18<27xx18>	any way I can execute that without having to have the cd / part?
T 1709463870 18<24xmb18>	yes remove i4 its useless cmd
T 1709463892 18<24xmb18>	remove cd / && , for just the find cmd
T 1709463904 18<27xx18>	but then it doesn't work unless I am in /
T 1709463949 18<24xmb18>	it does , its cmd find at absolte path , oh wait ur md5sum smth
T 1709463967 18<27xx18>	the md5sums files don't contain absolute path, they contain relative paths to /
T 1709463977 18<24xmb18>	try -execpath , sec ..
T 1709463996 18<24xmb18>	sry u need else , min ..
T 1709464038 18<24xmb18>	xx , i ran find , it showed absolte paths to args
T 1709464061 18<24xmb18>	eg i tried find ../usr/bin it all showed ../usr/bin/ paths
T 1709464102 18<24xmb18>	there is a -exexdir opt to exec in same dir as found
T 1709464116 18<27xx18>	well it doesn't work, so I'll rephrase my question - can I make `find` switch to some different $PWD ?
T 1709464150 18<27xx18>	I guess I can make it all run in a subshell so that I don't need to cd back
T 1709464159 18<24xmb18>	thats simple ye
T 1709464208 18<24xmb18>	( cd && find )
T 1709464288 18<26lopid18>	what you mean is "i want find's files output prefix to be …"?
T 1709464313 18<24xmb18>	=)
T 1709464321 18<26lopid18>	not "how can i run this without doing that"?
T 1709464380 18<22phogg18>	xx: you could cd beore each invocation of md5sum instead, but it's strictly better to change before running find. A subshell works, but you could also pushd && find && popd
T 1709464427 18<27xx18>	yeah a subshell it is then, thanks
T 1709464485 18<24xmb18>	fs question , if id chmod a-rwx / , are /home users blocked or smth ?
T 1709464504 18<22phogg18>	sm1999: you will break your system very badly, don't do that
T 1709464512 18<22phogg18>	er, xmb I mean, sorry
T 1709464519 18<22phogg18>	weirdest failed tab complete
T 1709464526 18<24xmb18>	yea thats why i ask
T 1709464570 18<24xmb18>	i look from security against hacks point
T 1709464590 18<22phogg18>	xmb: your question seems to imply that it will specifically break access to home dirs for users. I will do a lot worse than tha.
T 1709464628 18<24xmb18>	yea i ask , if itd break /home users
T 1709464635 18<22phogg18>	xmb: no, it will not do that
T 1709464642 18<22phogg18>	xmb: it will break E V E R Y T H I N G
T 1709464657 18<24xmb18>	i got a good idea , i try on windows wsl debian , safe thing to re-install
T 1709464671 18<24xmb18>	ok everything , ...
T 1709464686 18<24xmb18>	very good , =p ill have to try
T 1709464703 18<22phogg18>	there's no point in even trying it. You are removing x from directories for root, so even root can't traverse them. You are removing x on all files even for root, so even root can't execute any processes
T 1709464724 18<24xmb18>	i dont think root will fail
T 1709464728 18<24xmb18>	or would it
T 1709464732 18<22phogg18>	of course it would
T 1709464743 18<24xmb18>	hm then cant do ye
T 1709464780 18<24xmb18>	oh removing x makes bins break
T 1709464785 18<24xmb18>	thxx++ mate
T 1709464800 18<22phogg18>	This is a Whole Hawg situation. Welcome to Unix, safety is not guaranteed.
T 1709464814 18<22phogg18>	s/Whole/Hole/
T 1709464835 18<24xmb18>	common with todays world , not guaranteed whats asked for ,  =)
T 1709464911 18<22phogg18>	no, it will do exactly what you asked for
T 1709464916 18<22phogg18>	maybe not what you *wanted*
T 1709464953 18<24xmb18>	ah ye similiar case , my english is only basic
T 1709464990 18<24xmb18>	but , i actually asked for a-rwx , .. i didnt plan on changing u or g
T 1709465001 18<24xmb18>	so root may still work ?
T 1709465284 18<24xmb18>	oh a = all and e i meant everyone else .. ?
T 1709465297 18<24xmb18>	uge oe uga
T 1709465368 18<24xmb18>	or* sry
T 1709465470 18<24xmb18>	u root wrx g root same , .. wont work ?
T 1709466580 18<25ormaaj18>	directory perms don't affect being able to execute things. It'll break your PATH lookups.
T 1709467343 18<28emanuele618>	ormaaj: well, not if you are root, but as a regular user if you don't have x permissions on a directory you won't be able do anything with the files in that directory or its subdirectories; you will only be able to see the file names of the files in the directory if you also have r permissions
T 1709467930 18<22militantorc18>	i like when you have x but no r
T 1709467942 18<22militantorc18>	seen in some androids
T 1709470563 18<22phogg18>	xmb: yes, a is all. What did you mean? I presume you meant o, for "other" aka world permission. If you do chmod -R o-rwx / the system probably won't entire;y break, but you will probably mess up permissions on /tmp
T 1709471768 18<24xmb18>	phogg , i meant u and g root normal , only the third field there -rwx , and only on / , no subs
T 1709478191 18<25kurahaupo18>	phogg: why suggest pushd / && find … && popd when that's less reliable than ( cd / && exec find … )
T 1709478377 18<25kurahaupo18>	(both popd and cd - can fail in various ways; the simplest is "permission denied"
T 1709478382 18<25kurahaupo18>	)
T 1709523463 19*	Now talking on 22#bash
T 1709523463 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709523463 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709523580 19*	Now talking on 22#bash
T 1709523580 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709523580 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709526741 18<22loganlee18>	hello. `find / -maxdepth 3 \( -path /dev -o -path /run -o -path /tmp -o -path /home/lost+found -o -path /root -o -path /lost+found -o -path /boot/efi \) -prune -o -type f -user logan -group logan -iname 'todo.sh' -print` here why is \( ... \) -prune -o ... and not \( ... \) -prune -a ...?
T 1709527084 18<27larryv18>	if it were -a then you would be telling find to print paths that satisfy every condition listed, which is not possible.
T 1709527356 18<22loganlee18>	larryv, if i change to \( ... \) -prune -a ... it gives not results
T 1709527363 18<22loganlee18>	no results*
T 1709527381 18<27larryv18>	yeah. as i just said, the resulting condition is impossible to satisfy.
T 1709527414 18<22loganlee18>	yep i think exclusion condition -o inclusion condition is valid but not exclusion condition -a inclusion condition?
T 1709527449 18<27larryv18>	i won't confirm such an overbroad statement.
T 1709527455 18<27larryv18>	just look at what you'd be asking
T 1709527464 18<27larryv18>	a path cannot both be e.g., /dev AND have a name todo.sh
T 1709527524 18<22loganlee18>	yep
T 1709527591 18<22loganlee18>	thanks a lot
T 1709527608 18<27larryv18>	mhm
T 1709527707 18<22loganlee18>	i'll ask again later after some further study. thanks a lot larryv
T 1709527717 18<27larryv18>	np
T 1709527725 18<22pj18>	If you read the find docs the example given for -prune explicitly uses -o
T 1709527733 18<22tirnanog18>	https://pubs.opengroup.org/onlinepubs/9699919799/utilities/find.html
T 1709527739 18<22tirnanog18>	it shall always evaluate as true.
T 1709527747 18<22loganlee18>	ok
T 1709527890 18<22pj18>	well, since -prune always returns true then one would think it shouldn't matter if the condition is -a or -o, but since the docs say to use -o I would just use that and not worry about it.
T 1709527962 18<22tirnanog18>	that's precisely why it matters.
T 1709527980 18<22pj18>	oh I think I get it
T 1709527982 18<27larryv18>	it matters because with -a and -print at the end, all the primaries have to be true simultaneously to ever print anything
T 1709527983 18<22tirnanog18>	upon -prune being reached and its effect applied, that which follows must surely be an alternative.
T 1709527995 18<22tirnanog18>	it does more than just be true, after all.
T 1709527997 18<22pj18>	if the preceding conditions return false then it short-circuits the -prune.
T 1709528019 18<22tirnanog18>	yes. all primaries are joined by an implicit -a where neither -a nor -o is given.
T 1709528054 18<22pj18>	so prune may return true, but only if it reaches -prune.
T 1709528072 18<22tirnanog18>	yes.
T 1709528074 18<22pj18>	which it won't if the -path conditions aren't satisfied.
T 1709528128 18<22pj18>	loganlee: does this help? ^^^^^^
T 1709528199 18<22loganlee18>	pj, i'm a little tired today. i'll have a look at it later. :D
T 1709536002 18<27chomwitt18>	Why a glob's wild chars can not match a '/' but using globbing in other commands , like for example in debian's dpgk-query --search' can ?
T 1709536549 18<20bent_fingers18>	loganlee: i used to think the same thing.
T 1709536600 18<28emanuele618>	then you tried drinking coffee and now you are not tired anymore
T 1709536617 18<27larryv18>	chomwitt: what dpkg-query does is not globbing
T 1709536641 18<24ano18>	there is no such a thing as glob(bing) std/spec, glob(bing) mostly mean https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_13 but it can be anything
T 1709536670 18<28emanuele618>	cool link
T 1709536687 18<27larryv18>	chomwitt: you're really comparing filename generation/expansion to pattern matching. the former has extra restrictions over general pattern matching
T 1709536694 18<27chomwitt18>	larryv: so dpkg-query doesnt it's own expansion ?
T 1709536704 18<27chomwitt18>	/s/doesnt/does
T 1709536712 18<27larryv18>	chomwitt: it's not doing filename expansion at all
T 1709536744 18<27larryv18>	not as understood in the shell language, at any rate
T 1709536780 18<28emanuele618>	* ? [] does not match / mostly because the glob is compared against a file name, not an entire path; however if you use the glob patter in case  case $var in *a*) ;; esac   or [[ $var == *a* ]]   then * will be able to match /
T 1709536830 18<27chomwitt18>	larryv: so dpkg-query does on its own a search on the space of all installed files and the similarity to unix shell glob is that is using glob like wildchars ?
T 1709536855 18<27larryv18>	more or less
T 1709536884 18<27larryv18>	like emanuele6 just said, even the shell itself uses patterns in slightly different ways
T 1709537012 18<27chomwitt18>	emanuele6: so that is like having relative meaning according to the context used . Is that behavior documented somewhere ?
T 1709537037 18<27larryv18>	https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_13_03
T 1709537070 18<28emanuele618>	you don't even have to think of it as working differently in different context; the glob pattern is matches against the file name which will not contain a /
T 1709537167 18<27larryv18>	yeah but there's also other stuff like initial '.' having to be matched explicitly
T 1709537187 18<28emanuele618>	also that  *  cannot match an empty string when the entire glob is *
T 1709537201 18<28emanuele618>	e.g.  /usr/bin/*/bash    cannot match /usr/bin//bash
T 1709537243 18<28emanuele618>	because it actually compares * against the file names of the files in /usr/bin/ which will not contain any file with a empty name, because those cannot exist
T 1709537283 18*	27chomwitt thanks for the clarification , insights and the opengroup link larryv and emmanuelux
T 1709537341 18<28emanuele618>	thank you for thanking emmanuelux, i always think they are underappreciated
T 1709537359 18<27colo18>	:D
T 1709537376 18<27larryv18>	is that your evil twin
T 1709537388 18<27colo18>	or maybe the good twin?
T 1709537393 18<27larryv18>	:O
T 1709537412 18<28emanuele618>	maybe; i had a vanishing twin, maybe that is where it has gone :o
T 1709537541 18<27chomwitt18>	emanuele6: sorry!
T 1709537578 18*	27chomwitt thanks emanuele6 .
T 1709537629 18<24ano18>	does anyone use less as pager at daily basis? looks like lesspipe.sh and gentoo builtin lessopen are awful
T 1709537947 18<20bent_fingers18>	ano: everyone uses less
T 1709538051 18<20cappy18>	bent_fingers: less is more but cat is a bat with wings and it flies circles around less, at least for this guy.
T 1709538079 18<20bent_fingers18>	chomwitt: please consider the plight of he who serves you https://www.givesendgo.com/GBH2M
T 1709538152 18<20bent_fingers18>	ano: you can fix that, and yes, it's awful
T 1709538160 18<24ano18>	fat bat
T 1709538199 18<20cappy18>	s/bat is a cat.../
T 1709538270 18<28emanuele618>	bats are not flying felines; that is a common misconception
T 1709538404 18<20cappy18>	emanuele6: Yes, truly. But seriously, I've found the bat(1) pager far superior with its language syntax highlighting.
T 1709538506 18<20bent_fingers18>	i'm colorblind. doesn't matter to me
T 1709538551 18<20cappy18>	Perhaps ano is not?
T 1709538569 18<20bent_fingers18>	i open my texts with less, press f, and i'm good
T 1709538578 18<20bent_fingers18>	sometimes i press /
T 1709538608 18<20bent_fingers18>	not much else to it really
T 1709538660 18<28emanuele618>	i use the occasional ?
T 1709538663 18<20bent_fingers18>	cappy: perhaps he's eyeless?
T 1709538687 18<28emanuele618>	either that or bat eyesight
T 1709538698 18<20cappy18>	That could make for difficult debugging of a missing quote here and there.
T 1709538905 18<20cappy18>	bat automatically pipes its output through a pager (by default: less).  So the foundation remains viable.
T 1709538940 18<28emanuele618>	how much does it cost?
T 1709538962 18<20bent_fingers18>	were any bats harmed in it's making?
T 1709538962 18<20cappy18>	It's in the debian repo.
T 1709538999 18<28emanuele618>	oh, i don't use debian
T 1709539002 18<20cappy18>	DEB package bat-musl
T 1709539048 18<20cappy18>	emanuele6: https://github.com/sharkdp/bat
T 1709539051 18<20bent_fingers18>	sounds like a lot of piping when you use bat
T 1709539068 18<20bent_fingers18>	he can't access that
T 1709539085 18<20bent_fingers18>	cappy: consider helping  https://www.givesendgo.com/GBH2M
T 1709539094 18<28emanuele618>	wow advertisements in the readme file :o
T 1709539104 18<24ano18>	bat will cost ~3MB of rusty bloatness
T 1709539117 18<28emanuele618>	ano: how much does that cost?
T 1709539127 18<28emanuele618>	i heard rust is free
T 1709539160 18<20bent_fingers18>	could be
T 1709539174 18<28emanuele618>	rust removal however... quite expensive
T 1709539175 18<20bent_fingers18>	some things are free out there, after all
T 1709539217 18<28emanuele618>	i installed bat
T 1709539228 18<28emanuele618>	and printed out a .bat file with it
T 1709539237 18<28emanuele618>	fancy colours
T 1709539268 18<28emanuele618>	it is using a salmon colour to highlight "echo"
T 1709539296 18<19sphertext18>	does any body have a suggestion for a good sed tutorial?
T 1709539297 18<24ano18>	think free as in "free coc", not "free memory"
T 1709539311 18<20bent_fingers18>	atlantic pink salmon, to be precise
T 1709539318 18<20cappy18>	emanuele6: try --list-themes and --list-colors
T 1709539323 18<28emanuele618>	highlight -Oansi uses the regular green colour, not special truecolour
T 1709539335 18<20cappy18>	sorry --list-languages
T 1709539354 18<20bent_fingers18>	sphertext: the one in the title of #sed
T 1709539362 18<28emanuele618>	hmm. i ran  --list-themes  and it dumped a bunch of text; not what i would expect from a pager
T 1709539384 18<28emanuele618>	unbuffer bat --list-themes | less -R   to the rescue...
T 1709539410 18<28emanuele618>	needed to unbuffer, or bat --list-themes just outputs the theme names separated by newline
T 1709539420 18<20bent_fingers18>	this is nerve wracking
T 1709539421 18<20cappy18>	Ha. bat --list-themes | bat
T 1709539425 18<19sphertext18>	bent_fingers oh hmm.. i had that saved in my bookmarks, don't remember where i got it from. i was going to use it, but i checked the one about find on the same website and it didn't seem very comprehensive. so i assumed the sed one maybe isn't either
T 1709539432 18<28emanuele618>	cappy...
T 1709539440 18<28emanuele618>	why are you being so mean? D:
T 1709539447 18<28emanuele618>	with the wrong suggestions D:
T 1709539463 18<20cappy18>	Not mean at all.
T 1709539463 18<28emanuele618>	i just told you that will list only the theme names
T 1709539472 18<20bent_fingers18>	will emanuele6 like the app or not? we're sitting on our seats biting our nails in anticipation of the oucome
T 1709539472 18<24ano18>	sphertext: chk #sed /topic
T 1709539482 18<19sphertext18>	ano i just replied to that
T 1709539500 18<19sphertext18>	i guess if multiple ppl say it's good i should check it
T 1709539507 18<28emanuele618>	also even if you use   unbuffer bat --list-themes | bat    that messes up the colours because it re-highlights the text
T 1709539526 18<28emanuele618>	unbuffer bat --list-themes | less -R   is just better to see look at the themes
T 1709539594 18<20cappy18>	emanuele6: Yeah, hadn't tried that. But the language list is extensive and works well for bash.
T 1709539603 18<20bent_fingers18>	ano: i told him that already. you can't snatch my kudos from me
T 1709539611 18<28emanuele618>	mean suggestion :(
T 1709539628 18<20bent_fingers18>	i need 997 more kudos to gain immunity from channel banning
T 1709539630 18<28emanuele618>	there is an  ansi  theme to use standard colours instead of truecolors
T 1709539712 18<28emanuele618>	bat --theme=ansi foo.bat   now echo is purple :o
T 1709539722 18<28emanuele618>	err, magenta
T 1709539731 18<28emanuele618>	the same colours as cappy's nickname in weechat :D
T 1709539763 18<20bent_fingers18>	sphertext: multiple people also believed influenza wsa influenced by the stars
T 1709539811 18<20bent_fingers18>	but i wouldn't recommend communing with them in hopes of alleviating any future illness that unhappily visits upon you
T 1709539814 18<19sphertext18>	my 16 ansi theme in my terminal is 15 shades of grey + one shade of red
T 1709539825 18<28emanuele618>	ew
T 1709539860 18<19sphertext18>	i find that collapsing the dimensionality of visual design spares my cognitive resources which are limited
T 1709539875 18<28emanuele618>	wow, upgrade your brain?
T 1709539888 18<28emanuele618>	lol
T 1709539907 18<20bent_fingers18>	mine is black, white, red, and blue for the 16
T 1709539911 18<28emanuele618>	doesn't that just make colours harder to differenciate?
T 1709539928 18<19sphertext18>	https://0x0.st/HdcG.png
T 1709539932 18<28emanuele618>	s/differenciate/differentiate/ i know how to spell
T 1709539952 18<28emanuele618>	sphertext: i don't even know how many colours you are showing
T 1709539953 18<19sphertext18>	no, i find it's actually sufficient
T 1709539963 18<19sphertext18>	15 colors
T 1709539973 18<19sphertext18>	the red is omitted and left as an exercise of imagination for the beholder
T 1709539975 18<28emanuele618>	you didn't reduce the number of colours, you just made them harder to differenciate
T 1709539996 18<19sphertext18>	no, i reduced the dimensionality of visual information
T 1709540002 18<28emanuele618>	there are clearly different shades, there; but i cannot easily tell if shades that are far apart are different or not
T 1709540015 18<19sphertext18>	i can tell the shades apart, easily
T 1709540036 18<28emanuele618>	wow
T 1709540040 18<28emanuele618>	impressive
T 1709540075 18<19sphertext18>	when there's information across the hue dimension as well, i find it distracting
T 1709540078 18<20bent_fingers18>	and yet we still are left on edge over the verdict of whether or not bat wins approval
T 1709540087 18<19sphertext18>	i need more mental effort to process it
T 1709540121 18<28emanuele618>	with that colour palette for sure
T 1709540126 18<19sphertext18>	which leaves means mental energy for other things
T 1709540134 18<19sphertext18>	* less
T 1709540136 18<20bent_fingers18>	you can see color but choose not to do so?
T 1709540137 18<28emanuele618>	lol
T 1709540141 18<20bent_fingers18>	what in the world?
T 1709540175 18<19sphertext18>	hue is a redundant dimensions of visual representation
T 1709540221 18<20bent_fingers18>	i agree
T 1709540236 18<20bent_fingers18>	we should all have surgery and become monochromatics
T 1709540247 18<19sphertext18>	i still use 1 shade of red
T 1709540253 18<20bent_fingers18>	black & white forever!
T 1709540254 18<19sphertext18>	it's the only one that has a semantic justification
T 1709540311 18<20bent_fingers18>	when i have a child, if he or she or whatever can see color, i'm dropping it off at the fire station
T 1709540355 18<19sphertext18>	my desktop wallpaper is pitch black
T 1709540366 18<20bent_fingers18>	my child can only see black and white, damn the reduntant dimensions! damn them all!
T 1709540368 18<19sphertext18>	like the abyss of existence
T 1709540499 18<28emanuele618>	my desktop wallpaper is https://commons.wikimedia.org/wiki/File:Cow_Moos_-_geograph.org.uk_-_1885583.jpg
T 1709540514 18<19sphertext18>	exhausting
T 1709540535 18<20bent_fingers18>	pastroal
T 1709540539 18<20bent_fingers18>	pastoral
T 1709540542 18<20bent_fingers18>	idyllic
T 1709540563 18<19sphertext18>	anyway i'm not a psycho, i actually run this in a window constantly on one of my screens https://www.youtube.com/watch?v=VZUkuY3oo2k
T 1709540564 18<20bent_fingers18>	Van Goph would have been proud
T 1709540664 18<20bent_fingers18>	sphertext: i'm not convinced
T 1709540722 18<19sphertext18>	i wrote a bash script that starts that video every day. i'm vaguely using it to regulate my circadian rhythm
T 1709541295 18<26razamatan18>	an encrypted loopback file mounting bash alias (on smartos [illumos]) used to work fine to have a nested command that prompted for a decrypting password, but oddly, something changed that it no longer blocks for user input for the password
T 1709541317 18<26razamatan18>	would this be bash or the password prompting command?
T 1709541696 18<24geirha18>	a bit odd to pack that much logic into an alias. I would use a function. Anyway, no generic answer to your question. It depends on what exactly it runs, and in what context
T 1709541715 18<26razamatan18>	are you familiar w/ the lofiadm command in solaris?
T 1709541769 18<26razamatan18>	it's really not that bad.. the alias is just: mount $(lofiadm -c aes-256-cbc -a /path/to/enc/file) /mnt/path
T 1709541827 18<24geirha18>	if lofiadm uses the tty on stdin to read password, that should work. I'd add the missing quotes though
T 1709541831 18<26razamatan18>	the lofiadm returns the /dev/ path to the loopback device holding the unencrypted file handle after getting the password to unlock
T 1709541850 18<26razamatan18>	(i have the quotes, i just retyped from memory)
T 1709541926 18<26razamatan18>	the odd thing is, it works fine if i reorder the commands (and explicitly set the /dev device path which makes the whole thing a bit more brittle: lofiadm -c aes-256-cbc -a /path/to/en/file /dev/lofi/2 && mount /dev/lofi/2 /mnt/path
T 1709541984 18<26razamatan18>	again, the original version used to work fine prior to doing a system upgrade (so it's hard to tell what is causing issues)
T 1709542471 18<24geirha18>	See what it shows when you enable xtrace (set -x):  (set -x ; youralias)
T 1709542567 18<24geirha18>	oh and, if you run the same  lofiadm command as you do inside the command subsittution, it still asks for password? (i.e. without specifying the lofi dev)
T 1709542590 18<26razamatan18>	it correctly does the nested lofiadm as the first command, and does the bad behavior of asking for the password 4 times without actually blocking for the read
T 1709542627 18<26razamatan18>	the behavior is that it just keeps prompting the full retry count (i think 4 based on what i'm seeing) and failing
T 1709542677 18<24geirha18>	printf '<%s>\n' "$(read -rp "type something: " var && printf %s "$var")
T 1709542683 18<24geirha18>	does that one wait for input?
T 1709542719 18<26razamatan18>	should i just cut and paste that in a live prompt, or put that in an alias?
T 1709542750 18<24geirha18>	alias shouldn't really affect it, but try both just to be sure
T 1709542789 18<24geirha18>	oh and it's missing the closing " at the very end there
T 1709542793 18<24geirha18>	printf '<%s>\n' "$(read -rp "type something: " var && printf %s "$var")"
T 1709542816 18<26razamatan18>	i had to switch it up to: printf '<%s>\n' "$(read -rp 'type something: ' var && printf %s \$var)"
T 1709542822 18<26razamatan18>	and it did prompt correctly
T 1709542912 18<26razamatan18>	https://github.com/illumos/illumos-gate/tree/b70bf3ee79d81df3ccc36e553e0ff11049a2b51a/usr/src/cmd/lofiadm
T 1709542925 18<24geirha18>	well, sounds like lofiadm is the one that has changed behavior somehow. It should definitely have the same ability as that read to read from the tty
T 1709542937 18<26razamatan18>	ok.. :/
T 1709542944 18<26razamatan18>	i'll follow up w/ the illumos folks
T 1709543126 18<26razamatan18>	geirha: thanks..
T 1709543174 18<27Soliton18>	having to change that code seems suspicious...
T 1709546167 18<19Clocked18>	Hi! When I need the last 3 parts of this-is-a-sting-where-I-need-to-get-1-2-3 should I do this with 3 times ${string##*:-} and glue it back together or use cut/awk/or so ?
T 1709546219 18<20osse18>	Clocked: is the part you want always numbers and the rest never numbers?
T 1709546243 18<19Clocked18>	osse nope otherwise it would have been easy indeed
T 1709546316 18<27Soliton18>	# string=this-is-a-sting-where-I-need-to-get-1-2-3; echo "${string#"${string%-*-*-*}"-}"
T 1709546319 18<25shbot18>	Soliton: 1-2-3
T 1709546352 18<19Clocked18>	oh yeah in this case that would be possible!
T 1709546372 18<19Clocked18>	I thought such inner was never possible
T 1709546756 18<27Earnestly18>	Clocked: It is in the parameter section of parameter expansion, but not in the expansion part
T 1709546788 18<19Clocked18>	indeed!
T 1709547501 18<24xmb18>	# s() { for s ; do printf %s\\t "${s#${s%%+(-+([0-9]))}-}" ; done ; } ; s a-b-c-1-2-3-4 1-d-e-8-2 a-8-b-9-7
T 1709547503 18<25shbot18>	xmb: 1-2-3-4 8-2     9-7
T 1709547702 18<19Clocked18>	nice!
T 1709547759 18<19mawk18>	what's the command from detaching a background job?
T 1709547764 18<19mawk18>	I have a void
T 1709547796 18<27Soliton18>	perhaps you mean disown.
T 1709547804 18<19mawk18>	aaaaaa disown yes
T 1709547805 18<19mawk18>	thanks
T 1709547879 18<19mawk18>	^Z; bg; disown
T 1709547891 18<19mawk18>	it doesn't work on all programs though for some reason
T 1709547895 18<19mawk18>	I guess it's when they mess up the terminal
T 1709547961 18<19mawk18>	and we can always stop them from another terminal, as SIGSTOP cannot be caught
T 1709555614 18<24RhineDevil18>	I need to define a config file containing a structure for "objects" whose data I'll dispatch in multiple associative arrays. In order to do so I'd like to use a proper config file format, easy to edit and that also can refer to some internal variables defined by the script. What could I do?
T 1709555679 18<28emanuele618>	dconf
T 1709555778 18<29fb`18>	redirecting a long running stdout through a fifo to netcat. need it to not block script execution. script eventually blocks on a full output buffer
T 1709556022 18<27Soliton18>	perhaps you can ask your os for a bigger pipe size.
T 1709556037 18<25ormaaj18>	prod the reader and tell it to get busy. Either don't let it fill or don't write to a pipe
T 1709556065 18<25ormaaj18>	Or use nonblocking or polled i/o which shell doesn't really support.
T 1709556209 18<29fb`18>	stdbuf has not helped. script is designed to be unattended, as in a reader may or may not connect to drain the buffer
T 1709556238 18<27Soliton18>	how is that design supposed to work in practice?
T 1709556263 18<27colo18>	"named pipes considered footguns"
T 1709556366 18<29fb`18>	in practice the output can top out around 1MB. script blocks around 132K which has been an issue
T 1709556401 18<27Soliton18>	# cat /proc/sys/fs/pipe-max-size
T 1709556403 18<25shbot18>	Soliton: 1048576
T 1709556437 18<27Soliton18>	sounds like you should ask your os for a bigger pipe.
T 1709556460 18<27Soliton18>	you could also use pv -B as an additional buffer.
T 1709556586 18<29fb`18>	tried pv, still blocks ~132K. pipe-max-size is ~1MB
T 1709556667 18<27Soliton18>	so set your pipe to that size.
T 1709556759 18<27colo18>	what exactly causes the nc process involved not to send off the data to its TCP peer?
T 1709556788 18<29fb`18>	environment is limited doesn't have perl, for example to run fcntl
T 1709556834 18<29fb`18>	a tcp peer may not connect, it's an optional output
T 1709556994 18<29fb`18>	considering a watchdog to detect blocking. it would connect a local dummy peer to and flush the buffer
T 1709557324 18<24RhineDevil18>	emanuele6: I'd prefer a config file format parsable by native bash
T 1709557362 18<24RhineDevil18>	Or by standard tools
T 1709557480 18<28emanuele618>	as opposed to foreign bash
T 1709557512 18<29fb`18>	RhineDevil a config file formatted like a shell script with simple key-value variables wouldn't work? values could be post-processed with cli tools
T 1709559527 18<24RhineDevil18>	fb`: That was my initial idea, but if it's a standard format even better
T 1709559622 18<24RhineDevil18>	In general I'd want either a standard format or something easily parseable for my objective (organized key/value pairs representing fictional objects), with preference for standard format
T 1709559634 18<29fb`18>	maybe xml, yaml, or json then? a tool like this can read/write: https://github.com/mikefarah/yq
T 1709559748 18<24geirha18>	A better yq implementation at   https://github.com/kislyuk/yq
T 1709559982 18<24RhineDevil18>	fb`: As said before I'd use these formats only if they're parseable from bash and standard tools
T 1709560026 18<24RhineDevil18>	Since I'm making a tool that should be generally usable as long you have bash and basic tools like jq I don't wanna request weird dependencies users will have problems in installing
T 1709560066 18<29fb`18>	standard tools defined as.. what your package manager can installer? basic posix commands?
T 1709560075 18<29fb`18>	*install
T 1709560085 18<24RhineDevil18>	basic posix commands
T 1709560100 18<24RhineDevil18>	As now requested dependencies are aapt find gawk sed jq zstd grep
T 1709560110 18<24geirha18>	jq is certainly not posix
T 1709560113 18<24geirha18>	nor gawk or zstd
T 1709560142 18<24RhineDevil18>	They're generally available also originally it wasn't my work
T 1709560150 18<27Soliton18>	but since you apparently already use jq what is even the question...
T 1709560177 18<24RhineDevil18>	Soliton: would be a mess writing a config file for all packages in json...
T 1709560183 18<24RhineDevil18>	Imagine mantaining the package list
T 1709560207 18<24RhineDevil18>	I mean there's a reason why people use stuff like toml and yaml instead of json
T 1709560214 18<20osse18>	how about using bash syntax for the file? read the file by sourcing it and update it by declare -p
T 1709560219 18<27Soliton18>	but you don't want to...
T 1709560220 18<29fb`18>	uhm, tell nodejs devs that
T 1709560291 18<24RhineDevil18>	osse: I remember I've read in this chat a better solution that did exactly this but with parsing instead of sourcing
T 1709560365 18<24RhineDevil18>	fb`: I use javascript only cause I'm forced by circumstances and I think the world would be better if it wasn't invented
T 1709560431 18<29fb`18>	fair enough. so you prefer bash instead?
T 1709560452 18<24RhineDevil18>	No
T 1709560468 18<24RhineDevil18>	Or I mean
T 1709560472 18<24RhineDevil18>	Depends on the task
T 1709560570 18<24RhineDevil18>	So anyway, approved solution is bash-like config file. But wasn't there a way for including just variables instead of code?
T 1709565207 18<24OnlineCop18>	Within a local git repo, I'm usually okay doing `grep 'PATTERN' $(git ls-files)` to limit my searches to only checked-in files, except in a few cases where those files contain spaces or special characters. Do I have to modify IFS, or assign all $(git ls-files) results to an array, in order to do something like this, or is there an alternate command/method I could use?
T 1709565244 18<28emanuele618>	hmm, git grep
T 1709565288 18<27Soliton18>	yeah, use git grep. your current approach is broken and cannot be fixed.
T 1709565317 18<24OnlineCop18>	I just thought of `git grep` after I wrote that... that may be what I'll end up doing. :) Thanks, both.
T 1709565329 18<28selckin18>	git ls-files -oc --exclude-standard | ack -x
T 1709565350 18<22ash_worksi18>	sometimes I want to write a blob of crap to sed or awk. I use heredocs for this, but it pollutes the command history; so I thought of just using stdin, (eg `awk '1' -`) but the result will interweave lines because it doesn't wait for me to finish (eg with ^D)
T 1709565401 18<22ash_worksi18>	is there a way to get a program to wait for my to finish? ... like what happens when you do `foo="$(cat)"`
T 1709565592 18<22ash_worksi18>	I guess `echo "$(cat)" | awk`
T 1709565593 18<27JanC18>	'sponge' from moreutils ?
T 1709565598 18<25greycat18>	if you simply do    foo; bar   bar won't run until foo exits
T 1709565623 18<22ash_worksi18>	oh
T 1709565695 18<27JanC18>	https://manpages.org/sponge
T 1709565719 18<25greycat18>	I would avoid sponge.  It's not safe (data can be lost).
T 1709565793 18<25greycat18>	!sponge
T 1709565793 18<29greybot18>	sponge() ( tmp=$(mktemp) && cat > "$tmp" && cat -- "$tmp" > "$1" && rm -- "$tmp"; ) # read and write the same file in a pipeline: grep -v '^#' file | sponge file
T 1709565867 18<27JanC18>	lost in what way?
T 1709565875 18<22ash_worksi18>	greycat: hmm. in `awk; echo`, awk waits, but it still processes each line after hitting enter so you get an AA'BB' effect if you write lines interactively
T 1709565920 18<26KillerWasp18>	JanC: maybe he want write a big documentation and don't exist Ctrl+S
T 1709565932 18<25greycat18>	People usually want to do something like the man page's example (sed '...' file | grep '...' | sponge [-a] file) but this will truncate the file before writing to it.  If the system crashes during that write, the original data's gone.
T 1709565959 18<27JanC18>	for anything that isn't throwaway you would just use a real file, no?
T 1709565985 18<25greycat18>	You want to write to a new/temp file and only replace the original once the writing is done.
T 1709566001 18<25greycat18>	ash_worksi: I have no idea what you're doing.
T 1709566006 18<27JanC18>	this would be writing to stdout
T 1709566014 18<27JanC18>	not a file
T 1709566030 18<27JanC18>	if I undestand ash_worksi correctly
T 1709566045 18<26KillerWasp18>	sponge() ( cat > "$1.temp" && cat -- "$1.temp" > "$1" && rm -- "$1.temp"; )
T 1709566086 18<26KillerWasp18>	now is more secure, not Ctrl+S, it's always saved.
T 1709566150 18<22ash_worksi18>	JanC: that is correct and the input is not a file, it just my fingers... or pasting
T 1709566185 18<27JanC18>	but ash_worksi wants something like: sponge | grep foo
T 1709566212 18<22ash_worksi18>	In this particular case, I wanted to add few lines of spacing to my paste.
T 1709566213 18<27JanC18>	well, with sed or awk instead of grep  :)
T 1709566235 18<25greycat18>	I can't tell what they want at all.  Is it something like "I type a command and it takes a while to run, which catches me by surprise, because I'm already typing the next command, and now the output of the first command and my typing of the second command are all jumbled"?
T 1709566297 18<27JanC18>	yes, that's what ash_worksi mentioned: "but the result will interweave lines because it doesn't wait for me to finish"
T 1709566322 18<27JanC18>	they mean "interweave input & output", I suppose
T 1709566341 18<25greycat18>	you think they're running an *interactive* command?
T 1709566346 18<27JanC18>	yes
T 1709566355 18<22ash_worksi18>	yes to all of that
T 1709566371 18<27JanC18>	based on "but it pollutes the command history"
T 1709566384 18<25greycat18>	... I'm totally lost.
T 1709566388 18<27Soliton18>	you could disable the terminal echo.
T 1709566389 18<27JanC18>	that would not happen in a script...
T 1709566413 18<27JanC18>	they want to see input & output, I'm sure
T 1709566594 18<27JanC18>	ash_worksi: when this is just text from the "clipboard" (without manual editing & where you don't need to see the source), another option might be to use a utility that reads data directly from there instead of pasting it...
T 1709566741 18<22ash_worksi18>	JanC: the copied source is an interactive docker container that doesn't have access to the awk script; I could add it, but it's torn down frequently enough to be a nusance and infrequent enough not to added it to a new image
T 1709566811 18<27Soliton18>	pretty sure they mean  xclip | awk  or similar.
T 1709566850 18<22ash_worksi18>	oh
T 1709566935 18<22ash_worksi18>	I'm surprised greycat gave me the time of day on that question. I figured they'd think, "whatever they're trying to do is too stupid for me to engage"
T 1709566974 18<22ash_worksi18>	they must be in a pretty generous mood.
T 1709567156 18<27JanC18>	xclip only works for X11, on wayland you'd need wl-paste or something like that I think
T 1709567210 18<27JanC18>	or an appropriate clipboard tool for whatever else your system uses  :)
T 1709567666 18<22ash_worksi18>	thanks for the help, and also interpretation JanC
T 1709569849 18<24RhineDevil18>	Do I remember uncorrectly or there was a placeholder technique for config files where you placed a placeholder and then you could substitute it with a variable before echoing it?
T 1709569859 18<24RhineDevil18>	Without sourcing of course
T 1709569878 18<27Soliton18>	!template
T 1709569878 18<29greybot18>	http://mywiki.wooledge.org/TemplateFiles
T 1709570019 18<27Soliton18>	if you're blindly injecting into shell code that is not a good idea of course.
T 1709570613 18<22ash_worksi18>	RhineDevil: nginx containers use `envsubst`
T 1709570663 18<22ash_worksi18>	I just realized that's on that page Soliton linked anyway
T 1709573310 18<29luva18>	Hello, I want to write a bash script that does a backup. In that bash script, I want to just for every DNS lookup use a specific nameserver, since it needs to use a private one, without setting one in the OS. Can someone help me on how to do it?
T 1709573501 18<27Soliton18>	sounds like you need to check the documentation of the tool that does the lookup on how to specify the server.
T 1709573586 18<29luva18>	well I cant change the host OS Soliton
T 1709573601 18<29luva18>	host DNS*
T 1709573640 18<26lopid18>	`man dig`
T 1709576816 18<25greycat18>	luva: some DNS lookup programs have a way to specify a server; some do not.  Find one that does, that you can use, and then do whatever it takes to specify the server.  E.g. with dig, you use @ip.add.res.ss.  With some others it'll be a mandatory or optional argument.
T 1709579605 18<20bent_fingers18>	Grymoires sed tutorial shows this example: sed s/day/night/ <old >new
T 1709579627 18<20bent_fingers18>	And says for unix beginners to try this one: sed s/day/night/ old >new
T 1709579642 18<20bent_fingers18>	Why the second for beginners?
T 1709579666 18<25greycat18>	Most likely they're trying to get you to think about those two commands, and understand how they differ, if at all.
T 1709579733 18<25greycat18>	It's equivalent to comparing   cat file1   and  cat <file1
T 1709579836 18<28emanuele618>	meow
T 1709580059 18<19Liver_K18>	Is there any difference between ${name:-} and ${name}?
T 1709580072 18<25greycat18>	probably when set -u is in effect
T 1709580078 18<29phy172918>	If set -u explodes
T 1709580264 18<20bent_fingers18>	one has sed read from stdin, the other from an argument/positional parameter
T 1709580303 18<20bent_fingers18>	What difference does it make?
T 1709580432 18<29phy172918>	If it's seekable, what error messages say, where in the command it can go
T 1709580434 18<20bent_fingers18>	I suppose it has something to do with bragging rights
T 1709580530 18<20bent_fingers18>	Seekable? Never heard of it. Must be why I don't have any pull requests to respond to
T 1709580557 18<25greycat18>	I don't think sed cares about seekability, but other commands might.
T 1709580576 18<29phy172918>	iirc diff generally does
T 1709580598 18<25greycat18>	diff <() <() works, though
T 1709580624 18<29phy172918>	Does it? I though I had to use diff =() =()   (zshism)
T 1709580640 18<29phy172918>	Maybe GNU diff is fancier
T 1709580699 18<20bent_fingers18>	Join us in GNU. We enjoy awkard acronyms.
T 1709620790 19*	Now talking on 22#bash
T 1709620790 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709620790 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709636674 18<26dionys18>	[_]ↄ ... cheers
T 1709637169 18<19Artfaith18>	c[▅]
T 1709637347 18<28emanuele618>	!pizza
T 1709637438 18<24ano18>	!gastritis
T 1709643423 18<29nvz18>	heh
T 1709643452 18*	29nvz looks that up
T 1709643552 18<29nvz18>	na.. not gastritis.. but I do seem to have somethin goin on
T 1709643734 18<24ruvik18>	Hello guys
T 1709643758 18<29nvz18>	no guys here.. just us chickens
T 1709643795 18<29nvz18>	right scooby?
T 1709644023 18<28emanuele618>	https://www.youtube.com/watch?v=miomuSGoPzI
T 1709645315 18<24depesz18>	hi. given such input (array of strings): ns=( "m 1" "m 2" "s 1" "b 1" ) - what would be the sanest way to get number of elements that start with "m " ?
T 1709645328 18<24depesz18>	I can grep|wc -l, but it doesn't look sane.
T 1709645487 18<19Artfaith18>	depesz, do you want with loop or not?
T 1709645509 18<24depesz18>	ideally simple one-liner. but I'll take anything.
T 1709645526 18<24depesz18>	currently my "best" approach is: printf '%s\n' "${ns[@]}" | grep -c "^m "
T 1709645560 18<24depesz18>	only one execve, and no interpreted loops. but i somehow feel that there should be better way…
T 1709645857 18<19Artfaith18>	# declare ns=( "m 1" "m 2" "s 1" "b 1" ); declare el r=(); for el in "${ns[@]}"; do if [[ "$el" =~ ^m ]]; then r+=( "${el//[A-Za-z +]/}" ); fi; done; declare -p -- r;
T 1709645860 18<25shbot18>	Artfaith: declare -a r=([0]="1" [1]="2")
T 1709645860 18<27Soliton18>	unless you have loop phobia you'd just loop over the element and count.
T 1709645945 18<19Artfaith18>	`+` in the regex is redundant though.
T 1709645946 18<27Soliton18>	that grep approach only works if the elements contain no newline, btw.
T 1709645969 18<24depesz18>	they don't. the original value comes from mapfile-t
T 1709646025 18<27Soliton18>	you can use mapfile to handle NUL delimited input.
T 1709646031 18<24depesz18>	sorry, not sure what the r+= does. you are extracting some value form the ns elements? sorry. it was meant to *count* the elements, not check their "appendages" :)
T 1709646041 18<24depesz18>	Soliton: i know, but not in this case :)
T 1709646050 18<24geirha18>	you could do a while read loop instead of mapfile and do the count at the same time
T 1709646064 18<27Soliton18>	# ns=( "m 1" "m 2" "s 1" "b 1" ); for n in "${ns[@]}"; do [[ $n = m\ * ]] && count=$((count + 1)); done; echo "$count"
T 1709646066 18<25shbot18>	Soliton: 2
T 1709646075 18<24depesz18>	i could, but then I would have to rebuild the array anyway, as it is needed in array form later on.
T 1709646098 18<24geirha18>	count in addition to populating the array ...
T 1709646107 18<24depesz18>	Soliton: any reason to not use (( count++ )) ?
T 1709646123 18<27Soliton18>	not really.
T 1709646176 18<24geirha18>	while IFS= read -r line ; do ns+=( "$line" ) ; [[ $line = m\ * ]] && (( mcount++ )) ; done
T 1709646268 18<24depesz18>	yeah. that looks ok.
T 1709646276 18<24depesz18>	not sure why IFS=, though
T 1709646297 18<24geirha18>	without it it will trim leading and trailing whitespace
T 1709646323 18<28emanuele618>	the BEST way is    IFS= eval printf -v _ '"${arr[*]/*/%c}%n"' '"${arr[@]%%[!m]*}"' mcount    there is no competition
T 1709646347 18<19Artfaith18>	The best they may not understand.
T 1709646364 18<19Artfaith18>	The above will allow to move on, and get into this part later.
T 1709646387 18<19Artfaith18>	Though, I see "EVAL"!
T 1709646394 18<19Artfaith18>	Eval is Evil!
T 1709646443 18<19Artfaith18>	Even if we know that Bash being REPL is eval itself ^^"
T 1709646673 18<28emanuele618>	hmm, something is wrong
T 1709646708 18<28emanuele618>	# arr=( mauris cursus mattis molestie a. elementum eu facilisis sed odio morbi quis commodo odio aenean. sociis natoque penatibus et magnis dis parturient. fermentum odio eu feugiat pretium nibh. eu sem integer vitae justo eget magna fermentum. ); (IFS= eval set -x\; printf -v m '"${arr[*]/*/%c}%n"' '"${arr[@]%%[!m]*}"' mcount)
T 1709646709 18<25shbot18>	emanuele6: ++ printf -v m %c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%n m '' m m '' '' '' '' '' '' m '' '' '' '' '' '' '' '' m '' '' '' '' '' '' '' '' '' '' '' '' '' '' m '' mcount
T 1709646714 18<28emanuele618>	that looks correct, but
T 1709646730 18<28emanuele618>	# arr=( mauris cursus mattis molestie a. elementum eu facilisis sed odio morbi quis commodo odio aenean. sociis natoque penatibus et magnis dis parturient. fermentum odio eu feugiat pretium nibh. eu sem integer vitae justo eget magna fermentum. ); IFS= eval printf -v m '"${arr[*]/*/%c}%n"' '"${arr[@]%%[!m]*}"' mcount;  declare -p m mcount
T 1709646732 18<25shbot18>	emanuele6: declare -- m="m"
T 1709646732 18<25shbot18>	emanuele6: declare -- mcount="36"
T 1709646741 18<28emanuele618>	m only contains one m, and mcount in 36
T 1709646759 18<19Artfaith18>	depesz, the `+=` adds to the array.
T 1709646768 18<19Artfaith18>	++ adds to the integer.
T 1709646789 18<28emanuele618>	# arr=( mauris cursus mattis molestie a. elementum eu facilisis sed odio morbi quis commodo odio aenean. sociis natoque penatibus et magnis dis parturient. fermentum odio eu feugiat pretium nibh. eu sem integer vitae justo eget magna fermentum. ); IFS= eval printf -v m '"${arr[*]/*/%.1s}%n"' '"${arr[@]%%[!m]*}"' mcount;  declare -p m mcount
T 1709646790 18<25shbot18>	emanuele6: declare -- m="mmmmmm"
T 1709646790 18<25shbot18>	emanuele6: declare -- mcount="6"
T 1709646834 18<19Artfaith18>	As in the most languages.
T 1709646837 18<28emanuele618>	i think that is just a bug in bash; with printf's %c specifier and %n; it always assumes %c prints a byte even when it does not
T 1709646853 18<28emanuele618>	%.1s works correctly
T 1709646879 18<28emanuele618>	i am not sure why m is set to m when using -v m and %c, but that is probably also a bug
T 1709646896 18<28emanuele618>	%c ''  messes up some internal count
T 1709647046 18<28emanuele618>	# arr=( mauris cursus mattis molestie a. elementum eu facilisis sed odio morbi quis commodo odio aenean. sociis natoque penatibus et magnis dis parturient. fermentum odio eu feugiat pretium nibh. eu sem integer vitae justo eget magna fermentum. ); IFS= eval printf '"${arr[*]/*/%c}%n"' '"${arr[@]%%[!m]*}"' mcount;  declare -p mcount
T 1709647047 18<25shbot18>	emanuele6: mmmmmmdeclare -- mcount="36"
T 1709647053 18<28emanuele618>	without -v the output is correct
T 1709647060 18<28emanuele618>	but mcount is still wrong
T 1709647198 18<24ano18>	what does "${!var[@]*}" mean?
T 1709647205 18<28emanuele618>	# dash -c 'printf %c ""' | od -An -tc
T 1709647207 18<25shbot18>	emanuele6:   \0
T 1709647209 18<28emanuele618>	# ksh -c 'printf %c ""' | od -An -tc
T 1709647211 18<25shbot18>	emanuele6:   \0
T 1709647217 18<28emanuele618>	# printf %c '' | od -An -tc
T 1709647219 18<25shbot18>	emanuele6:   \0
T 1709647219 18<28emanuele618>	wow
T 1709647240 18<28emanuele618>	so %c ''  prints a NUL, it is not the same as %.1s :o
T 1709647245 18<28emanuele618>	i didn't know that
T 1709647251 18<28emanuele618>	printf %c in sh truly sucks
T 1709647272 18<28emanuele618>	ano: it expands to the variable names that start with "var"
T 1709647320 18<24ano18>	# var2=var1; var1=var2; printf {%s} "${!var[@]*}"
T 1709647320 18<28emanuele618>	oh, i misread that as ${!var@} sorry
T 1709647322 18<25shbot18>	ano: {}
T 1709647336 18<28emanuele618>	there var is an array
T 1709647342 18<28emanuele618>	it concatenates the values of var by space
T 1709647364 18<28emanuele618>	# var=(var) var1= var2=; printf {%s} "${!var[@]*}"
T 1709647366 18<25shbot18>	emanuele6: {}
T 1709647372 18<28emanuele618>	then i am not sure what it does
T 1709647380 18<28emanuele618>	# var=(var) var1= var2=; printf {%s} "${!var[1]*}"
T 1709647382 18<25shbot18>	emanuele6: {}
T 1709647394 18<28emanuele618>	i don't know; maybe it is not even that
T 1709647417 18<28emanuele618>	maybe it is trying to expand to variables that start with var[@] that cannot exist
T 1709647491 18<28emanuele618>	yes, that is what it does
T 1709647493 18<27Soliton18>	given that it only works with @ or * appended i'd guess it is a parser quirk because of the variable name prefix matching.
T 1709647725 18<28emanuele618>	i guess you can use it to write inline comments :)
T 1709647755 18<28emanuele618>	$ ./bash -c 'var=(var) var1= var2=; printf {%s}\\n "${!var[1]*}"'
T 1709647757 18<28emanuele618>	emanuele6debug: all_variables_matching_prefix("var[1]") was called.
T 1709647759 18<28emanuele618>	{}
T 1709647769 18<28emanuele618>	so yeah, that is what it is doing; confirmed
T 1709647800 18<28emanuele618>	# echo hi ${!a[@]i am a comment he he he he*} hello
T 1709647802 18<25shbot18>	emanuele6: hi hello
T 1709647858 18<28emanuele618>	!learn %c #redirect printf%c
T 1709647858 18<29greybot18>	OK, emanuele6
T 1709648143 18<28emanuele618>	!learn printf%c The `%c' format specifier in sh's printf does not print the character of the ASCII code corresponding to its number argument as it does for other languages' printf; it takes a string argument, and prints its first byte; it is similar to `%.1s', except that if the argument is an empty string, it will print a NUL character (\0) instead of printing nothing.
T 1709648143 18<29greybot18>	OK, emanuele6
T 1709648147 18<28emanuele618>	>:(
T 1709648404 18<28emanuele618>	(POSIX) The argument to the c conversion specifier can be a string containing zero or more bytes. If it contains one or more bytes, the first byte shall be written and any additional bytes shall be ignored. If the argument is an empty string, it is unspecified whether nothing is written or a null byte is written.
T 1709648549 18<28emanuele618>	!forget printf%c
T 1709648550 18<29greybot18>	OK, emanuele6
T 1709648620 18<28emanuele618>	!learn printf%c The %c format specifier in sh's printf does not print the character of the ASCII code corresponding to its number argument as it does for other languages' printf; it takes a string argument, and prints its first byte; it is similar to %.1s, except that its behaviour is unspecified if the argument is an empty string (in bash, it prints a NUL character instead of printing nothing.)
T 1709648620 18<29greybot18>	OK, emanuele6
T 1709648629 18<28emanuele618>	so printf %c in sh sucks even more
T 1709648652 18<28emanuele618>	at least you can use it in bash as a golfed   printf \\0 :   printf %c   is one byte shorter
T 1709652139 18<24depesz18>	this is *not* bash question, but you are smart, maybe you will be able to help - on one machine `man grep` (or other man pages) doesn't show colors. I checked, and both this box, and another (that does show color) have the same pager, pager options, and LESS_TERMCAP_.. env variables.
T 1709652195 18<24depesz18>	https://dpaste.org/aftGn
T 1709652229 18<26lopid18>	have you tried #linux?
T 1709652238 18<24depesz18>	i didn't. thanks.
T 1709652436 18<27Soliton18>	see what  tput colors  outputs.
T 1709652559 18<24depesz18>	256 in both cases.
T 1709653855 18<27Earnestly18>	https://github.com/landley/toybox/commit/a2419ad52d489bf1a84a9f3aa73afb351642c765
T 1709654248 18<28emanuele618>	https
T 1709655547 18<24depesz18>	solved. in case you'd stumble upon it - it seems to be broken by groff 1.23. fix is to either "export MANROFFOPT=-c" or "export GROFF_NO_SGR=1"
T 1709656200 18<27Earnestly18>	depesz: Is the goal to disable colours?
T 1709656211 18<24depesz18>	Earnestly: enable them. they got disabled by groff upgrade
T 1709656246 18<27Earnestly18>	depesz: I have 1.23 and -c is to "start with color output disabled"
T 1709656260 18<24depesz18>	Earnestly: where do you see that ?
T 1709656265 18<27Earnestly18>	In the manual
T 1709656270 18<24depesz18>	manual to what?
T 1709656285 18<24depesz18>	please note that -c is *not* option to man
T 1709656289 18<27Earnestly18>	depesz: groff, but it appears to be related to grotty
T 1709656294 18<27Earnestly18>	-c     Use grotty's legacy output format (see subsection “Legacy output format” above).  SGR and OSC escape sequences are not emitted.
T 1709656307 18<24depesz18>	exactly. it changes how color is outputted.
T 1709656307 18<27Earnestly18>	This also appears to exclude them
T 1709656312 18<24depesz18>	not for me.
T 1709656321 18<27Earnestly18>	depesz: Is this on a linux tty?
T 1709656324 18<24depesz18>	for me setting either of these things, or both of them, brings back color to manpages
T 1709656337 18<24depesz18>	linux, yes, in various terminal emulators.
T 1709656386 18<27Earnestly18>	NO_SGR: If set, grotty's legacy output format is used just as if the -c option were specified; see subsection “Legacy output format” above.
T 1709656482 18<24depesz18>	not sure what that has to do with it. are you saying that what I said is not true? well, it seems to be rather obscure, but known, bug: https://unix.stackexchange.com/a/771560/70436
T 1709656496 18<27Earnestly18>	depesz: Yeah it appears specific to SGR sequences, so bold and underline, etc. works but obviously it's expecting something different for colour
T 1709656564 18<27Earnestly18>	I wonder if there's a new way
T 1709656691 18<24depesz18>	if you'll find another, i'll gladly read about it.
T 1709656709 18<24depesz18>	you will need to find computer with broken man/groff/less/term* first, though :)
T 1709656979 18<27Earnestly18>	depesz: Seems like they just removed sgr (the command specifically) but provide it via -c and NO_SGR, but it's not very clear
T 1709657002 18<27Earnestly18>	provide "it", not being the command but "remain supported"
T 1709657032 18<27Earnestly18>	depesz: It seems a bit odd that "NO"_SGR would enable SGR
T 1709658822 19*	Now talking on 22#bash
T 1709658822 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709658822 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709658916 18<22FakuVe18>	I am changing it to plaintext
T 1709658923 18<22FakuVe18>	But actually it should be the same
T 1709658928 18<22FakuVe18>	You are right
T 1709658937 18<22FakuVe18>	no need to pass it to plaintext
T 1709659069 18<22FakuVe18>	it is taking ages though
T 1709659075 18<22FakuVe18>	Maybe my potato computer
T 1709659079 18<27Earnestly18>	FakuVe: Yeah it would
T 1709659085 18<22FakuVe18>	Also that is operating in an sdcard
T 1709659091 18<22FakuVe18>	:D
T 1709659123 18<27Earnestly18>	FakuVe: A nested for-loop like this is alone O^2 (quadratic), but that's probably unavoidable. But you're also forking quite a lot of stuff in this fairly fast, nested, loop
T 1709659126 18<22FakuVe18>	definitely rsync is not written this way "D
T 1709659147 18<27Earnestly18>	FakuVe: Here's a basic rewrite: https://0x0.st/H7pJ.txt (find of -maxdepth 1 means you probably want a for loop)
T 1709659162 18<27Earnestly18>	FakuVe: Sorry, <= should be > 1
T 1709659180 18<27Earnestly18>	Although that doesn't really need to exist
T 1709659206 18<27Earnestly18>	Because if the array has 1 element, then your file = fileb will always succeed
T 1709659240 18<27Earnestly18>	FakuVe: Instead of forking pup for *every* fileb and file comparison, you can fork it once for just file and then only fork pup for fileb
T 1709659305 18<22FakuVe18>	Thats looking nice
T 1709659311 18<27Earnestly18>	FakuVe: Another way to do this, which is what I'd do, is generate a list of all files and their titles. Then sort that list and extracting the duplicates
T 1709659318 18<22FakuVe18>	does pup work without quoting
T 1709659343 18<27Earnestly18>	FakuVe: What do you mean?
T 1709659351 18<27Earnestly18>	For the .css-selector?
T 1709659403 18<27Earnestly18>	You only need to quote if there's something that would undergo glob file expansions, quoting is used to suppress the meaning the shell gives to strings. If there's no shell specific syntax then there's no need to quote
T 1709659414 18<27Earnestly18>	literal quoting anyway
T 1709659426 18<22FakuVe18>	yeah let me try yours
T 1709659460 18<27Earnestly18>	FakuVe: You also don't need -name '*' that's the default behaviour
T 1709659462 18<22FakuVe18>	Mine may be the worse algorythm ever. It took 10 mins to find the second ocurrence
T 1709659474 18<22FakuVe18>	alright
T 1709659553 18<27Earnestly18>	FakuVe: It's mostly bad because of the amount of forking you do which is particularly slow. Yes it's also quadratic but unless you have thousands of files that shouldn't be very noticible
T 1709659591 18<22FakuVe18>	I think its also my computer
T 1709659600 18<22FakuVe18>	But yours didnt give any output
T 1709659767 18<22FakuVe18>	yeah if files > 1  , instead
T 1709659774 18<22FakuVe18>	instead of <= 1
T 1709659861 18<27Earnestly18>	FakuVe: Yeah I suggested that correction earlier
T 1709659911 18<27Earnestly18>	FakuVe: The other problem is you call pup on fileb way more times than necessary
T 1709660072 18<22FakuVe18>	it has got an issue
T 1709660078 18<22FakuVe18>	once it removes a file
T 1709660100 18<22FakuVe18>	It will iterate through that file afterwards  , and will have a warning of file doesnt exists
T 1709660107 18<22FakuVe18>	it doesnt matter though
T 1709660137 18<27Earnestly18>	If you have files a b c, then looping a a b c, b a b c, c a b c will call pup on a b c 3 times more than necessary. Also as your loops are complete file lists, removing one file will fail when it attempts to access it if it already existed in the for loop's "list"
T 1709660175 18<22FakuVe18>	yeah , whatever
T 1709660183 18<22FakuVe18>	It works , thats ok for me
T 1709660189 18<22FakuVe18>	good to learn how to do it properly
T 1709660197 18<22FakuVe18>	And I appreciate so much your help
T 1709660209 18<22FakuVe18>	For this case is more than fine Earnestly thank you
T 1709660277 18<25Lynx-18>	Can anyone advise on an especially CPU-friendly way to prepend a word to line outputs of a binary file and pass the result onto a FIFO without buffering more than each line?
T 1709660332 18<25Lynx-18>	right now I simply do while read line; printf term line >; done, but I'm hoping there is a way to avoid the byte-by-byte read penalty that that incurs
T 1709660558 18<25Lynx-18>	And bonus would be to use bash builtins
T 1709660561 18<22FakuVe18>	it was the sd card , I used it in my internal memory and like 8 times faster at least
T 1709660574 18<20twkm18>	i'd likely use awk or sed, along with unbuffer.
T 1709660601 18<22FakuVe18>	Yeah cheers
T 1709660677 18<22FakuVe18>	I am going for a run will check this back , cheers all
T 1709660759 18<25Lynx-18>	twkm thanks. Is the only way in bash to just use a byte-by-byte read? No clever trick to avoid that?
T 1709660778 18<27Earnestly18>	FakuVe: Consider: https://0x0.st/H7pk.txt
T 1709661070 18<27Earnestly18>	FakuVe: Or https://0x0.st/H7pF.txt
T 1709661143 18<27Earnestly18>	Lynx-: read will read(2) one byte at a time if the input is a pipe. It buffers if the input is a file. Bash's read has -N if you want to do buffered reads yourself
T 1709661238 18<27Earnestly18>	Lynx-: Which then means you'll need to pay careful attention to the exit status of read as to whether the buffer was filled, wasn't filled or was a read error or read timeout.
T 1709661365 18<25Lynx-18>	Earnestly thanks. Is the output from binaries like ping typically such that it outputs line by line such that if you read -t 0 the exit status will show you data is available after complete line has been written?
T 1709661404 18<27Earnestly18>	Lynx-: I would use awk
T 1709661468 18<27Earnestly18>	Don't try to do read -t 0 hacks for this, and no. As I write, read -N lets you do buffered reads, but like C, you just have to manage the input, i.e. detecting record separation and building variables until you do
T 1709661930 19*	Now talking on 22#bash
T 1709661930 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709661930 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709662197 18<25Lynx-18>	Earnestly once the data has been read in with say -N 512, what's the most efficient way to split up the lines without byte-by-byte read then at that point? So far I have this: https://pastebin.com/raw/Y7gwst09
T 1709662265 18<25Lynx-18>	echo $line shows indeed how you get the nice 512 bytes at a time, but then I'm wondering how to avoid then having to end up reading every character to work out the positions of the new lines.
T 1709662373 18<25Lynx-18>	ultimately I'd like to just print out the complete lines as they are completed, without requiring a byte-by-byte read on the read-in 512 byte chunks, if this is at all possible
T 1709662538 18<25Lynx-18>	ah, I can just printf "${line}" .. I see.
T 1709662604 18<25Lynx-18>	intereting - strace shows: "read(10, "64 bytes from localhost (::1): i"..., 155) = 64" reads
T 1709662636 18<25Lynx-18>	do I read that correctly that when -N 512 is specified it is resulting in 64 byte reads?
T 1709662685 18<25Lynx-18>	here is the strace: https://pastebin.com/raw/eUbcRhyJ
T 1709667679 19*	Now talking on 22#bash
T 1709667679 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709667679 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709674382 19*	Now talking on 22#bash
T 1709674382 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709674382 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709675352 18<22FakuVe18>	Earnestly: those two lastones work fast , but they do delete all files
T 1709675354 18<22FakuVe18>	https://0x0.st/H7pF.txt
T 1709675519 18<25Lynx-18>	So -N 512 results in several read calls like: <<<read(10, "64 bytes from localhost (::1): i"..., 475) = 64>>> - what governs the number 64?
T 1709675595 18<25greycat18>	That's how many you got.  I'm more curious about the 475, which is how many were requested.
T 1709675857 18<28emanuele618>	ping outputs a line every few seconds; so that already read 37 bytes from the previous line (or lines), and only requests 475 this time
T 1709675897 18<28emanuele618>	with -N512, read won't return until bash has put 512 characters on the variable, or EOF is reached, so it just keeps collecting
T 1709675917 18<25greycat18>	yeah, makes sense if they didn't show us the first line
T 1709675923 18<25Lynx-18>	so the chunk size of collection is dictated by the manner in which the binary outputs the chunks?
T 1709675944 18<25greycat18>	64 is how many bytes you *actually got*.  It's how many were *there*.
T 1709675957 18<25Lynx-18>	greycat here: https://pastebin.com/raw/eUbcRhyJ
T 1709676051 18<25Lynx-18>	isn't it 64 read and 475 of the 512 remaining
T 1709676053 18<24Nintendo18>	Bitching about jq a few weeks ago paid off, because today I used “// empty”, and it made me happy.
T 1709676067 18<25Lynx-18>	you see the number decreasing with each line
T 1709676108 18<25Lynx-18>	and then: rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0; rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
T 1709676233 18<28nphard18>	what's the difference between alteranet uses of '>'?
T 1709676242 18<28nphard18>	cut file > nu_file
T 1709676260 18<28nphard18>	cut -f1 < file > nu_file
T 1709676264 18<28nphard18>	both do the same
T 1709676283 18<28nphard18>	even the difference between 'cut -f1 file' and cut -f1 < file'
T 1709676308 18<28emanuele618>	if file is -,  cut -f1 -  reads from stdin; while  cut -f1 < -  reads from a file named - in the current directory
T 1709676333 18<25greycat18>	In the last line, the first command, cut opens the file itself, and therefore it knows the file name and can report it in error messages and so on.  In the second command, bash opens the file and cut only receives the already-opened file descriptor.
T 1709676466 18<25greycat18>	In the redirection command, if the file *can't* be opened, cut never even gets executed.  Bash tries to open it, fails, gives an error message, and never calls cut.
T 1709676476 18<28nphard18>	the next logical question begged is: which one is better?
T 1709676486 18<25Lynx-18>	what's the most efficient way to split up a string including newline characters into an array with elements having those separate lines from string? Is there a way to do that without byte-by-byte read?
T 1709676498 18<25greycat18>	Lynx-: mapfile / readarray
T 1709676521 18<25Lynx-18>	ah, yes
T 1709676919 18<27xx18>	# echo abc `#def` ghi
T 1709676921 18<25shbot18>	xx: abc ghi
T 1709676931 18<27xx18>	# echo abc "$(#def)" ghi
T 1709676938 18<25shbot18>	xx: Missing terminating quote, bracket or keyword
T 1709676944 18<27xx18>	why?
T 1709677009 18<20arraybolt318>	# echo abc \"\$(#def)\" ghi
T 1709677011 18<25shbot18>	arraybolt3: bash: syntax error near unexpected token `('
T 1709677055 18<27xx18>	# echo abc "$(\#def)" ghi
T 1709677055 18<25shbot18>	xx: no output
T 1709677649 18<27larryv18>	xx: the parser probably closes ` by simply looking for the next unquoted `. the contents of $(...) are parsed more rigorously
T 1709686297 19*	Now talking on 22#bash
T 1709686297 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709686297 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709686298 18<19puchu18>	fifi
T 1709686319 18<19puchu18>	$PROXY_PREFIX cmd
T 1709686339 18<19puchu18>	this doesnt seem to work, how i make this work?
T 1709686356 18<29nightstrike18>	djph: yes
T 1709686369 18<19puchu18>	PROXY_PREFIX="http_proxy=http://127.0.0.1:8118 https_proxy=${http_proxy}"
T 1709686375 18<19puchu18>	$PROXY_PREFIX cmd
T 1709686378 18<29nightstrike18>	tirnanog: ok, I'll keep debugging
T 1709686446 18<22tirnanog18>	puchu: a) PROXY_PREFIX=$PROXY_PREFIX cmd or ... b) export PROXY_PREFIX; cmd
T 1709686470 18<22tirnanog18>	or c) export it at the same time as assigning
T 1709686502 18<19puchu18>	tirnanog: thanks
T 1709686561 18<27larryv18>	hm, i assumed puchu was trying to export http{,s}_proxy in a particularly convoluted manner
T 1709686573 18<22tirnanog18>	oh yeah.
T 1709686579 18<22tirnanog18>	just looked at the value. oh dear.
T 1709686741 18<22tirnanog18>	puchu: more like this then: if [[ ${PROXY_ENABLED} -eq 1 ]]; then export http_proxy=http://127.0.0.1:8118; export https_proxy=${http_proxy}; fi
T 1709686750 18<25ormaaj18>	I'd create the heredoc after running sudo using the execline heredoc command.
T 1709686786 18<25ormaaj18>	"Oh but I can't install anything". hax0r that b0x0r. permission granted.
T 1709686869 18<22tirnanog18>	nightstrike: I take it you can't rely on the exit status?
T 1709686873 18<22tirnanog18>	(of cmd)
T 1709686982 18<25ormaaj18>	I guess technically you can do that anyway using just bash.
T 1709687175 18<19puchu18>	tirnanog thanks, i did it exactly like your - like this - :)
T 1709687257 18<22tirnanog18>	otherwise, you would have had to issue http_proxy=$http_proxy https_proxy=$http_proxy cmd after assigning. seems simpler just to export to begin with.
T 1709687515 18<29nightstrike18>	tirnanog: correct, it's poorly written
T 1709687847 18<25ormaaj18>	sudo -- bash +o monitor -O lastpipe -c '{ printf %s "$2" | { shift; { BASH_ENV=/proc/self/fd/${fd} exec -- "$@"; } {fd}<&0 <&"$tty"-; } {tty}<&0' bash bash 'cd /server && source blahblah; shift; unset -v fd BASH_ENV {fd}<&-' arg1 arg2 ...
T 1709687872 18<29nightstrike18>	tirnanog: it seems to have almost random return statuses
T 1709687971 18<25ormaaj18>	sudo -- bash +o monitor -O lastpipe -c '{ printf %s "$2" | { shift; { BASH_ENV=/proc/self/fd/${fd} exec -- "$@"; } {fd}<&0 <&"$tty"-; } {tty}<&0' bash bash 'cd /server && source blahblah; unset -v fd BASH_ENV {fd}<&-' arg1 arg2 ...
T 1709687978 18<25ormaaj18>	shift in wrong place.
T 1709688000 18<22tirnanog18>	nightstrike: how awful.
T 1709688075 18<25ormaaj18>	If only bash were posix I wouldn't need those extra {}'s
T 1709688278 18<24yuesbeez18>	ormaaj: thanks. what would arg1 arg2 be passed to in this case?
T 1709688303 18<25ormaaj18>	the exec'd bash shell
T 1709688339 18<25ormaaj18>	$1 stores the "heredoc" data. then dump it into a pipe, shift it away, exec remaining args
T 1709688376 18<25ormaaj18>	Oh and I have them in the wrong order duh
T 1709688399 18<25ormaaj18>	sudo -- bash +o monitor -O lastpipe -c '{ printf %s "$2" | { shift; { BASH_ENV=/proc/self/fd/${fd} exec -- "$@"; } {fd}<&0 <&"$tty"-; } {tty}<&0' bash 'cd /server && source blahblah; unset -v fd BASH_ENV {fd}<&-' bash arg1 arg2 ...
T 1709688408 18<25ormaaj18>	the first "bash" is argv[0]
T 1709688432 18<26sybariten18>	Is the "bind" command a bash specific thing?
T 1709688443 18<25ormaaj18>	sybariten: mostly
T 1709688457 18<25ormaaj18>	basically yes. some other shells have different bind command.
T 1709688567 18<26sybariten18>	Someone in the fzf channel said that in order to change a key shortcut binding, for a tool called fzf, i would just need to export an env var.  I fail to understand how he meant exactly, if i look into the config today the line which is originally used is    bind -m emacs-standard '"\ec": " \C-b\C-k \C-u`__fzf_cd__`\e\C-e\er\C-m\C-y\C-h\e \C-y\ey\C-x\C-x\C-d"'
T 1709688696 18<26sybariten18>	Hm, maybe he meant something else actually. Oh well.
T 1709688777 18<22tirnanog18>	the bind builtin is for altering readline(3) bindings, as applied specifically to bash. as concerns environment variables, it's unclear what they meant.
T 1709688827 18<22tirnanog18>	it's quite possible that they didn't know either.
T 1709688852 18<26sybariten18>	Yep, i think they may have meant what that key binding _does_ , judging from how its worded.... i realize now.
T 1709688888 18<22tirnanog18>	the only env vars recognised by fzf itself are FZF_DEFAULT_COMMAND, FZF_DEFAULT_OPS and FZF_API_KEY, according to a brief skim of its manual.
T 1709688892 18<22tirnanog18>	OPTS*
T 1709688921 18<26sybariten18>	And i think i know which variable to export in that case. But for picking up the key itself, i dont think i should do that, i should probably make a new /usr/share/doc/fzf/examples/key-bindings.bash , modify that and source it from my .bashrc
T 1709688932 18<25ormaaj18>	heh i tried it and got an error from my own code
T 1709688937 18<25ormaaj18>	libinit: Error: The shell failed to set the (E)UID and re-execing it with the correct values somehow failed to fix it. That should never happen. Not trying again to prevent an exec loop.
T 1709688949 18<25ormaaj18>	that branch should never be taken...
T 1709688965 18<25ormaaj18>	also I used --norc --noprofile. wtf
T 1709688966 18<26sybariten18>	s/"make a new"/"copy"
T 1709688971 18<22tirnanog18>	what manner of Lovecraftian horror have you unearthed now.
T 1709689306 18<25ormaaj18>	https://bpa.st/raw/2OIA that is "init.bash" which is sourced from .bashrc
T 1709689307 18<28checkbot18>	ormaaj: I think the problem is on line 20. Parameter expansions can't start with .. Double check syntax. See 25 issues on https://shellcheck.net/?id=cb89307
T 1709689319 18<25ormaaj18>	ah checkbot loves me
T 1709689352 18<25ormaaj18>	somehow sudo triggers this, but normally it doesn't, and should never.
T 1709689429 18<25ormaaj18>	it means it tried to run `exec -- env UID=correct uid bash`, then tried measuring it in the new shell and it still didn't match. Does sudo have something that blocks overwriting UID somehow?
T 1709689539 18<25ormaaj18>	probably not that doesn't seem possible.
T 1709689578 18<25ormaaj18>	unless env looks for SUDO being set and env has some misfeature that does that
T 1709689739 18*	25ormaaj stracing...
T 1709690319 18<25ormaaj18>	i wonder why sudo is unsetting UID and EUID to begin with. It just unsets them and lets the child fill them in? I never noticed that.
T 1709690446 18<25ormaaj18>	hmm lets try my new bash ebuild that doesn't have that stupid SSH define. Maybe it's f'd because gentoo
T 1709690556 18<25ormaaj18>	I wouldn't think sudo would trigger that either
T 1709690862 18<25ormaaj18>	maybe it is. it shouldn't be forcing my .bashrc to run with --norc
T 1709693155 18<22des_h18>	any chance i can read a file from the end backwards (for performance reasons) in either awk or sed?
T 1709693391 18<20tanath18>	des_h: `awk '{a[i++]=$0} END {for (j=i-1; j>=0;) print a[j--] }' FILE`
T 1709693405 18<20tanath18>	where FILE is your filename
T 1709693474 18<22des_h18>	doesn't that still read the whole file from top to bottom before the END block is executed?
T 1709693509 18<25hleneto18>	des_h, there's tac.
T 1709693519 18<20tanath18>	yeah
T 1709693541 18<22des_h18>	i'd like to start reading from the bottom backwards and stop after X < FNR lines (once a condition is met), so that i don't actually read all of the lines
T 1709693603 18<20tanath18>	i hadn't paid attn to the performance part since i didn't have context. just saw you wanted to read in reverse and grabbed a method. sorry
T 1709693706 18<22des_h18>	is there a reason this way of reading a file is not built into canonical terminal programs?
T 1709693749 18<27larryv18>	it's a weird requirement.
T 1709693775 18<27larryv18>	and it could only work on regular files, not streams, adding complexity
T 1709693826 18<22des_h18>	i have a file which has data appended to it regularly. like a log. i'd like to periodically edit the data in this file, but only check the new lines which i haven't already edited. the new lines would be at the bottom of the file
T 1709693859 18<20tanath18>	maybe just `tail -n <number_of_lines_to_read> <file_path> | tac`
T 1709693881 18<22des_h18>	problem is i don't know in advance how many new lines have been appended since i last checked
T 1709693911 18<22des_h18>	so i need to go backwards until i find a line which i've already edited
T 1709693927 18<22des_h18>	and stop
T 1709694067 18<20tanath18>	you could use vim and have it remember your last position. when you open the file you're where you left off
T 1709694196 18<22des_h18>	hmm or i could just write the last position i checked in another file and retrieve it later. then use sed to print only the lines higher than that position. i think it would still improve performance somewhat
T 1709695809 18<25ormaaj18>	There should be a way to detect whether an expression is being evaluated with eval... to define an alias that hooks a function definition by only expanding in the global scope of a sourced file, you can just look at BASH_SOURCE[0], but eval doesn't modify BASH_SOURCE, so eval "$(<file)" will break the alias.
T 1709696521 18<25ormaaj18>	You can't unset or overload BASH_SOURCE. An unhackable variable :(
T 1709697491 18<29noobaroo18>	I'm really stupid and can't solve a simple math equation
T 1709697540 18<29noobaroo18>	How many minutes and seconds is a video that is 579MB and has a bitrate of 4000KB/second?
T 1709697618 18<29nightstrike18>	it's roughly 2 and a half minutes
T 1709697640 18<29nightstrike18>	579/4
T 1709697655 18<25ormaaj18>	don't you have to like extract the video from its container and get the length of the raw stream?
T 1709697667 18<29nightstrike18>	well if it's constant bitrate...
T 1709697676 18<29nightstrike18>	so like, some old codec
T 1709697695 18<25ormaaj18>	oh right that tells you nothing
T 1709697696 18<25ormaaj18>	heh
T 1709697696 18<29nightstrike18>	or if 4M is the average, it's close enough
T 1709697786 18<29noobaroo18>	I got 144.75 but it just seems incorrect, it has to be way longer than 2 minutes
T 1709697799 18<29noobaroo18>	It just doesn't seem right.
T 1709697802 18<29noobaroo18>	Thanks.
T 1709697835 18<20bent_fingers18>	does anyone really use `grep -f pattern_file`?
T 1709697848 18<29nightstrike18>	noobaroo: well maybe you use a variable bitrate, and 4M isn't the right average
T 1709697872 18<25ormaaj18>	If it's even like half of the screen is a solid blue box for the entire  video, then even the approximation will be way wrong
T 1709697880 18<29nightstrike18>	tirnanog: for my question from earlier, maybe I oversimplified... what I'm actually doing is...  cmd <<< "input string" |& grep -q Error
T 1709697892 18<29nightstrike18>	Could <<< be affecting the ability of that to work reliably?
T 1709697916 18<25ormaaj18>	no
T 1709697917 18<29nightstrike18>	noobaroo: just open it in VLC
T 1709697954 18<25ormaaj18>	don't use &| though. It sucks.
T 1709697959 18<25ormaaj18>	|&
T 1709697996 18<29nightstrike18>	why does it suck?
T 1709698009 18<25ormaaj18>	(there are no cshisms that don't suck so naturally)
T 1709698023 18<29nightstrike18>	I can't even parse that :P
T 1709698061 18<29nightstrike18>	and anyway, 2>&1 still doesn't work
T 1709698070 18<29nightstrike18>	so the problem is elsewhere
T 1709698110 18<25ormaaj18>	portability mainly. |& has completely different meaning in other shells.
T 1709698135 18<29nightstrike18>	hm...  works on the command line, not in the script
T 1709698140 18<25ormaaj18>	Also it evaluates very strangely
T 1709698186 18<29nightstrike18>	strangely?
T 1709698259 18<25ormaaj18>	cmd 2>&1 |& # won't do what you think. because it isn't like an alias for an ordinary redirection.
T 1709698435 18<29nightstrike18>	hm...  well FWIW, I reverted all my temporary kludges back to my original script, and now it works.  So there must have been something screwed up externally.
T 1709698450 18<29nightstrike18>	I think that means it's time for bed.
T 1709698637 18<29nightstrike18>	ok, so one last thing.. I got stuck on this for days and then forgot about it...  I need to match a line of an output stream, and then remove the matching line, the one after, and the two previous.  I got `sed -e 'N;/match/!P;D'` to discard the matched line and one prior, but I can't get two prior and can't get the one after
T 1709698722 18<29nightstrike18>	I guess I can ask again in #sed
T 1709700600 18<29nightstrike18>	lololol... this abomination works...   `cat x | (mapfile -t; for ((i=0; i<${#MAPFILE[@]}; i++)); do if [[ "${MAPFILE[$i]}" == *"match"* ]]; then unset "MAPFILE[$((i-2))]" "MAPFILE[$((i-1))]" "MAPFILE[$i]" "MAPFILE[$((i+1))]"; fi; done; for i in "${MAPFILE[@]}"; do echo "$i"; done)`
T 1709700638 18<29nightstrike18>	who said you can't shove that square peg through a concrete wall? :P
T 1709700887 18<25ormaaj18>	except uuoc
T 1709700900 18<29nightstrike18>	what's that?
T 1709700901 18<25ormaaj18>	!uuoc
T 1709700901 18<29greybot18>	Useless Use Of Cat (cat foo | grep bar). See https://mywiki.wooledge.org/BashFAQ/119 and http://www.iki.fi/era/unix/award.html#cat
T 1709700915 18<29nightstrike18>	lol, that's what you point out from that horror?
T 1709700925 18<29nightstrike18>	cat is a standin for some other command I'm running
T 1709700953 18<25ormaaj18>	it's not really that wrong
T 1709700961 18<29nightstrike18>	dude, it's awful
T 1709700964 18<25ormaaj18>	I'd use a read loop instead since you   only really want one line at a time
T 1709700986 18<29nightstrike18>	and it's all because `grep -v -C` doesn't DTRT
T 1709701012 18<25ormaaj18>	there are other details I guess
T 1709701033 18<27larryv18>	could probably be a pretty straightforward awk script
T 1709701034 18<25ormaaj18>	array[$((foo))] is pointless for indexed arrays
T 1709701047 18<29nightstrike18>	larryv: if I knew awk
T 1709701086 18<29nightstrike18>	ormaaj: what do you mean?
T 1709701106 18<25ormaaj18>	the index is implicitly evaluated as a math expression
T 1709701111 18<25ormaaj18>	unless the array is associative
T 1709701126 18<29nightstrike18>	you mean I can do `unset "MAPFILE[i-1]" ?
T 1709701132 18<25ormaaj18>	yes
T 1709701150 18<29nightstrike18>	...you sure?
T 1709701154 18<25ormaaj18>	quite
T 1709701157 18<29nightstrike18>	ok, I'll try it
T 1709701210 18<29nightstrike18>	well, you're right... but I just lost my ssh connection
T 1709701229 18<29nightstrike18>	stupid vpn time limit
T 1709701270 18<29nightstrike18>	even MAPFILE[i] doesn't need $i
T 1709701271 18<29nightstrike18>	nice
T 1709701296 18<25ormaaj18>	MAPFILE[i] is more correct. They aren't quite equivalent.
T 1709701386 18<25ormaaj18>	MAPFILE is hideous. just pick a name
T 1709701417 18<29nightstrike18>	lol
T 1709701430 18<29nightstrike18>	The whole thing is hideous :)
T 1709701455 18*	27JAA picks 'a'.
T 1709701457 18<29nightstrike18>	and sadly, while it works in my small test, doesn't even work in the real deal
T 1709701490 18<29nightstrike18>	JAA: I worked with a guy that wrote...   `int one_thousand_milliseconds_in_seconds = 1;`
T 1709701499 18<27JAA18>	:-)
T 1709701530 18<29nightstrike18>	this was on like a $50m project with many layers of QA. That takes balls.
T 1709701551 18<27JAA18>	Nice
T 1709701633 18<29nightstrike18>	I think he was essentially giving the finger to QA
T 1709701649 18<29nightstrike18>	ah ha!  in my real code, I forgot to swap "match" with the actual match text :)
T 1709701779 18<25ormaaj18>	mapfile -t a <"$x"; typeset -i i; for i in "${!a[@]}"; do [[ $i == *match* ]] && i+=i-2 command unset -v -- 'a[i++]'{,,,,}; done
T 1709701840 18<29nightstrike18>	whoa
T 1709701844 18<27JAA18>	Probably `[[ ${a[i]} == *match* ]]`
T 1709701858 18<25ormaaj18>	that
T 1709701865 18<29nightstrike18>	that looks like magic
T 1709701879 18<29nightstrike18>	what's this {,,,,} notation?
T 1709701890 18<27JAA18>	Very neat trick on the `unset`, yeah.
T 1709701911 18<29nightstrike18>	I know of {1..5} for generating a sequence...
T 1709701945 18<27JAA18>	It just generates 'a[i++]' five times.
T 1709701962 18<27JAA18>	You might only want four, not sure.
T 1709701980 18<29nightstrike18>	should be 4, yeah
T 1709702003 18<27JAA18>	The effect is that it unsets ${a[i++]} five times, and the post-increment takes care of $i.
T 1709702048 18<27JAA18>	So it's equivalent to `unset -v -- 'a[i]' 'a[i+1]' 'a[i+2]' 'a[i+3]' 'a[i+4]'; ((i+=5))` more or less.
T 1709702056 18<29nightstrike18>	i+=i-2..  that seems a little suspect, no?
T 1709702070 18<27JAA18>	Yeah, that should be i+=-2.
T 1709702079 18<27JAA18>	Or i=i-2.
T 1709702087 18<29nightstrike18>	ok, got it...
T 1709702116 18<29nightstrike18>	well that's certainly better than what I wrote.  I still maintain that grep -v -C should work :)
T 1709702129 18<29nightstrike18>	thanks ormaaj , mind if I use your solution?
T 1709702213 18<29nightstrike18>	I guess that's the point of posting in an irc channel :)
T 1709702576 18<25ormaaj18>	+# shopt -s lastpipe; set +m; printf '%s\n' {0..4} match {6..10} | mapfile -t a; typeset -i i; for i in "${!a[@]}"; do [[ ${a[i]} == *match* ]] && i+=-2 command unset -v -- 'a[i++]'{,,,}; done; printf '%s ' "${a[@]}"; echo
T 1709702579 18<25shbot18>	ormaaj: 0 1 2 7 8 9 10
T 1709702584 18<29nightstrike18>	hm.. your code is a lot slower, unfortunately
T 1709702612 18<25ormaaj18>	It should be faster :o
T 1709702619 18<29nightstrike18>	Maybe I typed it wrong
T 1709702642 18<29nightstrike18>	maybe it's hung
T 1709702651 18<25ormaaj18>	if it's slower it's probably bash doing some stupid backflips to export i to command
T 1709702696 18<29nightstrike18>	there's about 140k lines of input text.  Mine finished in maybe ten seconds.  Yours is going on a minute now.
T 1709702722 18<29nightstrike18>	but again, I could have typed it wrong.  it's after midnight for me.
T 1709702732 18<29nightstrike18>	yup
T 1709702733 18<29nightstrike18>	s.bash: line 129: [i++]: bad array subscript
T 1709702735 18<25ormaaj18>	the first one I wrote has some bugs
T 1709702739 18<29nightstrike18>	I must have screwed that up
T 1709702746 18<25ormaaj18>	use the one I sent to shbot
T 1709702750 18<29nightstrike18>	ok
T 1709702863 18<29nightstrike18>	hm... the bugs you fixed are ones that I also fixed...  i+=-2, the LHS of the ==, the three ,,, isntead of 4
T 1709702910 18<25ormaaj18>	wouldn't be too surprised if it does something weird with a huge input either
T 1709702962 18<25ormaaj18>	It would be faster to read one line at a time, unset the preveious too elements, seek ahead a line, and continue
T 1709703064 18<29nightstrike18>	It would be faster to use sed :P
T 1709703071 18<25ormaaj18>	yes
T 1709703079 18<29nightstrike18>	I just don't know how
T 1709703090 18<29nightstrike18>	and both times I asked in #sed got crickets
T 1709703103 18<25ormaaj18>	well with sed you have to use labels and junk. I wouldn't bother.
T 1709703160 18<25ormaaj18>	that's the only way to look ahead more than one line
T 1709703163 18<29nightstrike18>	hm... yeah, it's the i++ that's causing bash to choke
T 1709703199 18<25ormaaj18>	bash sux
T 1709703210 18<20bent_fingers18>	nobody uses grep -f pattern-file
T 1709703215 18<25ormaaj18>	you should figure out where and report a bug :{
T 1709703225 18<29nightstrike18>	hah, they won't accept the bug report
T 1709703229 18<29nightstrike18>	this is bash 4.1.2
T 1709703232 18<20bent_fingers18>	do you think they'll remove the feature if i file a bug?
T 1709703237 18<25ormaaj18>	ah yeah. bug highly likely
T 1709703243 18<25ormaaj18>	probably a bug I reported
T 1709703248 18<25ormaaj18>	years ago
T 1709703258 18<29nightstrike18>	I sadly have to support RHEL6 for another 8 months, so I gotta live with old bash for now
T 1709703268 18<27larryv18>	bent_fingers: no.
T 1709703283 18<25ormaaj18>	41# shopt -s lastpipe; set +m; printf '%s\n' {0..4} match {6..10} | mapfile -t a; typeset -i i; for i in "${!a[@]}"; do [[ ${a[i]} == *match* ]] && i+=-2 command unset -v -- 'a[i++]'{,,,}; done; printf '%s ' "${a[@]}"; echo
T 1709703302 18<25ormaaj18>	is there a 41??
T 1709703310 18<25ormaaj18>	# triggers
T 1709703311 18<25shbot18>	ormaaj: Available triggers: +# bash-devel; 1# bash-1.14; 2# bash-2.05b; 32# bash-3.2; 3# bash-3.2; 42# bash-4.2; 43# bash-4.3; 44# bash-4.4; 4# bash-4.4; 50# bash-5.0; 51# bash-5.1; 52# bash-5.2; 5# bash-5.2; # bash-5.2; d# dash-0.5.9; sh# dash-0.5.9; k# ksh 93u+ 2012-08-01; m# mksh R59 2021/01/24; b# bourne; j# bourne(w/job);
T 1709703321 18<25ormaaj18>	42# shopt -s lastpipe; set +m; printf '%s\n' {0..4} match {6..10} | mapfile -t a; typeset -i i; for i in "${!a[@]}"; do [[ ${a[i]} == *match* ]] && i+=-2 command unset -v -- 'a[i++]'{,,,}; done; printf '%s ' "${a[@]}"; echo
T 1709703323 18<25shbot18>	ormaaj: bash: [i++]: bad array subscript
T 1709703323 18<25shbot18>	ormaaj: bash: [i++]: bad array subscript
T 1709703323 18<25shbot18>	ormaaj: 2 3 4 match 6 7 8 9 10
T 1709703336 18<29nightstrike18>	yeah that's what I get, bad array subscript
T 1709703340 18<25ormaaj18>	fine piece of shit bash is.
T 1709703361 18<29nightstrike18>	42 specifies the version?
T 1709703368 18<25ormaaj18>	something like that
T 1709703377 18<29nightstrike18>	well that's a friendly bot!
T 1709703414 18<29nightstrike18>	GNU bash, version 4.1.2(2)-release (x86_64-redhat-linux-gnu)
T 1709703427 18<29nightstrike18>	CentOS release 6.10 (Final)
T 1709703451 18<25ormaaj18>	mapfile must have been very new
T 1709703461 18<25ormaaj18>	i think it came out only shortly  before
T 1709703462 18<29nightstrike18>	it's 4+ only
T 1709703467 18<29nightstrike18>	yeah
T 1709703747 18<25ormaaj18>	oh wait lastpipe wouldn't have been available then either
T 1709703799 18<25ormaaj18>	42# printf '%s\n' {0..4} match {6..10} | { mapfile -t a; typeset -i i; for i in "${!a[@]}"; do [[ ${a[i]} == *match* ]] || continue; i+=-2 command unset -v -- 'a[i++]'{,,,}; done; printf '%s ' "${a[@]}"; echo; }
T 1709703801 18<25shbot18>	ormaaj: bash: [i++]: bad array subscript
T 1709703801 18<25shbot18>	ormaaj: bash: [i++]: bad array subscript
T 1709703801 18<25shbot18>	ormaaj: 2 3 4 match 6 7 8 9 10
T 1709703808 18<25ormaaj18>	:o
T 1709703817 18<27JAA18>	Huh, it unsets 0 and 1?
T 1709703848 18<27JAA18>	Oh, a match on the first line would be fun, too.
T 1709703859 18<25ormaaj18>	42# printf '%s\n' {0..4} match {6..10} | { mapfile -t a; typeset -i i; for i in "${!a[@]}"; do [[ ${a[i]} == *match* ]] || continue; (( i-=2 )); unset -v -- 'a[i++]'{,,,}; done; printf '%s ' "${a[@]}"; echo; }
T 1709703861 18<25shbot18>	ormaaj: 0 1 2 7 8 9 10
T 1709703889 18<25ormaaj18>	hm rite
T 1709703912 18<29nightstrike18>	JAA: for my purpose, it is guaranteed to not match on the first line
T 1709703932 18<27JAA18>	A match on the last line might also make it sad, or matches on consecutive lines, or matches two lines apart.
T 1709704019 18<22des_h18>	i have a log file with unix timestamps prefixing each line. i want to generate a new file where i convert the timestamps to a human format. i can retrieve the timestamps with either awk or sed, but how do i call the external `date` utility to perform the conversation and substitute the new value in place so that I output a modified line? in sed with some kind of bash command substitution it would be like `s/timestamp/$(convert timestamp)/`
T 1709704093 18<27JAA18>	I'd probably do it in gawk.
T 1709704098 18<29nightstrike18>	The program is outputting..  "attempted command X\nError processing command\nError was NOTFOUND\nprogram failed on 'attempted command X'"
T 1709704130 18<29nightstrike18>	There are many possible errors, I'm only trying to silence specifically the NOTFOUND error, so I'm guaranteed to get those four lines of text all at once
T 1709704137 18<29nightstrike18>	but I don't want to silence any other errors
T 1709704155 18<29nightstrike18>	(and I can't modify the source program to be less annoying)
T 1709704167 18<27JAA18>	Ah, fun.
T 1709704238 18<29nightstrike18>	des_h: we're having fun with mapfile right now. You can do the same!! (no really, don't)
T 1709704245 18<29nightstrike18>	(but you could)
T 1709704275 18<27JAA18>	lol
T 1709704281 18<25ormaaj18>	42# printf '%s\n' 0 match 2 3 4 match match {7..10} | { mapfile -t a; typeset -i i; for i in "${!a[@]}"; do [[ '((i -= 2) < 0 && i = 0), 1' -ne 0 ${a[i]} == *match* ]] || continue; unset -v -- 'a[i++]'{,,,}; done; printf '%s ' "${a[@]}"; echo; }
T 1709704283 18<25shbot18>	ormaaj: bash: syntax error in conditional expression
T 1709704283 18<25shbot18>	ormaaj: bash: syntax error near `${a[i]}'
T 1709704289 18<27JAA18>	If in Bash, I'd just do a `read` loop + `printf`.
T 1709704318 18<25ormaaj18>	ugh wat
T 1709704324 18<25ormaaj18>	+# printf '%s\n' 0 match 2 3 4 match match {7..10} | { mapfile -t a; typeset -i i; for i in "${!a[@]}"; do [[ '((i -= 2) < 0 && i = 0), 1' -ne 0 ${a[i]} == *match* ]] || continue; unset -v -- 'a[i++]'{,,,}; done; printf '%s ' "${a[@]}"; echo; }
T 1709704326 18<25shbot18>	ormaaj: bash: syntax error in conditional expression
T 1709704326 18<25shbot18>	ormaaj: bash: syntax error near `${a[i]}'
T 1709704330 18<27JAA18>	wut is that string?
T 1709704339 18<25ormaaj18>	oh
T 1709704346 18<25ormaaj18>	+# printf '%s\n' 0 match 2 3 4 match match {7..10} | { mapfile -t a; typeset -i i; for i in "${!a[@]}"; do [[ '((i -= 2) < 0 && i = 0), 1' -ne 0 && ${a[i]} == *match* ]] || continue; unset -v -- 'a[i++]'{,,,}; done; printf '%s ' "${a[@]}"; echo; }
T 1709704349 18<25shbot18>	ormaaj: bash: [[: ((i -= 2) < 0 && i = 0), 1: attempted assignment to non-variable (error token is "= 0), 1")
T 1709704349 18<25shbot18>	ormaaj: bash: [[: ((i -= 2) < 0 && i = 0), 1: attempted assignment to non-variable (error token is "= 0), 1")
T 1709704349 18<25shbot18>	ormaaj: etc... ( http://paste.wooledge.org/29296 )
T 1709704372 18<25fireonlive18>	# exit
T 1709704373 18<25shbot18>	fireonlive: logout
T 1709704373 18<25shbot18>	fireonlive: (shell exited with 0)
T 1709704381 18<25ormaaj18>	mh I'm not testing wraparound either. Screw you if you need that.
T 1709704537 18<29nightstrike18>	ormaaj: what's the reason for { mapfile...} vs (mapfile...) ?
T 1709704568 18<25ormaaj18>	{ doesn't create a subshell
T 1709704573 18<29nightstrike18>	ah, ok
T 1709704622 18<25ormaaj18>	I don't know what the problem with that last one is
T 1709704625 18<27JAA18>	But really, what is that string in the comparison?
T 1709704643 18<29nightstrike18>	I'm still trying to get the first one working
T 1709704645 18<27JAA18>	Doesn't that need to be a `$((...))` or something?
T 1709704665 18<29nightstrike18>	ormaaj> 42# printf '%s\n' {0..4} match {6..10} | { mapfile -t a; typeset -i i; for i in "${!a[@]}"; do [[ ${a[i]} == *match* ]] || continue; i+=-2 command unset -v -- 'a[i++]'{,,,}; done; printf '%s ' "${a[@]}"; echo; }
T 1709704666 18<29nightstrike18>	that one
T 1709704715 18<25ormaaj18>	wow that is a bug
T 1709704737 18<25ormaaj18>	I can't do anything without finding a bug
T 1709704759 18<27JAA18>	lol
T 1709704770 18<27JAA18>	:-)
T 1709704859 18<25ormaaj18>	no shell accepts that expression
T 1709704865 18<25ormaaj18>	I don't understand what's wrong with it\
T 1709704886 18<25ormaaj18>	+# let '(i -= 2) < 0 && i = 0'
T 1709704888 18<25shbot18>	ormaaj: bash: let: (i -= 2) < 0 && i = 0: attempted assignment to non-variable (error token is "= 0")
T 1709704896 18<25ormaaj18>	looks correct to me
T 1709704917 18<25ormaaj18>	k# let '(i -= 2) < 0 && i = 0'
T 1709704919 18<25shbot18>	ormaaj: ksh: let: (i -= 2) < 0 && i = 0: assignment requires lvalue
T 1709704925 18<25ormaaj18>	there is a fucking lvalue
T 1709704940 18<27larryv18>	&& has higher precedence than =
T 1709704955 18<25ormaaj18>	>:(
T 1709705062 18<25ormaaj18>	41# printf '%s\n' 0 match 2 3 4 match match {7..10} | { mapfile -t a; typeset -i i; for i in "${!a[@]}"; do [[ '(i -= 2) < 0 && (i = 0), 1' -ne 0 && ${a[i]} == *match* ]] || continue; unset -v -- 'a[i++]'{,,,}; done; printf '%s ' "${a[@]}"; echo; }
T 1709705074 18<25ormaaj18>	42# printf '%s\n' 0 match 2 3 4 match match {7..10} | { mapfile -t a; typeset -i i; for i in "${!a[@]}"; do [[ '(i -= 2) < 0 && (i = 0), 1' -ne 0 && ${a[i]} == *match* ]] || continue; unset -v -- 'a[i++]'{,,,}; done; printf '%s ' "${a[@]}"; echo; }
T 1709705076 18<25shbot18>	ormaaj: 0 9 10
T 1709705079 18<25ormaaj18>	yay!
T 1709705081 18<25ormaaj18>	>:(
T 1709705104 18<27larryv18>	lolol
T 1709705631 18<29nightstrike18>	ormaaj: what was the ultimate fix for "bad subscript" with older bash?
T 1709705791 19*	Now talking on 22#bash
T 1709705791 22*	Topic for 22#bash is: https://mywiki.wooledge.org/BashFAQ | https://mywiki.wooledge.org/BashGuide | https://gnu.org/s/bash/manual | https://mywiki.wooledge.org/Quotes | https://www.shellcheck.net/ | https://lists.gnu.org/mailman/listinfo/help-bash | https://git.savannah.gnu.org/cgit/bash.git?h=devel | bash-hackers.org is down
T 1709705791 22*	Topic for 22#bash set by 26ormaaj!~ormaaj@user/ormaaj (24Fri Feb 16 23:57:24 2024)
T 1709705846 18<29nightstrike18>	but what individual change made that go away? there were quite a few changes you were working with
T 1709705849 18<25ormaaj18>	which is odd, because an empty arithmetic expression is valid and equals zero. And those expressions were not empty
T 1709705871 18<25ormaaj18>	that last one looks like it works
T 1709705919 18<29nightstrike18>	I was trying to keep it simpler since I didn't need those extra cases
T 1709705923 18<29nightstrike18>	but I'll try it all the same
T 1709706040 18<29nightstrike18>	it doesn't
T 1709706299 18<29nightstrike18>	oh, hm..
T 1709706307 18<29nightstrike18>	it's almsot working
T 1709706351 18<29nightstrike18>	hey, it worked
T 1709706370 18<29nightstrike18>	both your one from before the extra requirements and the one you ended with
T 1709706407 18<29nightstrike18>	I had accidentally switched terminals to one that was using an older input program (the thing providing this garbage output), and its formatting was significantly different
T 1709706523 18<29nightstrike18>	it's still kinda slow, but it wokrs
T 1709706813 18<29nightstrike18>	ormaaj: ty for all the help. I'm gonna run with this.
T 1709706832 18<29nightstrike18>	Time to head to bed.   goodnight all
T 1709707318 18<25ormaaj18>	How are you supposed to get the max index of an array anyway?
T 1709707504 18<25ormaaj18>	# typeset -a a=([10]=); typeset -n r=a[-1]; echo "${!r}"
T 1709707507 18<25shbot18>	ormaaj: a[-1]
T 1709707510 18<25ormaaj18>	k# typeset -a a=([10]=); typeset -n r=a[-1]; echo "${!r}"
T 1709707512 18<25shbot18>	ormaaj: a[10]
T 1709707514 18<25ormaaj18>	fuck you bash.
T 1709707548 18<27JAA18>	Is iteration over keys guaranteed to be in order?
T 1709707555 18<25ormaaj18>	yes
T 1709707581 18<25ormaaj18>	I mean like, if you expand "${!a[@]}",  that will be in order
T 1709707611 18<27JAA18>	Yeah
T 1709707616 18<27JAA18>	Hmm
T 1709707651 18<25ormaaj18>	so b=("${!a[@]}"); echo "${b[-1]}"; will do it, but damn. All because Chet doesn't know how a freaking list should work.
T 1709707653 18<27JAA18>	And you can't do something like ${!a[-1]}.
T 1709707664 18<27JAA18>	Heh
T 1709707670 18<27JAA18>	Yeah, Bash arrays are weird.
T 1709710608 18<24xmb18>	if arr is without holes , ${#arr[@]} will return its next elem
T 1709710620 18<24xmb18>	0 1 2 , = 3
T 1709710634 18<27JAA18>	Yeah, but the discussion above was about sparse arrays.
T 1709710642 18<24xmb18>	ah k
T 1709710890 18<28emanuele618>	ack
T 1709712593 18<29andre144k18>	hello, how to "pgrep -f" for process "foo" or "bar" ?
T 1709712620 18<29andre144k18>	so when both is running once i get two process ids
T 1709712759 18<22pj18>	# ar=(); ar[1]=a ar[5]=b; ari=("${!ar[@]}"); echo "${ari[-1]}"
T 1709712761 18<25shbot18>	pj: 5
T 1709712773 18<22pj18>	JAA: This is the best way I can think of ^^^^^
T 1709712799 18<29andre144k18>	hopefully not for me ^^
T 1709712804 18<27JAA18>	Yeah
T 1709712817 18<22pj18>	basically copying the indexes into another array
T 1709712825 18<22pj18>	and then accessing the last element of that array
T 1709712873 18<22pj18>	oh, I see ormaaj came up with that earlier.
T 1709715092 18<24xmb18>	andre $( pgrep -f foo ; pgrep -f bar )
T 1709715125 18<24xmb18>	since it says only one pattern
T 1709715636 18<28emanuele618>	you can use  pgrep -f 'foo|bar'   i think
T 1709715676 18<28emanuele618>	yes
T 1709715746 18<29andre144k18>	thx
T 1709715748 18<27JAA18>	It's an ERE according to the man page.
T 1709715754 18<28emanuele618>	>:(
T 1709715781 18<27JAA18>	I completely missed it at first as it's tucked away near the bottom for some reason.
T 1709715857 18<28emanuele618>	did you know that "JAA" is a regular expression? :o
T 1709715872 18<27JAA18>	Whoa
T 1709715891 18<28emanuele618>	# printf 'Hello, %s\n' JAA emanuele6 | grep JAA
T 1709715892 18<25shbot18>	emanuele6: Hello, JAA
T 1709715921 18<27JAA18>	Amazing!
T 1709715933 18<28emanuele618>	JAAmazing!
T 1709715941 18<27JAA18>	:-)
T 1709718283 18<28nphard18>	is it posible a loop with two different values? cut -f1, cut -f2
T 1709718350 18<24xmb18>	u can save to two data structures
T 1709718351 18<28nphard18>	a yes with a variable perhaps?
T 1709718369 18<24xmb18>	whats the cut output look like
T 1709718406 18<28nphard18>	let's say the loop it's only for two iterations, how to tell the second time has to use 'cut -f2'?
T 1709718429 18<24xmb18>	show cut output plz ?
T 1709718441 18<28nphard18>	alright
T 1709718450 18<28nphard18>	it's kinda simple
T 1709718505 18<28nphard18>	https://dpaste.com/BLMFQKH44
T 1709718535 18<24xmb18>	u load -f1 into an arr , and -f2 to another
T 1709718547 18<24xmb18>	then u use those diff arrs for values
T 1709718658 18<28nphard18>	an array?
T 1709718689 18<20osse18>	while read -r num1 num2 num3; do blabla "$num1" "$num2" "$num3"; done
T 1709718702 18<20osse18>	no cut needed
T 1709718752 18<28nphard18>	osse: I need the columns
T 1709718773 18<28nphard18>	wow, so many ways, arrays, 'read -r'
T 1709718782 18<24xmb18>	v1=( 1 1 1 ) v2=( 2 2 2 ) v3=( 3 3 3 ) i=-1 ; while (( ++i <= ${#a[@]} )) ; do declare -n d1=a[i] d2=b[i] ; printf %s\\n "$i : $d1 / $d2" ; exit ; done
T 1709718799 18<28nphard18>	darn1!
T 1709718812 18<28nphard18>	that felt like a punch in the face.
T 1709718817 18<20osse18>	If the number of columns in known I would add num1, num2 and num3 to as many different arrays and process the arrays after the loop is done
T 1709718965 18<28nphard18>	alright, this is interesting, i'll be back to put all this into practice.
T 1709718965 18<24xmb18>	# v1=( 1 1 1 ) v2=( 2 2 2 ) v3=( 3 3 3 ) i=-1 ; while (( ++i <= ${#a[@]} )) ; do declare -n d1=v1[i] d2=v2[i] ; printf %s\\n "$i : $d1 / $d2" ; exit ; done
T 1709718968 18<25shbot18>	xmb: 0 : 1 / 2
T 1709718968 18<25shbot18>	xmb: logout
T 1709718968 18<25shbot18>	xmb: (shell exited with 0)
T 1709718970 18<28nphard18>	thanks all.
T 1709718978 18<24xmb18>	that one works
T 1709719024 18<28emanuele618>	# printf '1\t2\t3\na\tb\tc\nX\tY\tZ\n'
T 1709719026 18<25shbot18>	emanuele6: 1       2       3
T 1709719026 18<25shbot18>	emanuele6: a       b       c
T 1709719026 18<25shbot18>	emanuele6: X       Y       Z
T 1709719031 18<28emanuele618>	# printf '1\t2\t3\na\tb\tc\nX\tY\tZ\n' | jq -rnR '[ inputs / "\t" ] | transpose[] | join("\t")'
T 1709719033 18<25shbot18>	emanuele6: 1       a       X
T 1709719033 18<25shbot18>	emanuele6: 2       b       Y
T 1709719033 18<25shbot18>	emanuele6: 3       c       Z
T 1709719034 18<28nphard18>	xmb: but, declaring the variables with each column can become unwieldy with large numbers of files and unknown data fields.
T 1709719063 18<28nphard18>	xmb: does your solution need to put manually the data into the arrays manually for each file?
T 1709719075 18<24xmb18>	# v1=( 1 1 1 ) v2=( 2 2 2 ) v3=( 3 3 3 ) i=-1 ; while (( ++i <= ${#a[@]} )) ; do  printf %s\\n "$i : ${v1[i]} / ${v2[i]}" ; exit ; done
T 1709719077 18<25shbot18>	xmb: 0 : 1 / 2
T 1709719077 18<25shbot18>	xmb: logout
T 1709719077 18<25shbot18>	xmb: (shell exited with 0)
T 1709719096 18<24xmb18>	nphard it depends only on ur request
T 1709719103 18<28nphard18>	ths --> v1=( 1 1 1 ) v2=( 2 2 2 ) v3=( 3 3 3 )
T 1709719128 18<28nphard18>	*this
T 1709719147 18<28nphard18>	xmb: that's why I was using 'cut -fN'
T 1709719166 18<27Soliton18>	cut is very rarely useful.
T 1709719175 18<27Soliton18>	what is the goal?
T 1709719178 18<28nphard18>	pre-populating the arrays seems like hell of an extra work!!
T 1709719208 18<28nphard18>	Soliton: somthing like this --> https://dpaste.com/BLMFQKH44
T 1709719236 18<27Soliton18>	that is the input or output you want or what?
T 1709719255 18<28nphard18>	I was gonna use 'for in' but then realized is not that simple to change the values of '-fN' in the middle of the loop.
T 1709719279 18<28nphard18>	Soliton: 'cut -f1 file_with_cols'
T 1709719294 18<27Soliton18>	alright so there is no goal. nevermind.
T 1709719309 18<24xmb18>	awk ' { print $1 } '
T 1709719315 18<24xmb18>	this ur cut tries ?
T 1709719323 18<24xmb18>	print first col , then second
T 1709719325 18<28nphard18>	Soliton: separate the columns is the goal.
T 1709719330 18<24xmb18>	$1 only first
T 1709719345 18<28nphard18>	Soliton: in a loop
T 1709719345 18<27Soliton18>	and what does separate the columns mean?
T 1709719361 18<28nphard18>	filaA, fileB, fileC.
T 1709719367 18<27Soliton18>	!faq1
T 1709719367 18<29greybot18>	https://mywiki.wooledge.org/BashFAQ/001 -- How can I read a file (data stream, variable) line-by-line (and/or field-by-field)?
T 1709719432 18<28nphard18>	xmb: use it directly with the files? --> awk ' { print $1 } ' file_with_colums
T 1709719443 18<27Soliton18>	so far no idea how cut would do anything useful.
T 1709719463 18<28nphard18>	Soliton: that's why I am asking.
T 1709719479 18<27Soliton18>	but you're asking about cut and we have no idea what the actual goal is.
T 1709719481 18<28nphard18>	if I had the solution I would no be asking.
T 1709719494 18<24xmb18>	awk to print eleme
T 1709719502 18<28nphard18>	xmb: thanks, i'll try that
T 1709719508 18<24xmb18>	cut my tries failed , so awk
T 1709719517 18<24xmb18>	the point was , hold ..
T 1709719521 18<28nphard18>	xmb: can it be use in a loop?
T 1709719533 18<24geirha18>	while IFS=$'\t' read -r f1 f2 f3 ; do a+=( "$f1" ) b+=( "$f2" ) c+=( "$f3" ) ; done < file_with_cols
T 1709719539 18<24geirha18>	now you have three arrays
T 1709719554 18<28nphard18>	geirha: dope
T 1709719593 18<27Soliton18>	always amazes me a bit why people make it so hard to help them.
T 1709719594 18<28nphard18>	Soliton: why isn't 'cut' reccomended? Manually it was working quite well.
T 1709719595 18<24xmb18>	# dat=$'1 2 3\n1 2 3\n1 2 3' v1=( $( awk ' { print $2 } ' <<<"$dat" ) ) v2=( $( awk ' { print $2 } ' <<<"$dat" ) ) ; declare -p v2 v1
T 1709719597 18<25shbot18>	xmb: declare -a v2=([0]="2" [1]="2" [2]="2")
T 1709719597 18<25shbot18>	xmb: declare -a v1=([0]="2" [1]="2" [2]="2")
T 1709719603 18<24xmb18>	oo
T 1709719603 18<27Soliton18>	for what?
T 1709719614 18<24xmb18>	# dat=$'1 2 3\n1 2 3\n1 2 3' v1=( $( awk ' { print $1 } ' <<<"$dat" ) ) v2=( $( awk ' { print $2 } ' <<<"$dat" ) ) ; declare -p v2 v1
T 1709719615 18<25shbot18>	xmb: declare -a v2=([0]="2" [1]="2" [2]="2")
T 1709719615 18<25shbot18>	xmb: declare -a v1=([0]="1" [1]="1" [2]="1")
T 1709719622 18<27Soliton18>	if you want to do exactly what cut does then use it. you almost never do though.
T 1709719637 18<24geirha18>	don't do v1=( $(anything )   that's just broken
T 1709719640 18<24xmb18>	in this u make dat=.. away and both <<<"$dat" and replace em with ur file/s
T 1709719652 18<24xmb18>	awk ' code ' files
T 1709719713 18<27Soliton18>	i don't understand why you can't explain a goal. like "i have tab delimited input and i want to iterate it column by column" or whatever.
T 1709719730 18<24xmb18>	# printf $'1 2 3\n1 2 3\n1 2 3\n' >f1 ; v1=( $( awk ' { print $1 } ' f1 ) ) v2=( $( awk ' { print $2 } ' f1 ) ) ; declare -p v2 v1
T 1709719731 18<27Soliton18>	afaict it's just a big guessing game so far.
T 1709719733 18<25shbot18>	xmb: declare -a v2=([0]="2" [1]="2" [2]="2")
T 1709719733 18<25shbot18>	xmb: declare -a v1=([0]="1" [1]="1" [2]="1")
T 1709719742 18<29djph18>	Soliton: there's a bashphorism about that.
T 1709719839 18<27Soliton18>	(the only input shown so far wasn't tab delimited, btw.)
T 1709719875 18<24geirha18>	I'm just assuming the tabs got expanded into spaces either through copy/pasting or the pastebin itself
T 1709719903 18<24geirha18>	given that cut -f2 apparently works on the real data
T 1709719919 18<24xmb18>	the pastebin web looks like tabs
T 1709719954 18<27Soliton18>	i wonder how something not containing tabs looks like tabs.
T 1709719956 18<24xmb18>	# printf $'1\t2\t3\n1\t2\t3\n1\t2\t3\n' >f1 ; v1=( $( awk ' { print $1 } ' f1 ) ) v2=( $( awk ' { print $2 } ' f1 ) ) ; declare -p v2 v1
T 1709719958 18<25shbot18>	xmb: declare -a v2=([0]="2" [1]="2" [2]="2")
T 1709719958 18<25shbot18>	xmb: declare -a v1=([0]="1" [1]="1" [2]="1")
T 1709719986 18<24xmb18>	soli , there is much space between 1 and 2 and 3
T 1709719997 18<24xmb18>	im his web link , andro chrome client
T 1709720000 18<27Soliton18>	3 spaces in fact, yes. no tab in sight.
T 1709720005 18<24geirha18>	anyway, running cut or awk for each column is wasteful and you risk ending up with broken data. Especially bad when you use $() instead of reading it line by line
T 1709720006 18<24xmb18>	k
T 1709720043 18<24xmb18>	the $( is only format safe-format , he used 1 2 3 thats simple
T 1709720094 18<24geirha18>	That's obviously dummy data
T 1709720133 18<24xmb18>	ye well
T 1709720142 18<28emanuele618>	we yell
T 1709720149 18<24geirha18>	Consider what happens if you read column1 into array v1, then some process comes along and updates the tsv file, then you read column2 into array v2. Now v1 and v2 do not correspond to each other. Better to read the file once
T 1709720162 18<27Soliton18>	!using > nphard
T 1709720162 18<29greybot18>	nphard: "How can I do X using Y?" NEVER ask a question of that form. Y may not be the best way to do X. All you should ask is, "How do I do X?"
T 1709720209 18<24xmb18>	dude deliver code that uses [[ updated_file ]] then
T 1709720233 18<24geirha18>	wat?
T 1709720328 18<24xmb18>	erm i tried simple on topic
T 1709720362 18<24xmb18>	file read once , ye
T 1709720418 18<24xmb18>	# printf $'1\t2\t3\n1\t2\t3\n1\t2\t3\n' >f1 ; f=$( < f1 ) v1=( $( awk ' { print $1 } ' <<<"$f" ) ) v2=( $( awk ' { print $2 } ' <<<"$f" ) ) ; declare -p v2 v1
T 1709720420 18<25shbot18>	xmb: declare -a v2=([0]="2" [1]="2" [2]="2")
T 1709720420 18<25shbot18>	xmb: declare -a v1=([0]="1" [1]="1" [2]="1")
T 1709720479 18<27Soliton18>	!pf 50
T 1709720479 18<29greybot18>	https://mywiki.wooledge.org/BashPitfalls#pf50 -- Don't do this! -- hosts=( $(aws …) )
T 1709720550 18<27Soliton18>	why do you write code like that? do you think you're actually helping anyone?
T 1709721173 18<29netmonk18>	is there a good ressource explaining bash name expension regular expression
T 1709721175 18<29netmonk18>	?
T 1709721207 18<28llua18>	eh
T 1709721230 18<28emanuele618>	bash is a regular expression
T 1709721258 18<29netmonk18>	for instance, i do ls *foobar* which expand to 12_foobar and 12_foobar_1 but i would like to exclude the second one
T 1709721268 18<27Soliton18>	!glob
T 1709721268 18<29greybot18>	Globs are shell patterns that can be used for matching strings or expanding pathnames: [[ $name = Bob* ]]; rm -- *.txt; see http://mywiki.wooledge.org/glob
T 1709721277 18<27Soliton18>	!extblog
T 1709721281 18<27Soliton18>	!extglob
T 1709721281 18<29greybot18>	"Extended globs" (shopt -s extglob) allow you to say things like "all files that do not end in .jpg". See http://mywiki.wooledge.org/glob#extglob
T 1709721300 18<27Soliton18>	those are not regular expressions.
T 1709721338 18<29netmonk18>	ok i understand, is it possible just using blob to exlude 12_foobar_1 ?
T 1709721365 18<28llua18>	see the second link
T 1709721366 18<27Soliton18>	if you want the file to end with foobar then just don't put a * at the end.
T 1709721409 18<27Soliton18>	# touch 12_foobar 12_foobar_1; printf %s\\n *foobar
T 1709721411 18<25shbot18>	Soliton: 12_foobar
T 1709721462 18<29nvz18>	if you just want to exclude one file in particular you prob need to read the results of expansion and test
T 1709721478 18<27Soliton18>	or use an extglob.
T 1709721497 18<29netmonk18>	ok in this case yes, but this is not my exact current case. ls *foobar* -> 12_foobar_009_1 and 12_foobar_009 and 11_foobar_010_1 and 11_foobar_010
T 1709721514 18<29netmonk18>	i just want to keep the one not ending with _1
T 1709721527 18<27Soliton18>	# touch 12_foobar 12_foobar_1; printf %s\\n *foobar!(_1)
T 1709721529 18<25shbot18>	Soliton: 12_foobar
T 1709721543 18<27Soliton18>	(shbot has extglob enabled by default.)
T 1709721676 18<29netmonk18>	ok
T 1709721719 18<27Soliton18>	ah, you actually have more stuff in between.
T 1709721728 18<27Soliton18>	# touch 12_foobar_009_1 12_foobar_009 11_foobar_010_1 11_foobar_010; printf %s\\n *foobar!(*_1)
T 1709721729 18<25shbot18>	Soliton: 11_foobar_010
T 1709721729 18<25shbot18>	Soliton: 12_foobar_009
T 1709721732 18<29netmonk18>	and next issue, this doesnt work when the blob is an argument of a bash function
T 1709721792 18<27Soliton18>	# touch 12_foobar_009_1 12_foobar_009 11_foobar_010_1 11_foobar_010; f() { printf %s\\n "$@"; }; f *foobar!(*_1)
T 1709721794 18<25shbot18>	Soliton: 11_foobar_010
T 1709721794 18<25shbot18>	Soliton: 12_foobar_009
T 1709721802 18<27Soliton18>	not sure what you mean.
T 1709721836 18<27Soliton18>	you need to enable extglob (shopt -s extglob) in your shell to use extended globs.
T 1709721872 18<29netmonk18>	got a syntax error near token (
T 1709721878 18<27Soliton18>	you need to enable extglob (shopt -s extglob) in your shell to use extended globs.
T 1709721932 18<29netmonk18>	ok, this was the issue sorry im slow reader :)
T 1709721935 18<29netmonk18>	thanks solitonm
T 1709721942 18<29netmonk18>	s/nm/n/
T 1709721943 18<27Soliton18>	you're welcome.
T 1709721959 18<29nvz18>	that is a regular expression
T 1709722000 18<27Soliton18>	# [[ foo =~ *foobar!(*_1) ]]; echo $?
T 1709722001 18<25shbot18>	Soliton: 2
T 1709722017 18<27Soliton18>	nope, not a valid regular expression.
T 1709722039 18<29nvz18>	no i mean the search and replace
T 1709722095 18<29nvz18>	where they mispelled your nick
T 1709722487 18<29netmonk18>	that's right
T 1709722507 18<29netmonk18>	an old habit from #unix@ircnet to correct mispell by regexo
T 1709722553 18<28emanuele618>	+# [[ foo =~ *foobar!(*_1) ]]
T 1709722555 18<25shbot18>	emanuele6: bash: [[: invalid regular expression `*foobar!(*_1)': Invalid preceding regular expression
T 1709722564 18<28emanuele618>	nope; not a valid regular expression. :D
T 1709722629 18<28emanuele618>	because invalid preceding regular expression before *foobar!(*_1)
T 1709722662 18<28emanuele618>	no, actually it just prints the entire pattern for every error
T 1709722683 18<28emanuele618>	anyway, it prints the regex error from lib c in bash devel
T 1709722689 18<19Artfaith18>	Is it possible to change type of variable from array to string without any intermediary variable?
T 1709722715 18<19Artfaith18>	# declare a=( 0 1 ); declare a="${a[0]}"; declare -p a;
T 1709722717 18<25shbot18>	Artfaith: declare -a a=([0]="0" [1]="1")
T 1709722722 18<19Artfaith18>	# declare a=( 0 1 ); declare a="${a[1]}"; declare -p a;
T 1709722724 18<25shbot18>	Artfaith: declare -a a=([0]="1" [1]="1")
T 1709722782 18<19Artfaith18>	# declare a=( 0 1 ); declare _a="${a[1]}"; unset a; declare a="$_a"; declare -p a;
T 1709722784 18<25shbot18>	Artfaith: declare -- a="1"
T 1709722829 18<28emanuele618>	# eval 'unset -v a; a='"${a[1]@Q}"
T 1709722831 18<25shbot18>	emanuele6: no output
T 1709722861 18<19Artfaith18>	emanuele6, thank you, but is there any normal way?
T 1709722926 18<28emanuele618>	using declare with an assignment is not going remove attributes. to remove attributes you use  declare +a  (where a is the attribute letter). it is only legal to use +a on unset variables.
T 1709722963 18<28nphard18>	geirha: while IFS=$'\t' read -r f1 f2 f3 ; do a+=( "$f1" ) b+=( "$f2" ) c+=( "$f3" ) ; done < file_with_cols <--- this command, when reading back the variable 'echo $a' it only prints one character, not the actual column.
T 1709723003 18<27Soliton18>	!faq 5
T 1709723003 18<29greybot18>	https://mywiki.wooledge.org/BashFAQ/005 -- How can I use array variables?
T 1709723007 18<28emanuele618>	nphard:   printf %s\\n "${a[@]}"    not   echo $a
T 1709723057 18<28emanuele618>	note that if there are empty fields  IFS=$'\t'   will not work as you expect; empty fields are skipped
T 1709723080 18<28emanuele618>	a\t\tb   is the same as  a\tb\t    and  \t\tx   is the same as  x\t\t
T 1709723262 18<28nphard18>	interesting, had to clear the variable first after typing so many randomn commands.
T 1709723327 18<25ormaaj18>	I skip empty fields. Go to strawberry fields
T 1709723354 18<28nphard18>	mm.. this is quite interesting. So the columns have been split without any loop or awk or 'cut'.
T 1709723377 18<28nphard18>	somewhat wild.
T 1709723442 18<25ormaaj18>	woh
T 1709723470 18*	28nphard staring into the distance in state of shock
T 1709723478 18<25imi18>	hi, is there a better (quicker) way to check if given variable is an integer number than grep?
T 1709723513 18<28emanuele618>	!faq number
T 1709723513 18<29greybot18>	https://mywiki.wooledge.org/BashFAQ/018 -- How can I use numbers with leading zeros in a loop, e.g. 01, 02?
T 1709723518 18<28emanuele618>	hmm, not that
T 1709723553 18<28emanuele618>	anyway, you can use    case $x in ''|*[!0123456789]*) echo no;; *) echo yes; esac
T 1709723573 18<28emanuele618>	if it is empty, or contains a character that is not 0123456789 you could say it is not a number
T 1709723578 18<25imi18>	when I have leading zeroes I prefix it with 1 and then subtract 100. now the leading zeroes are gone
T 1709723593 18<19Artfaith18>	emanuele6, to clarify, remove attributes from unset variable?
T 1709723596 18<25imi18>	ok thanks
T 1709723603 18<19Artfaith18>	What is the reason to remove an attribute from anything unset?
T 1709723620 18<19Artfaith18>	Like, in case of local variable?
T 1709723634 18<28emanuele618>	you can only remove +a and +A from unset variables; if they have a value you cannot remove those attributes
T 1709723665 18<28nphard18>	emanuele6: so... when to use these? --> a\t\tb , a\tb\t , \t\tx , x\t\t
T 1709723666 18<28emanuele618>	other attributes e.g. l, x, u, i, can be removed whenever.
T 1709723666 18<19Artfaith18>	Other attributes can be remove but these two?
T 1709723682 18<19Artfaith18>	I see...
T 1709723689 18<19Artfaith18>	Thank you, emanuele6!
T 1709723713 18<28emanuele618>	# printf 'a\t\tb\n\ta\tb\n'
T 1709723714 18<25shbot18>	emanuele6: a               b
T 1709723715 18<25shbot18>	emanuele6:         a       b
T 1709723756 18<28emanuele618>	# printf 'a\t\tb\n\ta\tb\n' | while IFS=$'\t' read -r f1 f2 f3; do printf 'f1=%q f2=%q f3=%q\n' "$f1" "$f2" "$f3"; done
T 1709723758 18<25shbot18>	emanuele6: f1=a f2=b f3=''
T 1709723758 18<25shbot18>	emanuele6: f1=a f2=b f3=''
T 1709723786 18<28emanuele618>	nphard: i was saying that for   IFS=$'\t' read -r f1 f2 f3    those sets of two lines are the same
T 1709723815 18<28emanuele618>	if you have an hole in one of the columns
T 1709723840 18<28nphard18>	ah, yes, sometimes there'll be holes.
T 1709723861 18<25imi18>	emanuele6: what about negative numbers?
T 1709723880 18<28emanuele618>	you can use   case ${x#-} in ...
T 1709723889 18<25imi18>	ok thanks
T 1709723897 18<28emanuele618>	that way if there is a - at the start, and it still matches, it is allowed
T 1709723924 18<28emanuele618>	#- removes a - from the start of $x; so it checks the patterns on the value of $x with - removed
T 1709723976 18<25ormaaj18>	x<<1,x>>1
T 1709723986 18<28emanuele618>	!faq valid
T 1709723986 18<29greybot18>	https://mywiki.wooledge.org/BashFAQ/054 -- How can I tell whether a variable contains a valid number?
T 1709723994 18<28emanuele618>	that was the faq i was looking for :D
T 1709724017 18<25ormaaj18>	><
T 1709724020 18<28emanuele618>	ormaaj: x<<=1,x>>=1 ?
T 1709724031 18<25ormaaj18>	ya!
T 1709724194 18<28emanuele618>	nphard: then you cannot use  IFS=$'\t' read -r f1 f2 f3    you could use   while read -r; do a+=( "${REPLY%%$'\t'*}" ) REPLY=${REPLY#*$'\t'} b+=( "${REPLY%%$'\t'*}" ) REPLY=${REPLY#*$'\t'} c+=( "$REPLY" ); done
T 1709724274 18<28emanuele618>	# printf 'a\t\tb\n\ta\tb\n' | while read -r; do f1=${REPLY%%$'\t'*} REPLY=${REPLY#*$'\t'} f2=${REPLY%%$'\t'*} REPLY=${REPLY#*$'\t'} f3=$REPLY; printf 'f1=%q f2=%q f3=%q\n' "$f1" "$f2" "$f3"; done
T 1709724276 18<25shbot18>	emanuele6: f1=a f2='' f3=b
T 1709724276 18<25shbot18>	emanuele6: f1='' f2=a f3=b
T 1709724778 18<25ormaaj18>	shifty eyes <<
T 1709724800 18<25ormaaj18>	shifty numbers
T 1709724849 18<25ormaaj18>	there should be rotate operators :(
T 1709725054 18<28emanuele618>	x<<=1,x&=!!(x^x>>1)
T 1709725084 18<28emanuele618>	err |=
T 1709725108 18<28emanuele618>	hmm, i am not sure
T 1709725142 18<28emanuele618>	is bash's >> signed? if it is signed, it does not work
T 1709725158 18<28emanuele618>	# echo "$(( -2 >> 1 ))"
T 1709725159 18<25shbot18>	emanuele6: -1
T 1709725162 18<28emanuele618>	:\
T 1709725316 18<28emanuele618>	need to assume 64bit and use  x&(1<<63)     x=x<<1|!!(x&1<<63)
T 1709725334 18<25OMGOMG18>	emanuele6: what was that supposed to demonstrate?
T 1709725352 18<28emanuele618>	that -2 >> 1  is signed?
T 1709725408 18<25OMGOMG18>	what would the unsigned equivalent look like
T 1709725412 18<28emanuele618>	-2 is    1111111111111111111111111111111111111111111111111111111111111110
T 1709725426 18<28emanuele618>	if it is signed >>1 results in   1111111111111111111111111111111111111111111111111111111111111111
T 1709725430 18<28emanuele618>	so -1
T 1709725443 18<28emanuele618>	if it is not signed, it results in   0111111111111111111111111111111111111111111111111111111111111111
T 1709725459 18<28emanuele618>	that is 9223372036854775807
T 1709725470 18<25OMGOMG18>	ok
T 1709725473 18<25OMGOMG18>	thanks
T 1709725509 18<28emanuele618>	signed >> duplicates the top bit, so it adds a 0 if the top bit is 0, otherwise it adds a 1 if the top bit is 1
T 1709725518 18<28emanuele618>	while unsigned >> always adds 0s
T 1709725612 18<28nphard18>	darn! bash makes you think harder every step :/
T 1709725645 18<25OMGOMG18>	do you often encounter unsigned >> ?
T 1709725799 18<28emanuele618>	?
T 1709726060 18<24ano18>	what's the best way to strip trailing char?
T 1709726096 18<28emanuele618>	%%+([chars])  ?
T 1709726211 18<24ano18>	what about portable way, ${#... ${...%%[chars] loop?
T 1709726515 18<24ano18>	# char=/; var=/path/to//////////////; until (( "${#var}" == "${var_len=0}" )); do var_len=${#var}; var=${var%%${char}}; done; echo $var
T 1709726517 18<25shbot18>	ano: /path/to
T 1709726574 18<28emanuele618>	so busybox has (( but not +()?
T 1709726593 18<28emanuele618>	"$char" not $char
T 1709726656 18<28emanuele618>	also   ""  in  (( or $((  is a big no no in most shells
T 1709726657 18<24ano18>	hmm no it doesn't
T 1709726675 18<28emanuele618>	d# echo "$(( "${#PWD}" * 2 ))"
T 1709726676 18<25shbot18>	emanuele6: dash: 1: arithmetic expression: expecting primary: " "5" * 2 "
T 1709726717 18<28emanuele618>	anyway, if you want to remove just one characters; easiest way is probably  var=${var%"${var##*[!/]}"
T 1709726728 18<28emanuele618>	missing a }
