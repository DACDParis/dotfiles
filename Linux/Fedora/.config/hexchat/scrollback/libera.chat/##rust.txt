T 1707739725 19*	Now talking on 22##rust
T 1707739725 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1707739725 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1707742868 19*	Now talking on 22##rust
T 1707742868 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1707742868 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1707743084 18<25bertptrs18>	dav1d: Error has a couple of methods that you can only call on "dyn Error + 'static"
T 1707743114 18<25bertptrs18>	Which are (I think) inherited from Any requiring 'static
T 1707743528 18<24Bish18>	if i wanted to serialize datastructures of crates with serde im pretty much screwed, right?
T 1707743542 18<24Bish18>	in this case i want to use http::* things in my struct and it should be serializable
T 1707743558 18<24Bish18>	i could wrap it in my own type, but i can't magicially make it serializible via macro, right?
T 1707743565 18<24Bish18>	i could ofcourse write my own serializer, correct?
T 1707743574 18<20spb18>	https://serde.rs/remote-derive.html
T 1707743609 18<24Bish18>	cool
T 1707743610 18<24Bish18>	thanks
T 1707743652 18<24Bish18>	is this "dangerous" as in, what happens if i the 2 structs differ
T 1707743690 18<20spb18>	if you consider compiler errors dangerous
T 1707744110 18<24Bish18>	it bothers me i have to copy the definition of the thing i want to serialize
T 1707744157 18<24Bish18>	and what if they go deep?
T 1707744183 18<24Bish18>	then i'd have to provide many many of those?
T 1707744415 18<29demize18>	What from the http crate do you want to be able to de/serialize?  The http-serde crate might provide everything you need already.
T 1707744454 18<24Bish18>	guess it does, yeah
T 1707747953 18<26dav1d18>	bertptrs, that is unfortunate :(
T 1707748273 18<25bertptrs18>	I expect it to be related to Sentry's error sniffing logic. I haven't worked with them in Rust but in Python they try to downcast your uncaught exceptions to be more helpful in the reporting. I imagine that's why they want to touch the downcast methods
T 1708186109 19*	Now talking on 22##rust
T 1708186109 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708186109 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708438062 19*	Now talking on 22##rust
T 1708438062 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708438062 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708439546 19*	Now talking on 22##rust
T 1708439546 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708439546 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708439876 19*	Now talking on 22##rust
T 1708439876 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708439876 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708441150 18<22Ademan_18>	presumably in some cases, Fromiterator::from_iter() might do something more efficient than a naive for loop might. would it be valid for <HashMap as FromIterator>::from_iter() to take only the first value for a given key and discard the rest? I've written my code assuming that the resulting hash map will use the *last* value for a given key (the behavior you'd get with a naive `for (k, v) in i {
T 1708441156 18<22Ademan_18>	map.insert(k, v); }` ).
T 1708441619 18<20spb18>	the trait documentation doesn't say anything about how situations like that should be handled, so you should assume that any reasonable implementation is possible
T 1708443107 18<22Ademan_18>	spb: makes sense, thanks!
T 1708443377 18<28belst18>	FH_thecat: did u build in release mode? the github releases are all less than 10mb
T 1708443742 18<27FH_thecat18>	belst: I build it using "cargo build --release"
T 1708444143 18<27rendar18>	if i'm using thiserror, and i have `enum MainError { #[error("Math Error")] MathError(#[from] MathError),  ... }`   when i print the error from MainError with "{}" i only get "Math Error" string, but since its a nested enum, shouldn't thiserror automatically prints the real MathError string instead of that one?
T 1708444169 18<20spb18>	only if you tell it to
T 1708444184 18<20spb18>	#[error("Math Error: {0}")]
T 1708444194 18<27rendar18>	hmm, i see
T 1708444278 18<27rendar18>	of course, it takes the same parameter id as other errors which has String or whatever, ok
T 1708444365 18<20spb18>	all the fields of that enum variant are available to use in any normal format expression
T 1708444395 18<20spb18>	based on whether they impl Display or Debug
T 1708454504 18<25bertptrs18>	FH_thecat: late reply but looking at the binary most of it appears to be tree-sitter parsers for various languages. It's a bit silly to statically link treesitter dozens of times, but it does, and depending on the language (*cough* sql) those parsers are pretty damn big
T 1708454904 18<25bertptrs18>	in other words, the extensive langauge highlighting that difftastic does
T 1708454957 18<27FH_thecat18>	bertptrs: can I disable some parsers for languages that I don't need ?
T 1708454974 18<27FH_thecat18>	and why does it have to be statically linked anyway?
T 1708455042 18<27FH_thecat18>	I basically just need shell (sh,zsh), python and c
T 1708455062 18<25bertptrs18>	I'd have to RTFS it, but from an initial glance, it compiles everything unconditionally
T 1708455111 18<27FH_thecat18>	what a monstrosity !
T 1708455135 18<25bertptrs18>	soft disagree, you want a swiss army knife, you get a swiss army knife
T 1708455173 18<25bertptrs18>	It's kinda funny, rust (rightfully) gets blamed for large binaries but most of this is C :P
T 1708455197 18<20j`ey18>	https://github.com/Wilfred/difftastic/tree/master/vendored_parsers oh yeah lotsa parsers
T 1708455275 18<27FH_thecat18>	why can't the parsers be modular
T 1708455282 18<27FH_thecat18>	ie, just install those that I need
T 1708455291 18<25bertptrs18>	because the devs didn't bother to do it, since it's a maintenance and testing hassle
T 1708455298 18<25bertptrs18>	or so I'd guess
T 1708455308 18<25bertptrs18>	modular features make exponential testing and such
T 1708455335 18<27FH_thecat18>	I thought modular approach is "cleaner"
T 1708455354 18<20j`ey18>	it is but requires more code / maintainenace
T 1708455438 18<27FH_thecat18>	then, at least there should be configuration for the build, which ones to include
T 1708455463 18<27FH_thecat18>	that would not add any extra complexity
T 1708455479 18<20j`ey18>	it would
T 1708455490 18<25bertptrs18>	I very much encourage you to raise these concerns upstream (though in a friendlier tone). None of us develop this tool, I was just curious how the binary could be so large. Now I have an answer
T 1708455524 18<27FH_thecat18>	thank you
T 1708456242 18<24Odin-LAP18>	bertptrs: C also gets an unwarranted assumption of its binaries being small, with enormous amounts of its runtime support libraries being considered "just the operating system".
T 1708456280 18<20consus18>	because it usually is :D
T 1708456332 18<20consus18>	having stdlib in each binary and still relying on libc is really stoopid
T 1708456376 18<26dav1d18>	😬
T 1708456553 18<24Odin-LAP18>	consus: But it means a comparison with a binary that _does_ contain all of that stuff isn't exactly apples to apples.
T 1708456555 18<24Odin-LAP18>	:)
T 1708456615 18<20consus18>	Odin-LAP: who cares? you have a hello world with 386k weigh that still does not qualify as a static binary because of it's reliance on libgcc and libc
T 1708456625 18<20consus18>	That's stoopid
T 1708456641 18<20consus18>	No amount of Rust copium will help you justify this
T 1708456675 18<25bertptrs18>	consus: you got warned yesterday, hereby your second warning, please behave a bit more professional
T 1708456705 18<20consus18>	bertptrs: I've missed the first one
T 1708456719 18<20consus18>	what exactly are you accusing me of?
T 1708456738 18<25bertptrs18>	<bertptrs> but that's not a reason to be this negative as it's counterproductive
T 1708456762 18<20consus18>	how should I phrase it then?
T 1708456838 18<25bertptrs18>	avoid "stoobid" and "copium" while discussing people's hard work
T 1708456843 18<20consus18>	why?
T 1708456850 18<20consus18>	copium is really a good word
T 1708456857 18<20consus18>	it's not offending
T 1708456864 18<20consus18>	I'm not calling people names
T 1708456874 18<20consus18>	but the end result is really suboptimal
T 1708456933 18<20consus18>	for example it forces projects like uutils to create a really large binary with HUGE attack surface
T 1708457055 18<19nCrazed18>	"inflamtory language" comes to mind
T 1708457069 18<20consus18>	fair enough
T 1708457073 18<25bertptrs18>	I was struggling to put it into words but yeah, that's what I meant
T 1708457134 18<25cehteh18>	uutils is stil at 0.0.x stage, i would guess that binary size optimization isnt even considered yet
T 1708457168 18<25cehteh18>	there are ways to reduce rust executables sizes, eventually
T 1708457179 18<20consus18>	They went busybox-like route
T 1708457182 18<20consus18>	With a single binary
T 1708457191 18<25cehteh18>	which is good
T 1708457192 18<20j`ey18>	but are you sure that's due to size?
T 1708457200 18<20consus18>	one of the reasons
T 1708457217 18<20consus18>	cehteh: which also creates a huge gadget space
T 1708457256 18<25cehteh18>	i would like if rust had better support for dynamic linking, but that opens other cans of worms
T 1708457378 18<25cehteh18>	https://github.com/johnthagen/min-sized-rust  there are these tips, bit outdated but many are ok, still applying that would be the icing on the cake when you are ready for production releases
T 1708457514 18<20consus18>	it does not help much
T 1708457519 18<20consus18>	you win like ~50k
T 1708457537 18<20consus18>	well, strip helps, but that's obvious
T 1708457548 18<20consus18>	no distro will let a binary without striping
T 1708457563 18<25cehteh18>	this is not a process you can blindly apply, you have to look at your project and see what benefit it most
T 1708457587 18<20consus18>	strip does 80% of the work :)
T 1708457592 18<25cehteh18>	lto for example usually reduces code size, somtimes significantly, but in some cases it bloats
T 1708457602 18<20consus18>	not that much in my experience
T 1708457606 18<20consus18>	you may win 20%
T 1708457610 18<20consus18>	even 30%
T 1708457614 18<20consus18>	but still
T 1708457617 18<25cehteh18>	it depends on the exact project
T 1708457640 18<20consus18>	the thing is... it does not help small projects because of unconditional stdlib
T 1708457655 18<25cehteh18>	removing all the panic stuff/info should save a bit, but only when combined with the build_std thing
T 1708457657 18<20consus18>	and if you're writing something like a webapp
T 1708457662 18<20consus18>	who cares?
T 1708457677 18<20consus18>	it can 500M, that won't be an issue
T 1708457680 18<25cehteh18>	you where talking about uulib
T 1708457684 18<20consus18>	yeah
T 1708457720 18<20consus18>	total busybox on my system is 1.3M
T 1708457728 18<20consus18>	lemme check the uutils
T 1708457771 18<25cehteh18>	i wont be surprised when its at this stage magnitudes larger
T 1708457938 18<25cehteh18>	oh they have a release-small target already
T 1708457968 18<20consus18>	8.5 with release
T 1708457974 18<20consus18>	actually not bad
T 1708457981 18<20consus18>	less than 10x
T 1708458007 18<25cehteh18>	5.3 with the release-small profile
T 1708458020 18<20consus18>	comparable then
T 1708458025 18<25cehteh18>	so just stop ranting :D
T 1708458031 18<20consus18>	why?
T 1708458046 18<20j`ey18>	does uutils try to do anything better?
T 1708458048 18<25cehteh18>	its annoying
T 1708458049 18<20consus18>	that's exactly why they decided to do that
T 1708458053 18<20j`ey18>	or is it just 1:1?
T 1708458077 18<20consus18>	because otherwise the size would be (clap + stdlib) * n_utils
T 1708458086 18<20consus18>	j`ey: more colors
T 1708458091 18<20j`ey18>	heh
T 1708458093 18<20consus18>	j`ey: some other imprrovements
T 1708458099 18<20consus18>	if you like colors that is
T 1708458110 18<25cehteh18>	there where people here with an actual problem that their binary was too big, if only code golfing, usually they got helped
T 1708458151 18<25cehteh18>	ranting about potential other project could be too big .. and then find out that its actually not the case, is stupid
T 1708458163 18<20consus18>	errr
T 1708458170 18<20consus18>	you misread
T 1708458184 18<20consus18>	I was citing uutils as an example of why projects decide to do single binary
T 1708458193 18<25cehteh18>	<consus> for example it forces projects like uutils to create a really large binary with HUGE attack surface
T 1708458198 18<20consus18>	yeap
T 1708458235 18<20consus18>	the C coreutils does not have a single binary
T 1708458241 18<20consus18>	it has a lot of small tools
T 1708458254 18<20consus18>	it works because of the dynamic linking
T 1708458280 18<25cehteh18>	thats just a implementation/deployment detail
T 1708458284 18<20consus18>	uutils cannot do that because then the total sum would be (stdlib + clap + other common deps) * N-Utils
T 1708458307 18<25cehteh18>	i think you can build it (mostly) statically linked with some efforts
T 1708458322 18<20consus18>	true, but then you have a problem with tools like ping
T 1708458338 18<20consus18>	because ping, for example, requires special flags
T 1708458345 18<20consus18>	and/or suid
T 1708458390 18<25cehteh18>	sure, so what? ..
T 1708458413 18<20j`ey18>	consus: do you have the uutils grep vs coreutils grep?
T 1708458424 18<20consus18>	j`ey: in terms of features?
T 1708458459 18<20j`ey18>	sizes
T 1708458460 18<20consus18>	I'm not sure uutils aims at full posix compatibility
T 1708458481 18<25bertptrs18>	it aims to pass GNU coreutils tests
T 1708458532 18<20consus18>	huh, strange, cannot find grep in applets
T 1708458540 18<25cehteh18>	which is probably more demanding :D posix requirements on some tools are surprisingly minimal
T 1708458547 18<20consus18>	nah
T 1708458555 18<20consus18>	the level of compatibility is a nigthmare
T 1708458561 18<20j`ey18>	consus: oh, well some other binary will do
T 1708458563 18<20j`ey18>	find or whatever
T 1708458586 18<20consus18>	it took openbsd 8 years or so to write grep that worked for them
T 1708458596 18<25bertptrs18>	grep is not in coreutils, is it?
T 1708458614 18<20consus18>	not sure actually
T 1708458622 18<20spb18>	not last i knew
T 1708458624 18<20consus18>	nope, it's a separate thing
T 1708458626 18<20consus18>	as is find
T 1708458631 18<25cehteh18>	woudnt ping be in netutils? i dunno
T 1708458636 18<20consus18>	ping netutils
T 1708458636 18<25bertptrs18>	not on my system
T 1708458640 18<20consus18>	find findutils
T 1708458646 18<20consus18>	grep is grep :D
T 1708458654 18<20j`ey18>	grr
T 1708458676 18<25bertptrs18>	la la, la la la
T 1708458686 18<20consus18>	yeah, busybox provides a lot more
T 1708458686 18<25bertptrs18>	lababadap dap dap grep
T 1708458725 18<26dav1d18>	I think bertptrs broke :(
T 1708458757 18<25bertptrs18>	I'm just conditioned on Opus so whenever someone writes X is X I get "Life is Life" stuck in my head
T 1708458768 18<20consus18>	xD
T 1708458806 18<20consus18>	I was actually thinking about the song about that blue dudes on an spaceship
T 1708458817 18<20consus18>	Can't remember the band name
T 1708458822 18<25bertptrs18>	ah no. Eiffel 65
T 1708458827 18<25bertptrs18>	Different genre
T 1708458828 18<20consus18>	yeah, right
T 1708458839 18<25cehteh18>	bertptrs: https://www.youtube.com/watch?v=Zt2_11e6QPA ;)
T 1708458941 18<25cehteh18>	https://www.youtube.com/watch?v=y_cbTcaoErI  better version
T 1708459027 18<20consus18>	what is the explicit of '?'?
T 1708459072 18<20consus18>	I remember writing ResultExt with into_res() but I think stdlib should have something standard for that
T 1708459095 18<25cehteh18>	explicit? desugaring?
T 1708459114 18<20consus18>	Ok(foo().await?) => foo().await.into_res()
T 1708459141 18<25cehteh18>	its not that trivial
T 1708459173 18<25bertptrs18>	it cannot be desugared like that, since it's equivalent to match foo().await { Ok(val) => val, Err(e) => return Err(e.into()) }
T 1708459183 18<25bertptrs18>	there used to be the try! macro which did almost this
T 1708459228 18<25cehteh18>	https://rust-lang.github.io/rfcs/3058-try-trait-v2.html
T 1708459258 18<25bertptrs18>	https://doc.rust-lang.org/std/ops/trait.Try.html also this
T 1708459265 18<20consus18>	damn, I had it somewhere
T 1708459272 18<25cehteh18>	yeet
T 1708459292 18<20consus18>	probably the old laptop
T 1708459298 18<20consus18>	well, nevermind :(
T 1708459305 18<25bertptrs18>	I hate that yeet exists
T 1708459315 18<20consus18>	yeet?
T 1708459322 18<25bertptrs18>	https://doc.rust-lang.org/std/ops/struct.Yeet.html
T 1708459386 18<25bertptrs18>	it exists to avoid a bikeshed about what it should be called from slowing down the RFC; they chose a name that definitely nobody likes so it was sure to be changed later
T 1708459402 18<25bertptrs18>	as opposed to a "not quite great but acceptable" name sticking around after development
T 1708459414 18<28darkling18>	... and that was 10 years ago? :)
T 1708459418 18<20consus18>	:D
T 1708459434 18<20consus18>	I miss pure
T 1708459435 18<25bertptrs18>	it hasn't been stabilized yet, that's something
T 1708459509 18<20consus18>	.map_err(|e| e.into())
T 1708459509 18<20polychromata{J}18>	bertptrs: baba is baba
T 1708459510 18<20consus18>	yeah
T 1708459511 18<20consus18>	this
T 1708459527 18<20consus18>	I was looking for this
T 1708459537 18<25bertptrs18>	that's only half of what ? does, but sure
T 1708459561 18<20consus18>	it helps me not to wrap everything in Ok()
T 1708459572 18<20consus18>	Which look really ugly
T 1708459573 18<25bertptrs18>	Fair enough, it makes sense for your final return statement
T 1708459578 18<20consus18>	yeah
T 1708459578 18<25bertptrs18>	or just returns in geenral
T 1708459596 18<20consus18>	it's a pity that ? without ; is not a thing
T 1708459626 18<20consus18>	feels wront to explicitly mark return values as "good"
T 1708459648 18<20j`ey18>	feels right to me
T 1708459752 18<20consus18>	it was unambigous in the beginning, before ?
T 1708459765 18<20consus18>	but now the language itself has an operator for returning errors
T 1708459778 18<20consus18>	And now it feels weird
T 1708459875 18<25bertptrs18>	most languages have a keyword instead
T 1708459878 18<25bertptrs18>	either way works
T 1708459906 18<25bertptrs18>	C has… error codes and out parameters, I guess
T 1708460005 18<20consus18>	? is cool! but it would be even cooler to go one step further and allow `foo().await?` instead of `Ok(foo().await?)`
T 1708460049 18<20j`ey18>	I mean with ? that would make it context sensitive I guess
T 1708460119 18<20consus18>	more than it now?
T 1708460128 18<20j`ey18>	yes?
T 1708460146 18<20j`ey18>	I assumed you were saying if it was the return value, the Ok would be implicit
T 1708460153 18<20consus18>	yeah
T 1708460615 18<25bertptrs18>	the annoucement blog for anyhow did something like that, with a proc macro, but honestly it just muddies the water and makes types harder to explain
T 1708462853 18<26dav1d18>	Isn't  `Ok(foo().await?)` just a `foo().await.map_err(Into::into)` if you prefer not to use the `?` here
T 1708462873 18<20consus18>	yeah
T 1708462874 18<25bertptrs18>	It is
T 1708462888 18<20consus18>	but since we already have ?
T 1708462906 18<20consus18>	kinda makes sense to use it here too
T 1708462919 18<20consus18>	let foo = may_fail()?;
T 1708462935 18<20consus18>	but  may_fail()? does not do the same
T 1708463012 18<25bertptrs18>	does it not?
T 1708463053 18<20consus18>	nope
T 1708463070 18<26dav1d18>	but it does
T 1708463073 18<20consus18>	nope
T 1708463082 18<26dav1d18>	okay nvm
T 1708463085 18<20consus18>	Ok(foo()?) works
T 1708463090 18<20consus18>	foo()? -- does not
T 1708463106 18<25bertptrs18>	because the return type of foo()? is T, not Result<T, E>
T 1708463109 18<20consus18>	what I  mean is  that foo()? cannot be on the last line
T 1708463122 18<25bertptrs18>	that's actually caused by it doing the same
T 1708463135 18<20consus18>	but it behaves differently
T 1708463137 18<26dav1d18>	exactly because it does the same it does not work
T 1708463144 18<20consus18>	and that's weird
T 1708463153 18<20consus18>	no?
T 1708463153 18<25bertptrs18>	no it behaves the same. It turns a Result<T, E> into a T (or returns early)
T 1708463166 18<20consus18>	well, perhaps
T 1708463174 18<25bertptrs18>	And if your function returns a Result<T, E> you cannot return a T from it
T 1708463183 18<20consus18>	yeah, makes sense
T 1708463184 18<26dav1d18>	`let foo = may_fail().unwrap();` `works but `may_fail().unwrap()` we should make unwrap behave special
T 1708463194 18<20consus18>	nah
T 1708463198 18<20j`ey18>	that's what I meant about context
T 1708463213 18<26dav1d18>	although we could also tell the compiler to implicitly wrap items in Ok if there is a result expected
T 1708463222 18<20consus18>	let foo = foo().await?.some()?.other()?.chains()?;
T 1708463246 18<20consus18>	it will return Result<T> if some() fails, for example
T 1708463254 18<20consus18>	it will even converse it for you
T 1708463266 18<20consus18>	which is good, right?
T 1708463270 18<25bertptrs18>	dav1d: that stops working when you introduce nested Results, which is not uncommon in generic code
T 1708463277 18<26dav1d18>	bertptrs, it is a terrible idea
T 1708463284 18<26dav1d18>	it would also fuck with infering types
T 1708463297 18<26dav1d18>	e.g. collecting into anything that is a result
T 1708463333 18<25bertptrs18>	yea
T 1708463335 18<25bertptrs18>	better not
T 1708464302 18<20cappy18>	Is there a way to get cargo(1) to clean --release just the object files (ELF) from a project directory?
T 1708465223 18<20cappy18>	I've been using: find . -exec file {} \; | grep -i elf | awk '{print $1}' to locate the files for rm(1) but there might be a better way.
T 1708465593 18<20polychromata{J}18>	why just the object files?
T 1708465763 18<20cappy18>	polychromata{J}: They can be rebuilt. The source and other files will be picked up by my backup program. No sense in backing up ELFs.
T 1708465801 18<20j`ey18>	but cargo clean wont delete the source files
T 1708465818 18<20j`ey18>	everything that cargo clean deletes can be rebuilt
T 1708465833 18<20polychromata{J}18>	why not just exclude the entire target directory from backups?
T 1708465845 18<20polychromata{J}18>	that might happen by default, even; cargo tags it as a cache
T 1708465860 18<20nullie18>	tags?
T 1708465866 18<20cappy18>	j`ey: All true. I just started using Rust/Cargo today.
T 1708465871 18<20polychromata{J}18>	yeah, look inside.
T 1708465872 18<20j`ey18>	puts a special file in the foldre
T 1708465895 18<20nullie18>	oh, TIL
T 1708465916 18<20j`ey18>	cappy: see if your backup program knows about https://bford.info/cachedir/
T 1708465944 18<20cappy18>	polychromata{J}: Of course.
T 1708465997 18<20cappy18>	j`ey: cachedir... I'll look at that. No my backup program does not see such. Might look at an alternative for backups.
T 1708466997 18<20cappy18>	borgbackup will exclude CACHEDIR.TAG directories. It's in my repo. Thanks for the help guys.
T 1708470467 18<19turlando18>	If I know that due to some incompatibility my program will only run on 64 bit architectures, is it possible to restrict the target platforms in Cargo.toml and at the same time get access to, e.g., From<usize> for u64?
T 1708470505 18<20j`ey18>	nope
T 1708470536 18<19turlando18>	Would it be something sane to implement myself?
T 1708470550 18<20j`ey18>	You couldn't implement the From<usize>
T 1708470564 18<20j`ey18>	you can error on the pointer size though, but I think only from code
T 1708470576 18<20jbg18>	but you can always just write `as usize` since you know it's fine
T 1708470627 18<20jbg18>	(in the process creating that incompatibility if it didn't already exist!)
T 1708470687 18<19turlando18>	Having it handled at type level would make me feel better
T 1708470702 18<19turlando18>	And sleep better at night maybe
T 1708470826 18<20jbg18>	should be possible to refuse to compile on non-64-bit arch. use something like #[cfg(not(target_pointer_width = 64))] compile_error!("only 64-bit architectures are supported");
T 1708470845 18<20jbg18>	then you can use `42u64 as usize` and still sleep at night
T 1708470901 18<19turlando18>	That is true untile somebody decides that 32 bits are fine and the compiler will gladly allow that :
T 1708470903 18<22Arnavion18>	Or `#[cfg(target_pointer_width = 64)] fn convert(a: usize) -> u64 { a as _ }` and use `convert()` everywhere
T 1708470920 18<22Arnavion18>	so the fn won't be defined if it can't be used safely
T 1708470935 18<19turlando18>	Arnavion: that looks much better as long as it's a non-op
T 1708471005 18<20jbg18>	the body is clearly a no-op, you could put #[inline(always)] on it if you are really worried
T 1708471026 18<19turlando18>	It still has to do runtime checks even in release mode?
T 1708471049 18<20j`ey18>	there's no runtime checks with as
T 1708471053 18<19turlando18>	Sorry, I was reading "it's not a non-op"
T 1708471093 18<20jbg18>	you could also do similar with a trait to make it feel a bit more like From
T 1708471170 18<19turlando18>	I'm not sure why I can't guard the impl From with #[cfg] (sorry for the noob question)
T 1708471205 18<20jbg18>	you can't impl From
T 1708471216 18<20jbg18>	to impl a trait either the trait or the type must be local to your crate
T 1708471220 18<20jbg18>	(that's the short version)
T 1708471241 18<20jbg18>	look up "rust orphan rule" for the long version
T 1708471269 18<20jbg18>	so you can write a trait FromPointerWidth {} and impl that for u64 but you can't impl From for u64
T 1708471323 18<20jbg18>	similarly, you could make a wrapper, struct MyU64(u64); and then impl From<usize> for that
T 1708471325 18<19turlando18>	Oh, right, that's similar to how typeclass instances must be implemented
T 1708473217 19*	Now talking on 22##rust
T 1708473217 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708473217 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708484467 18<25Mikachu18>	https://github.com/Speykious/cve-rs
T 1708485262 18<26daddy18>	so glad i figured out what GLWTSPL was on first guess
T 1708487699 18<25Diablo-D318>	https://github.com/Speykious/cve-rs
T 1708487703 18<25Diablo-D318>	but why
T 1708488258 18<25Mikachu18>	i guess they got tired of the bug going unfixed for 6 years so they made some proofs of concept?
T 1708489733 18<26danieldg18>	they could at least expand that to use any of the other unsoundness bugs
T 1708489778 18<26danieldg18>	there are a few more to choose from afaik - typeid hash collisions are the one I recall offhand
T 1708490360 18<29phy172918>	Should have come up with a catchy name if they really wanted it fix. Unsafe at any lifetime is my terrible stab at it.
T 1708492647 18<25Widdershins18>	looking forward to the new trait solver tho...
T 1708492664 18<25Widdershins18>	i have some gripes with the way this one works
T 1708494015 18<25Mutabah18>	So do I... grumble grumble accepting tautalogical bounds
T 1708494045 18<25Mutabah18>	I've spent the two weeks thinking through/experimenting with a mrustc issue related to a crate having a tautalogical trait bound.
T 1708494092 18<25Mutabah18>	`S: SomeTrait, &S: SomeTrait<Assoc=S::Assoc>`, but there's a blanket `impl<S: SomeTrait> SomeTrait for &S { type Assoc = S::Assoc; }`
T 1708496203 18<26dav1d18>	turlando, or instead of converting u64 to usize, you convert usize to u64 which even works on 32bit platforms
T 1708498539 18<22davros118>	Any interesting features on the horizon in Rust .. have been obsessed with AI for a while and not keeping track of the language changes
T 1708498560 18<22davros118>	I remember a problem stopping nested 'From' impl
T 1708498573 18<22davros118>	Which might have needed a workaround like negative impl's or something
T 1708498581 18<22davros118>	Negative trait bounds (I forget)
T 1708501889 18<25bertptrs18>	negative trait bounds aren't on the way AFAIK, and the last release was a bit quiet, but before that we got async in traits and RPITIT which I find a hilarious acronym but also very useful
T 1708503065 18<24Bish18>	if a method returns a reference and i want to match it, why do i have to match with a reference? isnt this especially confusing with @str?
T 1708503071 18<24Bish18>	&str*
T 1708503080 18<24Bish18>	i am guessing it's a special case there?
T 1708503117 18<24Bish18>	https://github.com/hyperium/hyper/blob/00a703a9ef268266f8a8f78540253cbb2dcc6a55/examples/echo.rs#L24 for example this
T 1708503208 18<25Mutabah18>	You match a reference with a reference, that's how matching works
T 1708503217 18<25Mutabah18>	although, "match ergonomics" sometimes hides it
T 1708503233 18<25Mutabah18>	string literals are of type `&str`, so they match against a `&str`
T 1708503321 18<24Bish18>	what if i have 2 equal objects but they're duplicates
T 1708503328 18<24Bish18>	what happens if i match their references?
T 1708503363 18<24Bish18>	i guess the (Partial)Eq trait's == will get called and it can be whatever?
T 1708503377 18<25Mutabah18>	No, matching destructures to compare
T 1708503390 18<25Mutabah18>	and you can't match against a variable
T 1708503508 18<24Bish18>	hm confusing
T 1708503552 18<20jbg18>	how so?
T 1708503577 18<24Bish18>	i don't understand if that's a pointer comparison now
T 1708503589 18<20jbg18>	there is no comparison as such
T 1708503590 18<24Bish18>	or thje contents of the referenced object will be compared
T 1708503594 18<20jbg18>	not in the sense you are thinking
T 1708503595 18<20jbg18>	the left hand side of a match is a pattern, ideally one of the first concepts you learn in rust
T 1708503616 18<20jbg18>	names in there are new bindings, not the names of existing variables to compare to
T 1708503625 18<20jbg18>	you have other tools for that, like `if a == b`
T 1708503632 18<24Bish18>	so the compiler just compares the names, a constant struct in this case
T 1708503655 18<20jbg18>	you're matching structure -- types -- not content
T 1708503665 18<24Bish18>	ah okay
T 1708503677 18<20jbg18>	the book chapter on patterns is instructive here
T 1708503684 18<24Bish18>	but for &str that's special
T 1708503686 18<20jbg18>	https://doc.rust-lang.org/book/ch18-00-patterns.html
T 1708503688 18<25Mutabah18>	`match foo { bar => ... }` just defines `bar` as a variable with the same value as `foo`
T 1708503713 18<25Mutabah18>	`match foo { path::to::BAR => ... }` only works if `BAR` is a `const`, and it compares the contents (not using `==`)
T 1708503721 18<20jbg18>	Bish: any literals can be used in match
T 1708503729 18<20jbg18>	(as well as constants)
T 1708503782 18<20jbg18>	it's not that it's special for &str as such, but special for string literals. `match foo { bar => ... }` in Mutabah's example is still the same if foo is a &str
T 1708503826 18<20jbg18>	but `match foo { "bar" => ... }` will only compile if foo is a &str and will execute that arm only if it is "bar"
T 1708503861 18<25bertptrs18>	Bish: refererences compare by contents, pointers compare by address. This is also documented as such https://doc.rust-lang.org/std/primitive.reference.html
T 1708504181 18<24Bish18>	> Reference equality by address, instead of comparing the values pointed to
T 1708504215 18<24Bish18>	isn't that the opposite of "refererences compare by contents"
T 1708504246 18<25Mutabah18>	Did you read the rest of that sentence?
T 1708504261 18<25Mutabah18>	> is accomplished via implicit reference-pointer coercion and raw pointer equality via ptr::eq, while PartialEq compares values.
T 1708504279 18<24Bish18>	yeah i don't see where that dereferences
T 1708504285 18<24Bish18>	it sounds like pointer get compared
T 1708504294 18<24Bish18>	to me that is
T 1708504307 18<25Mutabah18>	It's saying that to compare two references by address you use `std::ptr::eq(ref1, ref2)`
T 1708504325 18<25Mutabah18>	(which will coerce `&T` to `*const T` then compare the two `*const T`s - comparing the addresses)
T 1708504364 18<24Bish18>	oh yeah i misread that sentence
T 1708504567 18<24Bish18>	so matching with (&Method::GET, "/test") will call .eq of both of them, right?
T 1708504583 18<24Bish18>	there i no pattern matching happening except for the tuple maybe
T 1708504653 18<28erk18>	Mutabah: To compare by address you actually don't want std::ptr::eq, you instead want the newly added std::ptr::addr_eq
T 1708504675 18<28erk18>	Otherwise it will use some fat pointer information that can give strange results.
T 1708504693 18<25Mutabah18>	erk: I was quoting docs
T 1708504838 18<24Bish18>	so match will pattern match and call .eq() for concrete types?
T 1708504856 18<24Bish18>	conrecte values*
T 1708504916 18<25Mutabah18>	It doesn't use `.eq`... it just uses primitive comparisons
T 1708505005 18<24Bish18>	so it uses.. == ?
T 1708505019 18<24Bish18>	what would i use to emulate match
T 1708505093 18<25Mutabah18>	it uses `==` and `memcmp` - match is a low-level language construct, so expands to some very low level things
T 1708505215 18<24Bish18>	when is == equal to .eq() if there is no primitive comparision?
T 1708505245 18<24Bish18>	Mutabah: wouldn't that mean i coulnd't compare something that is not copy?
T 1708505275 18<25Mutabah18>	if you write `foo == bar` then the `PartialEq::eq` trait method is invoked... unless it's a primitive integer/bool/float type, which the compiler already inherently knows how to equate
T 1708505297 18<25Mutabah18>	Maybe you should play around with `match` and read the book/reference on how it works
T 1708505346 18<24Bish18>	well, i don't feel like it helps me understanding how it operates, but i will try
T 1708505371 18<25Mutabah18>	Or, if you're brave - you could attempt to understand the mrustc `match` lowering code :)
T 1708505496 18<24Bish18>	i was hoping there is a simple explanation for example it just being .eq()
T 1708505541 18<25Mutabah18>	pattern matching is destructuring until it finds a pattern that doesn't destructure (i.e. a literal)
T 1708505542 18<24Bish18>	i compiled & looking at the assembler of something already and it seems to call into partialeq for &str
T 1708505623 18<24Bish18>	but for u32 it creates code on the spot
T 1708505645 18<24Bish18>	but i feel like that would happen if i did it without match as well
T 1708505756 18<24Bish18>	so match does many things. not a single thing.. okay
T 1708505959 18<25Mutabah18>	It does a LOT of things
T 1708505974 18<25Mutabah18>	for context - mrustc's match lowering code is larger than the rest of MIR lowering
T 1708506072 18<24Bish18>	why does that exist.. :o
T 1708506082 18<24Bish18>	is it the first rust compiler? because it says reimplementation
T 1708506139 18<25Mutabah18>	It's not the first, it's my project (hence why I know it's internals) to create a bootstrapping rust compiler
T 1708506157 18<25Mutabah18>	`match` is complex and powerful
T 1708506178 18<24Bish18>	why did you do this project?
T 1708506256 18<25Mutabah18>	fun?
T 1708506268 18<24Bish18>	i can get behind that
T 1708506303 18<25Widdershins18>	i am currently also doing a fun project (writing like 11 thousand words of documentation for a personal project for some reason)
T 1708506350 18<24Bish18>	i bet most people would disagree with your definitions of fun
T 1708507893 19*	Now talking on 22##rust
T 1708507893 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708507893 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708508320 19*	Now talking on 22##rust
T 1708508320 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708508320 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708509558 18<24Bish18>	Mutabah: why wouldn't i read up rustcs code
T 1708509558 18*	25Mutabah is away (not here ...)
T 1708509567 18<24Bish18>	would you say that's even more daunting?
T 1708510180 18<25bertptrs18>	Widdershins: can I dm you about something?
T 1708511178 18<25Mutabah18>	Bish: You could, I just don't know exactly where it is or how it looks (the `match` impl)
T 1708511505 18<20j`ey18>	Mutabah: so you didnt start mrustc by running rust2c on rustc?
T 1708511507 18<20j`ey18>	:p
T 1708511905 18<25Mutabah18>	j`ey: Well... strictly speaking that was what mrustc started out as - convert AST to C
T 1708511932 18<25Mutabah18>	but by the time I got anywhere near close to codegen, that was gone and C was backend
T 1708512353 18<25Widdershins18>	bertptrs: what's up
T 1708515686 18<24Bish18>	im still on my http2 streaming bodies adventure
T 1708515714 18<24Bish18>	https://bpa.st/5QQA but im stuck on e=hyper::Error(User(ManualUpgrade))
T 1708515731 18<24Bish18>	if someone knows whats going on it'd be cool
T 1708515783 18<24Bish18>	(specificially the websocket route, the rest works)
T 1708515985 18<24Bish18>	https://github.com/hyperium/hyper/blob/00a703a9ef268266f8a8f78540253cbb2dcc6a55/src/upgrade.rs#L264 https://github.com/hyperium/hyper/blob/00a703a9ef268266f8a8f78540253cbb2dcc6a55/src/server/conn/http1.rs#L220 this seems to be the "callstack" on that error
T 1708516127 18<24Bish18>	fuck me, im so stupid
T 1708516133 18<24Bish18>	rubber ducky best method
T 1708530419 19*	Now talking on 22##rust
T 1708530419 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708530419 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708531929 18<22bombastick18>	Hi
T 1708532597 18<22Aorimn18>	hi, what would be the most idiomatic way of converting a [u8; 6] to a [u8; 8] by adding zeroes to the end of it (so that I can u64::from_le_bytes() it afterward)?
T 1708532623 18<22Aorimn18>	the only solution I can think of is copying the bytes in a loop, but that doesn't sound nice
T 1708532635 18<22bombastick18>	what % of you use Rust for work as your primary language, as opposed to hobbyist?
T 1708532662 18<22Aorimn18>	I have this 6 size because I'm reading (impl Read) those 6 bytes
T 1708532692 18<25bertptrs18>	let mut dest = [0u8; 8]; reader.read(&mut dest[..6])?
T 1708532827 18<22Aorimn18>	ah... that's even better indeed ^^'   thanks bertptrs!
T 1708532851 18<25bertptrs18>	err, read_exact of course
T 1708532857 18<25bertptrs18>	close enough
T 1708532894 18<22Aorimn18>	yeah, I managed to make the translation :)
T 1708532895 18<25bertptrs18>	ideally the compiler realizes that it doesn't have to zero initialize the first 6 bytes but if not it's just six bytes, how hard can it be
T 1708532961 18<22Aorimn18>	in this case I'm not too strict on performances, I'll code the feature before looking at such issues (not even sure it'll be in a hot path at this point)
T 1708533058 18<25bertptrs18>	good decision
T 1708541622 18<19flipchan18>	im trying to print some ascii art, does anyone know any crates that lets you autoscale a string based on terminal size?
T 1708541646 18<19flipchan18>	I'm trying to scale the ascii art based on terminal size so it will work on all terminal sizes
T 1708541682 18<26danieldg18>	look for wrappers around ncurses or just access to termios in general to get the size
T 1708541685 18<25bertptrs18>	terminal_size and then wrap it yourself?
T 1708541688 18<25bertptrs18>	that's what clap does
T 1708541692 18<29alip18>	BufRead::lines() will OOM when you hand it /dev/zero, bug or feature?
T 1708541708 18<26danieldg18>	alip: working as intended
T 1708541718 18<29alip18>	nice
T 1708541725 18<25bertptrs18>	alip: you made it read until the end of the line, when there was no end of the line
T 1708541728 18<25bertptrs18>	what did you expect?
T 1708541734 18<26danieldg18>	alip: just like loop { vec.push(0) } OOMs
T 1708541740 18<29alip18>	i expected no newline found in LINE_MAX bytes with ENAMETOOLONG
T 1708541748 18<29alip18>	and hence i implemented it myself
T 1708541753 18<29alip18>	never trust rust stdlib lol
T 1708541780 18<26danieldg18>	LINE_MAX? is that the thing that gets() uses, but only if on a TTY?
T 1708541798 18<29alip18>	no line_max is just a random big number doesn't matter what
T 1708541806 18<29alip18>	friends don't oom on each other
T 1708541815 18<26danieldg18>	it'll never be big enough
T 1708541825 18<29alip18>	the alternative is far worse
T 1708541841 18<25bertptrs18>	going OOM on infinite input isn't that bad
T 1708541847 18<26danieldg18>	I want to read json-lines files with .lines() and have json blobs not be limited to a few MB
T 1708541864 18<29alip18>	i can see why the never big enough argument is logical
T 1708541866 18<25bertptrs18>	arbitrarily splitting lines after so many characters is bound to lead to weird surprises
T 1708541874 18<29alip18>	but then i'd at least expect a warning in lines() docs about this
T 1708541894 18<26danieldg18>	alip: the lack of a LINES_MAX reference *is* the warning
T 1708541905 18<29alip18>	nice
T 1708541912 18<29alip18>	never trust the stdlib docs
T 1708541931 18<26danieldg18>	if that's how you define trust...
T 1708541953 18<29alip18>	you say the lack of stating a limit is good enough for the code ooming on you
T 1708541958 18<29alip18>	and yes, that's how i define trust
T 1708541964 18<25bertptrs18>	code OOM'ing is safe behaviour
T 1708541970 18<29alip18>	mmph ofc it is
T 1708541972 18<29alip18>	ok nvm
T 1708541979 18<25bertptrs18>	as opposed to the alternatives it is
T 1708541985 18<26danieldg18>	you could just as easily call it an OS bug
T 1708541997 18<25bertptrs18>	BufRead::lines() has issues but this is not (imo) one of them
T 1708542021 18<26danieldg18>	/dev/zero should stop after you've read too much data
T 1708542035 18<26danieldg18>	maybe prompt you to be sure you want to read that much
T 1708542035 18<25bertptrs18>	I'd much prefer an API where you can hand out your own buffer
T 1708542039 18<25bertptrs18>	alas
T 1708542049 18<25bertptrs18>	(yes there's read_line but that's not an iterator)
T 1708542050 18<29alip18>	ye that'd solve it too bertptrs
T 1708542069 18<29alip18>	danieldg: c'mon now you're just being ridicilous
T 1708542092 18<29alip18>	it just means calling lines() in the wrong context may mean DOS
T 1708542103 18<29alip18>	and documenting that is nice and kind
T 1708542105 18<29alip18>	ofc it's safe
T 1708542149 18<26danieldg18>	calling any read function can mean dos if you don't put limiters on it
T 1708542162 18<26danieldg18>	lines() doesn't work well with nonblocking after all
T 1708542182 18<19int-e18>	danieldg: so my takeaway from that talk is that I'm not the first one to be surprised by Linux's madvise semantics ;-)
T 1708544281 19*	Now talking on 22##rust
T 1708544281 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708544281 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708545260 18<20capitol18>	I have this idea of a new clippy lint, maybe of the pedantic type. One way to make your code be non-portable to 32-bit arches is to write something like: let foo : usize = 4294967295;
T 1708545286 18<20capitol18>	and this feels like it would be nice to have a warning about
T 1708545416 18<20j`ey18>	you can just try compile for 32 bits :P
T 1708545424 18<26danieldg18>	how pedantic should it be?  Rust tries to be able to run with 16-bit usize too
T 1708545449 18<26danieldg18>	but there's a lot of code that wants more than 64K for things
T 1708545488 18<26danieldg18>	it's not too uncommon to want a vec![0;1<<20] as a buffer (1MB)
T 1708545642 18<20capitol18>	yeah, the 16 bit one should maybe be it's own lint, so that it would be able to enable just the ones that you support
T 1708545672 18<26danieldg18>	also, anything over 1<<31 in a usize will start to cause problems on 32-bit
T 1708545679 18<26danieldg18>	over or equal to
T 1708545692 18<20capitol18>	j`ey: true, this is more so that I hopefully don't have to send to many patches to other projects when I package for debian :)
T 1708545716 18<20capitol18>	yes
T 1708546644 18<28Vorpal18>	Hm I have a crate that can have multiple backends (for talking to distro package managers, different ones for different Linux distros). You can build with support for multiple. But if I disable all features it doesn't work, due to empty enums and the like. Which is a problem for publishing the crate. What is the recommended approach for this. I don't think it makes sense to set any specific distro backend as a default feature either.
T 1708546653 18<28Vorpal18>	The issue is enums like this one: https://0x0.st/H5bj.txt
T 1708546680 18<20j`ey18>	whats the issue with an empty enum?
T 1708546702 18<28Vorpal18>	j`ey: well match statements on those (with similar cfg directives) doesn't work when the body of the match statement becomes empty
T 1708546703 18<20j`ey18>	empty enums are fine in general
T 1708546708 18<28Vorpal18>	error[E0004]: non-exhaustive patterns: type `&config::Backend` is non-empty
T 1708546727 18<20j`ey18>	can you paste the code that fails
T 1708546732 18<20j`ey18>	 / full error
T 1708546740 18<28Vorpal18>	one second
T 1708546762 18<20j`ey18>	https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=6ed4245c28a8728d6edc7c355c313087
T 1708546848 18<26danieldg18>	depending on what you actually need, you could just add a 'not implemented' backend that is always available.  But yes, this should work already.
T 1708546849 18<28Vorpal18>	https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=3bd573a790b0fcaad5bff662d8b9e77d
T 1708546852 18<22Arnavion18>	Publishing shouldn't be a problem. You can do `--features` with `cargo publish`
T 1708546870 18<28Vorpal18>	ah, the issue seems to be the reference
T 1708546870 18<22Arnavion18>	so you can pick one or all of them just to satisfy `cargo publish`
T 1708546877 18<20j`ey18>	ah right
T 1708546897 18<26danieldg18>	wait, references are always inhabited now?  When did this happen?
T 1708546907 18<28Vorpal18>	hm for this enum it works, I have another one (different file checksums) where it will be trickier since it isn't copy
T 1708546931 18<20j`ey18>	danieldg: wasnt that always the case??
T 1708546953 18<26danieldg18>	j`ey: pretty sure you used to be able to match reference {}
T 1708546954 18<20j`ey18>	Vorpal: I think danieldg's suggestion of a NullBackend is probably the easiest.. maybe
T 1708546989 18<26danieldg18>	I think I used it in some Infallible impls
T 1708547008 18<28Vorpal18>	j`ey: for backend I don't need the reference (payload-less enum, Copy). For https://0x0.st/H5b2.txt I have a very similar situation, there I don't want to copy, so that will be trickier
T 1708547021 18<20j`ey18>	danieldg: same error on 1.18
T 1708547034 18<26danieldg18>	j`ey: ahh, "match *self" works
T 1708547040 18<26danieldg18>	Vorpal: you could use that
T 1708547064 18<28Vorpal18>	danieldg: won't that result in a copy though? For the second case.
T 1708547073 18<28Vorpal18>	(that is https://0x0.st/H5b2.txt )
T 1708547088 18<22Arnavion18>	Just do `--features` instead of adding a fake backend or changing your code...
T 1708547090 18<26danieldg18>	you can start throwing in ref in your match arms
T 1708547101 18<28Vorpal18>	Arnavion: yeah probably the right choice
T 1708547106 18<26danieldg18>	it will not force a copy
T 1708547126 18<28Vorpal18>	or that, that works too
T 1708547184 18<26danieldg18>	I suppose I wrote the Infallible matches prior to match ergonomics and didn't notice they used *
T 1708547261 18<28Vorpal18>	Arnavion: actually, right now --features work, but I plan to add other packages and data source types (flatpak, snap, rpm, tmpfiles.d) not all of them have all info on installed files, not all of them have info on installed packages, Some have both, some have either or. So I believe I could end up in a similar situation if I only build support for snap and flatpak say (no need to depend on any checksum library for those)
T 1708547289 18<28Vorpal18>	So I'm going with ref
T 1708547371 18<28Vorpal18>	still end up with a bunch of warnings though for --no-default-features (variable don't need to be mutable, unused variants, etc). Oh well. I think I'll live with that.
T 1708547446 18<20j`ey18>	you could also just explicitly fail to compile with no backend selected
T 1708547528 18<28Vorpal18>	I could yes, might make sense to tell any users other than me how to use it properly.
T 1708548459 18<22Arnavion18>	Vorpal:   https://github.com/Arnavion/k8s-openapi/blob/master/build.rs#L9-L60   If you need inspiration
T 1708548524 18<28Vorpal18>	#[cfg(not(any(feature = "arch_linux", feature = "debian")))] compile_error!("At least one backend must be enabled");
T 1708548534 18<28Vorpal18>	seems simpler
T 1708548603 18<28Vorpal18>	no need to add a build script if I don't need to
T 1708548619 18<22Arnavion18>	Yes, if it's just `any(feature, feature)` you can do it inline
T 1708548928 18<28Vorpal18>	well, I assume any takes any number of arguments, so I should be able to continue once I add more backends too
T 1708549040 18<22Arnavion18>	Yes
T 1708553966 19*	Now talking on 22##rust
T 1708553966 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708553966 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708554077 19*	Now talking on 22##rust
T 1708554077 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708554077 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708557493 18<26bwidawsk18>	I want to keep a hashmap where the values in the map are a hashable object. I don't care what the key will be, as it's an opaque handle that is used by the caller in the API. What is the best way to create unique keys to associate with the object? (I was thinking `hashmap.insert(object.hash(), object)`)
T 1708557514 18<26bwidawsk18>	(Could also use an atomic as an index ofc)
T 1708557576 18<22Arnavion18>	object.hash() is fine. To avoid double-hashing you can use something like   https://docs.rs/hash_hasher
T 1708557591 18<22Arnavion18>	or BTreeMap
T 1708557642 18<26bwidawsk18>	Arnavion: thank you
T 1708564558 18<26segfaultfizzbuzz18>	are there any good recommendations for how to store a secret string/token in a rust binary?
T 1708564607 18<26danieldg18>	either anywhere or nowhere
T 1708564615 18<26danieldg18>	anywhere if the binary can be a secret, nowhere if not
T 1708564788 18<26segfaultfizzbuzz18>	so a const String is about as good as it gets i guess?
T 1708564805 18<26segfaultfizzbuzz18>	i am aware of SGX but i can't do that unfortunately...
T 1708564835 18<26danieldg18>	yes, if you're not able to store it anywhere else secure either
T 1708564858 18<26danieldg18>	HSM, TPM, etc
T 1708564881 18<26segfaultfizzbuzz18>	so this isn't worthwhile for instance: https://crates.io/crates/secstr
T 1708564930 18<25Mutabah18>	that would help prevent runtime leaks
T 1708564976 18<25Mutabah18>	but the original secret will still be in the binary somewhere - you can obsfucate it, but that only adds a thin layer of protection
T 1708565007 18<26segfaultfizzbuzz18>	runtime leaks? on a related note, can unsafe code read/modify the program itself (which i suppose is in memory..?)  ?
T 1708565063 18<26segfaultfizzbuzz18>	secstr isn't stored on github, which is odd
T 1708565248 18<26danieldg18>	segfaultfizzbuzz: read, usually; modify, no, not unless it takes action to call mprotect
T 1708565290 18<26segfaultfizzbuzz18>	why wouldn't the operating system wall the program code off from the data ?
T 1708565308 18<26danieldg18>	most architectures don't support that
T 1708565326 18<26segfaultfizzbuzz18>	yipes
T 1708565347 18<25cehteh18>	moderm ones do, but ther are a zillion ways to circumvent it
T 1708565379 18<26danieldg18>	ASLR helps too
T 1708565396 18<26danieldg18>	but yeah, 'bypassing ASLR' is like 'hacking 102' these days
T 1708565425 18<25cehteh18>	x86-64 has write protection on executable pages
T 1708565440 18<26segfaultfizzbuzz18>	you would think that there would be read protection for those as well...
T 1708565446 18<26danieldg18>	yes - executable plages are *normally* write protected
T 1708565459 18<26danieldg18>	there's not normally a need or desire to read protect
T 1708565463 18<25cehteh18>	but a program could do all kinds of fancy stuff like creating a dynlib and loading that
T 1708565471 18<26segfaultfizzbuzz18>	...but why would you want to read at all?
T 1708565490 18<26danieldg18>	segfaultfizzbuzz: code and read-only data can share pages
T 1708565499 18<25cehteh18>	on linux you can do a lot protection with seccomp, but its not trivial
T 1708565504 18<26segfaultfizzbuzz18>	memory locality/speed then?
T 1708565518 18<26danieldg18>	seccomp doesn't help with read the executable
T 1708565534 18<26danieldg18>	you need less common things like memory protection keys
T 1708565547 18<25cehteh18>	yes but seccomp makes sure that a program cant m(un)protect pages it shouldn
T 1708565574 18<25cehteh18>	or load dynlibs and so on
T 1708565576 18<26danieldg18>	the memseal system calls are useful here too
T 1708565651 18<26segfaultfizzbuzz18>	darpa Measures for Establishment of Memory Signatures in Early Activated Lymphocytes
T 1708565709 18<26danieldg18>	no
T 1708565756 18<26danieldg18>	https://lwn.net/Articles/958438/
T 1708566272 18<26danieldg18>	basically a well-written program won't read from arbitrary memory addresses and so won't be a problem
T 1708566318 18<26danieldg18>	so just rely on that - rust doesn't let you bypass it without unsafe
T 1708566338 18<26segfaultfizzbuzz18>	right ok thanks
T 1708568561 18<25dkg18>	i'm struggling with Rust's C FFI: i'm building a shared object in Rust that exposes a function to the C ABI.  I want the external C code to be able to call the function with an argument that is a pointer to a fixed-length buffer of chars.  this argument, if non-null, will be used to return a limited-length, null-terminated error string if the function fails.
T 1708568615 18<25dkg18>	i'm having trouble with the typing for this buffer and how to get a Rust string error message to be written to it properly.
T 1708568623 18<26danieldg18>	*mut u8
T 1708568637 18<25Mutabah18>	By fixed-length, do you mean ABI/API specified, or is the length in another argument?
T 1708568649 18<25Mutabah18>	If it's the former - then `*mut [u8; 123]`
T 1708568660 18<25dkg18>	what i've got so far is:     #[repr(C)] pub struct foo_err_msg { message: [c_char; 128], }
T 1708568678 18<25dkg18>	the API specifies that the error buffer is always  a simple struct with 128 chars in it.
T 1708568700 18<25dkg18>	then the argument to the function is Option<&mut foo_err_msg>
T 1708568716 18<25Mutabah18>	that all seems reasonable
T 1708568726 18<25dkg18>	and i'll only write to it if let Some(err_out) = err_out
T 1708568739 18<25dkg18>	so the problem i'm having in the function is figuring out how to write to the buffer
T 1708568747 18<26danieldg18>	I'd use u8 and not c_char
T 1708568760 18<26danieldg18>	because rust prefers writing to u8
T 1708568778 18<26danieldg18>	and it's not like C actually cares if char is signed or not 99.9% of the time
T 1708568786 18<25dkg18>	hm, but in the C interface i'd prefer it is a char, because that's a clean hint to the C user that this will be a null-terminated string.
T 1708568803 18<25dkg18>	and if we're gonna get typing right, i kind of want to get it right :P
T 1708568817 18<26danieldg18>	here's a secret: char* and unsigned char* have the same ABI :)
T 1708568822 18<25dkg18>	but yeah, i'm seeing messgaes like: expected `[i8; 128]`, found `&[u8]`
T 1708568853 18<25dkg18>	i'm aware that they have the same ABI, i'm just trying to do this cleanly by respecting the type system and not tricking it :)
T 1708568854 18<26danieldg18>	yes, because rust wants to write to u8
T 1708568880 18<26danieldg18>	you can just impl std::io::Write for your struct foo_err_msg
T 1708568886 18<26danieldg18>	or fmt::Write, if you like
T 1708568905 18<26danieldg18>	copy the bytes one by one and cast them from u8 to i8
T 1708568946 18<25dkg18>	well, from u8 to std::ffi::c_char, since presumably different platforms have different c_chars -- they aren't all i8 :/
T 1708568958 18<26danieldg18>	yes
T 1708568961 18<25dkg18>	it happens to be i8 on my platform
T 1708568972 18<26danieldg18>	it's i8 or u8 basically everywhere
T 1708569003 18<25dkg18>	agreed
T 1708569005 18<26danieldg18>	only systems that aren't byte-addressible can get away with char not being a byte
T 1708569051 18<25dkg18>	but again, i'm trying to do clean typing without assumptions; that's one of the things i find compelling about Rust.  maybe i'm being too much of a purist
T 1708569095 18<26danieldg18>	your cast can be char, yes
T 1708569100 18<25dkg18>	so even if i switch to u8 instead of std::ffi::c_char, i get: expected `[u8; 128]`, found `&[u8]`
T 1708569113 18<25dkg18>	how do i deal with the length limit safely?
T 1708569123 18<26danieldg18>	you use a ref?
T 1708569124 18<25dkg18>	sorry if this is a n00b question, i'm a n00b 😛
T 1708569141 18<25Mutabah18>	you want .copy_from_slice
T 1708569151 18<25Mutabah18>	which might also require slicing the destination to the right length
T 1708569155 18<25dkg18>	yes, i'm using Option<&mut foo_err_msg>  and i'm in the case where "if let Some(err_msg) = err_msg {"
T 1708569170 18<25Mutabah18>	Or, a custom loop that writes into the destination and ensures that it's NUL terminated
T 1708569190 18<25dkg18>	i was hoping to use something like CString.as_bytes_with_nul()
T 1708569199 18<25dkg18>	so that i don't have to write any custom byte-level loops
T 1708569221 18<26danieldg18>	you'll still have to copy the memory from the CString to the output
T 1708569226 18<25dkg18>	agreed.
T 1708569231 18<25dkg18>	(fwiw, i'm jumping through these hoops to try to avoid any memory allocations across the FFI)
T 1708569232 18<26danieldg18>	but that could be with copy_from_slice
T 1708569258 18<26danieldg18>	writing to the destination buffer in-place is "nicer"
T 1708569275 18<26danieldg18>	vs writing to a String, converting to CString, then copying
T 1708569285 18<25dkg18>	i agree, it does seem cleaner to write to the destination buffer in place
T 1708569322 18<25dkg18>	but i don't know how to do that :/  and, in some cases, i'll have an Err that i want to extract a (potentially truncated) message from and copy it in
T 1708569403 18<26danieldg18>	dkg: struct Writer { buf: &mut [c_char] }  impl Writer { fn new(buf:&mut [c_char;128]) -> Self { Self { buf }}} impl std::fmt::Write for Writer { ...
T 1708569453 18<26danieldg18>	you can maintain the null-termination invariant as you write, or do it in Drop
T 1708569521 18<26danieldg18>	write_str is where you put either your u8->c_char loop, or a copy_from_slice if you decide to use u8 not c_char
T 1708569538 18<26danieldg18>	then you can call write!() on your Writer
T 1708569590 18<26danieldg18>	write_str should advance self.buf - that's why it uses a slice, not an array
T 1708569608 18<25dkg18>	thanks!  still trying to wrap my head around this…  i need a new struct to do this?  or i put this impl on my foo_err_msg ?
T 1708569616 18<26danieldg18>	new struct
T 1708569645 18<26danieldg18>	it has to track the 'cursor'
T 1708569700 18<25dkg18>	i see, the Writer struct is just the cursor tracker
T 1708569763 18<25dkg18>	ok, you've given me enough to chew on, i'll try to sort it out further.  thanks!  i thought this would be a bit simpler than it is turning out to be :/
T 1708570098 18<26danieldg18>	the simple way is to use the existing io::Write impl for &mut [u8]
T 1708570149 18<26danieldg18>	you can cast a &mut [u8;128] to a &mut [u8] and then write to it
T 1708570211 18<26danieldg18>	or even the one for Cursor<[u8;N]>
T 1708570240 18<26danieldg18>	I just noticed that one, it's nicer for this case
T 1708590780 18<24SiegeLord18>	Lets say I have a trait: `trait Foo { fn call(&self, ctx: impl Context) -> (); }`, is there a way to automatically implement it for functions with the same signature as the `call` associated function?
T 1708590803 18<24SiegeLord18>	Like a `fn foo(ctx: impl Context) -> () {}`
T 1708590831 18<25bertptrs18>	Sort of
T 1708591029 18<24SiegeLord18>	The final goal is to somehow write: `fn bar(call: impl Fn(impl Context) -> ()`
T 1708591048 18<24SiegeLord18>	Which isn't possible, so I'm attempting to write `fn bar(call: impl Foo)`
T 1708591062 18<24SiegeLord18>	But I want to do something approximating `bar(foo)`
T 1708591143 18<24SiegeLord18>	It's clear that I can, for every `foo`, write a manual implementation for some dummy type `F`, but I wonder if there's something with less boilerplate
T 1708591158 18<24SiegeLord18>	manual implementation of `Foo`
T 1708591211 18<25bertptrs18>	Ah I see, the problem is that you cannot have "impl Trait" in a trait bound
T 1708591223 18<25bertptrs18>	so my idea doesn't work https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=77a5b8655b47befd6cae887993bf6250
T 1708591272 18<25bertptrs18>	The double generics make it hard
T 1708591303 18<24SiegeLord18>	I think this is a type of HKT, so perhaps something using GATs could be a solution, but that's as far as that line of thought goes
T 1708591331 18<25bertptrs18>	I don't think you can express this particular thing yet. Which is sad, it's not an unreasonable question
T 1708591360 18<25bertptrs18>	If you can tweak the Foo trait a little it might work
T 1708591395 18<24SiegeLord18>	I can, it's something I fully control.
T 1708591409 18<25bertptrs18>	https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=27e2d1dc09c79939e69c9a917784863f
T 1708592096 18<24SiegeLord18>	Ah, that won't work. Here's the version with the dummy type, perhaps clarifying the design goals: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=3d7636e6c165af5ad4b5d0e12dad864d
T 1708597392 18<27sword_smith18>	Is a (u64,u64)->u128 multiplication as fast on my x86-64 machine as a (u32,u32)->u64 multiplication?
T 1708597537 18<25Mutabah18>	probably pretty close on its own...
T 1708597546 18<25Mutabah18>	but more data takes longer to load/manipulate
T 1708597632 18<28Norkle18>	hi
T 1708597687 18<25Mutabah18>	Hello.
T 1708597696 18<25Mutabah18>	Interesting hostname you have there
T 1708598605 18<29saati18>	sword_smith: on most cpus multiplication takes variable time determined by it's inputs
T 1708598631 18<29saati18>	bigger numbers can take a couple more cycles
T 1708598697 18<29saati18>	iirc zen4 has const time multiplication
T 1708598748 18<25Mutabah18>	saati: eeeh... multiplication units can be done in constant time based on the bit size
T 1708598778 18<25Mutabah18>	shift+add for each bit in the other number
T 1708599006 18<29saati18>	let's benchmark
T 1708599261 18<27sword_smith18>	saati: Thanks. I have a benchmark here, but it does some annoying addition, that I would like to remove: use std::ptr;
T 1708599264 18<27sword_smith18>	use criterion::measurement::WallTime;
T 1708599266 18<27sword_smith18>	use criterion::{
T 1708599269 18<27sword_smith18>	    criterion_group, criterion_main, BenchmarkGroup, BenchmarkId, Criterion, Throughput,
T 1708599272 18<27sword_smith18>	};
T 1708599274 18<27sword_smith18>	use twenty_first::shared_math::other::random_elements;
T 1708599277 18<27sword_smith18>	fn mul(c: &mut Criterion) {
T 1708599279 18<27sword_smith18>	    let mut group = c.benchmark_group("mul");
T 1708599282 18<27sword_smith18>	    let log2_of_sizes: Vec<usize> = vec![3, 7, 12, 18, 23];
T 1708599284 18<27sword_smith18>	    // Benchmarking forward ntt on BFieldElements
T 1708599287 18<27sword_smith18>	    for log2_of_size in log2_of_sizes.iter() {
T 1708599289 18<27sword_smith18>	        u32_mul(
T 1708599292 18<27sword_smith18>	            &mut group,
T 1708599294 18<27sword_smith18>	            BenchmarkId::new("(u32,u32)->u64", log2_of_size),
T 1708599297 18<27sword_smith18>	            *log2_of_size,
T 1708599299 18<27sword_smith18>	        );
T 1708599302 18<27sword_smith18>	    }
T 1708599304 18<27sword_smith18>	    for log2_of_size in log2_of_sizes.iter() {
T 1708599307 18<27sword_smith18>	        u64_mul(
T 1708599309 18<27sword_smith18>	            &mut group,
T 1708599312 18<27sword_smith18>	            BenchmarkId::new("(u64,u64)->u128", log2_of_size),
T 1708599313 18<20j`ey18>	um
T 1708599315 18<27sword_smith18>	            *log2_of_size,
T 1708599317 18<27sword_smith18>	        );
T 1708599320 18<27sword_smith18>	    }
T 1708599322 18<27sword_smith18>	    group.finish();
T 1708599325 18<27sword_smith18>	}
T 1708599327 18<27sword_smith18>	fn u32_mul(group: &mut BenchmarkGroup<WallTime>, bench_id: BenchmarkId, log2_of_size: usize) {
T 1708599330 18<27sword_smith18>	    let size: usize = 1 << log2_of_size;
T 1708599333 18<27sword_smith18>	    let xs: Vec<u32> = random_elements(size);
T 1708599335 18<27sword_smith18>	    group.throughput(Throughput::Elements(size as u64));
T 1708599338 18<27sword_smith18>	    group.bench_with_input(bench_id, &size, |b, _| {
T 1708599340 18<27sword_smith18>	        b.iter(|| {
T 1708599343 18<27sword_smith18>	            let mut acc = 0u64;
T 1708599345 18<27sword_smith18>	            for i in 0..(size - 1) {
T 1708599348 18<27sword_smith18>	                acc = acc.wrapping_add(xs[i] as u64 * xs[i + 1] as u64);
T 1708599350 18<27sword_smith18>	            }
T 1708599353 18<27sword_smith18>	            // Prevent the compiler from optimizing the loop away
T 1708599355 18<27sword_smith18>	            unsafe {
T 1708599358 18<27sword_smith18>	                ptr::write_volatile(&mut acc as *mut u64, acc);
T 1708599360 18<27sword_smith18>	            }
T 1708599363 18<27sword_smith18>	        })
T 1708599365 18<27sword_smith18>	    });
T 1708599368 18<27sword_smith18>	    group.sample_size(10);
T 1708599370 18<27sword_smith18>	}
T 1708599373 18<27sword_smith18>	fn u64_mul(group: &mut BenchmarkGroup<WallTime>, bench_id: BenchmarkId, log2_of_size: usize) {
T 1708599376 18<27sword_smith18>	    let size: usize = 1 << log2_of_size;
T 1708599378 18<27sword_smith18>	    let xs: Vec<u64> = random_elements(size);
T 1708599381 18<27sword_smith18>	    group.throughput(Throughput::Elements(size as u64));
T 1708599383 18<27sword_smith18>	    group.bench_with_input(bench_id, &size, |b, _| {
T 1708599386 18<27sword_smith18>	        b.iter(|| {
T 1708599388 18<27sword_smith18>	            let mut acc = 0u128;
T 1708599391 18<27sword_smith18>	            for i in 0..(size - 1) {
T 1708599393 18<27sword_smith18>	                acc = acc.wrapping_add(xs[i] as u128 * xs[i + 1] as u128);
T 1708599396 18<27sword_smith18>	            }
T 1708599398 18<27sword_smith18>	            // Prevent the compiler from optimizing the loop away
T 1708599400 18<20j`ey18>	bertptrs:
T 1708599401 18<27sword_smith18>	            unsafe {
T 1708599403 18<27sword_smith18>	                ptr::write_volatile(&mut acc as *mut u128, acc);
T 1708599406 18<27sword_smith18>	            }
T 1708599408 18<27sword_smith18>	        })
T 1708599411 18<27sword_smith18>	    });
T 1708599413 18<27sword_smith18>	    group.sample_size(10);
T 1708599416 18<27sword_smith18>	}
T 1708599418 18<27sword_smith18>	criterion_group!(benches, mul);
T 1708599421 18<27sword_smith18>	criterion_main!(benches);
T 1708599423 18<27sword_smith18>	fucking hell
T 1708599426 18<27sword_smith18>	sorry
T 1708599428 18<27sword_smith18>	I meant to copy-paste this: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021
T 1708599429 18<27Affliction18>	https://play.rust-lang.org/?version=stable&mode=debug&edition=2021 for code pastes; doing it that way results in you sending 1 message per second. And that is generally annoying.
T 1708599431 18<27sword_smith18>	yeah .. sorry guys. Didn't mean to spam. `irssi` warned me about 75 lines, but the command to go ahead is the command I use to delete my input (ctrl+a, ctrl+k).
T 1708599443 18<20j`ey18>	sword_smith: imagine if you accidentally pasted the same thing again lol
T 1708599483 18<27Affliction18>	nice how my message lined up with the very end, heh.
T 1708599483 18<25bertptrs18>	sword_smith: can you not do that again
T 1708599485 18<27sword_smith18>	My IRC client *should* make it harder to SPAM, imo.
T 1708599496 18<27sword_smith18>	Yes, I'm blaming my software, partially.
T 1708599499 18<20j`ey18>	bertptrs: ban him!!!
T 1708599514 18<25bertptrs18>	I think the youth of today would call it a skill issue
T 1708599524 18<25bertptrs18>	j`ey: accidents happen, let it slide
T 1708599528 18<27sword_smith18>	j`ey: Watch out with irony on text :)
T 1708599532 18<27Affliction18>	Anyway, you pasted a link to the empty playground; hit share and "permalink"
T 1708599543 18<20j`ey18>	sword_smith: I was hoping the multiple !! was enough :P
T 1708599561 18<27sword_smith18>	saati: Here's the benchmark I've written: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=d52ce86b44e054533e003e8440ed8ec0
T 1708599631 18<25Widdershins18>	sword_smith: what did you want to remove
T 1708599644 18<25bertptrs18>	j`ey: the double ping cancels out the exclamation marks
T 1708599668 18<25Widdershins18>	the exclamation marks cast your sarcasm to boolean
T 1708599673 18<20j`ey18>	bertptrs: oh true, my bad
T 1708599703 18<27sword_smith18>	saati: But my benchmark includes some summation, that I would like to avoid. The compiler is quick optimize away unused results though.
T 1708599738 18<24Bish18>	how many people here are fulltime rusters (getting paid for it)
T 1708599746 18<25Widdershins18>	you mean your volatile thing you're doing to force the loop not to optimize?
T 1708599748 18<27sword_smith18>	The benchmark I've written *almost* achieves what I want. And does run faster for (u32,u32)->u64 mul than for u64->u128 mul.
T 1708599777 18<25Widdershins18>	https://doc.rust-lang.org/std/hint/fn.black_box.html
T 1708599786 18<27sword_smith18>	Widdershins: The volatile thing *and* the entire accumulation. I don't actually want to add anything.
T 1708599790 18<27sword_smith18>	Just multiply.
T 1708599814 18<25Widdershins18>	see that link, that's the dedicated tool for this
T 1708600104 18<27sword_smith18>	Widdershins: Do you have something I can use on `stable`?
T 1708600494 18<29saati18>	yeah i was wrong, i can't demonstrate t
T 1708600524 18<29saati18>	it, but on skylake u64*u64 -> u128 is half as fast as u32*u32->u64, on zen3 they take the same time
T 1708600604 18<27sword_smith18>	Criterion has its own `black_box` thing that I think I can use. Not too well documented though.
T 1708601278 18<27sword_smith18>	saati: Managed to get a benchmark that I *think* does want I want it to. On my Intel Core i9-11950H multiplying two u64s takes the same time as multiplying two u32s.
T 1708601352 18<27sword_smith18>	Here's my benchmark: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=51d1ec615fb88dfeca508d58213efcbf
T 1708601437 18<25Widdershins18>	saati: black box is on stable, it's just not *const*
T 1708601441 18<25Widdershins18>	unless you're on unstable
T 1708601448 18<25Widdershins18>	sorry, sword_smith
T 1708601462 18<25Widdershins18>	using criterion's black box is also good
T 1708601530 18<25Widdershins18>	but std::hint::black_box has been stable since 1.66
T 1708601791 18<27sword_smith18>	Widdershins: I see. My IDE wanted to import `std::intrinsics::black_box` instead for some reason. And that thing gave me the `unstable` error.
T 1708601815 18<25Widdershins18>	the hint one just calls that, but yeah. which ide
T 1708601856 18<27sword_smith18>	VS Code. With `rust-analyzer`.
T 1708602343 22*	26ChanServ gives channel operator status to 18Widdershins
T 1708602542 22*	26Widdershins removes channel operator status from 18Widdershins
T 1708606547 19*	Now talking on 22##rust
T 1708606547 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708606547 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708606631 19*	Now talking on 22##rust
T 1708606631 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708606631 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708611059 18<27sword_smith18>	How can all these benchmarks take the same about of time? They really shouldn't, I think: https://github.com/Neptune-Crypto/twenty-first/blob/9f86d4a1341ef72bd2e6ae87e9fe0e4fb75ac170/twenty-first/benches/various_muls.rs
T 1708611079 18<27sword_smith18>	I'm I making an error in the benchmarking code?
T 1708611200 18<25bertptrs18>	what do you mean same amount of time?
T 1708611227 18<25bertptrs18>	criterion by default takes 100 samples over the course of 5 seconds, or longer if it's impossible to do within 5 seconds
T 1708611347 18<25bertptrs18>	oh the unsigned_mul test looks weird, that's ont how that works
T 1708611371 18<27sword_smith18>	bertptrs: Certain times are reported when a benchmark is run. That's the time I'm referring to.
T 1708611393 18<27sword_smith18>	`unsigned_mul/(u32,u32)->u64/1000000 time:   [306.18 µs 306.86 µs 307.70 µs]` etc.
T 1708611754 18<27sword_smith18>	bertptrs: If you think you can fix my tests, I would love to get your input :)
T 1708611760 18<27sword_smith18>	s/tests/benchmarks/
T 1708611946 18<25bertptrs18>	It goes against my religion to spell it out, but I do something fairly similar here: https://github.com/bertptrs/tracing-mutex/blob/master/benches/mutex.rs
T 1708612005 18<25bertptrs18>	but crucially you are misusing black_box
T 1708612012 18<25bertptrs18>	you don't pass it a closure, you pass it an expression
T 1708612041 18<25bertptrs18>	So I'm guessing all you're measuring is how quickly you can loop (size - 1) times
T 1708612279 18<25bertptrs18>	also for good measure, I recommend you use the same random data for all tests (to avoid random skew in how CPUs special-case certain multiplications) and use the windows() function instead of xs[i] xs[i + 1]
T 1708612479 18<27sword_smith18>	bertptrs: Now I'm getting some more sensible results.
T 1708613252 18<25cehteh18>	for some benchmarks i lock them on a specific core and set that core to a fixed frequency like 80% of its max. that makes the benchmarks slower but more reliable because overboost and thermal throttling wont happen
T 1708613357 18<27sword_smith18>	Pushed a commit. Now the results are sensible: https://github.com/Neptune-Crypto/twenty-first/blob/57699bb41100f60f7be11816587706acff49453f/twenty-first/benches/various_muls.rs
T 1708613391 18<25cehteh18>	on modern CPU's not all cores are equal, and i dont mean the efficiency/performance core thing, even having heterogenous cores some may run cooler and reach higher frequencies than their buddies on the same silicon
T 1708613391 18<29phy172918>	iirc the rust project uses callgrind to record the number of instructions (in addition to other things)
T 1708613441 18<25cehteh18>	yes using callgrind helps too, but its more atifical since it emulates a cpu/caches its not the real numbers you get
T 1708613469 18<26dminuoso18>	I have dovecot and want it to talk to a server-local HTTP server. What kind of simple but performant server library choices might I have? Security concerns are practically non-existent since the service is not exposed outside the server.
T 1708613531 18<26dminuoso18>	(Ultimately I just want something small with a small dependency closure)
T 1708614183 18<29alip18>	is there a way to split the parent and file name of a Path in one go rather than calling parent() and file_name() in sequence?
T 1708614305 18<26danieldg18>	alip: no, not unless you want to look at components instead of the parent
T 1708614348 18<29alip18>	thx
T 1708614439 18<26pflanze18>	Are there any philosophies around using borrowing rules for I/O? Like, File implements Read and gets operations that all take &mut self, of course that's needed as some implementations need to maintain state; but maybe it would be there anyway to make sure a file handle is only used from one place to avoid the possibility for interference statically? Or is that outside of Rust's concerns?
T 1708614489 18<26danieldg18>	pflanze: if you want to do that, you should wrap the File in something that only allows read/etc on a &mut
T 1708614505 18<26danieldg18>	pflanze: &File implements Read explicitly so this isn't needed
T 1708614561 18<26pflanze18>	So I get that the answer is that Rust does *not* use borrow checking rules for I/O.
T 1708614566 18<26danieldg18>	correct
T 1708614571 18<26pflanze18>	OK, thanks!
T 1708614586 18<26danieldg18>	look at read_at/write_at if you want to avoid interference
T 1708614679 18<20nullie18>	read and gets modify state on any file implementation
T 1708614736 18<26danieldg18>	that depends on what you count as state
T 1708614788 18<26danieldg18>	the file's cursor will get modified, but that is actually a kernel state thing that rust doesn't control
T 1708614961 18<26pflanze18>	Yep, IIRC on POSIX the cursor is even shared across processes.
T 1708614988 18<26danieldg18>	yes, it is
T 1708615062 18<20nullie18>	let's implement IO monad
T 1708615085 18<26danieldg18>	you can do that if you like
T 1708615171 18<26pflanze18>	(Last I know HKT are not ready hence no generic monad infrastructure.)
T 1708615199 18<26pflanze18>	(Not that I necessarily wanted to see monads, anyway.)
T 1708623317 19*	Now talking on 22##rust
T 1708623317 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708623317 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708628942 18<29monr0e18>	Moved from Windows to Linux, and am rebuilding a .net web application in Rust with Rocket. Tryign otu CLion, should I look elsewhere for an IDE? Been kinda spoiled by visual studio
T 1708629162 18<20cappy18>	monr0e: I'm looking for an IDE for Rust as well. Just went to https://www.jetbrains.com/clion/ and there is no mention of Rust; only C/C++. Is there a Rust plug-in?
T 1708629227 18<29monr0e18>	Yes, but I don't know how extensive it is. I ran into some sort of issue settin gup a new project too
T 1708629272 18<29monr0e18>	but that may also be because I have no idea how to use rust yet. In fact, I know next to nothing abotu it
T 1708629356 18<28monr0e-pooping18>	Oh I should change this nick
T 1708629389 18<20cappy18>	monr0e: I just started with Rust a day or two ago. But I found an alternate: VSCodium or Visual Studio Code can be set up for Rust:
T 1708629410 18<20cappy18>	monr0e: https://github.com/larina3315/personal-stuff/blob/main/coding/vsc-flatpak-rust.md
T 1708629431 18<27monr0e-phone18>	I really want to avoid a vscode solution tbh
T 1708629535 18<27monr0e-phone18>	I'm looking for something as close to equivalency as possible to visual studio
T 1708629535 18<20cappy18>	Believe that's why the open source VSCodium exists, apart from Microsoft's telemetry et al. Just mentioning it.
T 1708629594 18<27monr0e-phone18>	Honestly the telemetry is easy to fix, but I really have been spoiled by visual studio. That sort of featureset is second nature to me now
T 1708629626 18<27monr0e-phone18>	VSCode is something I use more for super basic website building
T 1708629646 18<20cappy18>	Understand your point. IDK of anything else. Perhaps someone else here can add?
T 1708629650 18<25LawnGnome18>	JetBrains has RustRover as their (fairly new) Rust specific product.
T 1708629664 18<25LawnGnome18>	I haven't used it, but if you're used to the JetBrains way of doing things, I assume it would work for you.
T 1708629702 18<27monr0e-phone18>	I have zero experience with jetbrains either tbh. I'm willing to try anything that has a decent enough featureset
T 1708629740 18<27monr0e-phone18>	RustRover is a plugin? Or an entire IDE in its own right?
T 1708629758 18<19Alexendoo18>	somewhere inbetween
T 1708629775 18<27monr0e-phone18>	Oh interesting
T 1708629780 18<20cappy18>	Is there pricing on RustRover? I'm at the site; don't see it.
T 1708629860 18<25bertptrs18>	I've previously used either CLion or IntelliJ Ultimate with the official rust plugin, but then I stopped having a rust job and moved to vscode + rust-analyzer
T 1708629862 18<20cappy18>	Or is it considered part of their "Products Pack"?
T 1708629869 18<25Diablo-D318>	I dont think they sell rustrover yet
T 1708629908 18<20cappy18>	So is their d/l a trial? (for now)
T 1708629915 18<27monr0e-phone18>	From what I can see RustRover is in beta
T 1708629929 18<25Diablo-D318>	cappy: "trial"
T 1708629961 18<25Diablo-D318>	its the same as intellij community edition, but with the rust plugin set instead of the java one
T 1708629976 18<20cappy18>	Diablo-D3: meaning, use it for a time until it's out of beta and then pay.
T 1708629981 18<27monr0e-phone18>	There's an entirely separate, though deprecated, plugin for intellij cappy
T 1708629999 18<25Diablo-D318>	cappy: basically.
T 1708630016 18<25Diablo-D318>	I'd probably take IDEA more seriously if they'd quit trying to split it up per language
T 1708630026 18<27monr0e-phone18>	I might try this preview. Looks interesting
T 1708630028 18<25Diablo-D318>	if I buy intellij ultimate, all of them are in the same IDE
T 1708630067 18<25Diablo-D318>	they jumped the shark, though
T 1708630078 18<25Diablo-D318>	they're all in on AI, which means they're basically dead.
T 1708630102 18<19nCrazed18>	last I tried RustRover on my current $job project, it choked on what I am guessing was the workspace set up that I had for that project
T 1708630109 18<27monr0e-phone18>	Ugh I noticed the ai thing
T 1708630110 18<19nCrazed18>	so still CLion + the plugin for me
T 1708630143 18<25bertptrs18>	Diablo-D3: if anyone who went all in on AI was dead, I'd be much happier about the future of the tech industry
T 1708630186 18<19Alexendoo18>	monr0e-phone: well you wanted it to be like VS :P
T 1708630213 18<27monr0e-phone18>	Alexendoo: No ai in VS 2017!
T 1708630231 18<27monr0e-phone18>	Lol "ai"
T 1708630323 18<19nCrazed18>	there's no AI in Intellij's 2017 offerings either :|
T 1708630546 19*	Now talking on 22##rust
T 1708630546 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708630546 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708631263 19*	Now talking on 22##rust
T 1708631263 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708631263 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708631637 18<26bwidawsk18>	istr there was work to allow `..Default::default()` for a struct that doesn't impl Default, but where the remaining members do. Did I make that up? If not, could someone please help me find it?
T 1708631675 18<25bertptrs18>	you might've, because that fundamentally cannot work
T 1708631702 18<25bertptrs18>	..Default::default() is less magic than you think; it's the struct update syntax
T 1708631720 18<25bertptrs18>	What it does, is "these are new fields, then take whatever else from this other struct"
T 1708631738 18<25bertptrs18>	Where all Default::default() does is call the default function and take the default values from there
T 1708631930 19*	Now talking on 22##rust
T 1708631930 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708631930 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708631936 18<26bwidawsk18>	but looks like it's not longer alive
T 1708632783 19*	Now talking on 22##rust
T 1708632783 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708632783 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708632966 19*	Now talking on 22##rust
T 1708632966 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708632966 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708634100 18<20maxsimo18>	list
T 1708635367 18<26swansone18>	Hey, I'm writting a unit test for a function that returns a Result. Is there a convenient shorthant to assert that it returns Ok, or prints Err if not?
T 1708635426 18<25bertptrs18>	just unwrap it?
T 1708635451 18<26swansone18>	Oh, that might work
T 1708635496 18<25bertptrs18>	Has the benefit of automatically failing the test too
T 1708635644 18<26swansone18>	Do I need to change the type signature of the test to do that?
T 1708635660 18<26swansone18>	Trying this gives me "^ cannot use the `?` operator in a function that returns `()`"
T 1708635923 18<26swansone18>	Trying to update the test function signature to return a result gives me an error that I need to implement the `Termination` trait
T 1708636259 18<26swansone18>	I think this is probably the best I can do then: `assert!(config.is_ok(), "{:?}", config)`
T 1708636718 18<19Alexendoo18>	swansone: unwrap as in .unwrap()
T 1708644557 18<25Widdershins18>	sigh, nightly clippy recently started complaining about redundant prelude imports. even when they are for no_std
T 1708644854 18<25Widdershins18>	nightly-2024-02-16 is fine, 2024-02-19 isn't
T 1708645152 18<25Widdershins18>	happened between the -18 and -19 toolchains
T 1708646696 18<25Widdershins18>	really struggling making a minimal reproducer for this!
T 1708646710 18<25Widdershins18>	i don't know why it dislikes my crate specifically
T 1708650579 18<25Widdershins18>	ok i figured it out bug submitted 😌
T 1708655909 18<25Widdershins18>	ok i sent the bug to the wrong place and failed to find the real issue, but i got an interesting idea from the real one
T 1708658506 18<25Widdershins18>	Is there a way to make cargo compile with the no_std prelude, even in std?
T 1708658591 18<25Mutabah18>	Why not just have `#![no_std]`
T 1708658602 18<25Mutabah18>	(and import std manually)
T 1708658611 18<25Widdershins18>	does that have other effects when the library is included in the whole program?
T 1708658622 18<25Widdershins18>	if the rest of the program is normal std?
T 1708658630 18<26danieldg18>	no
T 1708658633 18<25Widdershins18>	i am looking at https://github.com/rust-lang/rust/issues/121362#issuecomment-1955202508 here
T 1708658653 18<25Widdershins18>	though, as i'm currently looking to find out, that may only affect the *whole binary* when it applies to the program, not to each library individually
T 1708658657 18<26danieldg18>	you can use no-std crates normally from std ones
T 1708658658 18<25Mutabah18>	`no_std` libraries can be included in std-including binaries
T 1708658684 18<25Widdershins18>	do they produce the same code as if they were not no_std, as long as they use the same types etc.?
T 1708658689 18<25Mutabah18>	In fact it's very common for `no_std` libraries to have feature flags to turn on use of std/alloc
T 1708658695 18<25Mutabah18>	yes.
T 1708658711 18<25Mutabah18>	The stuff you use in `no_std` is the same in std (just re-exports)
T 1708658733 18<25Widdershins18>	yes, that's what i have. i have a library that has a std feature flag. currently this feature disables the no_std config, rather than causing std to be imported
T 1708658801 18<25Widdershins18>	as long as no_std code benefits from "stack overflow protection" and "runs init code before main" when included in a std program then that answers my question
T 1708658819 18<25Widdershins18>	seems likely that that would be the case
T 1708658837 18<26danieldg18>	if main is std, then it would
T 1708658849 18<26danieldg18>	stack overflow is also set up prior to main
T 1708658883 18<25Widdershins18>	context for the problem is also in that issue; rust nightly started throwing lint complaints for redundant imports when a maybe-no_std crate imports items that are also in the std prelude when it's std
T 1708658909 18<25Mutabah18>	The solution is to always be `no_std` but manually import std if needed
T 1708658914 18<25Mutabah18>	example: https://github.com/thepowersgang/stack_dst-rs/blob/master/src/lib.rs
T 1708658918 18<25Widdershins18>	not clear if they'll roll it back but if it's unambiguously a good idea to extern std instead of disable no_std i'll just do that, it does sound better
T 1708658924 18<25Widdershins18>	yea
T 1708658926 18<25Mutabah18>	It conditionally imports alloc (and std - for miri tricks)
T 1708658935 18<25Widdershins18>	mhm
T 1708659894 18<25Widdershins18>	alright sweet
T 1708659901 18<25Widdershins18>	thanks danieldg Mutabah
T 1708674489 18<24enoq18>	is there something that allows you to serialize JSON in a streaming fashion? like serializer.startArray(); serializer.writeStruct(struct); serializer.stopArray()
T 1708677827 18<24enoq18>	can anyone explain this? https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=52322953af6b6452bdc73953cbcd6845
T 1708677834 18<24enoq18>	error[E0369]: cannot add `&{integer}` to `&mut {integer}`
T 1708677878 18<24enoq18>	these don't look like really distinct types to me
T 1708678260 18<26dminuoso18>	Hi, is there a way to get a delimited use of ? when ultimately I dont return a io::Result<T> at the end, but I do make a bunch of successive calls to functions that do in the beginning?
T 1708678270 18<26dminuoso18>	Or is the idiomatic approach to just split this into two functions?
T 1708678294 18<20j`ey18>	try blocks, but not stable afaik
T 1708678362 18<20j`ey18>	enoq: I think you want reduce, not scan?
T 1708678388 18<24enoq18>	I want to turn [1, 2, 3] into [0, 1, 3, 6]
T 1708678406 18<26dav1d18>	enoq, they are distinct types, compiler tells you how you can fix it
T 1708678413 18<24enoq18>	dav1d, right, but why
T 1708678413 18<20j`ey18>	oh
T 1708678437 18<26dav1d18>	enoq, one is mutable the other isn't. You can impl traits for &Foo and &mut Foo separately
T 1708678457 18<26dav1d18>	enoq, &Foo and Foo are also not the same type
T 1708678473 18<24enoq18>	is there no trait impl for left hand &mut and right hand &
T 1708678515 18<26dav1d18>	enoq, yeah that's what is missing
T 1708678544 18<26dav1d18>	enoq, but it's the same for `&u32 + u32`
T 1708678566 18<24enoq18>	you mean you also can't add those?
T 1708678614 18<24enoq18>	the scan type signature is also kinda complicated btw
T 1708678655 18<26dminuoso18>	j`ey: Alright thanks.
T 1708678919 18<24enoq18>	looks like this is sort of what I want
T 1708678920 18<24enoq18>	https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=1e1dc6b62e21fb45d5a9a216e3844952
T 1708678927 18<24enoq18>	I've never used * before in rust
T 1708680557 18<27mkoncek18>	does rustc / cargo offer more granular optimize / debug flags? like -O<N> in gcc
T 1708680586 18<20j`ey18>	opt-level
T 1708680864 18<27mkoncek18>	also, i have two processes, one is sending UDP to a local address in a while loop and the other one is receiving them, after roughly 300 datagrams some of them get lost, is it possible i overflowed the kernel buffers?
T 1708681178 18<26dav1d18>	enoq, https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=e7ca6a2c5abc4babd48ce6ce27918140
T 1708681199 18<26dav1d18>	oh nvm I think I broke it
T 1708681220 18<24enoq18>	you forgot to sum it up
T 1708681234 18<24enoq18>	I know, the API does not work like in other languages
T 1708681240 18<26dav1d18>	yeah, I think yours is as good as it gets
T 1708681254 18<24enoq18>	thanks, was worried about the type soup
T 1708681265 18<26dav1d18>	enoq, eh `*state = *state + curr;`
T 1708681290 18<26dav1d18>	that should work, but it's just a minor thing which clippy probably also notices
T 1708681310 18<24enoq18>	what's the solution?
T 1708681339 18<26dav1d18>	oh clippy wants ` *state += curr;`
T 1708681342 18<26dav1d18>	that's nice
T 1708681355 18<24enoq18>	ah, yeah, less characters for the same thing then :)
T 1708681371 18<26dav1d18>	enoq, https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=ae625557c0702aa6b79b5a5b3c6c8797
T 1708681373 18<26dav1d18>	full thing
T 1708681384 18<24enoq18>	thanks
T 1708681393 18<24enoq18>	so let's say I want to execute this function at compile time
T 1708681404 18<24enoq18>	I think there's some form of constexpr
T 1708681456 18<26dav1d18>	enoq, you can't create a vector with items at compiletime, if you have an array you'd need to manually do it with a while loop I believe (not sure if for works alread)
T 1708681476 18<24enoq18>	because vec is heap allocated?
T 1708681549 18<25bertptrs18>	yea
T 1708681567 18<25bertptrs18>	also many of the functions you are using cannot be used in a const context yet
T 1708682190 18<24enoq18>	I suppose simple ::new methods are fine to make const?
T 1708682200 18<24enoq18>	when you just want to fill in default values for a struct
T 1708682364 18<20j`ey18>	yep
T 1708682445 18<24enoq18>	thanks
T 1708682486 18<24enoq18>	I don't really fully understand the limitation of no vectors inside const fns; it should be possible to just allocate that vector at compile time, right?
T 1708682548 18<24enoq18>	or does Rust have more guarantees  in that regard?
T 1708682620 18<24enoq18>	like: will not check how big the actual thing is after running it during compile but instead needs to know all sizes statically in advance?
T 1708682952 18<24enoq18>	oh :( https://github.com/rust-lang/rfcs/pull/2237
T 1708683282 18<27synapse18>	enoq, they're heap allocated
T 1708683333 18<27synapse18>	enoq, if you made a StaticVec<T> you could statically allocate it. some people call that an array. :-D
T 1708683372 18<27synapse18>	enoq, .push() and such don't make much sense if the allocation is fixed.
T 1708683417 18<24enoq18>	right, you should be able to iter over arrays though, right?
T 1708683425 18<27synapse18>	yes
T 1708683426 18<26dav1d18>	need someone to just reply with yes as a sanity check, if I destructure a struct its Drop impl wont run?
T 1708683462 18<24enoq18>	doesn't drop always run at the end of the lifetime?
T 1708683482 18<25bertptrs18>	You cannot destructure things that have Drop
T 1708683625 18<25bertptrs18>	Oh it seems you can, provided the things you destructure are Copy
T 1708683628 18<26dav1d18>	bertptrs, https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=ac877edafd206dbdb899fcd3be13ddbf ?
T 1708683653 18<26dav1d18>	okay seems like I need to properly figure out semantics
T 1708683655 18<26dav1d18>	thanks
T 1708683705 18<25bertptrs18>	dav1d: it's just moving out of the thing, not actually destroying it
T 1708683808 18<26dav1d18>	bertptrs, yeah I see, it only allows you to get a ref when destructuring. I have a Token which logs something on drop and I want to be able to transform that token to another token which logs more information, that transformation shouldn't trigger the initial drop though :(
T 1708683819 18<26dav1d18>	Guess I'll have to wrap everything in an option
T 1708683835 18<25bertptrs18>	ManuallyDrop might help?
T 1708683934 18<22davros118>	Haven't been following the rust world so much lately (AI hype got me) .. is there movement in the realm of this existing problem:
T 1708683962 18<22davros118>	Can't impl From for collections when the inner type has a From
T 1708683967 18<26dav1d18>	bertptrs, thanks, I though that wouldnt work but it looks like it should!
T 1708683985 18<22davros118>	I think it needed negative bounds or something (there might have been some other proposals)
T 1708684078 18<26dav1d18>	Actually I can just std::mem::forget
T 1708684096 18<22davros118>	In my own vecmath libs I ran into this .. 'struct Vec3<T>{x:T, y:T, z:T} .. can't impl From<[B;3]> for Vec3<A> where A:From<B> {} because it'll freak out at the possibility of infinite nesting or something
T 1708684432 18<25bertptrs18>	negative bounds aren't anywhere coming as far as I know, the new trait solver has been in limbo for a bit
T 1708684920 18<24enoq18>	is there no built in way to handle dates & ISO8601 formatting?
T 1708685439 18<25bertptrs18>	no, the standard library is intentionally somewhat limited since it's intended to be stable forever
T 1708685446 18<25bertptrs18>	you can look at either the chrono or time crates
T 1708685783 18<26dav1d18>	I thought Rust would catch this out of bounds on static arrays :( https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=f9bdc0f3c23bfde2073c9d7676c39c4b
T 1708685796 18<26dav1d18>	Is there a way to have the array access validated on compiletime?
T 1708686545 18<19turlando18>	dav1d: ironically the release llvm ir code is just a call to core::panicking::panic_bounds_check when i try to run weight
T 1708686571 18<19turlando18>	So it's actually doing some kind of const propagation
T 1708688848 18<26dav1d18>	turlando, nice! optimized panics
T 1708696020 19*	Now talking on 22##rust
T 1708696020 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708696020 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708696036 18<24enoq18>	I'm using the File buf reader lines() method I think
T 1708696069 18<24enoq18>	yep, that one handles \r\n
T 1708696321 19*	Now talking on 22##rust
T 1708696321 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708696321 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708696364 18<25cehteh18>	you can use that when you use std String -- but creating a string from untrusted io is fallible, by panic or you handling the Result
T 1708696447 18<25cehteh18>	and read_lines etc have no safeguard against malicious files that use extremely long lines. often thats ok, but sometimes thats a big problem
T 1708696496 18<24enoq18>	that's a problem in other languages as well
T 1708696499 18<25cehteh18>	and its all-or-nothing in case of invalid utf8
T 1708696504 18<25cehteh18>	yeah sure
T 1708696521 18<25cehteh18>	just telling you to consider it, if it doesnt matter ignore it
T 1708696532 18<24enoq18>	yeah, thank you for the tp
T 1708696534 18<24enoq18>	tip*
T 1708696570 18<24enoq18>	usually you've got an enforced size limit for uploaded files
T 1708696571 18<25cehteh18>	esp invalid utf8 isnt really unexpected
T 1708696593 18<25cehteh18>	you may at least handle that instead panicking
T 1708696599 18<24enoq18>	right
T 1708696755 18<25cehteh18>	gtg
T 1708697569 18<27sword_smith18>	I've seen the recommendation that a `Debug` implementation should be added as a rule of thumb.
T 1708697580 18<27sword_smith18>	Why?
T 1708697674 18<25bertptrs18>	https://rust-lang.github.io/api-guidelines/interoperability.html
T 1708697706 18<25bertptrs18>	private types not necessarily, but for public types it's very helpful for API consumers to debug their own codew
T 1708697807 18<28tstonge18>	it's nice to be able to format!("{:?}", my_obj), and all it takes is `Debug`
T 1708698096 18<25bertptrs18>	or if you're hip, to use the dbg! macro
T 1708699378 18<24enoq18>	how can you hold onto a value outside of a loop, that goes out of scope in a loop
T 1708699410 18<20nullie18>	enoq: set_fact?
T 1708699419 18<24enoq18>	what do you mean?
T 1708699429 18<20nullie18>	I don't quite understand what do you want to do
T 1708699433 18<24enoq18>	I need to keep track of a previous value
T 1708699447 18<24enoq18>	compare the current value to the previous value
T 1708699461 18<20nullie18>	well you could use set_fact to store it
T 1708699499 18<24enoq18>	I can only find Ansible stuff when I google that
T 1708699518 18<20nullie18>	oh, shit, sorry, I though it was #ansible :D
T 1708699539 18<20nullie18>	you can declare a variable outside of a loop
T 1708699590 18<24enoq18>	right, I can, but if I assign to it, I either need to move? it since the value goes out of scope
T 1708699595 18<24enoq18>	or copy it somehow
T 1708699629 18<20nullie18>	it will be moved by default
T 1708699643 18<20nullie18>	can you show the code for your current attempt?
T 1708699690 18<24enoq18>	nullie, https://dpaste.com/6WP8SDQYQ#line-150
T 1708699709 18<24enoq18>	error is ^^^^^^^^ borrowed value does not live long enough
T 1708699718 18<24enoq18>	line 172
T 1708699748 18<20nullie18>	remove the reference
T 1708699760 18<24enoq18>	you mean move it?
T 1708699777 18<20nullie18>	Option<ArticleLine> instead of Option<&ArticleLine>
T 1708699830 18<20nullie18>	and then Some(article_line) instead of Some(&article_line)
T 1708699849 18<20nullie18>	s/article_line/article/g
T 1708699903 18<24enoq18>	use of moved value now
T 1708699914 18<24enoq18>	https://dpaste.com/F2XWBCSTG
T 1708699926 18<24enoq18>	157 |             Some(cheapest) => {
T 1708699929 18<24enoq18>	value moved here
T 1708699949 18<20nullie18>	match lowest_price.as_ref()
T 1708700021 18<24enoq18>	https://dpaste.com/H2WCW7KRT
T 1708700030 18<24enoq18>	    |                     ^^^^^^^^^^^^ `lowest_price` is assigned to here but it was already borrowed
T 1708700035 18<24enoq18>	line 160
T 1708700064 18<24enoq18>	(my gutt feeling is that I need a copy)
T 1708700082 18<20nullie18>	lowest_price = match { }, and then at finish each branch with Some()
T 1708700132 18<20nullie18>	well, maybe it's not the right way
T 1708700234 18<26danieldg18>	you might be able to avoid a copy, but it depends on what exactly you are iterating and storing
T 1708700277 18<29phy172918>	It feels .fold(ish maybe with group_by
T 1708700315 18<24enoq18>	yes, it feels like group_by, but doesn't group by evaluated everything?
T 1708700353 18<24enoq18>	if I evaluate it, I'm loading 120 gigs of strings into memory
T 1708700399 18<20nullie18>	group_by should evaluate lazily
T 1708700500 18<24enoq18>	so it accumulates values until the grouping criterium does not match anymore?
T 1708700505 18<24enoq18>	then starts a new group?
T 1708700540 18<20nullie18>	it doesn't even accumulate group values
T 1708700549 18<20nullie18>	I think
T 1708700561 18<20nullie18>	"If the groups are consumed in order, or if each group’s iterator is dropped without keeping it around, then GroupBy uses no allocations. It needs allocations only if several group iterators are alive at the same time."
T 1708700571 18<24enoq18>	sounds like magic, will take a look thank you!
T 1708707914 18<28Vorpal18>	Does anyone know any tool to generate an install script similar to the one you curl for rustup. Lots of pieces of software have these, but most seem to be hand written for each project. Or depend on Go. Looking for something with multi-architecture support for my own usage. I'm absolutely proficient enough in shell script that I could hack something together. But then there is MacOS/Windows support (which I have no clue about). So I was hoping for some ready
T 1708707916 18<28Vorpal18>	made tool.
T 1708707939 18<28Vorpal18>	Preferably something that integrates easily with a rust build system too
T 1708707953 18<25bertptrs18>	as far as I know these tend to be hand-written
T 1708707998 18<25bertptrs18>	which is not great, people make the same mistakes over and over
T 1708708012 18<28Vorpal18>	That would be a good project then, for someone who has time for that (which I don't). So I too will hand-write one for my project, that will be Linux only.
T 1708708013 18<25bertptrs18>	but I don't think anyone's set up a standardized method yet
T 1708708054 18<25bertptrs18>	composer for example is a PHP tool so they decided to write it in PHP rather than bash. Makes sense but doesn't help standardization
T 1708708055 18<28Vorpal18>	really for my purpose it is a single binary, so all I need is to figure out which is the latest github release, and what architecture I'm running on. Then download and unpack the relevant binary into the current directory
T 1708708090 18<28Vorpal18>	heh, never heard of composer. I thought PHP was dead these days except for existing software (mediawiki, wordpress, probably a few more)
T 1708708148 18<25bertptrs18>	PHP is very much alive, and composer was its revival. it made libraries a lot more accessible and from that the ecosystem got a big boost
T 1708708153 18<24enoq18>	struggling with lifetimes here https://dpaste.com/GJASURSDQ error https://dpaste.com/65WKULUVC
T 1708708157 18<29phy172918>	it doesn't help that POSIX sh is a maze of twisty edge cases all of them sharp
T 1708708166 18<24enoq18>	I don't understand why I'm getting 2 different lifetimes here
T 1708708186 18<28Vorpal18>	phy1729: true. You can't assume bash. Mac OS uses zsh (which I happen to know since I use it myself). Then there is also dash.
T 1708708204 18<25LawnGnome18>	And, in fairness to Composer, anyone who wants to use it already has PHP installed, so making the installer a PHP script makes total sense from that perspective. Plus, yeah, cross platform shell scripting no es bueno.
T 1708708209 18<29phy172918>	and ksh on the BSDs, so you can only really assume POSIX sh
T 1708708243 18<25bertptrs18>	LawnGnome: I'm not dissing composer's choice, it makes perfect sense and lets them avoid POSIX shell
T 1708708249 18<25LawnGnome18>	I had to help maintain a cross platform (maximally, Linux, FreeBSD, macOS, Solaris) "install from tarball" type shell script for several years. I do not recommend the experience.
T 1708708250 18<28Vorpal18>	phy1729: oh right, well I don't build for BSDs (since cross-rs can't cross-test for them). So that I don't won't have to worry about
T 1708708255 18<25LawnGnome18>	bertptrs: I didn't think you were. :)
T 1708708273 18<29phy172918>	Vorpal: I'm on one, so I tend to care about them
T 1708708311 18<28Vorpal18>	phy1729: I wouldn't mind supporting them with pre-built binaries. But I refuse to support anything I can't actually run integration tests on in CI. That way lies madness.
T 1708708345 18<28Vorpal18>	I expect my program to work fine there (there is no reason it wouldn't it works on Windows even after all)
T 1708708368 18<28Vorpal18>	but BSDs and Mac OS ARM I can't cross test in CI, so they get no support.
T 1708708378 18<24enoq18>	is there a way to link the lambda parameter lifetime to the return value?
T 1708708381 18<28Vorpal18>	(I only use Linux myself, not even windows)
T 1708708907 18<24enoq18>	how does one group by two values
T 1708709661 18<24enoq18>	ok https://docs.rs/itertools/latest/src/itertools/groupbylazy.rs.html#299-307
T 1708709669 18<24enoq18>	looking at that signature, there are no lifetimes
T 1708709677 18<24enoq18>	    F: FnMut(&J::Item) -> K,
T 1708709683 18<24enoq18>	so &J and K are not related
T 1708709698 18<24enoq18>	I suppose that's why you can't use any K that refers to &J
T 1708709704 18<24enoq18>	so you have to copy?
T 1708709801 18<24enoq18>	so .group_by(|article| (article.code.clone(), article.pos))
T 1708709809 18<24enoq18>	code is a string, pos a usize
T 1708711475 18<29alip18>	using bitflags how do i check any one of a set of flags is set in a bitflags var? do i have a better way than calling contains() for each flag?
T 1708711488 18<29alip18>	i tried intersects() but it does not seem to do the right thing
T 1708711838 18<26dav1d18>	alip, does that work `FOO & (A |  B | C) > 0`?
T 1708712011 18<29alip18>	dav1d: no
T 1708712078 18<25Mikachu18>	what is a "bitflags var"
T 1708712109 18<29alip18>	a struct defined with bitflags::bitflags!
T 1708712118 18<29alip18>	i mean the crate
T 1708712433 18<20spb18>	the documentation for intersects seems to match what you described - what's different about it from what you want?
T 1708712591 18<20a5118>	I installed erdtree and erdtree says command not found
T 1708712741 18<29alip18>	spb: indeed, but it does not do what i want appearently, i use it with nix's type OFlag and e.g. (OFlag.O_RDONLY|OFlag.O_CLOEXEC|O_DIRECTORY).intersects(O_CREAT|O_TMPFILE) returns true for some reason. o.O
T 1708712875 18<20a5118>	bat and exa work but not erdtree
T 1708712921 18<20j`ey18>	a51: erd
T 1708713068 18<24enoq18>	how does one get an owned value out of a vec
T 1708713077 18<20j`ey18>	remove()
T 1708713086 18<20spb18>	depends what you want to happen to the thing in the vec
T 1708713095 18<26dav1d18>	enoq, remove, std::mem::take/replace
T 1708713104 18<24enoq18>	I want to move it into something else
T 1708713108 18<26dav1d18>	remove is quite expensive
T 1708713128 18<24enoq18>	the vec is only used to calculate something temporarlily
T 1708713133 18<20spb18>	and do you want to remove it from the vec, or leave something else in its place?
T 1708713146 18<26dav1d18>	enoq, if you want to get rid of the entire vector, into_iter()
T 1708713161 18<24enoq18>	I need to know the size of the vec as well
T 1708713184 18<24enoq18>	basically the length and the struct with the lowest value
T 1708713215 18<24enoq18>	basically this https://dpaste.com/866BQBL59
T 1708713242 18<24enoq18>	so I guess remove it is?
T 1708713317 18<29phy172918>	You're throwing away the Vec once you have the min?
T 1708713322 18<24enoq18>	yees
T 1708713326 18<20spb18>	so you're extracting the first item and then throwing away the vec
T 1708713337 18<24enoq18>	first item + vec length, then throwing it away
T 1708713383 18<29phy172918>	.into_iter().reduce and skip the sorting step
T 1708713403 18<20spb18>	and calculate the length before you do it
T 1708713407 18<29phy172918>	er Iterator has a .min
T 1708713433 18<20spb18>	using min means you don't have to actually sort the list which will be considerably faster
T 1708714980 18<24enoq18>	what does this mean: error[E0515]: cannot return value referencing temporary value https://dpaste.com/C7YCXKBJV
T 1708714997 18<24enoq18>	https://dpaste.com/2ZP7SP48S
T 1708715019 18<24enoq18>	I don't really understand what creates the temporary value
T 1708715113 18<28Vorpal18>	enoq: using rust playground would help rather than a pastebin so we can see which line and part the error applies to
T 1708715122 18<24enoq18>	yes, one sec
T 1708715128 18<28Vorpal18>	(see the /topic for a link to the playground)
T 1708715168 18<24enoq18>	https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=6ac152cbe4c36b75e0227875da658f17
T 1708715244 18<28Vorpal18>	hm, used to seeing type inlay hints from vscode, much harder without that :D. But I would expect you take article by value and return a reference to it in group_by()
T 1708715289 18<24enoq18>	at least intellij says &ArticleLine in line 168 but it's pretty buggy as well :/
T 1708715292 18<28Vorpal18>	some things that could help are to collect into a Vec and returning that vec.into_iter() since the computation won't depend on something after the function returns the iterator then
T 1708715334 18<24enoq18>	Vorpal, it's a 120gb string line iterator
T 1708715341 18<28Vorpal18>	but I understand you don't want that, since you try to keep everything as iterators very much so
T 1708715344 18<24enoq18>	I doubt I want to collec tthat
T 1708715350 18<28Vorpal18>	fair point!
T 1708715370 18<28Vorpal18>	what type is pos?
T 1708715374 18<28Vorpal18>	article.pos I mean
T 1708715377 18<24enoq18>	it's a usize
T 1708715389 18<28Vorpal18>	which is Copy. Huh
T 1708715438 18<28Vorpal18>	aha! article.code is a &str. You want to_owned() not clone()
T 1708715442 18<28Vorpal18>	I think that is it
T 1708715456 18<28Vorpal18>	pretty sure you are just cloning the reference into a new reference right now
T 1708715473 18<24enoq18>	same error
T 1708715494 18<24enoq18>	(article.code.to_owned(), article.pos) right?
T 1708715496 18<28Vorpal18>	hm you are right
T 1708715502 18<28Vorpal18>	yeah okay I'm confused too
T 1708715512 18<24enoq18>	the group_by is from itertools btw
T 1708715548 18<24enoq18>	what exactly is the temporary value btw?
T 1708715558 18<28Vorpal18>	I'm wondering that too now
T 1708715561 18<24enoq18>	is it the iterator? or is it the stuff inside the group_by
T 1708715620 18<28Vorpal18>	This type implements IntoIterator (it is not an iterator itself), because the group iterators need to borrow from this value. It should be stored in a local variable or temporary and iterated.
T 1708715628 18<28Vorpal18>	ah, that is probably the issue
T 1708715647 18<28Vorpal18>	you are borrowing from GroupBy itself
T 1708715720 18<28Vorpal18>	I don't have a good answer for how to solve that. I expect if you put it inside the next function it would work, but that is several layers deep in returning files, so that is no good for code organisation.
T 1708715745 18<28Vorpal18>	enoq: hopefully that has given you some idea about the cause though, even though I don't have a suggestion for the fix
T 1708715867 18<24enoq18>	Vorpal, basically, I can't into_iter() after the group by?
T 1708715901 18<28Vorpal18>	well, I haven't looked into the details, but I quoted a line from the documentation of group_by
T 1708715933 18<28Vorpal18>	it seems plausible that the moment you need to iterate over it you need to finish doing so in the same scope
T 1708715938 18<24enoq18>	right, I didn't understand that one tbh
T 1708716011 18<28Vorpal18>	I don't have a suggested fix, perhaps someone else can chime in. You could could try on https://users.rust-lang.org/ maybe?
T 1708716089 18<24enoq18>	there's https://stackoverflow.com/questions/47885478/how-to-use-itertools-group-by-iterator-method-without-a-for-loop
T 1708716097 18<24enoq18>	the suggestion is to clone everything :/
T 1708716199 18<28Vorpal18>	hm... maybe a different design then?
T 1708716302 18<24enoq18>	the one I tried before is passing in a lambda that is executed after each iteration, but closures sure are terrible in Rust, couldn't get it to work
T 1708717044 18<28Vorpal18>	could you pass in a separate function rather than lambda instead?
T 1708717280 18<25dkg18>	So i've got a functioning cdylib built now (i ended up deciding not to do the string manipulation in fixed-size buffers that i'd asked about earlier at all; ended up with a much cleaner interface and implementation, but thanks danieldg and Mutabah for walking me through it anyway)
T 1708717302 18<25dkg18>	now i'm struggling because the library object generated by the cdylib crate exposes a *ton* of symbols that i don't want it to expose.
T 1708717445 18<25dkg18>	i've done searches for "cdylib symbol visibility" and found nothing that works for me :(  i've tried passing a "version script" to the linker, but it ends up in conflict with the version script passed automatically by cargo
T 1708717476 18<25dkg18>	what i want is for the cdylib to only expose those symbols that are marked as C symbols
T 1708717493 18<25dkg18>	so, the things that cbindgen would pick up on, for example.
T 1708717549 18<25dkg18>	the desired C API is simple enough that i don't need to actually use cbindgen to produce it, and i'd prefer to avoid depending on that crate anyway during build.  Any pointers on what i can do to minimize the exported symbols in a cdylib?
T 1708717786 18<24enoq18>	Vorpal, tried this approach instead https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=22cc396e399dd04c469f98eb94d67d3b
T 1708717801 18<24enoq18>	getting "borrowed data escapes outside of closure"
T 1708717806 18<24enoq18>	I suppose it's the same issue
T 1708717914 18<20j`ey18>	dkg: so youre getting rust mangled symbols?
T 1708717964 18<20j`ey18>	(oops go to go)
T 1708718404 18<25dkg18>	j`ey: yes, i'm seeing rust mangled symbols in addition to the ones that i want to export
T 1708718623 18<25dkg18>	hm, actually, as i look at it further, maybe not!  i think i was just seeing mangled symbols in the non-stripped shared object.  when i run "strip" on it, the only symbols that remain are the deliberately exported ones.
T 1708720189 19*	Now talking on 22##rust
T 1708720189 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708720189 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708726487 18<26ljhklhjl18>	hi
T 1708726557 18<26ljhklhjl18>	https://tr.cpabestoffer.click/redirect?aff_id=1153&offer_id=121
T 1708726567 18<26ljhklhjl18>	https://tr.cpabestoffer.click/redirect?aff_id=1153&offer_id=121
T 1708729097 18<27lolita18>	Ok, el trato... dame una membresía gratis y te enviaré 5 videos de coños calientes después de un chat de sexo en vivo gratis, ¿es bueno el trato? https://tr.cpabestoffer.click/redirect?aff_id=1153&offer_id=121
T 1708729123 18<27lolita18>	Ok, el trato... dame una membresía gratis y te enviaré 5 videos de coños calientes después de un chat de sexo en vivo gratis, ¿es bueno el trato? https://tr.cpabestoffer.click/redirect?aff_id=1153&offer_id=121
T 1708729155 18<27lolita18>	Soy una chica soltera. Busco diversion con gente real.. Si realement quieres conocerme, sigue mi perfil personal
T 1708729156 18<27lolita18>	Si este enlace no funciona, cópielo y péguelo manual en su navegador: https://tr.cpabestoffer.click/redirect?aff_id=1153&offer_id=121
T 1708772561 19*	Now talking on 22##rust
T 1708772561 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708772561 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708772567 18<20osse18>	Of course, need to wait for a new release of cargo-lockdiff since the current one segfaults
T 1708772697 18<20osse18>	With that said, if there is a newer/better/shinier way to get a easily digestible "diff" of Cargo.lock then I'm all ears
T 1708775378 18*	26zato slaps Jarrko Oikarinen around with a big nice tuna sandwich 
T 1708775400 18<20jbg18>	osse: i like `lockdiff`
T 1708775429 18<20jbg18>	https://lib.rs/crates/lockdiff
T 1708775472 18<20jbg18>	not a cargo 'plugin' but rather just a command you can point git to, so `git diff` gives nice diffs on lock files automatically
T 1708775481 18<20jbg18>	works for some python and JS lockfile formats too
T 1708775607 18<20osse18>	 Cool, I'll check it out
T 1708775643 18<20osse18>	At first glance this looks more like what I would have written myself. The big table you get from cargo-lockdiff sort of sticks out
T 1708781270 18<20osse18>	I need to act on the inner value of an enum if the enum is of a particular variant: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=20be5267fe0800bc46c21dd271668b43 - Is there a way to make maybe_reverse2() work the same as maybe_reverse() ?
T 1708781362 18<20osse18>	Ahh, I think macro hygiene is screwing me here. the matches!() itself compiles just fine (there's a typo in the playground)
T 1708782341 18<29yuri603718>	Hello, I have a question about the &str type: is there any way to refer to the &str type other than by using a type statement? I'm attempting to write a custom deserialize function for a proprietary format of date time and in that deserialize function I'd like to call &str::deserialize however it appears that in rust it's impossible other than by creating a type statement.
T 1708782419 18<28erk18>	yuri6037: You could look into the built-in trait FromStr, and if you want to replicate what that does you will have to make a trait and then implement it for &str
T 1708782440 18<20osse18>	<&str>::deserialize()   works
T 1708782511 18<29yuri603718>	osse: thank you never seen that weird type syntax before but works or is it just a variant of the <type as trait> syntax?
T 1708782628 18<20osse18>	yuri6037: I'm not really qualified to answer :P But I *think* it's essentially the same as <type as trait> yes.
T 1708782640 18<29yuri603718>	ok
T 1708782650 18<29yuri603718>	thank you anyways
T 1708783165 18<20osse18>	yuri6037: tested a bit on the playground and I feel I know less than I did. the < > seem to be just to scope the &.
T 1708783191 18<29yuri603718>	ok I see
T 1708783198 18<20osse18>	&T::foo() is a reference to T::foo()  <&T>::foo() calls &T'
T 1708783206 18<20osse18>	ugh, whatever, you get what I mean.
T 1708783226 18<29yuri603718>	Oh ok that's like the parentheses in C casts
T 1708783272 18<20jbg18>	it's called a "qualified path"
T 1708783281 18<20jbg18>	and yeah it's basically like parens but for types
T 1708783289 18<29yuri603718>	Anyway that failed because the xml_serde_rs crate can't parse borrowed string it can only parse owned strings so it's gonna have to be more allocs
T 1708783292 18<20jbg18>	https://doc.rust-lang.org/reference/paths.html#qualified-paths
T 1708783307 18<20jbg18>	< Type (as TypePath)? >
T 1708783317 18<29yuri603718>	jbg: thanks for the name good to know
T 1708783372 18<29yuri603718>	I tried to reduce allocs but the lib I use does not appreciate
T 1708783386 18<20jbg18>	serde_xml_rs seems to be able to deserialize from &str
T 1708783424 18<29yuri603718>	apparently not: Failed to decode TTMD monitor data object: Custom { field: "invalid type: string \"05/06/2014 09:14:56\", expected a borrowed string" }
T 1708783452 18<20jbg18>	that error doesn't seem to say what you are saying it says though
T 1708783455 18<20jbg18>	in any case you'd have to show code
T 1708783858 18<29yuri603718>	Here is the code that failed with the error I gave you (note that the playground does not have serde_xml_rl): https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=581fd21d3150d2d6b7a4d87ce8c4a9f8
T 1708783956 18<20jbg18>	the error implies that serde_xml_rs is providing a String *that it allocated* while you are assuming it will provide a &str
T 1708783960 18<20jbg18>	i bet i know why as well
T 1708783963 18<20jbg18>	XML entities
T 1708783979 18<20jbg18>	it can't give a &str borrowed from the input because it has to interpret entities
T 1708784006 18<20jbg18>	best it could give is Cow<'a, str> -- the Borrowed variant if there are no entities and the Owned variant if there are. no idea if they implemented that or not
T 1708784030 18<20jbg18>	it's the same reason why serde_json can't reliably deserialize JSON strings into &str, only into String or Cow<'a, str>
T 1708784039 18<20jbg18>	because it needs to interpret backslash escapes
T 1708784455 18<19Alexendoo18>	It's based on xml-rs which doesn't borrow from the input
T 1708784536 18<19Alexendoo18>	You probably want quick-xml instead
T 1708784850 18<20jbg18>	quick-xml looks good. has the same setup as serde_json: you can deserialize strings into String, Cow<'a, str> or &str but &str will fail if the XML is non-UTF8, if there are any entities in the input, or if an element contains multiple cdatas
T 1708784894 18<29yuri603718>	Thanks for the tip
T 1708785355 18<20capitol18>	do anyone know if it's possible to check if you are in the context of a #[cfg(...)] conditional when writing a clippy lint? There is a stripped_cfg_items() function on the context object, but that is not what I want
T 1708785554 18<19Alexendoo18>	capitol: You can use any_parent_has_attr
T 1708785751 18<20capitol18>	Alexendoo: oh, thanks :)
T 1708787287 18<29yuri603718>	Does quick-xml support unordered readings?
T 1708787331 18<29yuri603718>	I.e. Does it support formats where objects may appear in any order in the tree and deserialize as a single structure with fields
T 1708788546 19*	Now talking on 22##rust
T 1708788546 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708788546 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708788723 19*	Now talking on 22##rust
T 1708788723 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708788723 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708788816 18<29yuri603718>	well I think there's no other choice at this point my input XML is unparseable in Rust
T 1708788869 18<19Alexendoo18>	Since you're in boring hyperbole mode I assume you're just using the library wrong
T 1708788895 18<19Alexendoo18>	As has been the case every other time
T 1708788902 18<20j`ey18>	lmao I really hate yuri6037's way of talking
T 1708788921 18<20j`ey18>	glad theyve been away for ages lol
T 1708788947 18<29yuri603718>	The problem is the library does not dcument anything about unordered items
T 1708788973 18<29yuri603718>	it appears nobody in Rust has through of unordered XML elements when parsing XML
T 1708789007 18<20j`ey18>	but apparently it's super common /s
T 1708789043 18<29yuri603718>	at least its common enough to be supported in C# and Jav
T 1708791425 18<20nullie18>	it was always a stupid idea to store structures in xml
T 1708791460 18<29yuri603718>	I ended finding something the quick_xml lib can do it but using very weird struct field names
T 1708791516 18<29yuri603718>	Like naming "monitor" instead of "monitors" in order to parse a Vec<Monitor> and naming "sensor" instead of "sensors" to parse a Vec<Sensor>
T 1708791532 18<29yuri603718>	This behavior is obviously not documented
T 1708791573 18<29yuri603718>	and error messages from the lib are misleading like saying that fields do not exist when they do on a standard text editor
T 1708791637 18<26danieldg18>	yes, if you want automatic things you'll need to use the right plurality; otherwise, you can generally rename them
T 1708791673 18<26danieldg18>	it's perfectly reasonable to have both <monitor> and <monitors> tags in XML
T 1708791691 18<24ksynwa18>	Is this the "correct" way to check a Path? `path == Path::new("filename.json")`
T 1708791700 18<26danieldg18>	ksynwa: define 'check'
T 1708791727 18<26danieldg18>	ksynwa: because that doesn't actually do anything but convert the type
T 1708791748 18<24ksynwa18>	I just wanna check if path points to filename.json
T 1708791783 18<24ksynwa18>	Don't care if there is a file there or not. Just what the string value is.
T 1708791810 18<26danieldg18>	ksynwa: ok, rephrasing: what do you want to *reject*?
T 1708792087 19*	Now talking on 22##rust
T 1708792087 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708792087 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708792254 18<20nullie18>	ksynwa: maybe path.to_str() == Some("filename.json")
T 1708792268 18<24ksynwa18>	Yeah that looks fine.
T 1708792278 18<20nullie18>	but why are you doing that?
T 1708792341 18<24ksynwa18>	nullie: I am reading the contents of a zip file. For certain filenames I want to handle the files differently.
T 1708792627 18<19Alexendoo18>	The == Path::new() allows skipping the UTF-8 check
T 1708794688 18<20nullie18>	yeah, could be faster
T 1708823390 19*	Now talking on 22##rust
T 1708823390 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708823390 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708828544 18<24krez18>	hello :D
T 1708834319 18<22thegman18>	is set_read_timeout not a thing on TcpListener
T 1708834340 18<22thegman18>	i cant figure out how to notify a listener that the sender has finished sending stuff
T 1708834384 18<26danieldg18>	tcplistener is for new sockets
T 1708834405 18<26danieldg18>	it's normally used in an event loop, not with timeouts
T 1708834519 18<22thegman18>	i thought tcplistener was used to receive bytes from a tcp stream
T 1708834889 18<27Affliction18>	nope, it's used to listen on a port and accept connections.
T 1708834919 18<22thegman18>	how do i recieve data then
T 1708834928 18<22thegman18>	tcp listener works but it wont close afterwards
T 1708834929 18<27Affliction18>	It creates TcpStreams for incoming connections, which are bidirectional
T 1708837557 18<25Widdershins18>	listener sockets bind to a port & wait for incoming connections, they don't send or receive data themselves
T 1708840407 18<22Ademan_18>	since &str[i] isn't supported (I understand why), is there a way I can iterate over characters in the string and pull out regions as a slice? I started going down that path and I don't think I can do it without a useless enumerate() to keep track of character index (can't == compare Skip<Char<...>> apparently)
T 1708840451 18<22Ademan_18>	the approach I was going for was going to require me to collect() into a new String anyway, if I could get it working
T 1708840779 18<25Widdershins18>	Ademan_: pull out what regions?
T 1708840828 18<22Ademan_18>	oh, char_indices() looks promising, if I want to grab a slice from start = s.char_indices() to stop = s.char_indices().skip();  can I just do &s.as_bytes()[start.0..stop.0] ?
T 1708840858 18<22Ademan_18>	Widdershins: some region I've selected while parsing
T 1708840934 18<22Ademan_18>	wait I'm being dumb s.as_bytes()[...] is going to be a &[u8] and I can't just get the current index with .0 heh
T 1708841057 18<22Ademan_18>	oh start.offset()..stop.offset() would work if it wasn't experimental
T 1708841117 18<22Ademan_18>	I assume s.as_bytes()[start.offset()..stop.offset()] would result in a valid utf-8 byte slice so I ought to be able to turn that back into a string slice, but I'm hosed since offset() is experimental anyway
T 1708841577 18<22Ademan_18>	oh huh, since Chars is a DoubleEndedIterator maybe it does everything I need by itself...
T 1708841606 18<22Ademan_18>	will have to look again later though, night
T 1708852943 18<20polychromata{J}18>	Ademan_: you can't index a string with a single integer, but you /can/ slice it with a range
T 1708852955 18<20polychromata{J}18>	(put you've probably already figured that out)
T 1708853351 18<20jbg18>	thegman: most likely you are actually using TcpStream (returned by accept() on TcpListener) without realising it. to close the connection you can just drop the TcpStream
T 1708857124 18<27synapse18>	can my Cargo example have its own dependencies?
T 1708857192 18<25Widdershins18>	synapse: examples can use dev dependencies
T 1708882893 19*	Now talking on 22##rust
T 1708882893 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708882893 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709072158 19*	Now talking on 22##rust
T 1709072158 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709072158 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709082580 19*	Now talking on 22##rust
T 1709082580 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709082580 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709164962 19*	Now talking on 22##rust
T 1709164962 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709164962 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709165582 20*	Disconnected (20)
T 1709165726 23*	28dacd is already in use. Retrying with 18david_...
T 1709165730 22*	26david_ sets mode 24+Z on 22david_
T 1709165730 22*	26david_ sets mode 24+i on 22david_
T 1709165730 22*	26david_ sets mode 24+w on 22david_
T 1709165730 -18SaslServ-	Last login from: ~dacd@newoobs.freeboxos.fr on Feb 29 00:02:35 2024 +0000.
T 1709165730 -18NickServ-	This nickname is registered. Please choose a different nickname, or identify via /msg NickServ IDENTIFY david_ <password>
T 1709165736 19*	Now talking on 22##rust
T 1709165736 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709165736 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709181363 18<20polychromata{J}18>	evalr: -0.0_f64
T 1709181365 -18evalr/22##rust-	polychromata{J}: -0.0
T 1709181438 18<20polychromata{J}18>	evalr: --nightly #![feature(float_next_up_down)] (0.0_f64.is_finite(), (-0.0_f64).is_finite())
T 1709181440 -18evalr/22##rust-	polychromata{J}: (true, true)
T 1709188597 18<19Chagall18>	Is anyone aware of a simple method for adding or parsing dakuten/handakuten in Japanese chars?
T 1709188630 18<19Chagall18>	(Simpler than writing lookup tables myself)
T 1709188720 18<19Chagall18>	IIRC it's possible by operating on the character codes depending on the encoding...
T 1709188752 18<19Chagall18>	But that's not very idiomatic(TM)
T 1709189317 18<22Arnavion18>	Parsing can be done by normalizing into whatever form separates the dakuten/handakuten (NFD?)
T 1709189343 18<22Arnavion18>	Adding can be done by the opposite normalization
T 1709189387 18<19Chagall18>	Ah, neat
T 1709189412 18<22Arnavion18>	evalr: use unicode_normalization::UnicodeNormalization; "ば".nfd().collect::<Vec<_>>()
T 1709189414 -18evalr/22##rust-	Arnavion: ['は', '\u{3099}']
T 1709189445 18<19Chagall18>	perfect, thanks
T 1709212532 20*	Disconnected (20)
T 1709212545 22*	26david_ sets mode 24+Z on 22david_
T 1709212545 22*	26david_ sets mode 24+i on 22david_
T 1709212545 22*	26david_ sets mode 24+w on 22david_
T 1709212545 -18SaslServ-	Last login from: ~dacd@newoobs.freeboxos.fr on Feb 29 13:15:37 2024 +0000.
T 1709212545 -18NickServ-	This nickname is registered. Please choose a different nickname, or identify via /msg NickServ IDENTIFY david_ <password>
T 1709212551 19*	Now talking on 22##rust
T 1709212551 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709212551 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709213993 19*	Now talking on 22##rust
T 1709213993 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709213993 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709216163 19*	Now talking on 22##rust
T 1709216163 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709216163 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709218715 18<22Ademan_18>	Just when I thought I was starting to figure lifetimes out... https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=2d1decc35a732b73a1a04340752d94dd why does the compiler want me to add 's (the lifetime of the &str CharIndices points to) to the result iterator? On the contrary the result lifetime 'r should be less than or equal to that, right?
T 1709218765 18<25cehteh18>	programmers rule #1 The compiler is always right :D
T 1709218800 18<22Ademan_18>	secondary question is: is there something that does what RefMap here does (wrap an iterator without owning it, and applying a map function to its elements results)
T 1709218908 18<19Alexendoo18>	.by_ref().map()?
T 1709218927 18<19Alexendoo18>	Or just .map if you already have a &mut Iterator
T 1709218985 18<22Ademan_18>	Alexendoo: thanks you're right!
T 1709219063 18<19Alexendoo18>	The trick being https://doc.rust-lang.org/std/iter/trait.Iterator.html#impl-Iterator-for-%26mut+I
T 1709219691 18<22Ademan_18>	so does ` -> impl Iterator<Item = char> + 's` express something other than "a type implementing iterator that lives *at least* as long as 's" ? If it means what I think, doesn't that mean the result could outlive the original string being referenced? (since we have CharIndices<'s>)
T 1709219740 18<25bertptrs18>	no, because CharIndices<'s> borrows the lifetime of the underlying string 's
T 1709219789 18<25bertptrs18>	I don't quite know why you're not allowed to unify the lifetimes into 'i; I would expect that to work
T 1709220011 18<22Ademan_18>	changing the lifetimes to simply be `'i: 'r + 's` appears to work but I still am really struggling why the lifetime of 'i should exceed 's. I feel like I missed something important not reading the rust book page by page or something.
T 1709220153 18<25bertptrs18>	ah now I understand, your relation was wrong
T 1709220277 18<25bertptrs18>	you wrote 's: 'i, but this is the wrong way around, it should be 'i: 's
T 1709220302 18*	20polychromata{J} frowns and flips through the Book yet again to confirm that `'a: 'b` means 'a lives at least as long as 'b
T 1709220593 18<20polychromata{J}18>	i'm confused too c.c
T 1709220594 18<22Ademan_18>	yeah so I am still confused lol, doesn't this indicate the the reference iter will borrow for 'i, which is now longer than 's, which is the lifetime of the underlying &str of CharIndices<> ? Maybe the key is me not understanding "no, because CharIndices<'s> borrows the lifetime of the underlying string 's" ?
T 1709220876 18<25bertptrs18>	Hmm, yeah, that makes no sense, even if it compiles
T 1709220890 18<22Ademan_18>	maybe it can be distilled further: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=c8fd35a844a20ce33ee9663bc6c9aa3c
T 1709220947 18<22Ademan_18>	hrm no, my modified version doesn't mind if 'i and 's are totally unrelated lifetimes, I guess *that* makes sense
T 1709221264 18<22Ademan_18>	HRM, this might be slightly enlightening https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=fdd7f10fad30b06b654c3f2c4bec67c8 as_str() returns a string reference with lifetime 's and the exact lifetime of 'i remains irrelevant. it's like it was "cut through". obvious but possibly relevant behavior
T 1709221272 18<22Ademan_18>	if anyone tires of me thinking out loud please tell me to shut up
T 1709221364 18<25cehteh18>	yoi can just remove 'i there :D
T 1709221416 18<25cehteh18>	well i'd only took a glimpse
T 1709221446 18<22Ademan_18>	yeah I think you're right, I'm kind of just exploring right now, though
T 1709221488 18<25cehteh18>	aim for minimal lifetime annotations, let the compiler infer as much and if possible use generic '_
T 1709221915 18<25cehteh18>	CharIndices::as_str()  returns the str with the same lifetime as CharIndices, theoretically it may be a longer lasting one, but that complicates things as it would need to expose another lifetime up
T 1709221940 18<25cehteh18>	you have some kindof artifical limit there, which makes sense
T 1709221962 18<25cehteh18>	impl<'a> CharIndices<'a> { pub fn as_str(&self) -> &'a str
T 1709222573 18<22Ademan_18>	is it fair to say that the return value of as_str()s lifetime is "up to 'a" ? Since typically I think of lifetimes as being "at least 'x"
T 1709222603 18<22Arnavion18>	No, it's "at least 'a"
T 1709222630 18<22Arnavion18>	The 'a is the lifetime of the original &str that .char_indices() was called on
T 1709222694 18<22Arnavion18>	The returned &str only borrows from that original &str and nothing from the CharIndices, so there's no reason to limit its lifetime to the CharIndices itself
T 1709223626 18<22Ademan_18>	Arnavion: the last part makes perfect sense, but I don't understand how you could borrow "at least 'a" if the lifetime of the original str is also 'a (which afaict it is, per what cehteh shared above)
T 1709223661 18<22Ademan_18>	or I guess the lifetime of the original string is *also* "at least 'a"
T 1709223690 18<22Ademan_18>	but then how could you borrow it safely longer than 'a? I wouldn't think you could.
T 1709224371 18<25cehteh18>	of course you cant
T 1709224736 18<29Beatussum18>	Hi! I'd like to write a function returning an iterator but what should I prefer to specify as return type ? 1) An `impl Iterator<Item = Something>` ? 2) The iterator type directly which could be therefore a bit long ?
T 1709224927 18<20j`ey18>	Beatussum: impl Iterator is good yeah
T 1709225053 18<29Beatussum18>	j`ey: if the iterator returned implements other traits (for example, Clone, Debug, etc.) should I specify them too?
T 1709225089 18<20j`ey18>	if they make sense
T 1709225232 18<22Ademan_18>	cehteh: then how can we say the lifetime is "at least 'a" ? longer than 'a would be longer than the known lifetime of the underlying string
T 1709225235 18<25cehteh18>	just specify what you need, no more no less
T 1709225304 18<25cehteh18>	Ademan_?
T 1709225314 18<29Beatussum18>	cehteh: okay I've got it
T 1709225319 18<29Beatussum18>	thanks :)
T 1709225527 18<27gastus18>	I tried .lines to count lines of a file found out that it's much slower than C fgets() function. Found rust-mio but I have issues compiling it on some systmes eg stdlib.h is missing (nixos) or OSX other error. Is there yet another solution I missed ? I am interested in using json-yy like very fast parsers cause I have to process like 3GB of JSON files.
T 1709225583 18<25cehteh18>	gastus: you use that with a BufReader ?
T 1709225841 18<29Beatussum18>	I've another question about the error `E0700`? I'm not sure to understand why a lifetime specifier is needed in the following case https://bpa.st/PG3A
T 1709226581 18<22Arnavion18>	Ademan_: We're talking about "at least" / "at most" from different points of view :)
T 1709226630 18<22Arnavion18>	A &'static str can be converted to a &'a str. So from the POV of the producer of the &'a str, the str lives at least as long as 'a (it could be living longer). From the POV of the consumer of the &'a str, the str lives at most as long as 'a
T 1709226686 18<22Arnavion18>	The consumer for example cannot put it in a variable of type &'static str, because the &str is only guaranteed to live at most as long as 'a
T 1709227131 18<22Arnavion18>	So in this case, CharIndices::as_str() could just return `"foo"` (str literals are &'static str) and it would compile fine. But when the caller of CharIndices::as_str() lost the original &str that they had called .char_indices() on, they would also lost the &str returned by CharIndices::as_str()
T 1709227466 18<29Guest1318>	Hi, how do I print the current enum variant as string, assuming its debug/display traits were changed to something unrelated(like a full error message), this output is what I'm looking for: https://play.rust-lang.org/?version=nightly&mode=debug&edition=2024&gist=9e002932cba05f4c386211e2356c9df2
T 1709228572 18<27gastus18>	cehteh: Looks like libc might do it as well. So google fooled me into using a maybe too complex library.
T 1709228599 18<25cehteh18>	huh?
T 1709228805 18<25cehteh18>	just using a BufReader should fix this, when you didnt do so already, while rust might be a bit more pedantic since it validates that the strings/lines are utf-8, when you need it really fast then you count the \n's
T 1709228810 18<25cehteh18>	byte wise
T 1709228851 18<27gastus18>	Yes, the UTF-8 might be the reason why it's slower. Cause the JSON parsing in C showed similar difference.
T 1709228873 18<25cehteh18>	i suspect the most slowdown comes when you dont do buffered io
T 1709228881 18<27gastus18>	I will try and report.
T 1709228918 18<25cehteh18>	reading each byte is then a syscall turnaround
T 1709228942 18<27gastus18>	In fact I was using BufReader (thanks GPT :-). So that's not the difference.
T 1709228962 18<25cehteh18>	ah ok, hence i asked, W/O would be slower
T 1709228973 18<25cehteh18>	maybe you use a bigger buffer as well
T 1709229008 18<27gastus18>	Maybe boost of my CPU is not setup correctly. Maybe RAM actually is the bottleneck. That would explain why UTF8 makes bigger difference than it should.
T 1709229019 18<19edgimar18>	What is the recommended way to compute an average and standard-deviation on a [f64]?  I'm looking for traits that are already defined, since I don't want to reinvent the wheel every time I need this.
T 1709229087 18<25cehteh18>	gastus: the utf-8 check adds certainly some penalty
T 1709229253 18<19Alexendoo18>	BufRead::lines allocates a new string for each line, there's read_line if you want to re-use the same buffer
T 1709229318 18<25cehteh18>	the fastest would be to mmap the file, some madvise hints and then iterate by bytes counting \n's .. possibly in few parallel threads :)
T 1709229329 18<19edgimar18>	And yes I can just do numbers.iter().sum / (numbers.len() as f64), but I want something like numbers.mean_and_std().
T 1709229336 18<25cehteh18>	of course thats the most involved was as well :)
T 1709230813 18<20consus18>	Documentation to From suggests that implementing From<T> for U also brings me Into<T> for U
T 1709230819 18<20consus18>	However, that's not happening
T 1709230830 18<20consus18>	What am I doing wrong?
T 1709230851 18<20j`ey18>	Into<U> for T
T 1709230856 18<20spb18>	implementing From<T> for U gets you Into<U> for T
T 1709230876 18<20consus18>	ah dammit
T 1709230898 18<20consus18>	shame :(
T 1709231084 18<29Guest1318>	If I try to find out type of 'e' by doing "let i:i64=e;", then I get ^ expected `i64`, found `Error`, but 'Error' is not good enough type information, whilst I know now it's an enum variant "pkg_config::Error::Command" at that spot in the code (through brute force means aka match over all variants but what if there's 100s?!). Is there some way to
T 1709231084 18<29Guest1318>	find that "pkg_config::Error::Command" type?
T 1709231393 18<20consus18>	given that I've implemented both From<T> for U and Into<T> for U, should I also imlement From<Vec<T>> and Into<Vec<T>>?
T 1709231403 18<20consus18>	Or these come for free?
T 1709231526 18<20spb18>	you generally shouldn't implement Into yourself
T 1709231543 18<20spb18>	if the conversion goes both ways, impl From<T> for U and From<U> for T
T 1709231556 18<20consus18>	sadly I cannot touch U
T 1709231559 18<20consus18>	that's foreign type
T 1709231625 18<20consus18>	Or it's possible to define From<U> if U is another crate?
T 1709231681 18<20spb18>	you can impl From<T> on U if you own T
T 1709231692 18<20consus18>	oh
T 1709231726 18<20spb18>	owning a type that's a generic param for the trait is enough to satisfy the orphan rule
T 1709231741 18<20consus18>	thanks
T 1709231745 18<20consus18>	    Ok(Json(list.into_iter().map(Into::into).collect()))
T 1709231760 18<20consus18>	So then I have this
T 1709231765 18<20consus18>	Vec<T> -> Vec<U>
T 1709231811 18<20consus18>	Is it possible to make it like this: Ok(Json(list.into())? Or this is not how things work?
T 1709231848 18<29Guest1318>	just making sure, can people see this message?
T 1709231849 18<20consus18>	I was under the impression that Into should work for T<U> -> T<F> conversions
T 1709231924 18<20spb18>	not in the general case
T 1709231932 18<20consus18>	:(
T 1709231950 18<29Guest1318>	hello?
T 1709231956 18<20consus18>	Guest13: Hi :)
T 1709231987 18<29Guest1318>	oh ok, sorry, i thought my messages weren't getting through, I guess then no one knows about my issue, which is fair
T 1709232020 18<20j`ey18>	Guest13: yes the compiler wont print the exact variant basically
T 1709232049 18<29nox18>	How would rustc know
T 1709232052 18<29Guest1318>	ok, thanks
T 1709232064 18<29Guest1318>	I don't know, I thought maybe macros
T 1709232073 18<29Guest1318>	but I'm too new
T 1709232105 18<29Guest1318>	I guess the way is through match after all
T 1709232121 18<20j`ey18>	or dbg!(e) if it supports Debug
T 1709232151 18<29nox18>	Guest13: e is an Error, rustc knows that, but it doesn't know which variant the value is, as that's known at runtime
T 1709232152 18<29Guest1318>	it does but it prints an explanation message, and I was trying to see which type it was so I can match against it instead
T 1709232166 18<29Guest1318>	nox, understood,. thanks
T 1709233371 18<20consus18>	spb: thanks, this pub trait VecExtInto<T, U> {
T 1709233371 18<20consus18>	    fn morf(self) -> Vec<U>;
T 1709233371 18<20consus18>	}
T 1709233371 18<20consus18>	impl<T,U> VecExtInto<T, U> for Vec<T>
T 1709233371 18<20consus18>	where
T 1709233372 18<20consus18>	    U: From<T>
T 1709233372 18<20consus18>	{
T 1709233373 18<20consus18>	    fn morf(self) -> Vec<U> {
T 1709233373 18<20consus18>	        self.into_iter().map(Into::into).collect()
T 1709233374 18<20consus18>	    }
T 1709233374 18<20consus18>	}
T 1709233375 18<20consus18>	does the trick
T 1709234370 18<27Ademan18>	Arnavion: thanks, that makes sense, now I just need to integrate that info haha
T 1709235556 18<27gastus18>	libc fopen returns FILE which is enum FILE {}. So there is no real way to check the result of an fopen call (trying to be unsafe to understand the speed difference). So looks like best way to go is write actual C code.
T 1709235951 18<20osse18>	gastus: Can call ptr.is_null() ?
T 1709236819 18<28_Vi18>	Is there already a feature proposal / pre-RFC about library compilation settings that are supposed to be adjusted only by a root crate, not intermediate dependencies? For example, `tokio_unstable`. Many rhai's Cargo-level features would look better as root-crate-only features.
T 1709254781 19*	Now talking on 22##rust
T 1709254781 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709254781 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709260299 18<26danieldg18>	is there a nicer-looking way of getting a String out of a HashMap<&str,&str> than map.get("key").map_or("", |s| s).into()?
T 1709260827 18<19She18>	danieldg: Consider https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_default instead of the map_or.
T 1709260915 18<26danieldg18>	She: can't; it's an Option<&&str>, which has no Default
T 1709261210 18<19She18>	Ooop, indeed, you'd also need to throw a cloned() into there.
T 1709261339 18<20polychromata{J}18>	evalr: <&str as Default>::default()
T 1709261341 -18evalr/22##rust-	polychromata{J}: ""
T 1709261351 18<20polychromata{J}18>	evalr: <&&str as Default>::default()
T 1709261352 -18evalr/22##rust-	polychromata{J}: error[E0277]: the trait bound `&&str: Default` is not satisfied ...
T 1709261353 -18evalr/22##rust-	polychromata{J}: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=18c5736f5e498008079eee3e407cea29
T 1709261359 18<20polychromata{J}18>	ah, that makes sense
T 1709261513 18<22Arnavion18>	Or get to Option<String> and then _or_default it, eg   .get().copied().map_or_else(Default::default, Into::into)
T 1709261727 18<26danieldg18>	sure.  Mine wins for code-golf, but I think I'll use .copied.unwrap_or_default.to_owned
T 1709261733 18<22Arnavion18>	Also   impl Default for &&T where &'static T: Default { fn default() -> Self { &Default::default() } }   would let &&str be Default, I think
T 1709261816 18<26danieldg18>	might fail due to str:!Sized
T 1709261868 18<26danieldg18>	I don't see the &&T impl in the docs
T 1709261871 18<25Mutabah18>	Nah, it'd fail due to `Default::default()` not being `const`
T 1709261876 18<26danieldg18>	ah
T 1709261928 18<22Arnavion18>	https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=bd3443fd171959867f0aa78d91bbb5a7   Bah
T 1709261988 18<22Arnavion18>	Yeah, makes sense, static promotion only works for const-evaluated exprs
T 1709268584 18<19mips64el18>	hi o/
T 1709273526 18<22Ademan_18>	are derived Clones inline? in general? with exception? always?
T 1709278979 18<25bertptrs18>	Ademan_: at present not defined, but you can use cargo-expand to see (it is)
T 1709285542 18<24Bish18>	whenever i use a stream i basicially HAVE to get the futures_util::StreamExt, why isn't that default? im guessing because stream is not a first class citizen in rust?
T 1709285547 18<24Bish18>	is it async streams that are not std::stream ?
T 1709286520 18<25bertptrs18>	std::stream does not exist yet, and currently the Stream trait is kept minimal to make future adoption easier
T 1709286988 18<24Bish18>	and where is "the" stream trait? is it in futures_util?
T 1709287189 18<25bertptrs18>	futures_core
T 1709287293 18<20nullie18>	is there a better way to do something n times (than for _ in 0..n)?
T 1709287411 18<20j`ey18>	(0..n).for_each(..) maybe
T 1709287456 18<20osse18>	std::iter::repeat(()).take(10).for_each(|()| do_something())  \O/
T 1709287472 18<20j`ey18>	heh
T 1709287495 18<20j`ey18>	thars more optimal since it doesnt need to count the numbers /s
T 1709287595 18<26dav1d18>	j`ey, https://rust-lang.github.io/rust-clippy/master/index.html#/needless_for_each
T 1709287657 18<26dav1d18>	Wait did they move that lint into pedantic 🤔
T 1709287658 18<20osse18>	Hmm, when is .for_each() more performant ?
T 1709287798 18<20j`ey18>	dav1d: not sure if that would apply here?
T 1709287862 18<26dav1d18>	can I make clippy pedantic on the playground?
T 1709287938 18<26dav1d18>	j`ey, yeah it doesn't
T 1709290054 18<20polychromata{J}18>	osse: probably never
T 1709290063 18<20polychromata{J}18>	all else being equal, just use for{}
T 1709290085 18<20polychromata{J}18>	IOW, `for _ in 0..n {}` /is/ the way to do that
T 1709290112 18<20polychromata{J}18>	(i'll accept for_each() if it's a lot nicer to write, e.g. at the end of a long iterator chain)
T 1709290127 18<20polychromata{J}18>	(at least until we get postfix control flow keywords c; )
T 1709292303 18<22prmthz18>	hello! does anyone know how can I set "cargo test" parameters like "--test-threads=2" in the .cargo/config.toml ?
T 1709293849 18<20curious-user18>	hi, is there an orm which can load nested one-to-many relations without jumping through hoops?
T 1709293924 18<20curious-user18>	sea orm can't do that at all, diesel can but requires a lot of grouped_by's and zip's
T 1709293981 18<20curious-user18>	it seems weird that such basic functionality is still missing from major orms
T 1709294097 18<20curious-user18>	(not bashing, just wondering maybe i've missed something)
T 1709295707 18<27sword_smith18>	How do I strip all special characters from a string? The concrete example I have right now is that I want to convert the string
T 1709295715 18<27sword_smith18>	"*a" into "a".
T 1709295747 18<27sword_smith18>	Or `&str`, I guess. I don't think that matters. But what I have now i of type `String`.
T 1709295858 18<20j`ey18>	hm, maybe .replace(&['a', 'b'....'z'], "")
T 1709295863 18<20j`ey18>	that seems a little annoying
T 1709295875 18<20j`ey18>	ah no, you can put a function there
T 1709295922 18<20j`ey18>	evalr: let a = String::from("a-z"); a.replace(|c|!c.is_alphabetic(), "")
T 1709295924 -18evalr/22##rust-	j`ey: error[E0282]: type annotations needed ...
T 1709295924 -18evalr/22##rust-	j`ey: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=8faea1028e4dbb8e42af3cf0ddd9caea
T 1709295953 18<20j`ey18>	evalr: et a = String::from("a-z"); a.replace(|c: char|!c.is_alphabetic(), "")
T 1709295955 -18evalr/22##rust-	j`ey: error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an ...
T 1709295955 -18evalr/22##rust-	j`ey: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=805e1fdc104003e093c03c105bf383df
T 1709295959 18<20j`ey18>	ffs lol
T 1709295983 18<19Lumpio-18>	...et?
T 1709296008 18<20j`ey18>	mis copy :)
T 1709296012 18<20polychromata{J}18>	evalr: let a = String::from("a-z"); a.replace(|c: char| !c.is_alphabetic(), "")
T 1709296014 -18evalr/22##rust-	polychromata{J}: "az"
T 1709296135 18<27sword_smith18>	j`ey: That seems to work :)
T 1709296327 18<27sword_smith18>	This is for the debugger of a VM. I'm auto-generating some type/variable name hints. The best solution would be to make the assembly-parser more permissive wrt. these names, but for now, j`ey's above snippet works.
T 1709296379 18<20polychromata{J}18>	eh, that's fair. :)
T 1709296391 18<20polychromata{J}18>	though perhaps…
T 1709296407 18<20polychromata{J}18>	evalr: let a = String::from("a**z%"); a.replace(|c: char| !c.is_alphabetic(), "_")
T 1709296409 -18evalr/22##rust-	polychromata{J}: "a__z_"
T 1709296441 18<20j`ey18>	yes _ is better, maybe
T 1709296463 18<20osse18>	polychromata{J}: i see. Then that performance claim in that clippy is a bit weird.
T 1709296500 18<20polychromata{J}18>	clippy makes a performance claim?
T 1709296534 18<20osse18>	Bad phrasing on my part, probably.
T 1709296546 18<20osse18>	I meant this, quoted from the link above: "for_each may be used after applying iterator transformers like filter for better readability and performance. It may also be used to fit a simple operation on one line. But when none of these apply, a simple for loop is more idiomatic."
T 1709296552 18<27sword_smith18>	All tests pass :) I'm going with the replacement with `_`.
T 1709296576 18<20polychromata{J}18>	i'd be surprised if `for bar in foo { $body }` and `foo.for_each(|bar| { $body });` compiled to any different code.
T 1709296731 18<20osse18>	Same
T 1709296744 18<20osse18>	Interesting, from the std docs: "In some cases for_each may also be faster than a loop, because it will use internal iteration on adapters like Chain."
T 1709296923 18<20osse18>	Aka. it can take some shortcut that doesn't involve literally calling next() I guess
T 1709296937 18<20osse18>	s/Aka\./IOW./
T 1709296974 18<19LDericher18>	hi, currently relearning rust on my stm32 "blue pill" thingy and ran into an ownership/borrowing problem. Code: https://bpa.st/EUEA Issue: Lines 72/73 work, but doing that inside the loop at L82/87 fails as `tx` and `buf` are moved into the loop. tx and buf are both okay to be made 'static if needed. how to proceed?
T 1709297195 18<19LDericher18>	also, changing `buf` to `&*buf` in L82 makes one error go away as the analyzer suggests, but doesn't that only give the first value to the `write` fn?
T 1709297978 18<20osse18>	LDericher: what is the signature of tx.write()
T 1709298076 19*	Now talking on 22##rust
T 1709298076 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709298076 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709298308 18<19LDericher18>	osse, `fn write(mut self, buffer: B) -> Transfer<R, B, Self>` and `B: ReadBuffer<Word = u8>`
T 1709298429 18<20spb18>	https://docs.rs/stm32f1xx-hal/latest/stm32f1xx_hal/serial/type.TxDma1.html
T 1709298439 18<20spb18>	that's the `tx` you're working with
T 1709298514 18<20spb18>	write() consumes self and presumably wraps it into the returned Transfer object so you have to wait for the operation to complete before using it again for a new one
T 1709298597 18<19LDericher18>	spb, yes and the error is: `stm32f1xx_hal::dma::WriteDma::write` takes ownership of the receiver `self`, which moves `tx`
T 1709298692 18<20spb18>	yes
T 1709298710 18<20spb18>	once you call tx.write() you cannot use tx any more because it is consumed by the write call
T 1709298760 18<19LDericher18>	but the `with_dma` call to initialize `tx` takes care of the DMA initialization, so I'd like to reuse tx
T 1709298782 18<20spb18>	you can't reuse tx, the api doesn't allow it
T 1709298805 18<20spb18>	what you can do is use the returned Transfer object to get a new tx out of it, once the transfer has completed
T 1709298854 18*	20polychromata{J} squints at that name.
T 1709298858 18<28null_ptr18>	osse: One problem with for loops is that the compiler cannot generate nested loops and needs additional state tracking. With internal iteration the iteration structure can be kept optimal.
T 1709298938 18<19LDericher18>	I don't see anything in the `xfer` that looks like "reinitiate this" ... on the other hand I just inspected the DMA init and it looks less complex than I assumed it to be
T 1709298971 18<20spb18>	LDericher: look at what's returned from wait()
T 1709299268 18<19LDericher18>	spb, looks fine https://bpa.st/ORDQ but only shifts the issue: `Tx::<stm32f1xx_hal::pac::USART1>::with_dma` takes ownership of the receiver `self`, which moves `serial.tx`
T 1709299326 18<20spb18>	that's not at all what i said to do
T 1709299371 18<19LDericher18>	and using wait() feels like a chicken-and-egg problem as I'd need a completed Transfer before starting one?
T 1709299471 18<20spb18>	once you start the transfer, you need to use wait(), get whichever type that particular variant returns in its tuple, call release() on that, and you get a new Tx
T 1709299487 18<20spb18>	set up dma again on that, and write it back over the top of `tx` so you can use it in the next loop
T 1709299599 18<20spb18>	i'm being vague here because i'm working purely from the rustdocs which are pretty hopeless
T 1709299617 18<20spb18>	hopefully there's some real documentation somewhere else to make actual sense of why all this dance is required
T 1709299748 18<19LDericher18>	well it works, idk why it is this convoluted, but the C(++) way is way more obscure btw
T 1709305277 19*	Now talking on 22##rust
T 1709305277 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709305277 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709312939 19*	Now talking on 22##rust
T 1709312939 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709312939 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709316253 19*	Now talking on 22##rust
T 1709316253 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709316253 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709345126 19*	Now talking on 22##rust
T 1709345126 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709345126 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709348632 18<29Sync0318>	Hi there -- I have am making a vim-like editor, and I am implementing functionality for buffers. Does an associated function exist for the iter type, that is similar to .next() but when the end of the iterator is reached, instead of returning None, it goes back to the start of the iterator. So it's effectively infinitely repeating? Is this a possibility? Cheers.
T 1709348736 18<26danieldg18>	sure; look at Iterator::cycle
T 1709348781 18<29Sync0318>	Thanks!
T 1709348783 18<26danieldg18>	it isn't used like you described but it does what you want
T 1709354580 18<26josh1929118>	¬¬LL
T 1709354811 18<26josh1929118>	Hi
T 1709356535 19*	Now talking on 22##rust
T 1709356535 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709356535 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709356629 19*	Now talking on 22##rust
T 1709356629 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709356629 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709362996 18<25Guest2718>	Iti
T 1709363025 18<25Guest2718>	YMEJWG
T 1709363074 18<25Guest2718>	Bn8
T 1709364424 18<19Wulf18>	How do I call posix_fadvise on an std::fs::File?
T 1709364958 18<20capitol18>	Wulf: https://docs.rs/nix/latest/nix/fcntl/fn.posix_fadvise.html maybe
T 1709365065 18<20capitol18>	Wulf: or did you mean how to get a rawfd? https://doc.rust-lang.org/std/fs/struct.File.html#impl-AsRawFd-for-File
T 1709365208 18<19Wulf18>	capitol: both. Why won't "use nix::fcntl::posix_fadvise;" not work? "no `posix_fadvise` in `fcntl`"
T 1709365250 18<20capitol18>	maybe "Available on crate feature fs only" have you enabled that feature?
T 1709365257 18<19Wulf18>	capitol: I have no idea what that means.
T 1709365334 18<20capitol18>	when you import it in Cargo.toml you can specify features
T 1709365423 18<20capitol18>	https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#choosing-features
T 1709365857 18<19Wulf18>	capitol: thanks, works.
T 1709366310 18<20capitol18>	Wulf: nice :)
T 1709369074 18<19Wulf18>	How do I declare a function parameter that is either a u64 or "nothing"? And how do I check for "nothing" in the code?
T 1709369104 18<27lambda18>	Wulf: Option<u64>?
T 1709369126 18<27lambda18>	that has a value of either `Some(n)` where `n` is a u64, or `None`
T 1709369187 18<27lambda18>	you can check which one it is with `match`, `if let`, or maybe there's an existing method on `Option` that does what you need - you'd need to explain a bit more about the problem you're trying to solve
T 1709369278 18<19Wulf18>	lambda: it's my second day with rust. Guess I'll look at each of them and see what looks more useful.
T 1709369358 18<27lambda18>	Wulf: FYI, Option isn't magic in any way, the definition at the top of this page is all it really is: https://doc.rust-lang.org/std/option/enum.Option.html
T 1709369388 18<27lambda18>	I'd recommend reading the relevant chapter in the book: https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html?highlight=option#the-option-enum-and-its-advantages-over-null-values
T 1709369581 18<19Chagall18>	anyone else notice a large drop in throughput and less stable measurements when using criterion with batched iterations?
T 1709369669 18<26dav1d18>	Is it feasible to have a macro_rules macro that accepts any enum without data in the variants and then just does something with the variants? I feel like this is proc macro territory
T 1709369954 18<27lambda18>	dav1d: should be possible, if a bit of a pain to cover all the things that can be in an enum definition (attributes and such)
T 1709370076 18<26dav1d18>	lambda, I remembered pin-project-lite does something like that for structs, doesn't seem terrible, just gotta figure out how to not discard docs
T 1709372576 18<20polychromata{J}18>	Wulf: `match{}` is the most general thing; all of Option's other operations can be implemented in terms of it
T 1709372585 18<25farnext18>	 /msg NickServ REGISTER farnext far.next@gmail.com
T 1709372635 18<20polychromata{J}18>	Option has a /ton/ of convenience methods; don't worry about learning them all at once. You'll gradually get to know what's best|prettiest to use in each situation, over time. :)
T 1709372649 18<20polychromata{J}18>	farnext: protip: don't set your password equal to your nickname c.c
T 1709372784 18<20polychromata{J}18>	I like Diceware. Although you can also just use [a-z]+ as long as it's long enough (e.g. 26.pow(11) is roughly equal to 7776.pow(4)).
T 1709372794 18<20polychromata{J}18>	And then, for IRC, there's client cert auth, of course.
T 1709374477 18<19Wulf18>	I'm quite confused with match, functions, error handling, etc. Could someone please translate this toy example to rust for me? https://paste.debian.net/1309229/
T 1709374825 18<20j`ey18>	Wulf: why dont you show us what you have so far
T 1709374991 18<20j`ey18>	Wulf: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021 is a good site for rust snippets
T 1709375631 18<26dav1d18>	ah right I remember, documentation is just an attribute in macro_rules
T 1709375788 18<19Wulf18>	j`ey: https://gist.github.com/rust-play/ef6118a1923a74cdefd328eb7b09a410
T 1709375832 18<20j`ey18>	alright, looks good so far
T 1709375841 18<19Wulf18>	j`ey: well, the error handling is missing.
T 1709375858 18<20j`ey18>	Wulf: then you need to return Result<Self, Error> instead of just Self
T 1709375874 18<20j`ey18>	fn new(foo: Option<u64>, bar: u64) -> Result<Self, YourErrorType> {
T 1709375889 18<19Wulf18>	j`ey: and what error type would that be?
T 1709375942 18<20j`ey18>	you have to make one up or use an exisiting error type
T 1709375950 18<20j`ey18>	or just ().. any type basically
T 1709375976 18<20polychromata{J}18>	The first counterquestion is…is this for a library or an application?
T 1709376040 18<20j`ey18>	Wulf: this extends the example, minimally, https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=4154763522c6ad453c327d76239b3169
T 1709376079 18<20polychromata{J}18>	If it's an app, you can play pretty fast and loose with error types.
T 1709376080 18<19Wulf18>	polychromata{J}: application, but it must not crash when a bad value is passed.
T 1709376091 18<20polychromata{J}18>	Right, of course.
T 1709376138 18<20polychromata{J}18>	So having proper error types isn't quite as important. You can use `Box<dyn Error>` or `anyhow::Error` or whatever—the latter is easy to get started with compared to alternatives, i believe
T 1709376143 18*	20polychromata{J} doublechecks this
T 1709376150 18<19Wulf18>	It will accept a TLS connection and receive the parameter through it. When it's bad, the connection is closed, but the application should keep running to handle other connections.
T 1709376189 18<20j`ey18>	we're not talking about crashing :)
T 1709376190 18<19Wulf18>	j`ey: thanks
T 1709376239 18<20polychromata{J}18>	Oh, wow, anyhow has a good amount of support for ad-hoc errors.
T 1709376245 18<20polychromata{J}18>	That's pretty nice.[^1]
T 1709376361 18<20polychromata{J}18>	So if you pull in anyhow and change the return type to `Result<Self, anyhow::Error>`, you can do things like `if foo > 9 { bail!("tried to construct a Hello with foo={foo:?} (foo must be less than 9)") }`
T 1709376390 18<20polychromata{J}18>	s/bail!/anyhow::bail!/
T 1709376408 18<20polychromata{J}18>	This is a few new things at once; what questions do you have? :)
T 1709376439 18<20j`ey18>	I wwould learn more about Result itself first
T 1709376442 18<19Wulf18>	polychromata{J}: I think throwing more libraries at me only increases my confusion ;-)
T 1709376478 18<20polychromata{J}18>	Well, personally i like to do proper error types everywhere, but that's a good bit more work. :)
T 1709376486 18<20polychromata{J}18>	(Also i use thiserror for that, which is another library.)
T 1709376495 18<20polychromata{J}18>	(Because it's more tedious to not.)
T 1709376526 18<20j`ey18>	I mean the easiest thing to do next is: struct WulfError {} and change the Result<Self, ()> to Result<Self, WulfError>
T 1709376527 18<20polychromata{J}18>	Rust's std tends to err on the minimal side, so if you try hard to avoid libraries, you're probably going to have a bad time. :)
T 1709376561 18*	20polychromata{J} notes that the Book introduces a library (rand) in chapter 2.
T 1709376578 18<20polychromata{J}18>	j`ey: The thing about that, though, is that it carries no information on what actually went wrong.
T 1709376586 18<20j`ey18>	sure
T 1709376589 18*	20polychromata{J} gestures to her error message. It's detailed.
T 1709376597 18<20j`ey18>	but this is like their second day of rust :P
T 1709376625 18*	20polychromata{J} tailswishes.
T 1709376628 18<20polychromata{J}18>	You may be right. :P
T 1709376751 18<20polychromata{J}18>	So yes, `struct WulfError;` is easy…
T 1709376868 18<29saati18>	enum WulfError{}; and the compiler proves you make no errors :)
T 1709376892 18<20polychromata{J}18>	Tch. Uninhabited types on day 2?
T 1709376903 18<20j`ey18>	hah
T 1709377639 18<26dav1d18>	Result::into_ok when 😡
T 1709377648 18<20polychromata{J}18>	never
T 1709377664 18<26dav1d18>	noooooooooooooo :(
T 1709377673 18<20polychromata{J}18>	i know right ;-;
T 1709377683 18<26dav1d18>	!
T 1709379615 18<25Diablo-D318>	you know, its kinda sad that microsoft is this huge big company thats tried to fix directwrite several times (and tbf, they have, its way better than it used to be)....
T 1709379631 18<25Diablo-D318>	but they cant catch up to a bunch of random dudes on the internet who made freetype.
T 1709391486 18<29Beatussum18>	Hi! I would like to implement a "symetric" trait e.g. if I implement MyTrait<A> is implemented for B, therefore MyTrait<B> is also implemented for A by using the previous implementation. What is the best way to achieve this?
T 1709391828 18<19tokie18>	Beatussum: look at From/Into. If you impl From you get the reverse Into trait from a blanket impl
T 1709391917 18<19tokie18>	https://doc.rust-lang.org/src/core/convert/mod.rs.html#747-749
T 1709391999 18<19tokie18>	oh, that's two different traits though
T 1709392544 18<29Beatussum18>	tokie: Yeah, I would like to have the same trait implemented `MyTrait<A>` and `MyTrait<B>` because `MyTrait` provide one method which should be used by an instance of `A` or `B`
T 1709392558 18<29Beatussum18>	`From` and `Into` provide two different method
T 1709393312 18<26josh1929118>	A
T 1709393316 18<26josh1929118>	/hwlp
T 1709394940 18<20polychromata{J}18>	evalr: trait MyTrait<T> {} impl<A, B> MyTrait<B> for A where B: MyTrait<A> {}
T 1709394941 -18evalr/22##rust-	polychromata{J}: ()
T 1709395018 18<20polychromata{J}18>	evalr: trait MyTrait<T> { fn method(&self, other: &T); } impl<A, B> MyTrait<B> for A where B: MyTrait<A> { fn method(&self, other: &B) { other.method(self) } }
T 1709395020 -18evalr/22##rust-	polychromata{J}: ()
T 1709395066 18<20polychromata{J}18>	Beatussum: a cursory check says that it works, but i have a sneaking feeling that there's some subtle reason why it'll break c.c
T 1709402548 19*	Now talking on 22##rust
T 1709402548 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709402548 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709451377 19*	Now talking on 22##rust
T 1709451377 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709451377 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709451483 18<25Widdershins18>	ok the distance from where i was at to the associative key-value version that we've been talking about was pretty short
T 1709451498 18<25Widdershins18>	this passes MIRI https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=a70e90eabeab883b7229a9c4f062f45b
T 1709451526 18<25Widdershins18>	probably a good idea to make it so this panics less when you ask for keys that aren't there or whatever but the underlying mechanism is sound
T 1709451708 18<25Widdershins18>	the symbol repo version of this would have a slightly different api, probably like add_clown but not accepting a value
T 1709452109 18<25Widdershins18>	or, this could be combined with the vec-of-vecs to make a type that doesn't need to be StableDeref itself... so many possibilities
T 1709456979 18<20polychromata{J}18>	Widdershins: passes miri huh
T 1709456993 18<20polychromata{J}18>	do you have yarn tests? do those pass miri?
T 1709459280 18<25Widdershins18>	polychromata{J}: no idk that. yarn is a dep manager for javascript that i avoid looking at, too me. just saying that this doesn't complain when i run that program under miri, so it does seem like the unsafety is pretty much legal
T 1709459299 18<20polychromata{J}18>	not the JavaScript yarn!
T 1709459363 18<20polychromata{J}18>	oh, i misremembered. it's called loom.
T 1709459368 18<25Widdershins18>	i'm unable to find what you're looking for then
T 1709459404 18<20polychromata{J}18>	different textileish word. ^.^;
T 1709459407 18<25Widdershins18>	based on the readme of loom miri is WAY more comprehensive
T 1709459451 18<25Widdershins18>	it also runs a godzillion times slower, and is made to test more of the things i care about here (i am personally a lot more worried about memory UB than the concurrency violation. the concurrency part is simple)
T 1709459531 18<25Widdershins18>	miri makes it so if you so much as accidentally create an intermediate reference when you shouldn't by spelling something in a basically equivalent but different way, it will throw up
T 1709460494 18<26dav1d18>	How can I `cfg(test)` expose something for doctests? Having `#[cfg(any(test, doctest))] pub mod test;` doesn't seem to do it
T 1709460520 18<25Widdershins18>	it doesn't?
T 1709460575 18<26dav1d18>	nope, module not found
T 1709460587 18<26dav1d18>	`unresolved import `enumap::test``
T 1709460601 18<25Widdershins18>	:(
T 1709460636 18<26dav1d18>	:( https://github.com/rust-lang/rust/issues/67295#issuecomment-568287766
T 1709460683 18<26dav1d18>	guess I'll just copy paste into every doctest
T 1709463061 18<26dav1d18>	What trickery am I missing to implement an iterator which yields mutable references form an array? https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=28afe7124468d51f23c63898bfe75944
T 1709463206 18<26dav1d18>	Seems like I'll have to go to unsafe, but meh
T 1709463658 18<26dav1d18>	I finessed it, I think? https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=0cc5e250dc61ce32044e4db239e0d45b
T 1709464322 18<25bertptrs18>	yeah, something like that
T 1709464349 18<25bertptrs18>	there's a reason the default slice iterators use unsafe, to avoid your dance overhead
T 1709464981 18<22gastus_18>	@ polychromata{J}  Want to get the prototype done. Might want to care about arena allocation like etc later. In fact I used C and wrote my own inc based allocation which crashed rust but worked for C and the benefit was small (which was I was told upfront here). Need to proof that merging data from CSV this way actually is faster and worth the effort first compared to eg database. It should be.
T 1709465038 18<22gastus_18>	There is another thing I dont' get yet and that's the unwind to catch panics. Eg when searching there might be unknown symbols which means that find won't find anything (in fact its actually a speedup). So pattern is like try { ..  return true/false} catch { return false }.
T 1709465051 18<22gastus_18>	Maybe passing mut to lambda or such is the way to go.
T 1709465079 18<22gastus_18>	Just sometimes missing the convenience of other languages like ruby begin .. code rescue false end done.
T 1709465115 18<20j`ey18>	you would return a Result, not panic there usually
T 1709465170 18<22gastus_18>	But then I have to write catching the none Some cases..
T 1709465188 18<22gastus_18>	And that's the cool thing about exceptions you don't have to.
T 1709465213 18<20j`ey18>	with the ? operator it's pretty easy to add early returns on Errors
T 1709465404 18<22gastus_18>	So it means Result is to be used instead of Some.
T 1709465450 18<20j`ey18>	Result is used if there could be an error.
T 1709465455 18<20j`ey18>	whereas option is just some or none
T 1709465569 18<22gastus_18>	None in my case means error. So ok_or is the way to go.
T 1709465878 18<22gastus_18>	But then need to turn error case into false. Then need a block within which ? is caught. Then I can use Some and patern matching
T 1709465990 18<20j`ey18>	you cant currently use ? in blocks
T 1709465992 18<20j`ey18>	only functions
T 1709466080 18<20j`ey18>	I guess you could use ? in a closure
T 1709466111 18<22gastus_18>	But then I still need to convert and for two ? its not worth the effort.
T 1709466734 18<25Widdershins18>	you definitely should not be using unwinding for that
T 1709467051 18<22gastus_18>	Widdershins: depends on whether speed or programmers time is important :-/ And that's what annoys me you either have srcipting or compiled. But you cannot mix depending on the part of a project you're working. Not everything is most important. And sometimes its ok to be fast and done and option to optimize later.
T 1709467070 18<22gastus_18>	But let's say you rewriting Dart/js/wahtever to Rust later is huge effort.
T 1709467076 18<25Widdershins18>	dav1d: i'd probably just delegate to core::slice::IterMut
T 1709467120 18<25Widdershins18>	gastus_: i'm saying you're going to waste time and cause lots of problems down the line if you try to it this way instead of learning more ergonomic spellings for these things that already exist
T 1709467147 18<25Widdershins18>	you aren't the only person in the world who needs the kind of control flow you're trying to write. the tools already exist, you just haven't actually asked questions about it yet
T 1709467184 18<22gastus_18>	https://dpaste.com/AU66MTVRY line 72 is one of the stuff I wrote for JS. It basically can create it's own bash completion. It allows to have multiple lazy nested commands done fast.  async ()  or () => or just {} -> it eats everything.
T 1709467217 18<22gastus_18>	Widdershins: which keywords do you suggest me looking up ?
T 1709467242 18<25Widdershins18>	i don't know because i don't know what you're trying to do. you're talking about how results aren't ergonomic to write but you haven't explained what you have
T 1709467304 18<22gastus_18>	I have many CSV files. which contain name/phone .. and they a date like 'company-2023-01-01'. I want to merge all data so that I can query and mix and filter them. Like a person is the same person if they have the same company numebr, the same mobile phone number or have similar name and same zip (this last thing is fuzzy).
T 1709467351 18<22gastus_18>	And because I mostly have like 8 different keys attached I thought that actually representing the data as numbers person is list of attributes. List of attributes is (key, value, list of sources it was found) kinda gets the job done and is memory efficient.
T 1709467387 18<22gastus_18>	Because there are many different ways to query (by GPS location from address, by region such as state, by company) I didn't find a way to make mysql always be fast. So I really was wonedring whether just using 8 threads and filter is easier cause not many users.
T 1709467396 18<25Widdershins18>	sure so what's the issue. i don't see what about this requires intentionally catching unwind
T 1709467418 18<25Widdershins18>	certainly the fact that you have mysql involved is part of your problem. it is a very poor database
T 1709467468 18<22gastus_18>	So searching a phone number which I represent as symbols cause I expect phone numbers to be presented in 20+ csvs the symbol might not exist. So the fun thing is in that case I don't have any work to do to say not found :-) And that was what the case was about mixing the symbol not found with iterating over the people and the attributes.
T 1709467510 18<22gastus_18>	The project is like 10y old and that time I didn't know better. And that's why I investigate bare metal approach to learn from it.
T 1709467564 18<25Widdershins18>	i mean you are just mostly describing indexing all these attributes in memory and skipping the rows with something not-found
T 1709467585 18<26dav1d18>	Widdershins, I'll have to try again, but I think I also needed the Option dance for that to work
T 1709467619 18<22gastus_18>	And because the fuzzy part matching by name / zip depends on task wanted the mixer to be fast and maintainable and adjustable to the task. And loading 300K lines into mysql was like 4h. Now there are 10+ such files. Now thought let me learn Rust and retry using it to learn understand whether the different solution is better and get hands dirty with Rust cause will not go away. And once I understand might
T 1709467625 18<22gastus_18>	get an impression whether I even want to throw away my TS code. Not there yet.
T 1709467629 18<25Widdershins18>	so start with a column that's always unique, iterate over it, and use .filter_map(|..| ...). it's really easy, because the closure returns Option and you can just skip all the ones with not-found using ?
T 1709467632 18<19Wulf18>	I'm stuck with this code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=a74eb6335c9f9de18829bbdd83368e82 . How to fix it?  If it's too large, I can create a smaller testcase for the error.
T 1709467699 18<22gastus_18>	Widdershins: but talking about DBs which one do you consider to be better ? I mean there are som any PG, DuckDB, to name just 2. Each ahvinvg its own sweet spot. PG has geo index mysql doesn't but mysql has cache. So for some stupid cache based workload mysql actually might be a good choice and fast choice without much work.
T 1709467752 18<22gastus_18>	Widdershins: And you hit the nail. I feel like TS has some nice concepts such as typing 'objects' and wonder why nobody misses is using Rust/Java cause some simple fetch as Promise<type here> use scripting like use cases might exist for such languages, too.
T 1709467779 18<22gastus_18>	https://github.com/automerge/automerge-repo.git solve it by having typed and untyped documents and converting between them.
T 1709467798 18<25Widdershins18>	Wulf: you've written code that tries to capture a unique reference to self in not just one but ten different threads
T 1709467821 18<25Widdershins18>	gastus_: postgres is a thousand times better than mysql
T 1709467831 18<25Widdershins18>	mysql does not "have cache"
T 1709467846 18<25Widdershins18>	mysql is almost categorically worse than postgres.
T 1709467852 18<22gastus_18>	https://dev.mysql.com/doc/refman/5.7/en/query-cache.html
T 1709467863 18<19Wulf18>	Widdershins: and I don't know what to do about it. I'm new to rust.
T 1709467864 18<25Widdershins18>	it is very, very hard to come up with any type of scenario where mysql performs better than postgres
T 1709467927 18<25Widdershins18>	gastus_: you've linked to a "feature" that was deprecated 7 years ago in an EOL release line
T 1709467939 18<28darkling18>	It used to be faster than Postgres IIRC, but that was something over 20 years ago. (MySQL prioritised speed; Postgres prioritised correctness).
T 1709467976 18<25Widdershins18>	it hasn't been truly faster than postgres in any typical database scenario any time in the last decade
T 1709467994 18<22gastus_18>	Gonna shut up and listen more.
T 1709467996 18<25Widdershins18>	it's some of the worst software i've ever had the displeasure of being required to use
T 1709468025 18<28darkling18>	Oh, I think there's much worse under the false bottom of that particular barrel. :)
T 1709468030 18<25Widdershins18>	and i've been a senior data engineer for like 7 years now working with quite a few different ones
T 1709468039 18<25bertptrs18>	Saw a beautiful article that tried to establish what exactly it was that the transaction isolation levels in mysql do guarantee, because it surely wasn't what the ANSI SQL spec required
T 1709468042 18<25Widdershins18>	darkling: maybe but you'd be surprised
T 1709468069 18<25bertptrs18>	Found it, this one https://jepsen.io/analyses/mysql-8.0.34
T 1709468070 18<25Widdershins18>	mysql doesn't even have reliable prepared statements in the latest version
T 1709468076 18<22gastus_18>	Widdershins: If you have use cases such as sales with different use currencies. I mean you either can have struct {EUR: currency, USD: currency} or a hash lik thing. Now you want to store and sum in database ? What's the best way to share such datatype with a database without having to implement sum multiple currencies twice ?
T 1709468081 18<25Widdershins18>	and they're not going to fix it
T 1709468121 18<25Widdershins18>	gastus_: sum numeric values grouped by currency
T 1709468154 18<25Widdershins18>	if you want the conversions that combine them to happen inside the database too, no you don't
T 1709468481 18<25bertptrs18>	I try to actively fight including currency conversions in my code. the finance guys can figure that one out
T 1709468642 18<22gastus_18>	I had in mind writing something like a booking platform for campers. And for tihs and others reasons I thought it would be fun to have documents with history builtin. So that wehn merges happens (offline usage) you know what changed and can guide conflict resolution. Kind of key/value store with git like history. So you find branches, you know state last synced with server and changes by user and what
T 1709468648 18<22gastus_18>	has'nt been synced etc. Now with TS everything is an object. You add typing. Done. With Rust ? Now how to store with PG ? Yes you can use JSON and query it. And you can reformat the docs to have final state and reversed history. But querying nested JSON keys kinda feels awkward. And then I wonder over and over again what if a database was a library and I could just share types with my app ? Why do I have
T 1709468654 18<22gastus_18>	to learn multiple programming languages and stored procedures ? You're right PG allows to create my own libraries. But then I am at the issue which is the most convenient way to package and distribute ? And that's a different story if you have a better tahn rust channel to discuss this I'd be interested in your opinion whether I am reinventing the wheel, too. Cause looking at the many github readmes (if
T 1709468660 18<22gastus_18>	youh ave hardawer, then otherwise, .. if you use conda otherwise pip otherwise ubuntu otherwise, ...) kinda sucks and feels like standardised glue code might be missing.
T 1709468663 18<22gastus_18>	And about summing -> you have to take care about rounding of database which could be different from your app.
T 1709468696 18<22gastus_18>	Liek PHP/JS didn't find a way to make both round the same way. I tried hard like 5+ different ways. Then I concluded Haskell like typeclasses might just fix it, but within DB? back at what if DB was a library ..
T 1709468706 18<20j`ey18>	this sounds quite off topoc tbh
T 1709469081 18<25Widdershins18>	you're storing well-structured data as json objects and wondering why it's harder to work with?
T 1709469114 18<25Widdershins18>	we have tools for that, it's called "having a relational schema"
T 1709469150 18<22gastus_18>	But they don't have history :-) So I could derive 'relational data' from it.
T 1709469449 18<25Widdershins18>	Wulf: as it is it looks like every thread is trying to share the whole `self` including the File. most of this will probably work if each worker has its own file handle
T 1709469514 18<22gastus_18>	@ Wulf Do you think its a wise idea to share a file handle across threads have each call read_exact and have it working ? To my knowledge which is limited a file handle gets loned. so if thread 10 seeks it'll gonna change location for running thread 1 ?
T 1709469537 18<25Widdershins18>	gastus_: it doesn't compile at all because the threads are capturing mutable self
T 1709469557 18<25Widdershins18>	that capture by the closure requires self to outlive static
T 1709469591 18<25Widdershins18>	and the fact it's mutable means it can't work at all with multiple threads
T 1709469597 18<19Wulf18>	gastus_: the threads don't seek the file, and reading is protected by the mutex. So there's only one read at a time.
T 1709469650 18<25Widdershins18>	why so many threads then
T 1709469692 18<19Wulf18>	Widdershins: for the hashing part.
T 1709469722 18<19Wulf18>	maybe I'll need to have one thread do the reading and pass blocks into hasher threads?
T 1709469735 18<22gastus_18>	Threads make sense if hashing is slower than loading data from disk which in the future might be the case cause they developed non volatile RAM like SSDs having speed of RAM. When they will be used by majority is a different question.
T 1709469737 18<25Widdershins18>	i guess i don't expect one thread's i/o to be that much faster than the hashing part
T 1709469794 18<19Wulf18>	I can read about 1.5 GiB from my disk, but a single thread can't hash that fast.
T 1709469800 18<19Wulf18>	(per second)
T 1709469818 18<25Widdershins18>	regardless the issue is that while you're getting the ids via the arc, you are using `self.file` without any kind of synchronization, and have a plain &mut ref to `self` captured, which must be unique
T 1709469866 18<19Wulf18>	any way to tell rust that my file is not mutable, while in fact, it is?
T 1709469883 18<25Widdershins18>	i recommend trying to make it so that the information needed for the work done by each thread is encapsulated entirely in a struct which you move deliberately
T 1709469936 18<22gastus_18>	Wulf: Why not use English to describe what you want to do using one sentence such as within a file witihn a region read blocks and hash each one within a thread summing up the results ? The question is interesting like if the disk is the bottleneck one thread is enough. Reading in a sequence is the fastest you can do on physical disks unless you have high fragmentation which might be the only case when
T 1709469942 18<22gastus_18>	asking OS to find the closest chunk which might not be worth it. Ok let's assume youh ave a RAM based disk so reading is fast and digesting is the bottleneck, then .. we're at what you try to do ?
T 1709469966 18<25Widdershins18>	gastus_: read_exact requires a mutable reference to the file
T 1709470006 18<25Widdershins18>	it's not about whether the contents of the file on disk are changing; it's about the fs::File object, in memory, having exclusive access by you which makes writes safe
T 1709470037 18<25Widdershins18>	but you aren't guaranteeing that only one of those references exists. quite the opposite
T 1709470081 18<19Wulf18>	gastus_: For now, I'm trying to create a multi-threaded file hasher. Reads must be sequential for best speed. Hashing must occur in multiple threads because otherwise that's the bottleneck.
T 1709470088 18<19Alexendoo18>	It requires &mut access to the thing that implements Read, &File does implement Read so you don't strictly need exclusive access to File since &mut &File works
T 1709470115 18<25Widdershins18>	Alexendoo: ah
T 1709470119 18<19Alexendoo18>	It may or may not be a bad idea to use
T 1709470131 18<25Widdershins18>	i think then that leaves just the lifetime issue then
T 1709470158 18<25Widdershins18>	in that this is capturing references and then starting in a thread, which isn't allowed
T 1709470166 18<25Widdershins18>	that might have to be an rc
T 1709470233 18<25Widdershins18>	https://doc.rust-lang.org/std/thread/fn.spawn.html requires that the closure be 'static
T 1709470481 18<19Alexendoo18>	since all the handles are being joined std::thread::scope would be a choice
T 1709470585 18<22gastus_18>	@ Wulf after 3 chat gpt iterations you end up with https://dpaste.com/6YTFRSV5C but I am still new to rust. But if you look at such code and move the file reading part up before caling into_par_iter would this just be clean readable code getting the job done ?
T 1709470627 18<22gastus_18>	The question I don't know yet wether into_par_iter will consume all items before starting or will start as fast as the items arrive.
T 1709470752 18<19Alexendoo18>	That wouldn't compile, but rayon is probably what I would use here. Create a synchronous iterator of chunks and then use rayon to process in parallel
T 1709470759 18<22gastus_18>	So typicall such eventually could be done with pipes and back pressure. Eg the thread pool saying 'all busy, don't deliver more items' But not sure what's the right Rust library for that.
T 1709470858 18<22gastus_18>	https://medium.com/@polyglot_factotum/rust-concurrency-a-streaming-workflow-served-with-a-side-of-back-pressure-955bdf0266b5 is from 2020 might be an alternative read to get an idea.
T 1709471397 18<22gastus_18>	@ Wulf tokio might lead to code looking something like this :  https://dpaste.com/GCPTUAYHD   And now you have abstracted away the multi threading part, you have eventually (unchecked) back pressuring and this all is done by tokio / async code which handles the waiting nicefully for you. Not saying its the perfect solution yet. But gives you some ideas. Now the feeding and receiving results is still
T 1709471403 18<22gastus_18>	lacking some abstraction. There might be some .async_map_paralell_iter() whatever ? But you might have the properties you want the main thread reading the bytes, handing the mover to the pool doing teh work and getting back the results.
T 1709471461 18<26dav1d18>	can you stop with this chat gpt garbage?
T 1709471520 18<22gastus_18>	dav1d: Can yout tell me what's garbage about the idea of using iterator, having bytes, backpressure and using async ? Sry truly believed it would be a nice way to turn the task into readable code.
T 1709471569 18<26dav1d18>	gastus_, the code is garbage, just look at `receive_chunk`. If you want to help someone but not write the code, then describe the algorithm or behaviour, don't add garbage code to it that will confuse and mislead readers.
T 1709471645 18<19Alexendoo18>	also tokio to read one file is kinda pointless
T 1709471713 18<19Wulf18>	gastus_: there are lots of subtle bugs. Usually the last block is smaller than the block size. My code handled this, the GPT one doesn't. And I need to use the block hashes as they are computed (and in order). The GPT code collects them all, which means e.g. unbounded memory usage.
T 1709471762 18*	26dav1d thinks copy pasting from chat gpt should be a bannable offense 
T 1709471763 18<19Wulf18>	Alexendoo: I will probably use tokio. The finished program will be a client/server model where one server can handle multiple clients and files.
T 1709471821 18<26dav1d18>	Wulf, you might still want to consider a separate thread (pool) for CPU bound work. Also file io just uses a blocking thread behind the scenes anyways
T 1709471861 18<22gastus_18>	Let me try showing pseudo code :-) which I think is very readable cause it talks about what it does: https://dpaste.com/6DFNHMB97 Whether it can be done with what version of Tokio or similar I lack experience yet.
T 1709471928 18<22gastus_18>	https://dpaste.com/5473YVRCA (indentation fixed sry)
T 1709471998 18<22gastus_18>	line 14 should be using do_work
T 1709472261 18<22gastus_18>	Wulf: That's why I said there is some abstraction missing on top. Like passing the idx for ordering or such. And the last pseudo code would allow to put a buffering stream component in between in case IO turns busy you have like 10 blocks in memory to continue processing cause CPU /calculation might be the bottlenick. Could all be overkill though.
T 1709472366 18<19Wulf18>	Learning rust is hard. I'll go for a walk.  Thanks so far!
T 1709474030 18<22gastus_18>	@Wulf https://users.rust-lang.org/t/does-async-have-a-notion-of-priority/81199 mind the link to "Reducing tail latencies with automatic cooperative task yielding". Wanting to say if you run multiple 'hashing' reqeusts the rest might suffer (?). I've been wondering about prioritizing about JS Promises / networking / Quic etc, too. According to changelog (nov 27 2023) nothing has been added (?).
T 1709523463 19*	Now talking on 22##rust
T 1709523463 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709523463 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709523581 19*	Now talking on 22##rust
T 1709523581 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709523581 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709537703 18<27gastus18>	Wulf:     let (tx, mut rx) = mpsc::channel::<u8>(10);
T 1709537727 18<27gastus18>	Is all you need you can send async/sync to it and it keeps eg 10 items thus once you filled those 10 will apply backpressure.
T 1709546538 18<29neiluj18>	Hiu! Getting the following error for a call to a derive macro: https://bpa.st/AFFA. I'm hesitating between implementing the CanonicalSer/Deser trait for the entire struct or only the E::G1Prepared types, though they would then have to be wrapped in a new struct
T 1709546579 18<29neiluj18>	which option (or other option) you think is best in terms of easy to write?
T 1709547604 18<29neiluj18>	went with a new struct with serializable types only and a function to map the previous struct to the serializable one
T 1709547613 18<29neiluj18>	let's keep it simple
T 1709549304 18<25elichai218>	Is it possible to tell `#[tracing::instrument]` to use the Display impl for the arguments?
T 1709549543 18<26dav1d18>	elichai2, yes, by using %field
T 1709549554 18<26dav1d18>	elichai2, https://docs.rs/tracing/latest/tracing/#recording-fields
T 1709549585 18<20jbg18>	yes, verbosely
T 1709549595 18<20jbg18>	skip_all and then %field for each field
T 1709549599 18<25elichai218>	got it, i'll skip all and manually add back
T 1709557694 18<19nlaerema18>	hello
T 1709557795 18<25bertptrs18>	o/
T 1709561632 18<29alip18>	> warning: dropping unsupported crate type `cdylib` for target `x86_64-unknown-linux-musl`
T 1709561647 18<29alip18>	can i somehow force it to build a dylib or is there just no way?
T 1709561661 18<29alip18>	i mean without installing a glibc toolchain
T 1709561730 18<29alip18>	and/or is there a way to detect this so i can skip tests that dep on the cdylib?
T 1709562160 18<29alip18>	ah nvm figured it out, building with distro rustc works
T 1709563270 18<20jbg18>	alpine has a patch that changes the musl target
T 1709563281 18<20jbg18>	so if your distro is alpine or alpine based, that's why it works
T 1709563331 18<20jbg18>	rust made the questionable early decision to make -unknown-linux-musl targets default to enabling the crt-static target feature, i think because they were focused on the use-case of making 0-dependency binaries
T 1709563350 18<20jbg18>	you can probably build with standard rustc if you disable the crt-static target feature
T 1709564786 18<29alip18>	thanks for the explanation
T 1709566677 18<26dav1d18>	Can I have iter.any or iter.all which separately tells me wether the iterator was empty?
T 1709566690 18<26dav1d18>	Cause I need the exact opposite behaviour of any/all
T 1709566700 18<26dav1d18>	all but if it's empty return false
T 1709566857 18<29phy172918>	Just curious why do you need that? all of nothing being true preserves monoidish properties
T 1709567020 18<26dav1d18>	phy1729, I have an iterator of matching limits, I want to drop a certain item if all of the limits are "passive" (just a bool), but I need to keep it if there is no matching limit
T 1709567099 18<26dav1d18>	I could do peekable and then check for empty I guess
T 1709567103 18<26dav1d18>	but not sure if that's better
T 1709568232 18<25bertptrs18>	any does return false if the iterator is empty
T 1709568275 18<25bertptrs18>	since existance on the empty set is always false, and universality on the empty set is always true
T 1709569894 18<27Ademan18>	is there a good way to make an iterator own some data? I produce some owned data down in a flat_map(), something like `flat_map(|x| { let y = calculate(x); z.thing_that_produces_another_iterator(&y) }` and it needs to live as long as the iterator itself (or at least, the relevant parts of the flat mat?)
T 1709570014 18<29phy172918>	Maybe turn it into an Iterator of Iterators and then flatten?
T 1709570306 18<25bertptrs18>	Ademan: add a move to that closure?
T 1709570711 18<27Ademan18>	isn't y already owned by that closure since it's scoped to it? hrm, this is pretty difficult I think, I couldn't even make like a `struct OwningIterator<T, U, I: Iterator<Item=U> { owned: T, iter: I }` to bundle them together since it would be self referential
T 1709572969 18<25bertptrs18>	ah I misread something, you construct y and then borrow it for your inner iterator
T 1709573101 18<20polychromata{J}18>	dav1d: you can fold() it
T 1709573997 18<26dav1d18>	bertptrs, any is the same as all, if I use any I need to invert the condition, which means I need to invert the result, same problem
T 1709574003 18<26dav1d18>	polychromata{J}, try_fold right?
T 1709574013 18<26dav1d18>	I want to short circuit
T 1709574029 18<20polychromata{J}18>	ah, yeah, you're right.
T 1709574079 18<26dav1d18>	My "solution" https://p.dav1d.de/8Yl.rs
T 1709574087 18<26dav1d18>	I have yet to test it (keep getting side tracked)
T 1709574157 18<25bertptrs18>	Oh I have an even worse idea, thanks for reminding me of filter()
T 1709574199 18<26dav1d18>	lol
T 1709574211 18*	26dav1d waits in anticipation
T 1709574424 18<25bertptrs18>	https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=057e53c5c9ba1e698b21b0b94bd47ec5
T 1709574447 18<25bertptrs18>	using find_map instead of find so the closure can take by value
T 1709574485 18<26dav1d18>	lol
T 1709574504 18<26dav1d18>	I might just use that and confuse everyone, love it
T 1709574580 18<25bertptrs18>	It works and it short circuits, those were my requirements
T 1709574835 18<26dav1d18>	yeah, it's a pretty smart solution, I did think of using find() but discarded it because I never thought about inverting the condition and then checking for none
T 1709574874 18<20polychromata{J}18>	evalr: use std::ops::ControlFlow::{self, *}; fn check<I: Iterator<Item = u128>>(iter: I) -> Option<ControlFlow<bool>> { iter.try_fold(None, |o, n| if n < 159936340279099635845489784282289365899 { Some(Continue(true)) } else { Some(Break(false)) }) }
T 1709574875 -18evalr/22##rust-	polychromata{J}: error[E0271]: type mismatch resolving `<Option<ControlFlow<bool, ...
T 1709574876 -18evalr/22##rust-	polychromata{J}: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=6d4fe0ec41b0c4d5313de7b59fd7ef57
T 1709575118 18<26dav1d18>	`159936340279099635845489784282289365899` that's a big number :D
T 1709575197 18<19int-e18>	close to 2^127 hmm and not prime.
T 1709575929 18<20polychromata{J}18>	evalr: use std::ops::ControlFlow::{self, *}; fn check<I: Iterator<Item = u128>>(iter: I) -> Option<bool> { iter.try_fold(None, |o, n| if n < 159936340279099635845489784282289365899 { Continue(Some(true)) } else { Break(Some(false)) }) } check([].into_iter())
T 1709575931 -18evalr/22##rust-	polychromata{J}: error[E0308]: mismatched types ...
T 1709575932 -18evalr/22##rust-	polychromata{J}: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=cbf42709499938b8cd2878de88126743
T 1709575995 18<20polychromata{J}18>	ah, yeah, and then you have to flatten the `ControlFlow<T, T>`
T 1709576064 18<26dav1d18>	int-e, do you have all primes up to 2^127 in your head? :p
T 1709576084 18<20polychromata{J}18>	evalr: use std::ops::ControlFlow::*; fn check<I: Iterator<Item = u128>>(iter: I) -> Option<bool> { let short_circuit = iter.try_fold(None, |o, n| if n < 159936340279099635845489784282289365899 { Continue(Some(true)) } else { Break(Some(false)) }); match short_circuit { Continue(value) | Break(value) => value } } check([].into_iter())
T 1709576086 -18evalr/22##rust-	polychromata{J}: error[E0596]: cannot borrow `iter` as mutable, as it is not decl ...
T 1709576087 -18evalr/22##rust-	polychromata{J}: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=a4520d439000162fedf13b8f27c3bcc9
T 1709576093 18<20polychromata{J}18>	for Celestia's sake
T 1709576099 18<25bertptrs18>	I don't know about them but factor is in coreutils
T 1709576133 18<20polychromata{J}18>	evalr: use std::ops::ControlFlow::*; fn check<I: Iterator<Item = u128>>(mut iter: I) -> Option<bool> { let short_circuit = iter.try_fold(None, |_, n| if n < 159936340279099635845489784282289365899 { Continue(Some(true)) } else { Break(Some(false)) }); match short_circuit { Continue(value) | Break(value) => value } } check([].into_iter())
T 1709576135 -18evalr/22##rust-	polychromata{J}: None
T 1709576137 18<20polychromata{J}18>	there
T 1709576146 18<26dav1d18>	bertptrs, :o that's neat!
T 1709576198 18<19int-e18>	Hmm `factor` used to be limited to 64 bits or so, so I trained myself to use pari/gp instead.
T 1709576236 18<19int-e18>	(which has a factor() function)
T 1709576246 18<26dav1d18>	polychromata{J}, I appreciate the solution but if that's not hidden away in a dusty module it's quite ugly :p
T 1709576266 18<25bertptrs18>	I used to use it for programming contests and those rarely need primes larger than that
T 1709576307 18<20polychromata{J}18>	dav1d: it would be a lot nicer if there was a ControlFlow::merge(), yeah c.c
T 1709576321 18<20polychromata{J}18>	huh, Result doesn't have such a method either
T 1709576333 18<20polychromata{J}18>	though you can at least do `.unwrap_or_else(identity)`
T 1709576363 18*	20polychromata{J} would probably just write an extension providing merge()
T 1709576367 18<20polychromata{J}18>	(bikeshed the name)
T 1709576407 18<20polychromata{J}18>	…or you could package the whole thing up into an extension on Iterator providing maybe_any() and maybe_all() :P
T 1709576418 18<20polychromata{J}18>	since that's what you really want, after all
T 1709576559 18<26dav1d18>	actually surprised there isnt anything in Itertools 🤔
T 1709576596 18<26dav1d18>	I guess find_or_first would simplify bertptr_s' solution a bit
T 1709576721 18<20polychromata{J}18>	find_or_first() wouldn't distinguish the empty case though
T 1709576794 18<26dav1d18>	polychromata{J}, on empty it would return None right?
T 1709576806 18<26dav1d18>	otherwise it always returns an element
T 1709576816 18<26dav1d18>	actually maybe doesn't even make it easier
T 1709576817 18<20polychromata{J}18>	oh right
T 1709576825 18<20polychromata{J}18>	it doesn't distinguish the /other two/ cases from each other.
T 1709576906 18<20polychromata{J}18>	wow itertools sure has a lot of methods
T 1709576911 18<20polychromata{J}18>	this is more than i remember, too
T 1709577252 18<26dav1d18>	yeah, e.g. I dont remember ever seeing the position_min/max/... ones
T 1709577278 18<26dav1d18>	nvm they exist since at least 0.9
T 1709580265 18<19edgimar18>	What is the best practice related to specifying a consistent version of a crate for use across a cargo workspace.  I have a workspace where one of the crates has a cdylib target that is a facade for functions in several of the other crates.  Is there a good way to ensure that when there is more than one crate that shares the same dependency, the dependencies use the same version?
T 1709580380 18<20polychromata{J}18>	cargo tries to do that automatically. but sometimes crates in the dependency tree depend on incompatible versions of the same crate, and those of course can't be unified
T 1709580399 18<25bertptrs18>	there are workspace dependencies too, where every crate in the workspace gets a certain dependency
T 1709580405 18<26dav1d18>	edgimar, if the versions are semver compatible then they will use the same version, if they aren't then I can't think of anything better than checking the Cargo.lock for duplicates or using cargo tree
T 1709580440 18<25bertptrs18>	https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#inheriting-a-dependency-from-a-workspace
T 1709580719 18<19edgimar18>	bertptrs: thanks, that looks promising.  Maybe unrelated, but I'm trying to diagnose a strange error that just started happening when trying to build, but I can't determine what change would be repsonsible for it:  there are several error messages "cannot find macro println in this scope" for a crate I'm depending on (rstar) - I'm not getting any traceback, besides the line in the rstar code with
T 1709580721 18<19edgimar18>	the println! - wasn't seeing these before, so I'm confused about what I might have changed in my code that would cause that error to occur.
T 1709580776 18<25bertptrs18>	edgimar: are you by chance doing a no_std build on a crate that doesn't support it
T 1709580969 18<19edgimar18>	That would have required changing something in a Cargo.toml file I assume?  I am not building any differently than before.  I did add an nalgebra = "*" dependency in one of my crates where rstar was already a dependency - hm. maybe a clue?
T 1709620790 19*	Now talking on 22##rust
T 1709620790 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709620790 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709622913 18<26daddy18>	Oh, bindgen enables runtime as a default feature, and *insert every sys crate in my stack* uses bindgen with default features
T 1709624425 18<26daddy18>	Is there a way I can build `build.rs` files with a set of RUSTFLAGS that are separate from RUSTFLAGS used on non-build.rs ?
T 1709627166 18<22Arnavion18>	Yes, by not using RUSTFLAGS. Use target.rustflags in .cargo/config.toml instead
T 1709627735 18<26daddy18>	target.<cfg>.rustflags ? what would I use for `cfg()` ?
T 1709627782 18<26daddy18>	I don't think <triple> gives me any way to specify build.
T 1709628069 18<26daddy18>	I'm building on the same system I'll be running it on so I can't specify different triples.
T 1709638053 18<25elichai218>	is there a way with tracing::instrument to bypass rust's fmt machinery and use something faster?
T 1709638369 18<20osse18>	elichai2: to log the files, e.g. args to functions you meaǹ?
T 1709638416 18<25elichai218>	osse: yes, ideally with things like `#[instrument(field(...))]` and `tracing::debug!(...)`
T 1709638427 18<25elichai218>	but the debug/info etc macros I can replace with my own
T 1709638444 18<20osse18>	elichai2: if it's your own type i suppose you can implement the Value trait yourself
T 1709638487 18<25elichai218>	osse it is Sealed though: https://docs.rs/tracing/latest/tracing/trait.Value.html
T 1709638541 18<20osse18>	huh
T 1709638546 18<20osse18>	I don't know, then
T 1709638555 18<20osse18>	the Visit trait isn't, but I don't know if that helps
T 1709638620 18<25elichai218>	but the visitor will still call `record_debug`
T 1709638634 18<25elichai218>	maybe if I directly use the `valuable` crate I could do it
T 1709638817 18<20osse18>	yeah but it's up to use to implement it
T 1709638834 18<20osse18>	I figured you could avoid the implementation of Debug inside it somehow
T 1709639576 18<26dav1d18>	Ignoring endianness issues etc. Am I even allowed to transmute &[f64] to &[u8]?
T 1709639622 18<26dav1d18>	I guess slice length would break, so from_raw_parts 🤔
T 1709639841 18<29neiluj18>	Hey! Trying to implement the Serialize/Deserialize trait for a type implementing the following trait: https://docs.rs/ark-serialize/latest/ark_serialize/trait.CanonicalSerialize.html
T 1709639854 18<25elichai218>	dav1d: no, the length would not match
T 1709639860 18<29neiluj18>	not sure how to turn the writer into a serializer
T 1709639870 18<25elichai218>	you need to deconstruct the slice, multiply the length, and construct a new slice
T 1709639905 18<26dav1d18>	elichai2, yeah, see my second sentence. looking at bytemuck, it should be safe https://docs.rs/bytemuck/latest/src/bytemuck/internal.rs.html#353-372
T 1709639917 18<26dav1d18>	but probably should just use bytemuck in the first place
T 1709639921 18<25elichai218>	yep, f64 has no padding
T 1709639929 18<25elichai218>	so if it's initialized it's safe to read as u8
T 1709639945 18<25elichai218>	all primitives except `bool` don't have paddings
T 1709639955 18<26dav1d18>	and alignment is fine, since u8. The other way probably is not fine
T 1709639963 18<26dav1d18>	right?
T 1709639972 18<26dav1d18>	&[u8] -> &[f64]
T 1709640017 18<25elichai218>	yep
T 1709640026 18<25elichai218>	the other way you need to check and offset alignment
T 1709640060 18<26dav1d18>	Thanks! Always good to have a second opinion on this
T 1709640141 18<25elichai218>	always run your unsafe code through miri ;)
T 1709653736 18<26jess18>	if i'm casting from a u64 and a u32 and would like it to overflow, is there a more correct way to do it that tells clippy that overflow is desired?
T 1709653743 18<26jess18>	from a u64 to a u32*
T 1709653861 18<26jess18>	for context this is for using a u64 siphash as an array index usize for a bloom filter, so overflow is not really a problem for me. it'll get modulo too regardless
T 1709653895 18<25bertptrs18>	you can #[allow(clippy::cast_possible_wrap)] but by default Clippy already allows those
T 1709653910 18<26jess18>	i'm on clippy pedantic
T 1709653947 18<25bertptrs18>	or #[allow(clippy::cast_possible_truncation)] which is more correct imo
T 1709653955 18<26jess18>	just thought there might be some magic function or trait that is "cast this with wrapping please" that would satisfy clippy
T 1709654145 18<26danieldg18>	maybe clippy could learn that (some_u64 & 0xFFFF_FFFF) as u32 can't truncate?
T 1709654201 18<26jess18>	^ no implementation for `u64 & u32`
T 1709654202 18<26danieldg18>	not sure if doing constant-propagation to make that rule nicer is beyond clippy or not
T 1709654203 18<26jess18>	boo sadface
T 1709654221 18<26danieldg18>	well yes, you have to upcast the mask
T 1709654231 18<26danieldg18>	or, you know, literals
T 1709654250 18<25bertptrs18>	you're missing the point, & could automatically downcast since the result should be equivalent
T 1709654279 18<25bertptrs18>	uX & u32 fits in an u32 regardless of X
T 1709654301 18<25bertptrs18>	but automatic conversions are bad™ so I'm happy it doesn't work lioke that
T 1709654301 18<26jess18>	yes, indeed
T 1709654303 18<26danieldg18>	right.  The bitwise and/or ops could easily be implemented for arbitrary sizes
T 1709654309 18<26jess18>	but the compiler doesnt seem to know it
T 1709654351 18<26danieldg18>	I think libcore could impl it
T 1709654365 18<26danieldg18>	but it'd probably break things if you do it now
T 1709654366 18<26jess18>	i can apparently right shift a u64 to a u32
T 1709654377 18<26danieldg18>	I don't think you can
T 1709654384 18<25bertptrs18>	you can shift any int with any other int for some reason
T 1709654401 18<26danieldg18>	isn't it only u32 and maybe u8 on the rhs of the shift?
T 1709654408 18<26danieldg18>	or maybe usize?
T 1709654425 18<26jess18>	oh, im reading the impl wrong
T 1709654441 18<25bertptrs18>	danieldg: no pretty much everything https://doc.rust-lang.org/std/primitive.u128.html#impl-Shl%3C%26i128%3E-for-%26u128
T 1709654449 18<26danieldg18>	huh
T 1709654520 18<25bertptrs18>	there's no reason it works like this, but there is also no reason it shouldn't work so they just did it
T 1709654540 18<26danieldg18>	I guess it's not symmetric, so there's no gain from trying to propagate types through it
T 1709654603 18<26danieldg18>	for | you could have takes_u64(x | y) and it'd end up inferring both x and y are u64 now, but if widening or happens then y could easily get inferred to be i32
T 1709654609 18<26danieldg18>	or maybe u32
T 1709655385 18<22gastus_18>	I want to store pointers to vecs which I eventually want to remove (set to NULL). Now I could be using Option but will take more memory. Would it make sense to have special Option<> type for pointers if they are NULL meaning "no value" so not having to use an enum ?
T 1709655424 18<20j`ey18>	gastus_: do you mean pointers or references?
T 1709655430 18<20j`ey18>	*const T or &T?
T 1709655476 18<26danieldg18>	gastus_: std::ptr::NonNull
T 1709655498 18<26danieldg18>	references already do it
T 1709655534 18<26danieldg18>	Option<NonNull> or Option<&T> are guaranteed to fit in a usize
T 1709655539 18<25bertptrs18>	danieldg: Option<&T> and *const T have the same size
T 1709655585 18<27rendar18>	i always wondered something, if i have `fn myfn(&self) {   for i in &self.data { .. }  .. }`  <- why here we have to use &self.data, if self is already of &Self type ?
T 1709655589 18<20j`ey18>	but not Option<*const T>
T 1709655606 18<26danieldg18>	rendar: self is the object
T 1709655608 18<25bertptrs18>	rendar: because otherwise self.data would attempt to move out of self, which it can't
T 1709655634 18<25bertptrs18>	and if it can, you might not want it to
T 1709655672 18<27rendar18>	bertptrs, ok, right, so it's just a further notation to remark the user: look you're traversing and not moving out
T 1709655695 18<27rendar18>	it would be very messy code in the other way, indeed
T 1709655725 18<25bertptrs18>	well you could move data out of self and then traverse it, which does something different, but unless data is Copy you can't
T 1709655766 18<26danieldg18>	"let Self { data, .. } = self; for i in data { .. }" does the same thing as &self.data
T 1709655778 18<27rendar18>	oh right
T 1709658822 19*	Now talking on 22##rust
T 1709658822 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709658822 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709660283 18<27n118>	 is here a way how to tell compiler that a method should be included only for "lib" use? i mean the #[cfg...
T 1709660316 18<26segfaultfizzbuzz18>	suggestions for a rust library for transforming markdown into an html form, or for a markdown parser which i could easily extend (as a bad programmer) to have form elements?
T 1709660380 18<20j`ey18>	n1: what do you mean for 'lib' use?
T 1709660397 18<20j`ey18>	if it's part of a non-binary crate, it's always for a library?
T 1709660438 18<27n118>	j`ey: i use my rust app as a dependency in another project - i suppose it turns into a "lib" mode (dunno how to phrase it better) when tne intrypoint in lib.rs instead of main.rs
T 1709660488 18<20j`ey18>	n1: yes
T 1709660532 18<27n118>	the thing is this... i have a method that is not used in binary mode (thus i get unused warning) but it's used in lib mode
T 1709660537 18<27n118>	does if make sense j`ey ?
T 1709660541 18<27n118>	it*
T 1709660553 18<20j`ey18>	n1: what file is that method in?
T 1709660607 18<27n118>	src/config.rs
T 1709660636 18<20j`ey18>	n1: and you have mod config in src/lib.rs?
T 1709660679 18<27n118>	yes
T 1709660689 18<27n118>	pub mod config; to be exact
T 1709660699 18<27n118>	re-export
T 1709660716 18<26danieldg18>	n1: you should *not* have 'mod config' in main.rs then
T 1709660730 18<26danieldg18>	you should 'use yourcrate::config' in main.rs
T 1709660755 18<29JordiGH18>	Hey, any of you use Prisma? What are your impressions? I'm trying to find a fun Rust project to work on that people enjoy using and care about. Prisma came to mind, but I'm not sure if it's loved or not.
T 1709660769 18<27n118>	danieldg: i need that line there because i use that file in both modes - only one particular method is not used in binary mode
T 1709660833 18<20j`ey18>	n1: no dont have mod config in main.rs
T 1709660842 18<20j`ey18>	n1: you should 'use' the library crate from the binary one
T 1709660994 18<27n118>	im lost ... i removed the "mod config;" line from my main.rs - now im getting tons of errors of "unresolbed import"
T 1709661015 18<26danieldg18>	n1: remove all 'mod' lines in main.rs
T 1709661022 18<20j`ey18>	'use <yourcratename>::config;'
T 1709661023 18<26danieldg18>	unless the module is only for the binary
T 1709661146 18<27n118>	j`ey: done - but now im getting another couple of errors that weren't there before
T 1709661175 18<20j`ey18>	tell us, and we can help fix it
T 1709661178 18<20j`ey18>	otherwise, we cant :P
T 1709661321 18<27n118>	sure ... but that seems like a random error of "cannot fined a method from a trait" or value of this type cannot be build from that type
T 1709661334 18<27n118>	looks like someone just f'ked my code :)
T 1709661361 18<26danieldg18>	n1: if you are still duplicating 'mod' lines, then you'll get that
T 1709661378 18<26danieldg18>	because you will define two different types with the same name
T 1709661389 18<27n118>	so i guess the real question is what the "substitude 'mod config' with 'use <cratename>::config;'" really does
T 1709661425 18<26danieldg18>	it removes the duplication
T 1709661457 18<27n118>	https://dpaste.com/B6LW487LG head of my main file before the errors
T 1709661476 18<27n118>	once i comment out line 3 and uncommet line 10 i get the errors
T 1709661494 18<26danieldg18>	... read what I said
T 1709661499 18<26danieldg18>	17:50:15 < danieldg> n1: remove all 'mod' lines in main.rs
T 1709661525 18<27n118>	just like that? not needed anymore?
T 1709661541 18<26danieldg18>	you may need to replace them with 'use' lines
T 1709661571 18<27n118>	okay i didnt get that
T 1709661573 18<27n118>	will try
T 1709661676 18<27n118>	https://imgur.com/a/1EZ6H4c
T 1709661686 18<27n118>	even worse lol
T 1709661723 18<26danieldg18>	no, you now have a TODO list for fixing your lib
T 1709661735 18<26danieldg18>	make things you need public, or remove the use if you don't need it
T 1709661930 19*	Now talking on 22##rust
T 1709661930 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709661930 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709662034 18<27n118>	that sounds like "to make that one particular method hidden from bin-mode you have to rewrite all the imports"
T 1709662040 18<27n118>	thats nuts to me
T 1709662086 18<26danieldg18>	the problem is that the way you were doing it was wrong
T 1709662112 18<26danieldg18>	it worked, but you had two copies of your code
T 1709662119 18<27n118>	what exactly was wrong? i was acting based on tutorials where every part of my app needs to be "mod"ed
T 1709662141 18<27n118>	>two copies of your code - what do you mean exactly?
T 1709662144 18<26danieldg18>	that's true if you only have a main.rs
T 1709662148 18<26danieldg18>	or only a lib.rs
T 1709662163 18<26danieldg18>	having both means you're making two crates, one that depends on the other
T 1709662213 18<20spb18>	you put all of your library code into the library crate. you make your binary crate depend on the library crate. things in the library that aren't used by the binary are not dead code because they're exported from the library
T 1709662219 18<20spb18>	it's quite simple
T 1709662322 18<27n118>	okay so instead of one monolith i need to separate (it is but probably imported wrongly) my code - right?
T 1709662389 18<20spb18>	the best answer depends on what you're actually doing and the specifics of your particular design
T 1709662489 18<27n118>	i guess i will just go with that one warning ig
T 1709662526 18<27n118>	but ... im curious whats the difference between mod and use thing that you suggested
T 1709662563 18<26danieldg18>	the tutorial should tell you about them
T 1709662568 18<26danieldg18>	or the docs do
T 1709662569 18<27n118>	my guess it's that moding hard-"imports" all the stuff but on the other hand the "use" really imports what i need
T 1709662580 18<20spb18>	your library and your binary are different crates. the binary implicitly depends upon the library. by writing 'mod' in both, you are including the code of those files into both crates and duplicating it
T 1709662596 18<20spb18>	by writing 'use' in the binary, you just refer to the version that was already built as part of the library
T 1709662673 18<27n118>	makes sense
T 1709662690 18<27n118>	do i need to ad some stuff to cargo too? or just update my "imports"?
T 1709662731 18<20spb18>	first you need to stop using "import" to refer to something that is not importing
T 1709662768 18<20spb18>	and no, you do not need to change anything in cargo because, as i said above, the binary crates within a project implicitly depend on the library crate
T 1709662804 18<27n118>	so once a lib.rs exists the binary is suddenly dependend on the lib - right?
T 1709662833 18<20spb18>	yes
T 1709662892 18<27n118>	maybe i got enlighted - i try it once again - the thing is i need to move all my mods to lib.rs and then use what i actually need in my main.rs - right?
T 1709662909 18<27n118>	so basically my lib is the library and main comes in and says what it needs
T 1709662930 18<27n118>	and the libs knows all the "books" thanks to "mod"s
T 1709662935 18<27n118>	am i right?
T 1709663013 18<20spb18>	any code that is a part of the library should be included only in the library, i.e. a 'mod' declaration for it should appear only in lib.rs or something included from lib.rs
T 1709663026 18<27n118>	right
T 1709663028 18<20spb18>	any code that is a part of *only* the binary, you can declare the 'mod' in main.rs
T 1709663046 18<20spb18>	and any code which is a part of the library and is used by the binary, you 'use' in the binary code
T 1709663111 18<20spb18>	note that if you have multiple modules in play, then using src/main.rs and src/lib.rs will be very confusing because you can't tell from just the folder structure whether a given module is in the lib or the bin
T 1709663146 18<27n118>	the code is 99% used in binary ... actually it was 100% as long as the whole app was a cli app - now i did add a few stuff so i can use the app as a dependency and use the functionality programatically instead of from CLI - so thats why i did add a few methods which are use in "dependecy" mode only
T 1709663207 18<20spb18>	if you want to make the code usable as a library, then you need to go all in on the idea and make your binary just be another consumer of that library
T 1709663231 18<27n118>	i see
T 1709663236 18<27n118>	damn it :)
T 1709663245 18<27n118>	thx for your time spb
T 1709667679 19*	Now talking on 22##rust
T 1709667679 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709667679 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709674383 19*	Now talking on 22##rust
T 1709674383 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709674383 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709674611 18<20nullie18>	What can I do here to pass store correctly: https://gist.github.com/nullie/d5f02dcd8ae84b1b94a128ee66155984
T 1709676051 18<20polychromata{J}18>	nullie: not familiar with wasm, but it looks like binding is keeping the borrow of store around. Since you seem to need binding throughout, you'll have to find a way to get it to not keep the borrow past the call to exports(), or else use shared ownership of store.
T 1709676198 18<25chairs18>	maybe you don't need to use the same `store` everywhere? (I'm also not familiar with wasm so don't know)
T 1709676363 18<20nullie18>	no, it panics if you pass other store
T 1709676497 18<20nullie18>	I don't get why does it need store for those calls
T 1709676559 18<25chairs18>	another guess: maybe you're supposed to save the output of `.func()` and only use it later after `binding` has gone out of scope
T 1709676621 18<20nullie18>	yeah, looks like .func() result is copiable
T 1709676812 18<25chairs18>	s/gone out of scope/can be dropped/ # I don't think you need to play explicit scoping games here, but doing so might help with understanding the issue as usual with lifetimes
T 1709676886 18<20nullie18>	yeah, I have to drop binding before I can use store again
T 1709686297 19*	Now talking on 22##rust
T 1709686297 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709686297 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709686745 18<25Widdershins18>	danieldg: I'm curious what makes Cheri pointers and size ints different widths
T 1709686808 18<26danieldg18>	cheri pointers are 128 bits; they store validity information in addition to the usual 64-bit start position
T 1709686941 18<26danieldg18>	so technically you could just declare usize to be u128, but that's really inefficient as the maximum allocation is still well below u64::MAX
T 1709687128 18<25Widdershins18>	oh man it's architecturally capability-based?
T 1709688763 18<20polychromata{J}18>	danieldg: why so? why not just `size.next_multiple_of(align) * len`?
T 1709688774 18<20polychromata{J}18>	(. You broke `slice::from_ref()`.)
T 1709688782 18<20polychromata{J}18>	…ahh
T 1709688848 18<26danieldg18>	yep
T 1709688853 18<20polychromata{J}18>	and you /could/ require padding after every allocation of a T, but at that point `{ size: 5, align: 4 }` is kind op meaningless.
T 1709688882 18<26danieldg18>	requiring padding after every allocation is exactly today
T 1709688906 18<26danieldg18>	since you can't actually use the padding, if your memcpy could overwrite it
T 1709688916 18<20polychromata{J}18>	yep.
T 1709688988 18<20polychromata{J}18>	just not worth it to save a few bytes here and there when you have some `struct(u8, u32);`s.
T 1709689015 18<26danieldg18>	better support for repr(packed) is about the best we could do
T 1709689031 18*	20polychromata{J} nods.
T 1709689067 18<20polychromata{J}18>	That way, the usecases that really want to squeeze bytes out, and are okay trading cycles to get them, can make that decision.
T 1709689109 18<26danieldg18>	and with modern cpu and memory speeds, that's true a lot more of the time than you might think
T 1709689180 18<26danieldg18>	if your data is >1MB you will likely get a speedup from packing it
T 1709689204 18<26danieldg18>	unless you're doing a lot more compute than usual on it
T 1709690265 18<20polychromata{J}18>	really? huh.
T 1709690275 18*	20polychromata{J} imagines a PackedVec…
T 1709690292 18<20polychromata{J}18>	the iterators would have to be streaming though.
T 1709690420 18<26danieldg18>	yes, it makes all your code ugly and doesn't work well if you want atomics or anything like that
T 1709690482 18<26danieldg18>	often performance isn't that critical, or you aren't actually saturating the memory bus, or other reasons
T 1709696328 18<25Widdershins18>	you can already get the best packing possible other than alignment overhead by just reordering fields (by descending alignment requirement), but if the fields themselves have alignment overhead the waste starts to add up
T 1709696367 18<26danieldg18>	yes, and that's pretty common
T 1709696380 18<25Widdershins18>	mhm
T 1709705791 19*	Now talking on 22##rust
T 1709705791 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709705791 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709711813 18<22shamelessshill18>	Hello, good folks. I have a rather simple but strange question.
T 1709711839 18<22shamelessshill18>	So in my project, I have a bunch of crates... and I have a script that bumps up versions.
T 1709711878 18<20osse18>	So far so good
T 1709711888 18<22shamelessshill18>	So, my question is this - if my script bumps up the version in the Cargo.toml files for each of my crates, it should be fine if the same script bumps up the versions in Cargo.lock as well, yes?
T 1709711913 18<22shamelessshill18>	We check in Cargo.lock into version control, and the version update step is done as a separate commit (no dependencies added, etc.)
T 1709711934 18<22shamelessshill18>	I thought of running a build and the adding the generated Cargo.lock, but that seems like overkill?
T 1709711987 18<22shamelessshill18>	Otherwise right now I observe that the crate versions (my own crates) in the lockfile are falling behind the toml versions because people keep forgetting to check in the lock file (nor should they have to, imho).
T 1709712044 18<22shamelessshill18>	and overkill since all the changes are for my own crates (not deps) and only the version string would change to match that in the TOML file... I'm not adding any dependencies during this version bumping step.
T 1709712048 18<22shamelessshill18>	Thoughts?
T 1709712078 18<22shamelessshill18>	I thought of checksum issues, but we don't track checksums in the lock file for our own crates, do we? Only for external dependencies.
T 1709712105 18<22shamelessshill18>	Any other issues that come to mind?
T 1709712534 18<20polychromata{J}18>	shamelessshill: simplistic editing of the lockfile sounds like a good way to break things
T 1709712573 18<20polychromata{J}18>	do you know what happens if the lockfile specifies a crate with a version that has a dependency, but doesn't say anything about that dependency?
T 1709712575 18<20polychromata{J}18>	(I don't.)
T 1709712589 18<20polychromata{J}18>	how about `cargo generate-lockfile`?
T 1709712663 18<22shamelessshill18>	Hmmm
T 1709712683 18<20polychromata{J}18>	actually…isn't the overall thing you're trying to do just `cargo update`?
T 1709712709 18<22shamelessshill18>	It is true that right now the script is run as a separate independent "version change only" step, but that __requires__ developer discpline. You're right - I don't like the idea myself.
T 1709712732 18<22shamelessshill18>	polychromata{J}: Wouldn't `cargo update` update the dependencies as well?
T 1709712741 18<22shamelessshill18>	Even minor/patch versions, I mean.
T 1709712749 18<25bertptrs18>	correct, so you don't want that
T 1709712751 18<22shamelessshill18>	I think cago generate lockfile looks promising... polychromata{J} ... TIL
T 1709712794 18<22shamelessshill18>	bertptrs: Yes, indeed. Let me experiment with generate lockfile and see...
T 1709712855 18<22shamelessshill18>	Oops... looks like generate-lockfile also updates
T 1709712857 18<22shamelessshill18>	:(
T 1709713114 18<25bertptrs18>	so it does, that's annoying
T 1709713129 18<25bertptrs18>	I guess you could get awaym with `cargo check` instead of a full build?
T 1709713207 18<22shamelessshill18>	Actually, I found something that does appears to work: `cargo update --workspace`
T 1709713219 18<25bertptrs18>	that should still update deps if I read the docs?
T 1709713224 18<22shamelessshill18>	"--workspace Attempt to update only packages defined in the workspace. Other packages are updated only if they don’t already exist in the lockfile. This option is useful for updating Cargo.lock after you’ve changed version numbers in Cargo.toml.
T 1709713228 18<22shamelessshill18>	"
T 1709713231 18<25bertptrs18>	ooooh
T 1709713232 18<22shamelessshill18>	__Seems__ to work
T 1709713233 18<25bertptrs18>	that's brilliant
T 1709713239 18<22shamelessshill18>	Let me double-check! :)
T 1709713245 18<25bertptrs18>	somewhat misnamed but w/e
T 1709713247 18<22shamelessshill18>	bertptrs: Yeah... beautiful indeed!
T 1709713259 18<22shamelessshill18>	Yeah, I would never have guessed with that flag name.
T 1709713299 18<22shamelessshill18>	Yup... appears to work! So polychromata{J} was right after all. Hehehe.
T 1709713333 18<20polychromata{J}18>	…that's a really bad name for that flag.
T 1709713338 18<20polychromata{J}18>	Good find though.
T 1709713364 18<22shamelessshill18>	Indeed... I only happened to even go to that doc page because the generate-lockfile docs said that `update` had more options... so pure luck!
T 1709714493 18<27gastus18>	I want to experiment with non utf-8 fast csv parsing and wanted to create ffi bindings to zsv now bindgen fails to find some definitions. Is it best to manually convert or is bindgen supposed to understand all header files and my configuration is incomplete ?
T 1709714545 18<25bertptrs18>	bindgen doesn't understand all header files, and you usually have to make it ignore things
T 1709715593 18<27rendar18>	in your experience, do you think exist one crate which abstracts Box<&str> and adds useful traits (e.g. From, etc) ?
T 1709715611 18<27rendar18>	i mean, Box<Rc<&str>>
T 1709715664 18<27rendar18>	i want to create |1 ptr size poiting to| --->  |ref_count|my string data|
T 1709715710 18<25Mutabah18>	`Rc<str>` is a fat pointer to counts and string data
T 1709715714 18<25bertptrs18>	That's just Rc<str>
T 1709715720 18<25Mutabah18>	although, maybe you'd want a string interning crate
T 1709715786 18<25bertptrs18>	nvm, Rc<str> is two pointer size because of the fat pointer
T 1709716189 18<27rendar18>	Mutabah, no, i don't want a global state to check
T 1709716238 18<27rendar18>	i wish to get only 1 pointer size, like a Box, but also a ref counter for cheap cloning
T 1709716250 18<27rendar18>	can i combine the 2 things?
T 1709716268 18<27rendar18>	having only 1 heap allocation that contains both ref counter and string data
T 1709716350 18<25bertptrs18>	Not right now, there is no nice way to create DSTs from rust
T 1709716386 18<25bertptrs18>	your allocation would have to store |len|rc|data|
T 1709716529 18<27rendar18>	bertptrs, yes sorry, i meant just that one
T 1709716537 18<27rendar18>	rc+len+data
T 1709716544 18<27rendar18>	in one unique block, isn't that possible?
T 1709716567 18<25bertptrs18>	Creating dsts yourself is annoying but it's not impossible I guess
T 1709716577 18<25bertptrs18>	You have to basically do it without language support
T 1709716598 18<27rendar18>	what you mean with DSTs?
T 1709716605 18<25bertptrs18>	dynamically sized types
T 1709716610 18<27rendar18>	i see
T 1709716612 18<25bertptrs18>	types that do not have a fixed size\
T 1709716614 18<25bertptrs18>	such as str
T 1709716658 18<25bertptrs18>	or slices
T 1709716680 18<27rendar18>	bertptrs, well, Box<str> is not dinamically sized type, because sizeof(Box<str>) is 8 (1 pointer size), then it allocates N bytes on heap, just like Vec<u8> which is 24 in sizeof, but then it allocates N bytes on heap, am i wrong?
T 1709716704 18<25bertptrs18>	wrong, sizeof Box<str> is 16
T 1709716715 18<25bertptrs18>	because str is a DST
T 1709716715 18<27rendar18>	because of the fat pointer?
T 1709716718 18<25bertptrs18>	Correct
T 1709716721 18<27rendar18>	yeah
T 1709716726 18<27rendar18>	what about Box<&str> ?
T 1709716734 18<25bertptrs18>	That one is indeed size 8
T 1709716752 18<27rendar18>	indeed, but Box<&str> is a pointer pointing to |len|data..| ?!
T 1709716757 18<27rendar18>	or just data?
T 1709716794 18<27rendar18>	or is a pointer pointing to |len|ptr_to_data|    which in turn points to |data..| ?
T 1709716794 18<25bertptrs18>	Box<&str> is pointing to an &str which is contains a length and a pointer to the data
T 1709716812 18<27rendar18>	so with Box<&str> i get 2 heap allocations per string?
T 1709716830 18<25bertptrs18>	not necessarily heap allocations (can use a static str after all) but yes two indirections
T 1709716845 18<27rendar18>	oh gosh :| i see
T 1709717028 18<27rendar18>	now i get the purpose of a crate that tried to fix this problem, and had strings of 2 pointer size
T 1709717213 18<27rendar18>	https://crates.io/crates/tendril
T 1709717228 18<27rendar18>	that's is! i found it, doesn't this crate does what i need?
T 1709717328 18<25Mutabah18>	Maybe it is
T 1709717338 18<25Mutabah18>	Depends on why you want those single-pointer strings
T 1709717356 18<25Mutabah18>	What you were asking for reminds me of the `RcString` type I have in mrustc (... in C++, but same idea)
T 1709717370 18<25Mutabah18>	A pointer to a refcount, length, and then string data
T 1709717509 18<27rendar18>	Mutabah, that's simple: consider a very large hasmap with strings as keys, i don't need them to be mutable, still i will spare a lot of memory not having 24 bytes for each string
T 1709717522 18<27rendar18>	what is mrust?
T 1709717586 18<25bertptrs18>	Mutabah's Rust Compiler
T 1709717728 18<27rendar18>	really?
T 1709718047 18<27synapse18>	I have a colleague who uses Result<(), ()> instead of bool. in a way, I kinda get why 'return Err(());' is more readable than 'return false;' :P
T 1709718065 18<25Mutabah18>	`Result` carries more semantic information than a `bool`
T 1709718085 18<25Mutabah18>	is `false` "operation failed" or is it "don't worry about me"?
T 1709718096 18<27synapse18>	yeah, it's answering a generic question
T 1709718106 18<27synapse18>	whereas Result<(), ()> is always whether some operation went well
T 1709718962 18<20mkoncek118>	and allows ? shortcut
T 1709719216 18<27Affliction18>	Caller probably still needs to map_err it into something sane, but yeah, I might start using that pattern
T 1709719237 18<25bertptrs18>	nothing matches! can't fix
T 1709719245 18<27Affliction18>	true
T 1709719245 18<25bertptrs18>	Or just is_ok()
T 1709720984 18<26kpcyrd18>	I'd still use anyhow::Result<T>, then provide a simple message for bail!. the few bytes in the binary for a &'static str shouldn't hurt.
T 1709721019 18<26kpcyrd18>	I use anyhow::Result<()> quite often
T 1709722802 18<20mkoncek118>	no method named `poll` found for mutable reference `&mut (dyn Future<Output = ()> + 'static)` in the current scope
T 1709722829 18<20mkoncek118>	i have a vector of Box<dyn Future>
T 1709722864 18<20mkoncek118>	also, should i be using PollFn instead?
T 1709722874 18<26dav1d18>	Is there a nice way to just take the first item from a &mut [T]?
T 1709722918 18<26dav1d18>	`take_first` is of course nightly
T 1709722938 18<25bertptrs18>	split_at_mut can kind of do it but it's not perfect
T 1709722939 18<26dav1d18>	guess I'll just have to do split_first :(
T 1709722948 18<25bertptrs18>	oh split_first too
T 1709723032 18<26dav1d18>	aight thanks
T 1709723034 18<25bertptrs18>	mkoncek1: is the Future trait in scope? Not sure if it's part of the prelude
T 1709723228 18<20mkoncek118>	oh right, poll is not a member function
T 1709723237 18<20mkoncek118>	fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;
T 1709723245 18<20mkoncek118>	the first arg is not a reference to self
T 1709724341 18<25bertptrs18>	No it's a pin, because the requirements for Future are slightly stronger. poll is a member though
T 1709724377 18<25bertptrs18>	Members are allowed to take Pin, Arc, Rc, Box, or any combination of them as their self
T 1709725321 18<20mkoncek118>	really? didn't know about that
T 1709725343 18<25Widdershins18>	and don't forget native references that counts too
T 1709725365 18<25Widdershins18>	altho idk how much you can layer it actually
T 1709725459 18<25Widdershins18>	&&self isn't allowed, but self: &Box<Self> is
T 1709725481 18<25Widdershins18>	i guess that's 'cause && just decays to &
T 1709725482 18<20spb18>	https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=90eec5e4a7a77b0663fd3db944c5a929
T 1709725499 18<20spb18>	`a.foo()` doesn't compile in that case
T 1709725526 18<25Widdershins18>	ah you can do it then it just doesn't let you implicitly type it like &self
T 1709725584 18<20spb18>	i'm not sure in what situation this would be useful, mind
T 1709725600 18<25Widdershins18>	ok yeah even deranged types like &Rc<&Box<&&Self>> are allowable for method receivers. but yeah not very useful, you won't see it much
T 1709725630 18<25Widdershins18>	usually it is like `self: Box<Self>` so that you can take ownership of the value via a box instead of the value itself
T 1709725661 18<25Widdershins18>	otherwise anything that would receive &Box<Self> you can just let it decay to &self by dereferencing
T 1709725914 18<25bertptrs18>	There's the Wake trait that takes Arc<Self> and &Arc<Self>
T 1709725971 18<25Widdershins18>	&arc so you don't have to mess with the count by cloning it
T 1709725990 18<25bertptrs18>	Exactly
T 1709726114 18<25bertptrs18>	but rather than making an arbitrary decision on what makes sense, the standard just allows all combinations
