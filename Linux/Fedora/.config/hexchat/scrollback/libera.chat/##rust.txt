T 1707739725 19*	Now talking on 22##rust
T 1707739725 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1707739725 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1707742868 19*	Now talking on 22##rust
T 1707742868 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1707742868 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1707743084 18<25bertptrs18>	dav1d: Error has a couple of methods that you can only call on "dyn Error + 'static"
T 1707743114 18<25bertptrs18>	Which are (I think) inherited from Any requiring 'static
T 1707743528 18<24Bish18>	if i wanted to serialize datastructures of crates with serde im pretty much screwed, right?
T 1707743542 18<24Bish18>	in this case i want to use http::* things in my struct and it should be serializable
T 1707743558 18<24Bish18>	i could wrap it in my own type, but i can't magicially make it serializible via macro, right?
T 1707743565 18<24Bish18>	i could ofcourse write my own serializer, correct?
T 1707743574 18<20spb18>	https://serde.rs/remote-derive.html
T 1707743609 18<24Bish18>	cool
T 1707743610 18<24Bish18>	thanks
T 1707743652 18<24Bish18>	is this "dangerous" as in, what happens if i the 2 structs differ
T 1707743690 18<20spb18>	if you consider compiler errors dangerous
T 1707744110 18<24Bish18>	it bothers me i have to copy the definition of the thing i want to serialize
T 1707744157 18<24Bish18>	and what if they go deep?
T 1707744183 18<24Bish18>	then i'd have to provide many many of those?
T 1707744415 18<29demize18>	What from the http crate do you want to be able to de/serialize?  The http-serde crate might provide everything you need already.
T 1707744454 18<24Bish18>	guess it does, yeah
T 1707747953 18<26dav1d18>	bertptrs, that is unfortunate :(
T 1707748273 18<25bertptrs18>	I expect it to be related to Sentry's error sniffing logic. I haven't worked with them in Rust but in Python they try to downcast your uncaught exceptions to be more helpful in the reporting. I imagine that's why they want to touch the downcast methods
T 1708186109 19*	Now talking on 22##rust
T 1708186109 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708186109 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708438062 19*	Now talking on 22##rust
T 1708438062 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708438062 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708439546 19*	Now talking on 22##rust
T 1708439546 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708439546 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708439876 19*	Now talking on 22##rust
T 1708439876 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708439876 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708441150 18<22Ademan_18>	presumably in some cases, Fromiterator::from_iter() might do something more efficient than a naive for loop might. would it be valid for <HashMap as FromIterator>::from_iter() to take only the first value for a given key and discard the rest? I've written my code assuming that the resulting hash map will use the *last* value for a given key (the behavior you'd get with a naive `for (k, v) in i {
T 1708441156 18<22Ademan_18>	map.insert(k, v); }` ).
T 1708441619 18<20spb18>	the trait documentation doesn't say anything about how situations like that should be handled, so you should assume that any reasonable implementation is possible
T 1708443107 18<22Ademan_18>	spb: makes sense, thanks!
T 1708443377 18<28belst18>	FH_thecat: did u build in release mode? the github releases are all less than 10mb
T 1708443742 18<27FH_thecat18>	belst: I build it using "cargo build --release"
T 1708444143 18<27rendar18>	if i'm using thiserror, and i have `enum MainError { #[error("Math Error")] MathError(#[from] MathError),  ... }`   when i print the error from MainError with "{}" i only get "Math Error" string, but since its a nested enum, shouldn't thiserror automatically prints the real MathError string instead of that one?
T 1708444169 18<20spb18>	only if you tell it to
T 1708444184 18<20spb18>	#[error("Math Error: {0}")]
T 1708444194 18<27rendar18>	hmm, i see
T 1708444278 18<27rendar18>	of course, it takes the same parameter id as other errors which has String or whatever, ok
T 1708444365 18<20spb18>	all the fields of that enum variant are available to use in any normal format expression
T 1708444395 18<20spb18>	based on whether they impl Display or Debug
T 1708454504 18<25bertptrs18>	FH_thecat: late reply but looking at the binary most of it appears to be tree-sitter parsers for various languages. It's a bit silly to statically link treesitter dozens of times, but it does, and depending on the language (*cough* sql) those parsers are pretty damn big
T 1708454904 18<25bertptrs18>	in other words, the extensive langauge highlighting that difftastic does
T 1708454957 18<27FH_thecat18>	bertptrs: can I disable some parsers for languages that I don't need ?
T 1708454974 18<27FH_thecat18>	and why does it have to be statically linked anyway?
T 1708455042 18<27FH_thecat18>	I basically just need shell (sh,zsh), python and c
T 1708455062 18<25bertptrs18>	I'd have to RTFS it, but from an initial glance, it compiles everything unconditionally
T 1708455111 18<27FH_thecat18>	what a monstrosity !
T 1708455135 18<25bertptrs18>	soft disagree, you want a swiss army knife, you get a swiss army knife
T 1708455173 18<25bertptrs18>	It's kinda funny, rust (rightfully) gets blamed for large binaries but most of this is C :P
T 1708455197 18<20j`ey18>	https://github.com/Wilfred/difftastic/tree/master/vendored_parsers oh yeah lotsa parsers
T 1708455275 18<27FH_thecat18>	why can't the parsers be modular
T 1708455282 18<27FH_thecat18>	ie, just install those that I need
T 1708455291 18<25bertptrs18>	because the devs didn't bother to do it, since it's a maintenance and testing hassle
T 1708455298 18<25bertptrs18>	or so I'd guess
T 1708455308 18<25bertptrs18>	modular features make exponential testing and such
T 1708455335 18<27FH_thecat18>	I thought modular approach is "cleaner"
T 1708455354 18<20j`ey18>	it is but requires more code / maintainenace
T 1708455438 18<27FH_thecat18>	then, at least there should be configuration for the build, which ones to include
T 1708455463 18<27FH_thecat18>	that would not add any extra complexity
T 1708455479 18<20j`ey18>	it would
T 1708455490 18<25bertptrs18>	I very much encourage you to raise these concerns upstream (though in a friendlier tone). None of us develop this tool, I was just curious how the binary could be so large. Now I have an answer
T 1708455524 18<27FH_thecat18>	thank you
T 1708456242 18<24Odin-LAP18>	bertptrs: C also gets an unwarranted assumption of its binaries being small, with enormous amounts of its runtime support libraries being considered "just the operating system".
T 1708456280 18<20consus18>	because it usually is :D
T 1708456332 18<20consus18>	having stdlib in each binary and still relying on libc is really stoopid
T 1708456376 18<26dav1d18>	😬
T 1708456553 18<24Odin-LAP18>	consus: But it means a comparison with a binary that _does_ contain all of that stuff isn't exactly apples to apples.
T 1708456555 18<24Odin-LAP18>	:)
T 1708456615 18<20consus18>	Odin-LAP: who cares? you have a hello world with 386k weigh that still does not qualify as a static binary because of it's reliance on libgcc and libc
T 1708456625 18<20consus18>	That's stoopid
T 1708456641 18<20consus18>	No amount of Rust copium will help you justify this
T 1708456675 18<25bertptrs18>	consus: you got warned yesterday, hereby your second warning, please behave a bit more professional
T 1708456705 18<20consus18>	bertptrs: I've missed the first one
T 1708456719 18<20consus18>	what exactly are you accusing me of?
T 1708456738 18<25bertptrs18>	<bertptrs> but that's not a reason to be this negative as it's counterproductive
T 1708456762 18<20consus18>	how should I phrase it then?
T 1708456838 18<25bertptrs18>	avoid "stoobid" and "copium" while discussing people's hard work
T 1708456843 18<20consus18>	why?
T 1708456850 18<20consus18>	copium is really a good word
T 1708456857 18<20consus18>	it's not offending
T 1708456864 18<20consus18>	I'm not calling people names
T 1708456874 18<20consus18>	but the end result is really suboptimal
T 1708456933 18<20consus18>	for example it forces projects like uutils to create a really large binary with HUGE attack surface
T 1708457055 18<19nCrazed18>	"inflamtory language" comes to mind
T 1708457069 18<20consus18>	fair enough
T 1708457073 18<25bertptrs18>	I was struggling to put it into words but yeah, that's what I meant
T 1708457134 18<25cehteh18>	uutils is stil at 0.0.x stage, i would guess that binary size optimization isnt even considered yet
T 1708457168 18<25cehteh18>	there are ways to reduce rust executables sizes, eventually
T 1708457179 18<20consus18>	They went busybox-like route
T 1708457182 18<20consus18>	With a single binary
T 1708457191 18<25cehteh18>	which is good
T 1708457192 18<20j`ey18>	but are you sure that's due to size?
T 1708457200 18<20consus18>	one of the reasons
T 1708457217 18<20consus18>	cehteh: which also creates a huge gadget space
T 1708457256 18<25cehteh18>	i would like if rust had better support for dynamic linking, but that opens other cans of worms
T 1708457378 18<25cehteh18>	https://github.com/johnthagen/min-sized-rust  there are these tips, bit outdated but many are ok, still applying that would be the icing on the cake when you are ready for production releases
T 1708457514 18<20consus18>	it does not help much
T 1708457519 18<20consus18>	you win like ~50k
T 1708457537 18<20consus18>	well, strip helps, but that's obvious
T 1708457548 18<20consus18>	no distro will let a binary without striping
T 1708457563 18<25cehteh18>	this is not a process you can blindly apply, you have to look at your project and see what benefit it most
T 1708457587 18<20consus18>	strip does 80% of the work :)
T 1708457592 18<25cehteh18>	lto for example usually reduces code size, somtimes significantly, but in some cases it bloats
T 1708457602 18<20consus18>	not that much in my experience
T 1708457606 18<20consus18>	you may win 20%
T 1708457610 18<20consus18>	even 30%
T 1708457614 18<20consus18>	but still
T 1708457617 18<25cehteh18>	it depends on the exact project
T 1708457640 18<20consus18>	the thing is... it does not help small projects because of unconditional stdlib
T 1708457655 18<25cehteh18>	removing all the panic stuff/info should save a bit, but only when combined with the build_std thing
T 1708457657 18<20consus18>	and if you're writing something like a webapp
T 1708457662 18<20consus18>	who cares?
T 1708457677 18<20consus18>	it can 500M, that won't be an issue
T 1708457680 18<25cehteh18>	you where talking about uulib
T 1708457684 18<20consus18>	yeah
T 1708457720 18<20consus18>	total busybox on my system is 1.3M
T 1708457728 18<20consus18>	lemme check the uutils
T 1708457771 18<25cehteh18>	i wont be surprised when its at this stage magnitudes larger
T 1708457938 18<25cehteh18>	oh they have a release-small target already
T 1708457968 18<20consus18>	8.5 with release
T 1708457974 18<20consus18>	actually not bad
T 1708457981 18<20consus18>	less than 10x
T 1708458007 18<25cehteh18>	5.3 with the release-small profile
T 1708458020 18<20consus18>	comparable then
T 1708458025 18<25cehteh18>	so just stop ranting :D
T 1708458031 18<20consus18>	why?
T 1708458046 18<20j`ey18>	does uutils try to do anything better?
T 1708458048 18<25cehteh18>	its annoying
T 1708458049 18<20consus18>	that's exactly why they decided to do that
T 1708458053 18<20j`ey18>	or is it just 1:1?
T 1708458077 18<20consus18>	because otherwise the size would be (clap + stdlib) * n_utils
T 1708458086 18<20consus18>	j`ey: more colors
T 1708458091 18<20j`ey18>	heh
T 1708458093 18<20consus18>	j`ey: some other imprrovements
T 1708458099 18<20consus18>	if you like colors that is
T 1708458110 18<25cehteh18>	there where people here with an actual problem that their binary was too big, if only code golfing, usually they got helped
T 1708458151 18<25cehteh18>	ranting about potential other project could be too big .. and then find out that its actually not the case, is stupid
T 1708458163 18<20consus18>	errr
T 1708458170 18<20consus18>	you misread
T 1708458184 18<20consus18>	I was citing uutils as an example of why projects decide to do single binary
T 1708458193 18<25cehteh18>	<consus> for example it forces projects like uutils to create a really large binary with HUGE attack surface
T 1708458198 18<20consus18>	yeap
T 1708458235 18<20consus18>	the C coreutils does not have a single binary
T 1708458241 18<20consus18>	it has a lot of small tools
T 1708458254 18<20consus18>	it works because of the dynamic linking
T 1708458280 18<25cehteh18>	thats just a implementation/deployment detail
T 1708458284 18<20consus18>	uutils cannot do that because then the total sum would be (stdlib + clap + other common deps) * N-Utils
T 1708458307 18<25cehteh18>	i think you can build it (mostly) statically linked with some efforts
T 1708458322 18<20consus18>	true, but then you have a problem with tools like ping
T 1708458338 18<20consus18>	because ping, for example, requires special flags
T 1708458345 18<20consus18>	and/or suid
T 1708458390 18<25cehteh18>	sure, so what? ..
T 1708458413 18<20j`ey18>	consus: do you have the uutils grep vs coreutils grep?
T 1708458424 18<20consus18>	j`ey: in terms of features?
T 1708458459 18<20j`ey18>	sizes
T 1708458460 18<20consus18>	I'm not sure uutils aims at full posix compatibility
T 1708458481 18<25bertptrs18>	it aims to pass GNU coreutils tests
T 1708458532 18<20consus18>	huh, strange, cannot find grep in applets
T 1708458540 18<25cehteh18>	which is probably more demanding :D posix requirements on some tools are surprisingly minimal
T 1708458547 18<20consus18>	nah
T 1708458555 18<20consus18>	the level of compatibility is a nigthmare
T 1708458561 18<20j`ey18>	consus: oh, well some other binary will do
T 1708458563 18<20j`ey18>	find or whatever
T 1708458586 18<20consus18>	it took openbsd 8 years or so to write grep that worked for them
T 1708458596 18<25bertptrs18>	grep is not in coreutils, is it?
T 1708458614 18<20consus18>	not sure actually
T 1708458622 18<20spb18>	not last i knew
T 1708458624 18<20consus18>	nope, it's a separate thing
T 1708458626 18<20consus18>	as is find
T 1708458631 18<25cehteh18>	woudnt ping be in netutils? i dunno
T 1708458636 18<20consus18>	ping netutils
T 1708458636 18<25bertptrs18>	not on my system
T 1708458640 18<20consus18>	find findutils
T 1708458646 18<20consus18>	grep is grep :D
T 1708458654 18<20j`ey18>	grr
T 1708458676 18<25bertptrs18>	la la, la la la
T 1708458686 18<20consus18>	yeah, busybox provides a lot more
T 1708458686 18<25bertptrs18>	lababadap dap dap grep
T 1708458725 18<26dav1d18>	I think bertptrs broke :(
T 1708458757 18<25bertptrs18>	I'm just conditioned on Opus so whenever someone writes X is X I get "Life is Life" stuck in my head
T 1708458768 18<20consus18>	xD
T 1708458806 18<20consus18>	I was actually thinking about the song about that blue dudes on an spaceship
T 1708458817 18<20consus18>	Can't remember the band name
T 1708458822 18<25bertptrs18>	ah no. Eiffel 65
T 1708458827 18<25bertptrs18>	Different genre
T 1708458828 18<20consus18>	yeah, right
T 1708458839 18<25cehteh18>	bertptrs: https://www.youtube.com/watch?v=Zt2_11e6QPA ;)
T 1708458941 18<25cehteh18>	https://www.youtube.com/watch?v=y_cbTcaoErI  better version
T 1708459027 18<20consus18>	what is the explicit of '?'?
T 1708459072 18<20consus18>	I remember writing ResultExt with into_res() but I think stdlib should have something standard for that
T 1708459095 18<25cehteh18>	explicit? desugaring?
T 1708459114 18<20consus18>	Ok(foo().await?) => foo().await.into_res()
T 1708459141 18<25cehteh18>	its not that trivial
T 1708459173 18<25bertptrs18>	it cannot be desugared like that, since it's equivalent to match foo().await { Ok(val) => val, Err(e) => return Err(e.into()) }
T 1708459183 18<25bertptrs18>	there used to be the try! macro which did almost this
T 1708459228 18<25cehteh18>	https://rust-lang.github.io/rfcs/3058-try-trait-v2.html
T 1708459258 18<25bertptrs18>	https://doc.rust-lang.org/std/ops/trait.Try.html also this
T 1708459265 18<20consus18>	damn, I had it somewhere
T 1708459272 18<25cehteh18>	yeet
T 1708459292 18<20consus18>	probably the old laptop
T 1708459298 18<20consus18>	well, nevermind :(
T 1708459305 18<25bertptrs18>	I hate that yeet exists
T 1708459315 18<20consus18>	yeet?
T 1708459322 18<25bertptrs18>	https://doc.rust-lang.org/std/ops/struct.Yeet.html
T 1708459386 18<25bertptrs18>	it exists to avoid a bikeshed about what it should be called from slowing down the RFC; they chose a name that definitely nobody likes so it was sure to be changed later
T 1708459402 18<25bertptrs18>	as opposed to a "not quite great but acceptable" name sticking around after development
T 1708459414 18<28darkling18>	... and that was 10 years ago? :)
T 1708459418 18<20consus18>	:D
T 1708459434 18<20consus18>	I miss pure
T 1708459435 18<25bertptrs18>	it hasn't been stabilized yet, that's something
T 1708459509 18<20consus18>	.map_err(|e| e.into())
T 1708459509 18<20polychromata{J}18>	bertptrs: baba is baba
T 1708459510 18<20consus18>	yeah
T 1708459511 18<20consus18>	this
T 1708459527 18<20consus18>	I was looking for this
T 1708459537 18<25bertptrs18>	that's only half of what ? does, but sure
T 1708459561 18<20consus18>	it helps me not to wrap everything in Ok()
T 1708459572 18<20consus18>	Which look really ugly
T 1708459573 18<25bertptrs18>	Fair enough, it makes sense for your final return statement
T 1708459578 18<20consus18>	yeah
T 1708459578 18<25bertptrs18>	or just returns in geenral
T 1708459596 18<20consus18>	it's a pity that ? without ; is not a thing
T 1708459626 18<20consus18>	feels wront to explicitly mark return values as "good"
T 1708459648 18<20j`ey18>	feels right to me
T 1708459752 18<20consus18>	it was unambigous in the beginning, before ?
T 1708459765 18<20consus18>	but now the language itself has an operator for returning errors
T 1708459778 18<20consus18>	And now it feels weird
T 1708459875 18<25bertptrs18>	most languages have a keyword instead
T 1708459878 18<25bertptrs18>	either way works
T 1708459906 18<25bertptrs18>	C has… error codes and out parameters, I guess
T 1708460005 18<20consus18>	? is cool! but it would be even cooler to go one step further and allow `foo().await?` instead of `Ok(foo().await?)`
T 1708460049 18<20j`ey18>	I mean with ? that would make it context sensitive I guess
T 1708460119 18<20consus18>	more than it now?
T 1708460128 18<20j`ey18>	yes?
T 1708460146 18<20j`ey18>	I assumed you were saying if it was the return value, the Ok would be implicit
T 1708460153 18<20consus18>	yeah
T 1708460615 18<25bertptrs18>	the annoucement blog for anyhow did something like that, with a proc macro, but honestly it just muddies the water and makes types harder to explain
T 1708462853 18<26dav1d18>	Isn't  `Ok(foo().await?)` just a `foo().await.map_err(Into::into)` if you prefer not to use the `?` here
T 1708462873 18<20consus18>	yeah
T 1708462874 18<25bertptrs18>	It is
T 1708462888 18<20consus18>	but since we already have ?
T 1708462906 18<20consus18>	kinda makes sense to use it here too
T 1708462919 18<20consus18>	let foo = may_fail()?;
T 1708462935 18<20consus18>	but  may_fail()? does not do the same
T 1708463012 18<25bertptrs18>	does it not?
T 1708463053 18<20consus18>	nope
T 1708463070 18<26dav1d18>	but it does
T 1708463073 18<20consus18>	nope
T 1708463082 18<26dav1d18>	okay nvm
T 1708463085 18<20consus18>	Ok(foo()?) works
T 1708463090 18<20consus18>	foo()? -- does not
T 1708463106 18<25bertptrs18>	because the return type of foo()? is T, not Result<T, E>
T 1708463109 18<20consus18>	what I  mean is  that foo()? cannot be on the last line
T 1708463122 18<25bertptrs18>	that's actually caused by it doing the same
T 1708463135 18<20consus18>	but it behaves differently
T 1708463137 18<26dav1d18>	exactly because it does the same it does not work
T 1708463144 18<20consus18>	and that's weird
T 1708463153 18<20consus18>	no?
T 1708463153 18<25bertptrs18>	no it behaves the same. It turns a Result<T, E> into a T (or returns early)
T 1708463166 18<20consus18>	well, perhaps
T 1708463174 18<25bertptrs18>	And if your function returns a Result<T, E> you cannot return a T from it
T 1708463183 18<20consus18>	yeah, makes sense
T 1708463184 18<26dav1d18>	`let foo = may_fail().unwrap();` `works but `may_fail().unwrap()` we should make unwrap behave special
T 1708463194 18<20consus18>	nah
T 1708463198 18<20j`ey18>	that's what I meant about context
T 1708463213 18<26dav1d18>	although we could also tell the compiler to implicitly wrap items in Ok if there is a result expected
T 1708463222 18<20consus18>	let foo = foo().await?.some()?.other()?.chains()?;
T 1708463246 18<20consus18>	it will return Result<T> if some() fails, for example
T 1708463254 18<20consus18>	it will even converse it for you
T 1708463266 18<20consus18>	which is good, right?
T 1708463270 18<25bertptrs18>	dav1d: that stops working when you introduce nested Results, which is not uncommon in generic code
T 1708463277 18<26dav1d18>	bertptrs, it is a terrible idea
T 1708463284 18<26dav1d18>	it would also fuck with infering types
T 1708463297 18<26dav1d18>	e.g. collecting into anything that is a result
T 1708463333 18<25bertptrs18>	yea
T 1708463335 18<25bertptrs18>	better not
T 1708464302 18<20cappy18>	Is there a way to get cargo(1) to clean --release just the object files (ELF) from a project directory?
T 1708465223 18<20cappy18>	I've been using: find . -exec file {} \; | grep -i elf | awk '{print $1}' to locate the files for rm(1) but there might be a better way.
T 1708465593 18<20polychromata{J}18>	why just the object files?
T 1708465763 18<20cappy18>	polychromata{J}: They can be rebuilt. The source and other files will be picked up by my backup program. No sense in backing up ELFs.
T 1708465801 18<20j`ey18>	but cargo clean wont delete the source files
T 1708465818 18<20j`ey18>	everything that cargo clean deletes can be rebuilt
T 1708465833 18<20polychromata{J}18>	why not just exclude the entire target directory from backups?
T 1708465845 18<20polychromata{J}18>	that might happen by default, even; cargo tags it as a cache
T 1708465860 18<20nullie18>	tags?
T 1708465866 18<20cappy18>	j`ey: All true. I just started using Rust/Cargo today.
T 1708465871 18<20polychromata{J}18>	yeah, look inside.
T 1708465872 18<20j`ey18>	puts a special file in the foldre
T 1708465895 18<20nullie18>	oh, TIL
T 1708465916 18<20j`ey18>	cappy: see if your backup program knows about https://bford.info/cachedir/
T 1708465944 18<20cappy18>	polychromata{J}: Of course.
T 1708465997 18<20cappy18>	j`ey: cachedir... I'll look at that. No my backup program does not see such. Might look at an alternative for backups.
T 1708466997 18<20cappy18>	borgbackup will exclude CACHEDIR.TAG directories. It's in my repo. Thanks for the help guys.
T 1708470467 18<19turlando18>	If I know that due to some incompatibility my program will only run on 64 bit architectures, is it possible to restrict the target platforms in Cargo.toml and at the same time get access to, e.g., From<usize> for u64?
T 1708470505 18<20j`ey18>	nope
T 1708470536 18<19turlando18>	Would it be something sane to implement myself?
T 1708470550 18<20j`ey18>	You couldn't implement the From<usize>
T 1708470564 18<20j`ey18>	you can error on the pointer size though, but I think only from code
T 1708470576 18<20jbg18>	but you can always just write `as usize` since you know it's fine
T 1708470627 18<20jbg18>	(in the process creating that incompatibility if it didn't already exist!)
T 1708470687 18<19turlando18>	Having it handled at type level would make me feel better
T 1708470702 18<19turlando18>	And sleep better at night maybe
T 1708470826 18<20jbg18>	should be possible to refuse to compile on non-64-bit arch. use something like #[cfg(not(target_pointer_width = 64))] compile_error!("only 64-bit architectures are supported");
T 1708470845 18<20jbg18>	then you can use `42u64 as usize` and still sleep at night
T 1708470901 18<19turlando18>	That is true untile somebody decides that 32 bits are fine and the compiler will gladly allow that :
T 1708470903 18<22Arnavion18>	Or `#[cfg(target_pointer_width = 64)] fn convert(a: usize) -> u64 { a as _ }` and use `convert()` everywhere
T 1708470920 18<22Arnavion18>	so the fn won't be defined if it can't be used safely
T 1708470935 18<19turlando18>	Arnavion: that looks much better as long as it's a non-op
T 1708471005 18<20jbg18>	the body is clearly a no-op, you could put #[inline(always)] on it if you are really worried
T 1708471026 18<19turlando18>	It still has to do runtime checks even in release mode?
T 1708471049 18<20j`ey18>	there's no runtime checks with as
T 1708471053 18<19turlando18>	Sorry, I was reading "it's not a non-op"
T 1708471093 18<20jbg18>	you could also do similar with a trait to make it feel a bit more like From
T 1708471170 18<19turlando18>	I'm not sure why I can't guard the impl From with #[cfg] (sorry for the noob question)
T 1708471205 18<20jbg18>	you can't impl From
T 1708471216 18<20jbg18>	to impl a trait either the trait or the type must be local to your crate
T 1708471220 18<20jbg18>	(that's the short version)
T 1708471241 18<20jbg18>	look up "rust orphan rule" for the long version
T 1708471269 18<20jbg18>	so you can write a trait FromPointerWidth {} and impl that for u64 but you can't impl From for u64
T 1708471323 18<20jbg18>	similarly, you could make a wrapper, struct MyU64(u64); and then impl From<usize> for that
T 1708471325 18<19turlando18>	Oh, right, that's similar to how typeclass instances must be implemented
T 1708473217 19*	Now talking on 22##rust
T 1708473217 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708473217 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708484467 18<25Mikachu18>	https://github.com/Speykious/cve-rs
T 1708485262 18<26daddy18>	so glad i figured out what GLWTSPL was on first guess
T 1708487699 18<25Diablo-D318>	https://github.com/Speykious/cve-rs
T 1708487703 18<25Diablo-D318>	but why
T 1708488258 18<25Mikachu18>	i guess they got tired of the bug going unfixed for 6 years so they made some proofs of concept?
T 1708489733 18<26danieldg18>	they could at least expand that to use any of the other unsoundness bugs
T 1708489778 18<26danieldg18>	there are a few more to choose from afaik - typeid hash collisions are the one I recall offhand
T 1708490360 18<29phy172918>	Should have come up with a catchy name if they really wanted it fix. Unsafe at any lifetime is my terrible stab at it.
T 1708492647 18<25Widdershins18>	looking forward to the new trait solver tho...
T 1708492664 18<25Widdershins18>	i have some gripes with the way this one works
T 1708494015 18<25Mutabah18>	So do I... grumble grumble accepting tautalogical bounds
T 1708494045 18<25Mutabah18>	I've spent the two weeks thinking through/experimenting with a mrustc issue related to a crate having a tautalogical trait bound.
T 1708494092 18<25Mutabah18>	`S: SomeTrait, &S: SomeTrait<Assoc=S::Assoc>`, but there's a blanket `impl<S: SomeTrait> SomeTrait for &S { type Assoc = S::Assoc; }`
T 1708496203 18<26dav1d18>	turlando, or instead of converting u64 to usize, you convert usize to u64 which even works on 32bit platforms
T 1708498539 18<22davros118>	Any interesting features on the horizon in Rust .. have been obsessed with AI for a while and not keeping track of the language changes
T 1708498560 18<22davros118>	I remember a problem stopping nested 'From' impl
T 1708498573 18<22davros118>	Which might have needed a workaround like negative impl's or something
T 1708498581 18<22davros118>	Negative trait bounds (I forget)
T 1708501889 18<25bertptrs18>	negative trait bounds aren't on the way AFAIK, and the last release was a bit quiet, but before that we got async in traits and RPITIT which I find a hilarious acronym but also very useful
T 1708503065 18<24Bish18>	if a method returns a reference and i want to match it, why do i have to match with a reference? isnt this especially confusing with @str?
T 1708503071 18<24Bish18>	&str*
T 1708503080 18<24Bish18>	i am guessing it's a special case there?
T 1708503117 18<24Bish18>	https://github.com/hyperium/hyper/blob/00a703a9ef268266f8a8f78540253cbb2dcc6a55/examples/echo.rs#L24 for example this
T 1708503208 18<25Mutabah18>	You match a reference with a reference, that's how matching works
T 1708503217 18<25Mutabah18>	although, "match ergonomics" sometimes hides it
T 1708503233 18<25Mutabah18>	string literals are of type `&str`, so they match against a `&str`
T 1708503321 18<24Bish18>	what if i have 2 equal objects but they're duplicates
T 1708503328 18<24Bish18>	what happens if i match their references?
T 1708503363 18<24Bish18>	i guess the (Partial)Eq trait's == will get called and it can be whatever?
T 1708503377 18<25Mutabah18>	No, matching destructures to compare
T 1708503390 18<25Mutabah18>	and you can't match against a variable
T 1708503508 18<24Bish18>	hm confusing
T 1708503552 18<20jbg18>	how so?
T 1708503577 18<24Bish18>	i don't understand if that's a pointer comparison now
T 1708503589 18<20jbg18>	there is no comparison as such
T 1708503590 18<24Bish18>	or thje contents of the referenced object will be compared
T 1708503594 18<20jbg18>	not in the sense you are thinking
T 1708503595 18<20jbg18>	the left hand side of a match is a pattern, ideally one of the first concepts you learn in rust
T 1708503616 18<20jbg18>	names in there are new bindings, not the names of existing variables to compare to
T 1708503625 18<20jbg18>	you have other tools for that, like `if a == b`
T 1708503632 18<24Bish18>	so the compiler just compares the names, a constant struct in this case
T 1708503655 18<20jbg18>	you're matching structure -- types -- not content
T 1708503665 18<24Bish18>	ah okay
T 1708503677 18<20jbg18>	the book chapter on patterns is instructive here
T 1708503684 18<24Bish18>	but for &str that's special
T 1708503686 18<20jbg18>	https://doc.rust-lang.org/book/ch18-00-patterns.html
T 1708503688 18<25Mutabah18>	`match foo { bar => ... }` just defines `bar` as a variable with the same value as `foo`
T 1708503713 18<25Mutabah18>	`match foo { path::to::BAR => ... }` only works if `BAR` is a `const`, and it compares the contents (not using `==`)
T 1708503721 18<20jbg18>	Bish: any literals can be used in match
T 1708503729 18<20jbg18>	(as well as constants)
T 1708503782 18<20jbg18>	it's not that it's special for &str as such, but special for string literals. `match foo { bar => ... }` in Mutabah's example is still the same if foo is a &str
T 1708503826 18<20jbg18>	but `match foo { "bar" => ... }` will only compile if foo is a &str and will execute that arm only if it is "bar"
T 1708503861 18<25bertptrs18>	Bish: refererences compare by contents, pointers compare by address. This is also documented as such https://doc.rust-lang.org/std/primitive.reference.html
T 1708504181 18<24Bish18>	> Reference equality by address, instead of comparing the values pointed to
T 1708504215 18<24Bish18>	isn't that the opposite of "refererences compare by contents"
T 1708504246 18<25Mutabah18>	Did you read the rest of that sentence?
T 1708504261 18<25Mutabah18>	> is accomplished via implicit reference-pointer coercion and raw pointer equality via ptr::eq, while PartialEq compares values.
T 1708504279 18<24Bish18>	yeah i don't see where that dereferences
T 1708504285 18<24Bish18>	it sounds like pointer get compared
T 1708504294 18<24Bish18>	to me that is
T 1708504307 18<25Mutabah18>	It's saying that to compare two references by address you use `std::ptr::eq(ref1, ref2)`
T 1708504325 18<25Mutabah18>	(which will coerce `&T` to `*const T` then compare the two `*const T`s - comparing the addresses)
T 1708504364 18<24Bish18>	oh yeah i misread that sentence
T 1708504567 18<24Bish18>	so matching with (&Method::GET, "/test") will call .eq of both of them, right?
T 1708504583 18<24Bish18>	there i no pattern matching happening except for the tuple maybe
T 1708504653 18<28erk18>	Mutabah: To compare by address you actually don't want std::ptr::eq, you instead want the newly added std::ptr::addr_eq
T 1708504675 18<28erk18>	Otherwise it will use some fat pointer information that can give strange results.
T 1708504693 18<25Mutabah18>	erk: I was quoting docs
T 1708504838 18<24Bish18>	so match will pattern match and call .eq() for concrete types?
T 1708504856 18<24Bish18>	conrecte values*
T 1708504916 18<25Mutabah18>	It doesn't use `.eq`... it just uses primitive comparisons
T 1708505005 18<24Bish18>	so it uses.. == ?
T 1708505019 18<24Bish18>	what would i use to emulate match
T 1708505093 18<25Mutabah18>	it uses `==` and `memcmp` - match is a low-level language construct, so expands to some very low level things
T 1708505215 18<24Bish18>	when is == equal to .eq() if there is no primitive comparision?
T 1708505245 18<24Bish18>	Mutabah: wouldn't that mean i coulnd't compare something that is not copy?
T 1708505275 18<25Mutabah18>	if you write `foo == bar` then the `PartialEq::eq` trait method is invoked... unless it's a primitive integer/bool/float type, which the compiler already inherently knows how to equate
T 1708505297 18<25Mutabah18>	Maybe you should play around with `match` and read the book/reference on how it works
T 1708505346 18<24Bish18>	well, i don't feel like it helps me understanding how it operates, but i will try
T 1708505371 18<25Mutabah18>	Or, if you're brave - you could attempt to understand the mrustc `match` lowering code :)
T 1708505496 18<24Bish18>	i was hoping there is a simple explanation for example it just being .eq()
T 1708505541 18<25Mutabah18>	pattern matching is destructuring until it finds a pattern that doesn't destructure (i.e. a literal)
T 1708505542 18<24Bish18>	i compiled & looking at the assembler of something already and it seems to call into partialeq for &str
T 1708505623 18<24Bish18>	but for u32 it creates code on the spot
T 1708505645 18<24Bish18>	but i feel like that would happen if i did it without match as well
T 1708505756 18<24Bish18>	so match does many things. not a single thing.. okay
T 1708505959 18<25Mutabah18>	It does a LOT of things
T 1708505974 18<25Mutabah18>	for context - mrustc's match lowering code is larger than the rest of MIR lowering
T 1708506072 18<24Bish18>	why does that exist.. :o
T 1708506082 18<24Bish18>	is it the first rust compiler? because it says reimplementation
T 1708506139 18<25Mutabah18>	It's not the first, it's my project (hence why I know it's internals) to create a bootstrapping rust compiler
T 1708506157 18<25Mutabah18>	`match` is complex and powerful
T 1708506178 18<24Bish18>	why did you do this project?
T 1708506256 18<25Mutabah18>	fun?
T 1708506268 18<24Bish18>	i can get behind that
T 1708506303 18<25Widdershins18>	i am currently also doing a fun project (writing like 11 thousand words of documentation for a personal project for some reason)
T 1708506350 18<24Bish18>	i bet most people would disagree with your definitions of fun
T 1708507893 19*	Now talking on 22##rust
T 1708507893 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708507893 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708508320 19*	Now talking on 22##rust
T 1708508320 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708508320 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708509558 18<24Bish18>	Mutabah: why wouldn't i read up rustcs code
T 1708509558 18*	25Mutabah is away (not here ...)
T 1708509567 18<24Bish18>	would you say that's even more daunting?
T 1708510180 18<25bertptrs18>	Widdershins: can I dm you about something?
T 1708511178 18<25Mutabah18>	Bish: You could, I just don't know exactly where it is or how it looks (the `match` impl)
T 1708511505 18<20j`ey18>	Mutabah: so you didnt start mrustc by running rust2c on rustc?
T 1708511507 18<20j`ey18>	:p
T 1708511905 18<25Mutabah18>	j`ey: Well... strictly speaking that was what mrustc started out as - convert AST to C
T 1708511932 18<25Mutabah18>	but by the time I got anywhere near close to codegen, that was gone and C was backend
T 1708512353 18<25Widdershins18>	bertptrs: what's up
T 1708515686 18<24Bish18>	im still on my http2 streaming bodies adventure
T 1708515714 18<24Bish18>	https://bpa.st/5QQA but im stuck on e=hyper::Error(User(ManualUpgrade))
T 1708515731 18<24Bish18>	if someone knows whats going on it'd be cool
T 1708515783 18<24Bish18>	(specificially the websocket route, the rest works)
T 1708515985 18<24Bish18>	https://github.com/hyperium/hyper/blob/00a703a9ef268266f8a8f78540253cbb2dcc6a55/src/upgrade.rs#L264 https://github.com/hyperium/hyper/blob/00a703a9ef268266f8a8f78540253cbb2dcc6a55/src/server/conn/http1.rs#L220 this seems to be the "callstack" on that error
T 1708516127 18<24Bish18>	fuck me, im so stupid
T 1708516133 18<24Bish18>	rubber ducky best method
T 1708530419 19*	Now talking on 22##rust
T 1708530419 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708530419 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708531929 18<22bombastick18>	Hi
T 1708532597 18<22Aorimn18>	hi, what would be the most idiomatic way of converting a [u8; 6] to a [u8; 8] by adding zeroes to the end of it (so that I can u64::from_le_bytes() it afterward)?
T 1708532623 18<22Aorimn18>	the only solution I can think of is copying the bytes in a loop, but that doesn't sound nice
T 1708532635 18<22bombastick18>	what % of you use Rust for work as your primary language, as opposed to hobbyist?
T 1708532662 18<22Aorimn18>	I have this 6 size because I'm reading (impl Read) those 6 bytes
T 1708532692 18<25bertptrs18>	let mut dest = [0u8; 8]; reader.read(&mut dest[..6])?
T 1708532827 18<22Aorimn18>	ah... that's even better indeed ^^'   thanks bertptrs!
T 1708532851 18<25bertptrs18>	err, read_exact of course
T 1708532857 18<25bertptrs18>	close enough
T 1708532894 18<22Aorimn18>	yeah, I managed to make the translation :)
T 1708532895 18<25bertptrs18>	ideally the compiler realizes that it doesn't have to zero initialize the first 6 bytes but if not it's just six bytes, how hard can it be
T 1708532961 18<22Aorimn18>	in this case I'm not too strict on performances, I'll code the feature before looking at such issues (not even sure it'll be in a hot path at this point)
T 1708533058 18<25bertptrs18>	good decision
T 1708541622 18<19flipchan18>	im trying to print some ascii art, does anyone know any crates that lets you autoscale a string based on terminal size?
T 1708541646 18<19flipchan18>	I'm trying to scale the ascii art based on terminal size so it will work on all terminal sizes
T 1708541682 18<26danieldg18>	look for wrappers around ncurses or just access to termios in general to get the size
T 1708541685 18<25bertptrs18>	terminal_size and then wrap it yourself?
T 1708541688 18<25bertptrs18>	that's what clap does
T 1708541692 18<29alip18>	BufRead::lines() will OOM when you hand it /dev/zero, bug or feature?
T 1708541708 18<26danieldg18>	alip: working as intended
T 1708541718 18<29alip18>	nice
T 1708541725 18<25bertptrs18>	alip: you made it read until the end of the line, when there was no end of the line
T 1708541728 18<25bertptrs18>	what did you expect?
T 1708541734 18<26danieldg18>	alip: just like loop { vec.push(0) } OOMs
T 1708541740 18<29alip18>	i expected no newline found in LINE_MAX bytes with ENAMETOOLONG
T 1708541748 18<29alip18>	and hence i implemented it myself
T 1708541753 18<29alip18>	never trust rust stdlib lol
T 1708541780 18<26danieldg18>	LINE_MAX? is that the thing that gets() uses, but only if on a TTY?
T 1708541798 18<29alip18>	no line_max is just a random big number doesn't matter what
T 1708541806 18<29alip18>	friends don't oom on each other
T 1708541815 18<26danieldg18>	it'll never be big enough
T 1708541825 18<29alip18>	the alternative is far worse
T 1708541841 18<25bertptrs18>	going OOM on infinite input isn't that bad
T 1708541847 18<26danieldg18>	I want to read json-lines files with .lines() and have json blobs not be limited to a few MB
T 1708541864 18<29alip18>	i can see why the never big enough argument is logical
T 1708541866 18<25bertptrs18>	arbitrarily splitting lines after so many characters is bound to lead to weird surprises
T 1708541874 18<29alip18>	but then i'd at least expect a warning in lines() docs about this
T 1708541894 18<26danieldg18>	alip: the lack of a LINES_MAX reference *is* the warning
T 1708541905 18<29alip18>	nice
T 1708541912 18<29alip18>	never trust the stdlib docs
T 1708541931 18<26danieldg18>	if that's how you define trust...
T 1708541953 18<29alip18>	you say the lack of stating a limit is good enough for the code ooming on you
T 1708541958 18<29alip18>	and yes, that's how i define trust
T 1708541964 18<25bertptrs18>	code OOM'ing is safe behaviour
T 1708541970 18<29alip18>	mmph ofc it is
T 1708541972 18<29alip18>	ok nvm
T 1708541979 18<25bertptrs18>	as opposed to the alternatives it is
T 1708541985 18<26danieldg18>	you could just as easily call it an OS bug
T 1708541997 18<25bertptrs18>	BufRead::lines() has issues but this is not (imo) one of them
T 1708542021 18<26danieldg18>	/dev/zero should stop after you've read too much data
T 1708542035 18<26danieldg18>	maybe prompt you to be sure you want to read that much
T 1708542035 18<25bertptrs18>	I'd much prefer an API where you can hand out your own buffer
T 1708542039 18<25bertptrs18>	alas
T 1708542049 18<25bertptrs18>	(yes there's read_line but that's not an iterator)
T 1708542050 18<29alip18>	ye that'd solve it too bertptrs
T 1708542069 18<29alip18>	danieldg: c'mon now you're just being ridicilous
T 1708542092 18<29alip18>	it just means calling lines() in the wrong context may mean DOS
T 1708542103 18<29alip18>	and documenting that is nice and kind
T 1708542105 18<29alip18>	ofc it's safe
T 1708542149 18<26danieldg18>	calling any read function can mean dos if you don't put limiters on it
T 1708542162 18<26danieldg18>	lines() doesn't work well with nonblocking after all
T 1708542182 18<19int-e18>	danieldg: so my takeaway from that talk is that I'm not the first one to be surprised by Linux's madvise semantics ;-)
T 1708544281 19*	Now talking on 22##rust
T 1708544281 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708544281 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708545260 18<20capitol18>	I have this idea of a new clippy lint, maybe of the pedantic type. One way to make your code be non-portable to 32-bit arches is to write something like: let foo : usize = 4294967295;
T 1708545286 18<20capitol18>	and this feels like it would be nice to have a warning about
T 1708545416 18<20j`ey18>	you can just try compile for 32 bits :P
T 1708545424 18<26danieldg18>	how pedantic should it be?  Rust tries to be able to run with 16-bit usize too
T 1708545449 18<26danieldg18>	but there's a lot of code that wants more than 64K for things
T 1708545488 18<26danieldg18>	it's not too uncommon to want a vec![0;1<<20] as a buffer (1MB)
T 1708545642 18<20capitol18>	yeah, the 16 bit one should maybe be it's own lint, so that it would be able to enable just the ones that you support
T 1708545672 18<26danieldg18>	also, anything over 1<<31 in a usize will start to cause problems on 32-bit
T 1708545679 18<26danieldg18>	over or equal to
T 1708545692 18<20capitol18>	j`ey: true, this is more so that I hopefully don't have to send to many patches to other projects when I package for debian :)
T 1708545716 18<20capitol18>	yes
T 1708546644 18<28Vorpal18>	Hm I have a crate that can have multiple backends (for talking to distro package managers, different ones for different Linux distros). You can build with support for multiple. But if I disable all features it doesn't work, due to empty enums and the like. Which is a problem for publishing the crate. What is the recommended approach for this. I don't think it makes sense to set any specific distro backend as a default feature either.
T 1708546653 18<28Vorpal18>	The issue is enums like this one: https://0x0.st/H5bj.txt
T 1708546680 18<20j`ey18>	whats the issue with an empty enum?
T 1708546702 18<28Vorpal18>	j`ey: well match statements on those (with similar cfg directives) doesn't work when the body of the match statement becomes empty
T 1708546703 18<20j`ey18>	empty enums are fine in general
T 1708546708 18<28Vorpal18>	error[E0004]: non-exhaustive patterns: type `&config::Backend` is non-empty
T 1708546727 18<20j`ey18>	can you paste the code that fails
T 1708546732 18<20j`ey18>	 / full error
T 1708546740 18<28Vorpal18>	one second
T 1708546762 18<20j`ey18>	https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=6ed4245c28a8728d6edc7c355c313087
T 1708546848 18<26danieldg18>	depending on what you actually need, you could just add a 'not implemented' backend that is always available.  But yes, this should work already.
T 1708546849 18<28Vorpal18>	https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=3bd573a790b0fcaad5bff662d8b9e77d
T 1708546852 18<22Arnavion18>	Publishing shouldn't be a problem. You can do `--features` with `cargo publish`
T 1708546870 18<28Vorpal18>	ah, the issue seems to be the reference
T 1708546870 18<22Arnavion18>	so you can pick one or all of them just to satisfy `cargo publish`
T 1708546877 18<20j`ey18>	ah right
T 1708546897 18<26danieldg18>	wait, references are always inhabited now?  When did this happen?
T 1708546907 18<28Vorpal18>	hm for this enum it works, I have another one (different file checksums) where it will be trickier since it isn't copy
T 1708546931 18<20j`ey18>	danieldg: wasnt that always the case??
T 1708546953 18<26danieldg18>	j`ey: pretty sure you used to be able to match reference {}
T 1708546954 18<20j`ey18>	Vorpal: I think danieldg's suggestion of a NullBackend is probably the easiest.. maybe
T 1708546989 18<26danieldg18>	I think I used it in some Infallible impls
T 1708547008 18<28Vorpal18>	j`ey: for backend I don't need the reference (payload-less enum, Copy). For https://0x0.st/H5b2.txt I have a very similar situation, there I don't want to copy, so that will be trickier
T 1708547021 18<20j`ey18>	danieldg: same error on 1.18
T 1708547034 18<26danieldg18>	j`ey: ahh, "match *self" works
T 1708547040 18<26danieldg18>	Vorpal: you could use that
T 1708547064 18<28Vorpal18>	danieldg: won't that result in a copy though? For the second case.
T 1708547073 18<28Vorpal18>	(that is https://0x0.st/H5b2.txt )
T 1708547088 18<22Arnavion18>	Just do `--features` instead of adding a fake backend or changing your code...
T 1708547090 18<26danieldg18>	you can start throwing in ref in your match arms
T 1708547101 18<28Vorpal18>	Arnavion: yeah probably the right choice
T 1708547106 18<26danieldg18>	it will not force a copy
T 1708547126 18<28Vorpal18>	or that, that works too
T 1708547184 18<26danieldg18>	I suppose I wrote the Infallible matches prior to match ergonomics and didn't notice they used *
T 1708547261 18<28Vorpal18>	Arnavion: actually, right now --features work, but I plan to add other packages and data source types (flatpak, snap, rpm, tmpfiles.d) not all of them have all info on installed files, not all of them have info on installed packages, Some have both, some have either or. So I believe I could end up in a similar situation if I only build support for snap and flatpak say (no need to depend on any checksum library for those)
T 1708547289 18<28Vorpal18>	So I'm going with ref
T 1708547371 18<28Vorpal18>	still end up with a bunch of warnings though for --no-default-features (variable don't need to be mutable, unused variants, etc). Oh well. I think I'll live with that.
T 1708547446 18<20j`ey18>	you could also just explicitly fail to compile with no backend selected
T 1708547528 18<28Vorpal18>	I could yes, might make sense to tell any users other than me how to use it properly.
T 1708548459 18<22Arnavion18>	Vorpal:   https://github.com/Arnavion/k8s-openapi/blob/master/build.rs#L9-L60   If you need inspiration
T 1708548524 18<28Vorpal18>	#[cfg(not(any(feature = "arch_linux", feature = "debian")))] compile_error!("At least one backend must be enabled");
T 1708548534 18<28Vorpal18>	seems simpler
T 1708548603 18<28Vorpal18>	no need to add a build script if I don't need to
T 1708548619 18<22Arnavion18>	Yes, if it's just `any(feature, feature)` you can do it inline
T 1708548928 18<28Vorpal18>	well, I assume any takes any number of arguments, so I should be able to continue once I add more backends too
T 1708549040 18<22Arnavion18>	Yes
T 1708553966 19*	Now talking on 22##rust
T 1708553966 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708553966 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708554077 19*	Now talking on 22##rust
T 1708554077 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708554077 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708557493 18<26bwidawsk18>	I want to keep a hashmap where the values in the map are a hashable object. I don't care what the key will be, as it's an opaque handle that is used by the caller in the API. What is the best way to create unique keys to associate with the object? (I was thinking `hashmap.insert(object.hash(), object)`)
T 1708557514 18<26bwidawsk18>	(Could also use an atomic as an index ofc)
T 1708557576 18<22Arnavion18>	object.hash() is fine. To avoid double-hashing you can use something like   https://docs.rs/hash_hasher
T 1708557591 18<22Arnavion18>	or BTreeMap
T 1708557642 18<26bwidawsk18>	Arnavion: thank you
T 1708564558 18<26segfaultfizzbuzz18>	are there any good recommendations for how to store a secret string/token in a rust binary?
T 1708564607 18<26danieldg18>	either anywhere or nowhere
T 1708564615 18<26danieldg18>	anywhere if the binary can be a secret, nowhere if not
T 1708564788 18<26segfaultfizzbuzz18>	so a const String is about as good as it gets i guess?
T 1708564805 18<26segfaultfizzbuzz18>	i am aware of SGX but i can't do that unfortunately...
T 1708564835 18<26danieldg18>	yes, if you're not able to store it anywhere else secure either
T 1708564858 18<26danieldg18>	HSM, TPM, etc
T 1708564881 18<26segfaultfizzbuzz18>	so this isn't worthwhile for instance: https://crates.io/crates/secstr
T 1708564930 18<25Mutabah18>	that would help prevent runtime leaks
T 1708564976 18<25Mutabah18>	but the original secret will still be in the binary somewhere - you can obsfucate it, but that only adds a thin layer of protection
T 1708565007 18<26segfaultfizzbuzz18>	runtime leaks? on a related note, can unsafe code read/modify the program itself (which i suppose is in memory..?)  ?
T 1708565063 18<26segfaultfizzbuzz18>	secstr isn't stored on github, which is odd
T 1708565248 18<26danieldg18>	segfaultfizzbuzz: read, usually; modify, no, not unless it takes action to call mprotect
T 1708565290 18<26segfaultfizzbuzz18>	why wouldn't the operating system wall the program code off from the data ?
T 1708565308 18<26danieldg18>	most architectures don't support that
T 1708565326 18<26segfaultfizzbuzz18>	yipes
T 1708565347 18<25cehteh18>	moderm ones do, but ther are a zillion ways to circumvent it
T 1708565379 18<26danieldg18>	ASLR helps too
T 1708565396 18<26danieldg18>	but yeah, 'bypassing ASLR' is like 'hacking 102' these days
T 1708565425 18<25cehteh18>	x86-64 has write protection on executable pages
T 1708565440 18<26segfaultfizzbuzz18>	you would think that there would be read protection for those as well...
T 1708565446 18<26danieldg18>	yes - executable plages are *normally* write protected
T 1708565459 18<26danieldg18>	there's not normally a need or desire to read protect
T 1708565463 18<25cehteh18>	but a program could do all kinds of fancy stuff like creating a dynlib and loading that
T 1708565471 18<26segfaultfizzbuzz18>	...but why would you want to read at all?
T 1708565490 18<26danieldg18>	segfaultfizzbuzz: code and read-only data can share pages
T 1708565499 18<25cehteh18>	on linux you can do a lot protection with seccomp, but its not trivial
T 1708565504 18<26segfaultfizzbuzz18>	memory locality/speed then?
T 1708565518 18<26danieldg18>	seccomp doesn't help with read the executable
T 1708565534 18<26danieldg18>	you need less common things like memory protection keys
T 1708565547 18<25cehteh18>	yes but seccomp makes sure that a program cant m(un)protect pages it shouldn
T 1708565574 18<25cehteh18>	or load dynlibs and so on
T 1708565576 18<26danieldg18>	the memseal system calls are useful here too
T 1708565651 18<26segfaultfizzbuzz18>	darpa Measures for Establishment of Memory Signatures in Early Activated Lymphocytes
T 1708565709 18<26danieldg18>	no
T 1708565756 18<26danieldg18>	https://lwn.net/Articles/958438/
T 1708566272 18<26danieldg18>	basically a well-written program won't read from arbitrary memory addresses and so won't be a problem
T 1708566318 18<26danieldg18>	so just rely on that - rust doesn't let you bypass it without unsafe
T 1708566338 18<26segfaultfizzbuzz18>	right ok thanks
T 1708568561 18<25dkg18>	i'm struggling with Rust's C FFI: i'm building a shared object in Rust that exposes a function to the C ABI.  I want the external C code to be able to call the function with an argument that is a pointer to a fixed-length buffer of chars.  this argument, if non-null, will be used to return a limited-length, null-terminated error string if the function fails.
T 1708568615 18<25dkg18>	i'm having trouble with the typing for this buffer and how to get a Rust string error message to be written to it properly.
T 1708568623 18<26danieldg18>	*mut u8
T 1708568637 18<25Mutabah18>	By fixed-length, do you mean ABI/API specified, or is the length in another argument?
T 1708568649 18<25Mutabah18>	If it's the former - then `*mut [u8; 123]`
T 1708568660 18<25dkg18>	what i've got so far is:     #[repr(C)] pub struct foo_err_msg { message: [c_char; 128], }
T 1708568678 18<25dkg18>	the API specifies that the error buffer is always  a simple struct with 128 chars in it.
T 1708568700 18<25dkg18>	then the argument to the function is Option<&mut foo_err_msg>
T 1708568716 18<25Mutabah18>	that all seems reasonable
T 1708568726 18<25dkg18>	and i'll only write to it if let Some(err_out) = err_out
T 1708568739 18<25dkg18>	so the problem i'm having in the function is figuring out how to write to the buffer
T 1708568747 18<26danieldg18>	I'd use u8 and not c_char
T 1708568760 18<26danieldg18>	because rust prefers writing to u8
T 1708568778 18<26danieldg18>	and it's not like C actually cares if char is signed or not 99.9% of the time
T 1708568786 18<25dkg18>	hm, but in the C interface i'd prefer it is a char, because that's a clean hint to the C user that this will be a null-terminated string.
T 1708568803 18<25dkg18>	and if we're gonna get typing right, i kind of want to get it right :P
T 1708568817 18<26danieldg18>	here's a secret: char* and unsigned char* have the same ABI :)
T 1708568822 18<25dkg18>	but yeah, i'm seeing messgaes like: expected `[i8; 128]`, found `&[u8]`
T 1708568853 18<25dkg18>	i'm aware that they have the same ABI, i'm just trying to do this cleanly by respecting the type system and not tricking it :)
T 1708568854 18<26danieldg18>	yes, because rust wants to write to u8
T 1708568880 18<26danieldg18>	you can just impl std::io::Write for your struct foo_err_msg
T 1708568886 18<26danieldg18>	or fmt::Write, if you like
T 1708568905 18<26danieldg18>	copy the bytes one by one and cast them from u8 to i8
T 1708568946 18<25dkg18>	well, from u8 to std::ffi::c_char, since presumably different platforms have different c_chars -- they aren't all i8 :/
T 1708568958 18<26danieldg18>	yes
T 1708568961 18<25dkg18>	it happens to be i8 on my platform
T 1708568972 18<26danieldg18>	it's i8 or u8 basically everywhere
T 1708569003 18<25dkg18>	agreed
T 1708569005 18<26danieldg18>	only systems that aren't byte-addressible can get away with char not being a byte
T 1708569051 18<25dkg18>	but again, i'm trying to do clean typing without assumptions; that's one of the things i find compelling about Rust.  maybe i'm being too much of a purist
T 1708569095 18<26danieldg18>	your cast can be char, yes
T 1708569100 18<25dkg18>	so even if i switch to u8 instead of std::ffi::c_char, i get: expected `[u8; 128]`, found `&[u8]`
T 1708569113 18<25dkg18>	how do i deal with the length limit safely?
T 1708569123 18<26danieldg18>	you use a ref?
T 1708569124 18<25dkg18>	sorry if this is a n00b question, i'm a n00b 😛
T 1708569141 18<25Mutabah18>	you want .copy_from_slice
T 1708569151 18<25Mutabah18>	which might also require slicing the destination to the right length
T 1708569155 18<25dkg18>	yes, i'm using Option<&mut foo_err_msg>  and i'm in the case where "if let Some(err_msg) = err_msg {"
T 1708569170 18<25Mutabah18>	Or, a custom loop that writes into the destination and ensures that it's NUL terminated
T 1708569190 18<25dkg18>	i was hoping to use something like CString.as_bytes_with_nul()
T 1708569199 18<25dkg18>	so that i don't have to write any custom byte-level loops
T 1708569221 18<26danieldg18>	you'll still have to copy the memory from the CString to the output
T 1708569226 18<25dkg18>	agreed.
T 1708569231 18<25dkg18>	(fwiw, i'm jumping through these hoops to try to avoid any memory allocations across the FFI)
T 1708569232 18<26danieldg18>	but that could be with copy_from_slice
T 1708569258 18<26danieldg18>	writing to the destination buffer in-place is "nicer"
T 1708569275 18<26danieldg18>	vs writing to a String, converting to CString, then copying
T 1708569285 18<25dkg18>	i agree, it does seem cleaner to write to the destination buffer in place
T 1708569322 18<25dkg18>	but i don't know how to do that :/  and, in some cases, i'll have an Err that i want to extract a (potentially truncated) message from and copy it in
T 1708569403 18<26danieldg18>	dkg: struct Writer { buf: &mut [c_char] }  impl Writer { fn new(buf:&mut [c_char;128]) -> Self { Self { buf }}} impl std::fmt::Write for Writer { ...
T 1708569453 18<26danieldg18>	you can maintain the null-termination invariant as you write, or do it in Drop
T 1708569521 18<26danieldg18>	write_str is where you put either your u8->c_char loop, or a copy_from_slice if you decide to use u8 not c_char
T 1708569538 18<26danieldg18>	then you can call write!() on your Writer
T 1708569590 18<26danieldg18>	write_str should advance self.buf - that's why it uses a slice, not an array
T 1708569608 18<25dkg18>	thanks!  still trying to wrap my head around this…  i need a new struct to do this?  or i put this impl on my foo_err_msg ?
T 1708569616 18<26danieldg18>	new struct
T 1708569645 18<26danieldg18>	it has to track the 'cursor'
T 1708569700 18<25dkg18>	i see, the Writer struct is just the cursor tracker
T 1708569763 18<25dkg18>	ok, you've given me enough to chew on, i'll try to sort it out further.  thanks!  i thought this would be a bit simpler than it is turning out to be :/
T 1708570098 18<26danieldg18>	the simple way is to use the existing io::Write impl for &mut [u8]
T 1708570149 18<26danieldg18>	you can cast a &mut [u8;128] to a &mut [u8] and then write to it
T 1708570211 18<26danieldg18>	or even the one for Cursor<[u8;N]>
T 1708570240 18<26danieldg18>	I just noticed that one, it's nicer for this case
T 1708590780 18<24SiegeLord18>	Lets say I have a trait: `trait Foo { fn call(&self, ctx: impl Context) -> (); }`, is there a way to automatically implement it for functions with the same signature as the `call` associated function?
T 1708590803 18<24SiegeLord18>	Like a `fn foo(ctx: impl Context) -> () {}`
T 1708590831 18<25bertptrs18>	Sort of
T 1708591029 18<24SiegeLord18>	The final goal is to somehow write: `fn bar(call: impl Fn(impl Context) -> ()`
T 1708591048 18<24SiegeLord18>	Which isn't possible, so I'm attempting to write `fn bar(call: impl Foo)`
T 1708591062 18<24SiegeLord18>	But I want to do something approximating `bar(foo)`
T 1708591143 18<24SiegeLord18>	It's clear that I can, for every `foo`, write a manual implementation for some dummy type `F`, but I wonder if there's something with less boilerplate
T 1708591158 18<24SiegeLord18>	manual implementation of `Foo`
T 1708591211 18<25bertptrs18>	Ah I see, the problem is that you cannot have "impl Trait" in a trait bound
T 1708591223 18<25bertptrs18>	so my idea doesn't work https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=77a5b8655b47befd6cae887993bf6250
T 1708591272 18<25bertptrs18>	The double generics make it hard
T 1708591303 18<24SiegeLord18>	I think this is a type of HKT, so perhaps something using GATs could be a solution, but that's as far as that line of thought goes
T 1708591331 18<25bertptrs18>	I don't think you can express this particular thing yet. Which is sad, it's not an unreasonable question
T 1708591360 18<25bertptrs18>	If you can tweak the Foo trait a little it might work
T 1708591395 18<24SiegeLord18>	I can, it's something I fully control.
T 1708591409 18<25bertptrs18>	https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=27e2d1dc09c79939e69c9a917784863f
T 1708592096 18<24SiegeLord18>	Ah, that won't work. Here's the version with the dummy type, perhaps clarifying the design goals: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=3d7636e6c165af5ad4b5d0e12dad864d
T 1708597392 18<27sword_smith18>	Is a (u64,u64)->u128 multiplication as fast on my x86-64 machine as a (u32,u32)->u64 multiplication?
T 1708597537 18<25Mutabah18>	probably pretty close on its own...
T 1708597546 18<25Mutabah18>	but more data takes longer to load/manipulate
T 1708597632 18<28Norkle18>	hi
T 1708597687 18<25Mutabah18>	Hello.
T 1708597696 18<25Mutabah18>	Interesting hostname you have there
T 1708598605 18<29saati18>	sword_smith: on most cpus multiplication takes variable time determined by it's inputs
T 1708598631 18<29saati18>	bigger numbers can take a couple more cycles
T 1708598697 18<29saati18>	iirc zen4 has const time multiplication
T 1708598748 18<25Mutabah18>	saati: eeeh... multiplication units can be done in constant time based on the bit size
T 1708598778 18<25Mutabah18>	shift+add for each bit in the other number
T 1708599006 18<29saati18>	let's benchmark
T 1708599261 18<27sword_smith18>	saati: Thanks. I have a benchmark here, but it does some annoying addition, that I would like to remove: use std::ptr;
T 1708599264 18<27sword_smith18>	use criterion::measurement::WallTime;
T 1708599266 18<27sword_smith18>	use criterion::{
T 1708599269 18<27sword_smith18>	    criterion_group, criterion_main, BenchmarkGroup, BenchmarkId, Criterion, Throughput,
T 1708599272 18<27sword_smith18>	};
T 1708599274 18<27sword_smith18>	use twenty_first::shared_math::other::random_elements;
T 1708599277 18<27sword_smith18>	fn mul(c: &mut Criterion) {
T 1708599279 18<27sword_smith18>	    let mut group = c.benchmark_group("mul");
T 1708599282 18<27sword_smith18>	    let log2_of_sizes: Vec<usize> = vec![3, 7, 12, 18, 23];
T 1708599284 18<27sword_smith18>	    // Benchmarking forward ntt on BFieldElements
T 1708599287 18<27sword_smith18>	    for log2_of_size in log2_of_sizes.iter() {
T 1708599289 18<27sword_smith18>	        u32_mul(
T 1708599292 18<27sword_smith18>	            &mut group,
T 1708599294 18<27sword_smith18>	            BenchmarkId::new("(u32,u32)->u64", log2_of_size),
T 1708599297 18<27sword_smith18>	            *log2_of_size,
T 1708599299 18<27sword_smith18>	        );
T 1708599302 18<27sword_smith18>	    }
T 1708599304 18<27sword_smith18>	    for log2_of_size in log2_of_sizes.iter() {
T 1708599307 18<27sword_smith18>	        u64_mul(
T 1708599309 18<27sword_smith18>	            &mut group,
T 1708599312 18<27sword_smith18>	            BenchmarkId::new("(u64,u64)->u128", log2_of_size),
T 1708599313 18<20j`ey18>	um
T 1708599315 18<27sword_smith18>	            *log2_of_size,
T 1708599317 18<27sword_smith18>	        );
T 1708599320 18<27sword_smith18>	    }
T 1708599322 18<27sword_smith18>	    group.finish();
T 1708599325 18<27sword_smith18>	}
T 1708599327 18<27sword_smith18>	fn u32_mul(group: &mut BenchmarkGroup<WallTime>, bench_id: BenchmarkId, log2_of_size: usize) {
T 1708599330 18<27sword_smith18>	    let size: usize = 1 << log2_of_size;
T 1708599333 18<27sword_smith18>	    let xs: Vec<u32> = random_elements(size);
T 1708599335 18<27sword_smith18>	    group.throughput(Throughput::Elements(size as u64));
T 1708599338 18<27sword_smith18>	    group.bench_with_input(bench_id, &size, |b, _| {
T 1708599340 18<27sword_smith18>	        b.iter(|| {
T 1708599343 18<27sword_smith18>	            let mut acc = 0u64;
T 1708599345 18<27sword_smith18>	            for i in 0..(size - 1) {
T 1708599348 18<27sword_smith18>	                acc = acc.wrapping_add(xs[i] as u64 * xs[i + 1] as u64);
T 1708599350 18<27sword_smith18>	            }
T 1708599353 18<27sword_smith18>	            // Prevent the compiler from optimizing the loop away
T 1708599355 18<27sword_smith18>	            unsafe {
T 1708599358 18<27sword_smith18>	                ptr::write_volatile(&mut acc as *mut u64, acc);
T 1708599360 18<27sword_smith18>	            }
T 1708599363 18<27sword_smith18>	        })
T 1708599365 18<27sword_smith18>	    });
T 1708599368 18<27sword_smith18>	    group.sample_size(10);
T 1708599370 18<27sword_smith18>	}
T 1708599373 18<27sword_smith18>	fn u64_mul(group: &mut BenchmarkGroup<WallTime>, bench_id: BenchmarkId, log2_of_size: usize) {
T 1708599376 18<27sword_smith18>	    let size: usize = 1 << log2_of_size;
T 1708599378 18<27sword_smith18>	    let xs: Vec<u64> = random_elements(size);
T 1708599381 18<27sword_smith18>	    group.throughput(Throughput::Elements(size as u64));
T 1708599383 18<27sword_smith18>	    group.bench_with_input(bench_id, &size, |b, _| {
T 1708599386 18<27sword_smith18>	        b.iter(|| {
T 1708599388 18<27sword_smith18>	            let mut acc = 0u128;
T 1708599391 18<27sword_smith18>	            for i in 0..(size - 1) {
T 1708599393 18<27sword_smith18>	                acc = acc.wrapping_add(xs[i] as u128 * xs[i + 1] as u128);
T 1708599396 18<27sword_smith18>	            }
T 1708599398 18<27sword_smith18>	            // Prevent the compiler from optimizing the loop away
T 1708599400 18<20j`ey18>	bertptrs:
T 1708599401 18<27sword_smith18>	            unsafe {
T 1708599403 18<27sword_smith18>	                ptr::write_volatile(&mut acc as *mut u128, acc);
T 1708599406 18<27sword_smith18>	            }
T 1708599408 18<27sword_smith18>	        })
T 1708599411 18<27sword_smith18>	    });
T 1708599413 18<27sword_smith18>	    group.sample_size(10);
T 1708599416 18<27sword_smith18>	}
T 1708599418 18<27sword_smith18>	criterion_group!(benches, mul);
T 1708599421 18<27sword_smith18>	criterion_main!(benches);
T 1708599423 18<27sword_smith18>	fucking hell
T 1708599426 18<27sword_smith18>	sorry
T 1708599428 18<27sword_smith18>	I meant to copy-paste this: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021
T 1708599429 18<27Affliction18>	https://play.rust-lang.org/?version=stable&mode=debug&edition=2021 for code pastes; doing it that way results in you sending 1 message per second. And that is generally annoying.
T 1708599431 18<27sword_smith18>	yeah .. sorry guys. Didn't mean to spam. `irssi` warned me about 75 lines, but the command to go ahead is the command I use to delete my input (ctrl+a, ctrl+k).
T 1708599443 18<20j`ey18>	sword_smith: imagine if you accidentally pasted the same thing again lol
T 1708599483 18<27Affliction18>	nice how my message lined up with the very end, heh.
T 1708599483 18<25bertptrs18>	sword_smith: can you not do that again
T 1708599485 18<27sword_smith18>	My IRC client *should* make it harder to SPAM, imo.
T 1708599496 18<27sword_smith18>	Yes, I'm blaming my software, partially.
T 1708599499 18<20j`ey18>	bertptrs: ban him!!!
T 1708599514 18<25bertptrs18>	I think the youth of today would call it a skill issue
T 1708599524 18<25bertptrs18>	j`ey: accidents happen, let it slide
T 1708599528 18<27sword_smith18>	j`ey: Watch out with irony on text :)
T 1708599532 18<27Affliction18>	Anyway, you pasted a link to the empty playground; hit share and "permalink"
T 1708599543 18<20j`ey18>	sword_smith: I was hoping the multiple !! was enough :P
T 1708599561 18<27sword_smith18>	saati: Here's the benchmark I've written: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=d52ce86b44e054533e003e8440ed8ec0
T 1708599631 18<25Widdershins18>	sword_smith: what did you want to remove
T 1708599644 18<25bertptrs18>	j`ey: the double ping cancels out the exclamation marks
T 1708599668 18<25Widdershins18>	the exclamation marks cast your sarcasm to boolean
T 1708599673 18<20j`ey18>	bertptrs: oh true, my bad
T 1708599703 18<27sword_smith18>	saati: But my benchmark includes some summation, that I would like to avoid. The compiler is quick optimize away unused results though.
T 1708599738 18<24Bish18>	how many people here are fulltime rusters (getting paid for it)
T 1708599746 18<25Widdershins18>	you mean your volatile thing you're doing to force the loop not to optimize?
T 1708599748 18<27sword_smith18>	The benchmark I've written *almost* achieves what I want. And does run faster for (u32,u32)->u64 mul than for u64->u128 mul.
T 1708599777 18<25Widdershins18>	https://doc.rust-lang.org/std/hint/fn.black_box.html
T 1708599786 18<27sword_smith18>	Widdershins: The volatile thing *and* the entire accumulation. I don't actually want to add anything.
T 1708599790 18<27sword_smith18>	Just multiply.
T 1708599814 18<25Widdershins18>	see that link, that's the dedicated tool for this
T 1708600104 18<27sword_smith18>	Widdershins: Do you have something I can use on `stable`?
T 1708600494 18<29saati18>	yeah i was wrong, i can't demonstrate t
T 1708600524 18<29saati18>	it, but on skylake u64*u64 -> u128 is half as fast as u32*u32->u64, on zen3 they take the same time
T 1708600604 18<27sword_smith18>	Criterion has its own `black_box` thing that I think I can use. Not too well documented though.
T 1708601278 18<27sword_smith18>	saati: Managed to get a benchmark that I *think* does want I want it to. On my Intel Core i9-11950H multiplying two u64s takes the same time as multiplying two u32s.
T 1708601352 18<27sword_smith18>	Here's my benchmark: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=51d1ec615fb88dfeca508d58213efcbf
T 1708601437 18<25Widdershins18>	saati: black box is on stable, it's just not *const*
T 1708601441 18<25Widdershins18>	unless you're on unstable
T 1708601448 18<25Widdershins18>	sorry, sword_smith
T 1708601462 18<25Widdershins18>	using criterion's black box is also good
T 1708601530 18<25Widdershins18>	but std::hint::black_box has been stable since 1.66
T 1708601791 18<27sword_smith18>	Widdershins: I see. My IDE wanted to import `std::intrinsics::black_box` instead for some reason. And that thing gave me the `unstable` error.
T 1708601815 18<25Widdershins18>	the hint one just calls that, but yeah. which ide
T 1708601856 18<27sword_smith18>	VS Code. With `rust-analyzer`.
T 1708602343 22*	26ChanServ gives channel operator status to 18Widdershins
T 1708602542 22*	26Widdershins removes channel operator status from 18Widdershins
T 1708606547 19*	Now talking on 22##rust
T 1708606547 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708606547 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708606631 19*	Now talking on 22##rust
T 1708606631 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708606631 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708611059 18<27sword_smith18>	How can all these benchmarks take the same about of time? They really shouldn't, I think: https://github.com/Neptune-Crypto/twenty-first/blob/9f86d4a1341ef72bd2e6ae87e9fe0e4fb75ac170/twenty-first/benches/various_muls.rs
T 1708611079 18<27sword_smith18>	I'm I making an error in the benchmarking code?
T 1708611200 18<25bertptrs18>	what do you mean same amount of time?
T 1708611227 18<25bertptrs18>	criterion by default takes 100 samples over the course of 5 seconds, or longer if it's impossible to do within 5 seconds
T 1708611347 18<25bertptrs18>	oh the unsigned_mul test looks weird, that's ont how that works
T 1708611371 18<27sword_smith18>	bertptrs: Certain times are reported when a benchmark is run. That's the time I'm referring to.
T 1708611393 18<27sword_smith18>	`unsigned_mul/(u32,u32)->u64/1000000 time:   [306.18 µs 306.86 µs 307.70 µs]` etc.
T 1708611754 18<27sword_smith18>	bertptrs: If you think you can fix my tests, I would love to get your input :)
T 1708611760 18<27sword_smith18>	s/tests/benchmarks/
T 1708611946 18<25bertptrs18>	It goes against my religion to spell it out, but I do something fairly similar here: https://github.com/bertptrs/tracing-mutex/blob/master/benches/mutex.rs
T 1708612005 18<25bertptrs18>	but crucially you are misusing black_box
T 1708612012 18<25bertptrs18>	you don't pass it a closure, you pass it an expression
T 1708612041 18<25bertptrs18>	So I'm guessing all you're measuring is how quickly you can loop (size - 1) times
T 1708612279 18<25bertptrs18>	also for good measure, I recommend you use the same random data for all tests (to avoid random skew in how CPUs special-case certain multiplications) and use the windows() function instead of xs[i] xs[i + 1]
T 1708612479 18<27sword_smith18>	bertptrs: Now I'm getting some more sensible results.
T 1708613252 18<25cehteh18>	for some benchmarks i lock them on a specific core and set that core to a fixed frequency like 80% of its max. that makes the benchmarks slower but more reliable because overboost and thermal throttling wont happen
T 1708613357 18<27sword_smith18>	Pushed a commit. Now the results are sensible: https://github.com/Neptune-Crypto/twenty-first/blob/57699bb41100f60f7be11816587706acff49453f/twenty-first/benches/various_muls.rs
T 1708613391 18<25cehteh18>	on modern CPU's not all cores are equal, and i dont mean the efficiency/performance core thing, even having heterogenous cores some may run cooler and reach higher frequencies than their buddies on the same silicon
T 1708613391 18<29phy172918>	iirc the rust project uses callgrind to record the number of instructions (in addition to other things)
T 1708613441 18<25cehteh18>	yes using callgrind helps too, but its more atifical since it emulates a cpu/caches its not the real numbers you get
T 1708613469 18<26dminuoso18>	I have dovecot and want it to talk to a server-local HTTP server. What kind of simple but performant server library choices might I have? Security concerns are practically non-existent since the service is not exposed outside the server.
T 1708613531 18<26dminuoso18>	(Ultimately I just want something small with a small dependency closure)
T 1708614183 18<29alip18>	is there a way to split the parent and file name of a Path in one go rather than calling parent() and file_name() in sequence?
T 1708614305 18<26danieldg18>	alip: no, not unless you want to look at components instead of the parent
T 1708614348 18<29alip18>	thx
T 1708614439 18<26pflanze18>	Are there any philosophies around using borrowing rules for I/O? Like, File implements Read and gets operations that all take &mut self, of course that's needed as some implementations need to maintain state; but maybe it would be there anyway to make sure a file handle is only used from one place to avoid the possibility for interference statically? Or is that outside of Rust's concerns?
T 1708614489 18<26danieldg18>	pflanze: if you want to do that, you should wrap the File in something that only allows read/etc on a &mut
T 1708614505 18<26danieldg18>	pflanze: &File implements Read explicitly so this isn't needed
T 1708614561 18<26pflanze18>	So I get that the answer is that Rust does *not* use borrow checking rules for I/O.
T 1708614566 18<26danieldg18>	correct
T 1708614571 18<26pflanze18>	OK, thanks!
T 1708614586 18<26danieldg18>	look at read_at/write_at if you want to avoid interference
T 1708614679 18<20nullie18>	read and gets modify state on any file implementation
T 1708614736 18<26danieldg18>	that depends on what you count as state
T 1708614788 18<26danieldg18>	the file's cursor will get modified, but that is actually a kernel state thing that rust doesn't control
T 1708614961 18<26pflanze18>	Yep, IIRC on POSIX the cursor is even shared across processes.
T 1708614988 18<26danieldg18>	yes, it is
T 1708615062 18<20nullie18>	let's implement IO monad
T 1708615085 18<26danieldg18>	you can do that if you like
T 1708615171 18<26pflanze18>	(Last I know HKT are not ready hence no generic monad infrastructure.)
T 1708615199 18<26pflanze18>	(Not that I necessarily wanted to see monads, anyway.)
T 1708623317 19*	Now talking on 22##rust
T 1708623317 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708623317 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708628942 18<29monr0e18>	Moved from Windows to Linux, and am rebuilding a .net web application in Rust with Rocket. Tryign otu CLion, should I look elsewhere for an IDE? Been kinda spoiled by visual studio
T 1708629162 18<20cappy18>	monr0e: I'm looking for an IDE for Rust as well. Just went to https://www.jetbrains.com/clion/ and there is no mention of Rust; only C/C++. Is there a Rust plug-in?
T 1708629227 18<29monr0e18>	Yes, but I don't know how extensive it is. I ran into some sort of issue settin gup a new project too
T 1708629272 18<29monr0e18>	but that may also be because I have no idea how to use rust yet. In fact, I know next to nothing abotu it
T 1708629356 18<28monr0e-pooping18>	Oh I should change this nick
T 1708629389 18<20cappy18>	monr0e: I just started with Rust a day or two ago. But I found an alternate: VSCodium or Visual Studio Code can be set up for Rust:
T 1708629410 18<20cappy18>	monr0e: https://github.com/larina3315/personal-stuff/blob/main/coding/vsc-flatpak-rust.md
T 1708629431 18<27monr0e-phone18>	I really want to avoid a vscode solution tbh
T 1708629535 18<27monr0e-phone18>	I'm looking for something as close to equivalency as possible to visual studio
T 1708629535 18<20cappy18>	Believe that's why the open source VSCodium exists, apart from Microsoft's telemetry et al. Just mentioning it.
T 1708629594 18<27monr0e-phone18>	Honestly the telemetry is easy to fix, but I really have been spoiled by visual studio. That sort of featureset is second nature to me now
T 1708629626 18<27monr0e-phone18>	VSCode is something I use more for super basic website building
T 1708629646 18<20cappy18>	Understand your point. IDK of anything else. Perhaps someone else here can add?
T 1708629650 18<25LawnGnome18>	JetBrains has RustRover as their (fairly new) Rust specific product.
T 1708629664 18<25LawnGnome18>	I haven't used it, but if you're used to the JetBrains way of doing things, I assume it would work for you.
T 1708629702 18<27monr0e-phone18>	I have zero experience with jetbrains either tbh. I'm willing to try anything that has a decent enough featureset
T 1708629740 18<27monr0e-phone18>	RustRover is a plugin? Or an entire IDE in its own right?
T 1708629758 18<19Alexendoo18>	somewhere inbetween
T 1708629775 18<27monr0e-phone18>	Oh interesting
T 1708629780 18<20cappy18>	Is there pricing on RustRover? I'm at the site; don't see it.
T 1708629860 18<25bertptrs18>	I've previously used either CLion or IntelliJ Ultimate with the official rust plugin, but then I stopped having a rust job and moved to vscode + rust-analyzer
T 1708629862 18<20cappy18>	Or is it considered part of their "Products Pack"?
T 1708629869 18<25Diablo-D318>	I dont think they sell rustrover yet
T 1708629908 18<20cappy18>	So is their d/l a trial? (for now)
T 1708629915 18<27monr0e-phone18>	From what I can see RustRover is in beta
T 1708629929 18<25Diablo-D318>	cappy: "trial"
T 1708629961 18<25Diablo-D318>	its the same as intellij community edition, but with the rust plugin set instead of the java one
T 1708629976 18<20cappy18>	Diablo-D3: meaning, use it for a time until it's out of beta and then pay.
T 1708629981 18<27monr0e-phone18>	There's an entirely separate, though deprecated, plugin for intellij cappy
T 1708629999 18<25Diablo-D318>	cappy: basically.
T 1708630016 18<25Diablo-D318>	I'd probably take IDEA more seriously if they'd quit trying to split it up per language
T 1708630026 18<27monr0e-phone18>	I might try this preview. Looks interesting
T 1708630028 18<25Diablo-D318>	if I buy intellij ultimate, all of them are in the same IDE
T 1708630067 18<25Diablo-D318>	they jumped the shark, though
T 1708630078 18<25Diablo-D318>	they're all in on AI, which means they're basically dead.
T 1708630102 18<19nCrazed18>	last I tried RustRover on my current $job project, it choked on what I am guessing was the workspace set up that I had for that project
T 1708630109 18<27monr0e-phone18>	Ugh I noticed the ai thing
T 1708630110 18<19nCrazed18>	so still CLion + the plugin for me
T 1708630143 18<25bertptrs18>	Diablo-D3: if anyone who went all in on AI was dead, I'd be much happier about the future of the tech industry
T 1708630186 18<19Alexendoo18>	monr0e-phone: well you wanted it to be like VS :P
T 1708630213 18<27monr0e-phone18>	Alexendoo: No ai in VS 2017!
T 1708630231 18<27monr0e-phone18>	Lol "ai"
T 1708630323 18<19nCrazed18>	there's no AI in Intellij's 2017 offerings either :|
T 1708630546 19*	Now talking on 22##rust
T 1708630546 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708630546 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708631263 19*	Now talking on 22##rust
T 1708631263 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708631263 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708631637 18<26bwidawsk18>	istr there was work to allow `..Default::default()` for a struct that doesn't impl Default, but where the remaining members do. Did I make that up? If not, could someone please help me find it?
T 1708631675 18<25bertptrs18>	you might've, because that fundamentally cannot work
T 1708631702 18<25bertptrs18>	..Default::default() is less magic than you think; it's the struct update syntax
T 1708631720 18<25bertptrs18>	What it does, is "these are new fields, then take whatever else from this other struct"
T 1708631738 18<25bertptrs18>	Where all Default::default() does is call the default function and take the default values from there
T 1708631930 19*	Now talking on 22##rust
T 1708631930 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708631930 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708631936 18<26bwidawsk18>	but looks like it's not longer alive
T 1708632783 19*	Now talking on 22##rust
T 1708632783 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708632783 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708632966 19*	Now talking on 22##rust
T 1708632966 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708632966 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708634100 18<20maxsimo18>	list
T 1708635367 18<26swansone18>	Hey, I'm writting a unit test for a function that returns a Result. Is there a convenient shorthant to assert that it returns Ok, or prints Err if not?
T 1708635426 18<25bertptrs18>	just unwrap it?
T 1708635451 18<26swansone18>	Oh, that might work
T 1708635496 18<25bertptrs18>	Has the benefit of automatically failing the test too
T 1708635644 18<26swansone18>	Do I need to change the type signature of the test to do that?
T 1708635660 18<26swansone18>	Trying this gives me "^ cannot use the `?` operator in a function that returns `()`"
T 1708635923 18<26swansone18>	Trying to update the test function signature to return a result gives me an error that I need to implement the `Termination` trait
T 1708636259 18<26swansone18>	I think this is probably the best I can do then: `assert!(config.is_ok(), "{:?}", config)`
T 1708636718 18<19Alexendoo18>	swansone: unwrap as in .unwrap()
T 1708644557 18<25Widdershins18>	sigh, nightly clippy recently started complaining about redundant prelude imports. even when they are for no_std
T 1708644854 18<25Widdershins18>	nightly-2024-02-16 is fine, 2024-02-19 isn't
T 1708645152 18<25Widdershins18>	happened between the -18 and -19 toolchains
T 1708646696 18<25Widdershins18>	really struggling making a minimal reproducer for this!
T 1708646710 18<25Widdershins18>	i don't know why it dislikes my crate specifically
T 1708650579 18<25Widdershins18>	ok i figured it out bug submitted 😌
T 1708655909 18<25Widdershins18>	ok i sent the bug to the wrong place and failed to find the real issue, but i got an interesting idea from the real one
T 1708658506 18<25Widdershins18>	Is there a way to make cargo compile with the no_std prelude, even in std?
T 1708658591 18<25Mutabah18>	Why not just have `#![no_std]`
T 1708658602 18<25Mutabah18>	(and import std manually)
T 1708658611 18<25Widdershins18>	does that have other effects when the library is included in the whole program?
T 1708658622 18<25Widdershins18>	if the rest of the program is normal std?
T 1708658630 18<26danieldg18>	no
T 1708658633 18<25Widdershins18>	i am looking at https://github.com/rust-lang/rust/issues/121362#issuecomment-1955202508 here
T 1708658653 18<25Widdershins18>	though, as i'm currently looking to find out, that may only affect the *whole binary* when it applies to the program, not to each library individually
T 1708658657 18<26danieldg18>	you can use no-std crates normally from std ones
T 1708658658 18<25Mutabah18>	`no_std` libraries can be included in std-including binaries
T 1708658684 18<25Widdershins18>	do they produce the same code as if they were not no_std, as long as they use the same types etc.?
T 1708658689 18<25Mutabah18>	In fact it's very common for `no_std` libraries to have feature flags to turn on use of std/alloc
T 1708658695 18<25Mutabah18>	yes.
T 1708658711 18<25Mutabah18>	The stuff you use in `no_std` is the same in std (just re-exports)
T 1708658733 18<25Widdershins18>	yes, that's what i have. i have a library that has a std feature flag. currently this feature disables the no_std config, rather than causing std to be imported
T 1708658801 18<25Widdershins18>	as long as no_std code benefits from "stack overflow protection" and "runs init code before main" when included in a std program then that answers my question
T 1708658819 18<25Widdershins18>	seems likely that that would be the case
T 1708658837 18<26danieldg18>	if main is std, then it would
T 1708658849 18<26danieldg18>	stack overflow is also set up prior to main
T 1708658883 18<25Widdershins18>	context for the problem is also in that issue; rust nightly started throwing lint complaints for redundant imports when a maybe-no_std crate imports items that are also in the std prelude when it's std
T 1708658909 18<25Mutabah18>	The solution is to always be `no_std` but manually import std if needed
T 1708658914 18<25Mutabah18>	example: https://github.com/thepowersgang/stack_dst-rs/blob/master/src/lib.rs
T 1708658918 18<25Widdershins18>	not clear if they'll roll it back but if it's unambiguously a good idea to extern std instead of disable no_std i'll just do that, it does sound better
T 1708658924 18<25Widdershins18>	yea
T 1708658926 18<25Mutabah18>	It conditionally imports alloc (and std - for miri tricks)
T 1708658935 18<25Widdershins18>	mhm
T 1708659894 18<25Widdershins18>	alright sweet
T 1708659901 18<25Widdershins18>	thanks danieldg Mutabah
T 1708674489 18<24enoq18>	is there something that allows you to serialize JSON in a streaming fashion? like serializer.startArray(); serializer.writeStruct(struct); serializer.stopArray()
T 1708677827 18<24enoq18>	can anyone explain this? https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=52322953af6b6452bdc73953cbcd6845
T 1708677834 18<24enoq18>	error[E0369]: cannot add `&{integer}` to `&mut {integer}`
T 1708677878 18<24enoq18>	these don't look like really distinct types to me
T 1708678260 18<26dminuoso18>	Hi, is there a way to get a delimited use of ? when ultimately I dont return a io::Result<T> at the end, but I do make a bunch of successive calls to functions that do in the beginning?
T 1708678270 18<26dminuoso18>	Or is the idiomatic approach to just split this into two functions?
T 1708678294 18<20j`ey18>	try blocks, but not stable afaik
T 1708678362 18<20j`ey18>	enoq: I think you want reduce, not scan?
T 1708678388 18<24enoq18>	I want to turn [1, 2, 3] into [0, 1, 3, 6]
T 1708678406 18<26dav1d18>	enoq, they are distinct types, compiler tells you how you can fix it
T 1708678413 18<24enoq18>	dav1d, right, but why
T 1708678413 18<20j`ey18>	oh
T 1708678437 18<26dav1d18>	enoq, one is mutable the other isn't. You can impl traits for &Foo and &mut Foo separately
T 1708678457 18<26dav1d18>	enoq, &Foo and Foo are also not the same type
T 1708678473 18<24enoq18>	is there no trait impl for left hand &mut and right hand &
T 1708678515 18<26dav1d18>	enoq, yeah that's what is missing
T 1708678544 18<26dav1d18>	enoq, but it's the same for `&u32 + u32`
T 1708678566 18<24enoq18>	you mean you also can't add those?
T 1708678614 18<24enoq18>	the scan type signature is also kinda complicated btw
T 1708678655 18<26dminuoso18>	j`ey: Alright thanks.
T 1708678919 18<24enoq18>	looks like this is sort of what I want
T 1708678920 18<24enoq18>	https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=1e1dc6b62e21fb45d5a9a216e3844952
T 1708678927 18<24enoq18>	I've never used * before in rust
T 1708680557 18<27mkoncek18>	does rustc / cargo offer more granular optimize / debug flags? like -O<N> in gcc
T 1708680586 18<20j`ey18>	opt-level
T 1708680864 18<27mkoncek18>	also, i have two processes, one is sending UDP to a local address in a while loop and the other one is receiving them, after roughly 300 datagrams some of them get lost, is it possible i overflowed the kernel buffers?
T 1708681178 18<26dav1d18>	enoq, https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=e7ca6a2c5abc4babd48ce6ce27918140
T 1708681199 18<26dav1d18>	oh nvm I think I broke it
T 1708681220 18<24enoq18>	you forgot to sum it up
T 1708681234 18<24enoq18>	I know, the API does not work like in other languages
T 1708681240 18<26dav1d18>	yeah, I think yours is as good as it gets
T 1708681254 18<24enoq18>	thanks, was worried about the type soup
T 1708681265 18<26dav1d18>	enoq, eh `*state = *state + curr;`
T 1708681290 18<26dav1d18>	that should work, but it's just a minor thing which clippy probably also notices
T 1708681310 18<24enoq18>	what's the solution?
T 1708681339 18<26dav1d18>	oh clippy wants ` *state += curr;`
T 1708681342 18<26dav1d18>	that's nice
T 1708681355 18<24enoq18>	ah, yeah, less characters for the same thing then :)
T 1708681371 18<26dav1d18>	enoq, https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=ae625557c0702aa6b79b5a5b3c6c8797
T 1708681373 18<26dav1d18>	full thing
T 1708681384 18<24enoq18>	thanks
T 1708681393 18<24enoq18>	so let's say I want to execute this function at compile time
T 1708681404 18<24enoq18>	I think there's some form of constexpr
T 1708681456 18<26dav1d18>	enoq, you can't create a vector with items at compiletime, if you have an array you'd need to manually do it with a while loop I believe (not sure if for works alread)
T 1708681476 18<24enoq18>	because vec is heap allocated?
T 1708681549 18<25bertptrs18>	yea
T 1708681567 18<25bertptrs18>	also many of the functions you are using cannot be used in a const context yet
T 1708682190 18<24enoq18>	I suppose simple ::new methods are fine to make const?
T 1708682200 18<24enoq18>	when you just want to fill in default values for a struct
T 1708682364 18<20j`ey18>	yep
T 1708682445 18<24enoq18>	thanks
T 1708682486 18<24enoq18>	I don't really fully understand the limitation of no vectors inside const fns; it should be possible to just allocate that vector at compile time, right?
T 1708682548 18<24enoq18>	or does Rust have more guarantees  in that regard?
T 1708682620 18<24enoq18>	like: will not check how big the actual thing is after running it during compile but instead needs to know all sizes statically in advance?
T 1708682952 18<24enoq18>	oh :( https://github.com/rust-lang/rfcs/pull/2237
T 1708683282 18<27synapse18>	enoq, they're heap allocated
T 1708683333 18<27synapse18>	enoq, if you made a StaticVec<T> you could statically allocate it. some people call that an array. :-D
T 1708683372 18<27synapse18>	enoq, .push() and such don't make much sense if the allocation is fixed.
T 1708683417 18<24enoq18>	right, you should be able to iter over arrays though, right?
T 1708683425 18<27synapse18>	yes
T 1708683426 18<26dav1d18>	need someone to just reply with yes as a sanity check, if I destructure a struct its Drop impl wont run?
T 1708683462 18<24enoq18>	doesn't drop always run at the end of the lifetime?
T 1708683482 18<25bertptrs18>	You cannot destructure things that have Drop
T 1708683625 18<25bertptrs18>	Oh it seems you can, provided the things you destructure are Copy
T 1708683628 18<26dav1d18>	bertptrs, https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=ac877edafd206dbdb899fcd3be13ddbf ?
T 1708683653 18<26dav1d18>	okay seems like I need to properly figure out semantics
T 1708683655 18<26dav1d18>	thanks
T 1708683705 18<25bertptrs18>	dav1d: it's just moving out of the thing, not actually destroying it
T 1708683808 18<26dav1d18>	bertptrs, yeah I see, it only allows you to get a ref when destructuring. I have a Token which logs something on drop and I want to be able to transform that token to another token which logs more information, that transformation shouldn't trigger the initial drop though :(
T 1708683819 18<26dav1d18>	Guess I'll have to wrap everything in an option
T 1708683835 18<25bertptrs18>	ManuallyDrop might help?
T 1708683934 18<22davros118>	Haven't been following the rust world so much lately (AI hype got me) .. is there movement in the realm of this existing problem:
T 1708683962 18<22davros118>	Can't impl From for collections when the inner type has a From
T 1708683967 18<26dav1d18>	bertptrs, thanks, I though that wouldnt work but it looks like it should!
T 1708683985 18<22davros118>	I think it needed negative bounds or something (there might have been some other proposals)
T 1708684078 18<26dav1d18>	Actually I can just std::mem::forget
T 1708684096 18<22davros118>	In my own vecmath libs I ran into this .. 'struct Vec3<T>{x:T, y:T, z:T} .. can't impl From<[B;3]> for Vec3<A> where A:From<B> {} because it'll freak out at the possibility of infinite nesting or something
T 1708684432 18<25bertptrs18>	negative bounds aren't anywhere coming as far as I know, the new trait solver has been in limbo for a bit
T 1708684920 18<24enoq18>	is there no built in way to handle dates & ISO8601 formatting?
T 1708685439 18<25bertptrs18>	no, the standard library is intentionally somewhat limited since it's intended to be stable forever
T 1708685446 18<25bertptrs18>	you can look at either the chrono or time crates
T 1708685783 18<26dav1d18>	I thought Rust would catch this out of bounds on static arrays :( https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=f9bdc0f3c23bfde2073c9d7676c39c4b
T 1708685796 18<26dav1d18>	Is there a way to have the array access validated on compiletime?
T 1708686545 18<19turlando18>	dav1d: ironically the release llvm ir code is just a call to core::panicking::panic_bounds_check when i try to run weight
T 1708686571 18<19turlando18>	So it's actually doing some kind of const propagation
T 1708688848 18<26dav1d18>	turlando, nice! optimized panics
T 1708696020 19*	Now talking on 22##rust
T 1708696020 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708696020 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708696036 18<24enoq18>	I'm using the File buf reader lines() method I think
T 1708696069 18<24enoq18>	yep, that one handles \r\n
T 1708696321 19*	Now talking on 22##rust
T 1708696321 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708696321 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708696364 18<25cehteh18>	you can use that when you use std String -- but creating a string from untrusted io is fallible, by panic or you handling the Result
T 1708696447 18<25cehteh18>	and read_lines etc have no safeguard against malicious files that use extremely long lines. often thats ok, but sometimes thats a big problem
T 1708696496 18<24enoq18>	that's a problem in other languages as well
T 1708696499 18<25cehteh18>	and its all-or-nothing in case of invalid utf8
T 1708696504 18<25cehteh18>	yeah sure
T 1708696521 18<25cehteh18>	just telling you to consider it, if it doesnt matter ignore it
T 1708696532 18<24enoq18>	yeah, thank you for the tp
T 1708696534 18<24enoq18>	tip*
T 1708696570 18<24enoq18>	usually you've got an enforced size limit for uploaded files
T 1708696571 18<25cehteh18>	esp invalid utf8 isnt really unexpected
T 1708696593 18<25cehteh18>	you may at least handle that instead panicking
T 1708696599 18<24enoq18>	right
T 1708696755 18<25cehteh18>	gtg
T 1708697569 18<27sword_smith18>	I've seen the recommendation that a `Debug` implementation should be added as a rule of thumb.
T 1708697580 18<27sword_smith18>	Why?
T 1708697674 18<25bertptrs18>	https://rust-lang.github.io/api-guidelines/interoperability.html
T 1708697706 18<25bertptrs18>	private types not necessarily, but for public types it's very helpful for API consumers to debug their own codew
T 1708697807 18<28tstonge18>	it's nice to be able to format!("{:?}", my_obj), and all it takes is `Debug`
T 1708698096 18<25bertptrs18>	or if you're hip, to use the dbg! macro
T 1708699378 18<24enoq18>	how can you hold onto a value outside of a loop, that goes out of scope in a loop
T 1708699410 18<20nullie18>	enoq: set_fact?
T 1708699419 18<24enoq18>	what do you mean?
T 1708699429 18<20nullie18>	I don't quite understand what do you want to do
T 1708699433 18<24enoq18>	I need to keep track of a previous value
T 1708699447 18<24enoq18>	compare the current value to the previous value
T 1708699461 18<20nullie18>	well you could use set_fact to store it
T 1708699499 18<24enoq18>	I can only find Ansible stuff when I google that
T 1708699518 18<20nullie18>	oh, shit, sorry, I though it was #ansible :D
T 1708699539 18<20nullie18>	you can declare a variable outside of a loop
T 1708699590 18<24enoq18>	right, I can, but if I assign to it, I either need to move? it since the value goes out of scope
T 1708699595 18<24enoq18>	or copy it somehow
T 1708699629 18<20nullie18>	it will be moved by default
T 1708699643 18<20nullie18>	can you show the code for your current attempt?
T 1708699690 18<24enoq18>	nullie, https://dpaste.com/6WP8SDQYQ#line-150
T 1708699709 18<24enoq18>	error is ^^^^^^^^ borrowed value does not live long enough
T 1708699718 18<24enoq18>	line 172
T 1708699748 18<20nullie18>	remove the reference
T 1708699760 18<24enoq18>	you mean move it?
T 1708699777 18<20nullie18>	Option<ArticleLine> instead of Option<&ArticleLine>
T 1708699830 18<20nullie18>	and then Some(article_line) instead of Some(&article_line)
T 1708699849 18<20nullie18>	s/article_line/article/g
T 1708699903 18<24enoq18>	use of moved value now
T 1708699914 18<24enoq18>	https://dpaste.com/F2XWBCSTG
T 1708699926 18<24enoq18>	157 |             Some(cheapest) => {
T 1708699929 18<24enoq18>	value moved here
T 1708699949 18<20nullie18>	match lowest_price.as_ref()
T 1708700021 18<24enoq18>	https://dpaste.com/H2WCW7KRT
T 1708700030 18<24enoq18>	    |                     ^^^^^^^^^^^^ `lowest_price` is assigned to here but it was already borrowed
T 1708700035 18<24enoq18>	line 160
T 1708700064 18<24enoq18>	(my gutt feeling is that I need a copy)
T 1708700082 18<20nullie18>	lowest_price = match { }, and then at finish each branch with Some()
T 1708700132 18<20nullie18>	well, maybe it's not the right way
T 1708700234 18<26danieldg18>	you might be able to avoid a copy, but it depends on what exactly you are iterating and storing
T 1708700277 18<29phy172918>	It feels .fold(ish maybe with group_by
T 1708700315 18<24enoq18>	yes, it feels like group_by, but doesn't group by evaluated everything?
T 1708700353 18<24enoq18>	if I evaluate it, I'm loading 120 gigs of strings into memory
T 1708700399 18<20nullie18>	group_by should evaluate lazily
T 1708700500 18<24enoq18>	so it accumulates values until the grouping criterium does not match anymore?
T 1708700505 18<24enoq18>	then starts a new group?
T 1708700540 18<20nullie18>	it doesn't even accumulate group values
T 1708700549 18<20nullie18>	I think
T 1708700561 18<20nullie18>	"If the groups are consumed in order, or if each group’s iterator is dropped without keeping it around, then GroupBy uses no allocations. It needs allocations only if several group iterators are alive at the same time."
T 1708700571 18<24enoq18>	sounds like magic, will take a look thank you!
T 1708707914 18<28Vorpal18>	Does anyone know any tool to generate an install script similar to the one you curl for rustup. Lots of pieces of software have these, but most seem to be hand written for each project. Or depend on Go. Looking for something with multi-architecture support for my own usage. I'm absolutely proficient enough in shell script that I could hack something together. But then there is MacOS/Windows support (which I have no clue about). So I was hoping for some ready
T 1708707916 18<28Vorpal18>	made tool.
T 1708707939 18<28Vorpal18>	Preferably something that integrates easily with a rust build system too
T 1708707953 18<25bertptrs18>	as far as I know these tend to be hand-written
T 1708707998 18<25bertptrs18>	which is not great, people make the same mistakes over and over
T 1708708012 18<28Vorpal18>	That would be a good project then, for someone who has time for that (which I don't). So I too will hand-write one for my project, that will be Linux only.
T 1708708013 18<25bertptrs18>	but I don't think anyone's set up a standardized method yet
T 1708708054 18<25bertptrs18>	composer for example is a PHP tool so they decided to write it in PHP rather than bash. Makes sense but doesn't help standardization
T 1708708055 18<28Vorpal18>	really for my purpose it is a single binary, so all I need is to figure out which is the latest github release, and what architecture I'm running on. Then download and unpack the relevant binary into the current directory
T 1708708090 18<28Vorpal18>	heh, never heard of composer. I thought PHP was dead these days except for existing software (mediawiki, wordpress, probably a few more)
T 1708708148 18<25bertptrs18>	PHP is very much alive, and composer was its revival. it made libraries a lot more accessible and from that the ecosystem got a big boost
T 1708708153 18<24enoq18>	struggling with lifetimes here https://dpaste.com/GJASURSDQ error https://dpaste.com/65WKULUVC
T 1708708157 18<29phy172918>	it doesn't help that POSIX sh is a maze of twisty edge cases all of them sharp
T 1708708166 18<24enoq18>	I don't understand why I'm getting 2 different lifetimes here
T 1708708186 18<28Vorpal18>	phy1729: true. You can't assume bash. Mac OS uses zsh (which I happen to know since I use it myself). Then there is also dash.
T 1708708204 18<25LawnGnome18>	And, in fairness to Composer, anyone who wants to use it already has PHP installed, so making the installer a PHP script makes total sense from that perspective. Plus, yeah, cross platform shell scripting no es bueno.
T 1708708209 18<29phy172918>	and ksh on the BSDs, so you can only really assume POSIX sh
T 1708708243 18<25bertptrs18>	LawnGnome: I'm not dissing composer's choice, it makes perfect sense and lets them avoid POSIX shell
T 1708708249 18<25LawnGnome18>	I had to help maintain a cross platform (maximally, Linux, FreeBSD, macOS, Solaris) "install from tarball" type shell script for several years. I do not recommend the experience.
T 1708708250 18<28Vorpal18>	phy1729: oh right, well I don't build for BSDs (since cross-rs can't cross-test for them). So that I don't won't have to worry about
T 1708708255 18<25LawnGnome18>	bertptrs: I didn't think you were. :)
T 1708708273 18<29phy172918>	Vorpal: I'm on one, so I tend to care about them
T 1708708311 18<28Vorpal18>	phy1729: I wouldn't mind supporting them with pre-built binaries. But I refuse to support anything I can't actually run integration tests on in CI. That way lies madness.
T 1708708345 18<28Vorpal18>	I expect my program to work fine there (there is no reason it wouldn't it works on Windows even after all)
T 1708708368 18<28Vorpal18>	but BSDs and Mac OS ARM I can't cross test in CI, so they get no support.
T 1708708378 18<24enoq18>	is there a way to link the lambda parameter lifetime to the return value?
T 1708708381 18<28Vorpal18>	(I only use Linux myself, not even windows)
T 1708708907 18<24enoq18>	how does one group by two values
T 1708709661 18<24enoq18>	ok https://docs.rs/itertools/latest/src/itertools/groupbylazy.rs.html#299-307
T 1708709669 18<24enoq18>	looking at that signature, there are no lifetimes
T 1708709677 18<24enoq18>	    F: FnMut(&J::Item) -> K,
T 1708709683 18<24enoq18>	so &J and K are not related
T 1708709698 18<24enoq18>	I suppose that's why you can't use any K that refers to &J
T 1708709704 18<24enoq18>	so you have to copy?
T 1708709801 18<24enoq18>	so .group_by(|article| (article.code.clone(), article.pos))
T 1708709809 18<24enoq18>	code is a string, pos a usize
T 1708711475 18<29alip18>	using bitflags how do i check any one of a set of flags is set in a bitflags var? do i have a better way than calling contains() for each flag?
T 1708711488 18<29alip18>	i tried intersects() but it does not seem to do the right thing
T 1708711838 18<26dav1d18>	alip, does that work `FOO & (A |  B | C) > 0`?
T 1708712011 18<29alip18>	dav1d: no
T 1708712078 18<25Mikachu18>	what is a "bitflags var"
T 1708712109 18<29alip18>	a struct defined with bitflags::bitflags!
T 1708712118 18<29alip18>	i mean the crate
T 1708712433 18<20spb18>	the documentation for intersects seems to match what you described - what's different about it from what you want?
T 1708712591 18<20a5118>	I installed erdtree and erdtree says command not found
T 1708712741 18<29alip18>	spb: indeed, but it does not do what i want appearently, i use it with nix's type OFlag and e.g. (OFlag.O_RDONLY|OFlag.O_CLOEXEC|O_DIRECTORY).intersects(O_CREAT|O_TMPFILE) returns true for some reason. o.O
T 1708712875 18<20a5118>	bat and exa work but not erdtree
T 1708712921 18<20j`ey18>	a51: erd
T 1708713068 18<24enoq18>	how does one get an owned value out of a vec
T 1708713077 18<20j`ey18>	remove()
T 1708713086 18<20spb18>	depends what you want to happen to the thing in the vec
T 1708713095 18<26dav1d18>	enoq, remove, std::mem::take/replace
T 1708713104 18<24enoq18>	I want to move it into something else
T 1708713108 18<26dav1d18>	remove is quite expensive
T 1708713128 18<24enoq18>	the vec is only used to calculate something temporarlily
T 1708713133 18<20spb18>	and do you want to remove it from the vec, or leave something else in its place?
T 1708713146 18<26dav1d18>	enoq, if you want to get rid of the entire vector, into_iter()
T 1708713161 18<24enoq18>	I need to know the size of the vec as well
T 1708713184 18<24enoq18>	basically the length and the struct with the lowest value
T 1708713215 18<24enoq18>	basically this https://dpaste.com/866BQBL59
T 1708713242 18<24enoq18>	so I guess remove it is?
T 1708713317 18<29phy172918>	You're throwing away the Vec once you have the min?
T 1708713322 18<24enoq18>	yees
T 1708713326 18<20spb18>	so you're extracting the first item and then throwing away the vec
T 1708713337 18<24enoq18>	first item + vec length, then throwing it away
T 1708713383 18<29phy172918>	.into_iter().reduce and skip the sorting step
T 1708713403 18<20spb18>	and calculate the length before you do it
T 1708713407 18<29phy172918>	er Iterator has a .min
T 1708713433 18<20spb18>	using min means you don't have to actually sort the list which will be considerably faster
T 1708714980 18<24enoq18>	what does this mean: error[E0515]: cannot return value referencing temporary value https://dpaste.com/C7YCXKBJV
T 1708714997 18<24enoq18>	https://dpaste.com/2ZP7SP48S
T 1708715019 18<24enoq18>	I don't really understand what creates the temporary value
T 1708715113 18<28Vorpal18>	enoq: using rust playground would help rather than a pastebin so we can see which line and part the error applies to
T 1708715122 18<24enoq18>	yes, one sec
T 1708715128 18<28Vorpal18>	(see the /topic for a link to the playground)
T 1708715168 18<24enoq18>	https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=6ac152cbe4c36b75e0227875da658f17
T 1708715244 18<28Vorpal18>	hm, used to seeing type inlay hints from vscode, much harder without that :D. But I would expect you take article by value and return a reference to it in group_by()
T 1708715289 18<24enoq18>	at least intellij says &ArticleLine in line 168 but it's pretty buggy as well :/
T 1708715292 18<28Vorpal18>	some things that could help are to collect into a Vec and returning that vec.into_iter() since the computation won't depend on something after the function returns the iterator then
T 1708715334 18<24enoq18>	Vorpal, it's a 120gb string line iterator
T 1708715341 18<28Vorpal18>	but I understand you don't want that, since you try to keep everything as iterators very much so
T 1708715344 18<24enoq18>	I doubt I want to collec tthat
T 1708715350 18<28Vorpal18>	fair point!
T 1708715370 18<28Vorpal18>	what type is pos?
T 1708715374 18<28Vorpal18>	article.pos I mean
T 1708715377 18<24enoq18>	it's a usize
T 1708715389 18<28Vorpal18>	which is Copy. Huh
T 1708715438 18<28Vorpal18>	aha! article.code is a &str. You want to_owned() not clone()
T 1708715442 18<28Vorpal18>	I think that is it
T 1708715456 18<28Vorpal18>	pretty sure you are just cloning the reference into a new reference right now
T 1708715473 18<24enoq18>	same error
T 1708715494 18<24enoq18>	(article.code.to_owned(), article.pos) right?
T 1708715496 18<28Vorpal18>	hm you are right
T 1708715502 18<28Vorpal18>	yeah okay I'm confused too
T 1708715512 18<24enoq18>	the group_by is from itertools btw
T 1708715548 18<24enoq18>	what exactly is the temporary value btw?
T 1708715558 18<28Vorpal18>	I'm wondering that too now
T 1708715561 18<24enoq18>	is it the iterator? or is it the stuff inside the group_by
T 1708715620 18<28Vorpal18>	This type implements IntoIterator (it is not an iterator itself), because the group iterators need to borrow from this value. It should be stored in a local variable or temporary and iterated.
T 1708715628 18<28Vorpal18>	ah, that is probably the issue
T 1708715647 18<28Vorpal18>	you are borrowing from GroupBy itself
T 1708715720 18<28Vorpal18>	I don't have a good answer for how to solve that. I expect if you put it inside the next function it would work, but that is several layers deep in returning files, so that is no good for code organisation.
T 1708715745 18<28Vorpal18>	enoq: hopefully that has given you some idea about the cause though, even though I don't have a suggestion for the fix
T 1708715867 18<24enoq18>	Vorpal, basically, I can't into_iter() after the group by?
T 1708715901 18<28Vorpal18>	well, I haven't looked into the details, but I quoted a line from the documentation of group_by
T 1708715933 18<28Vorpal18>	it seems plausible that the moment you need to iterate over it you need to finish doing so in the same scope
T 1708715938 18<24enoq18>	right, I didn't understand that one tbh
T 1708716011 18<28Vorpal18>	I don't have a suggested fix, perhaps someone else can chime in. You could could try on https://users.rust-lang.org/ maybe?
T 1708716089 18<24enoq18>	there's https://stackoverflow.com/questions/47885478/how-to-use-itertools-group-by-iterator-method-without-a-for-loop
T 1708716097 18<24enoq18>	the suggestion is to clone everything :/
T 1708716199 18<28Vorpal18>	hm... maybe a different design then?
T 1708716302 18<24enoq18>	the one I tried before is passing in a lambda that is executed after each iteration, but closures sure are terrible in Rust, couldn't get it to work
T 1708717044 18<28Vorpal18>	could you pass in a separate function rather than lambda instead?
T 1708717280 18<25dkg18>	So i've got a functioning cdylib built now (i ended up deciding not to do the string manipulation in fixed-size buffers that i'd asked about earlier at all; ended up with a much cleaner interface and implementation, but thanks danieldg and Mutabah for walking me through it anyway)
T 1708717302 18<25dkg18>	now i'm struggling because the library object generated by the cdylib crate exposes a *ton* of symbols that i don't want it to expose.
T 1708717445 18<25dkg18>	i've done searches for "cdylib symbol visibility" and found nothing that works for me :(  i've tried passing a "version script" to the linker, but it ends up in conflict with the version script passed automatically by cargo
T 1708717476 18<25dkg18>	what i want is for the cdylib to only expose those symbols that are marked as C symbols
T 1708717493 18<25dkg18>	so, the things that cbindgen would pick up on, for example.
T 1708717549 18<25dkg18>	the desired C API is simple enough that i don't need to actually use cbindgen to produce it, and i'd prefer to avoid depending on that crate anyway during build.  Any pointers on what i can do to minimize the exported symbols in a cdylib?
T 1708717786 18<24enoq18>	Vorpal, tried this approach instead https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=22cc396e399dd04c469f98eb94d67d3b
T 1708717801 18<24enoq18>	getting "borrowed data escapes outside of closure"
T 1708717806 18<24enoq18>	I suppose it's the same issue
T 1708717914 18<20j`ey18>	dkg: so youre getting rust mangled symbols?
T 1708717964 18<20j`ey18>	(oops go to go)
T 1708718404 18<25dkg18>	j`ey: yes, i'm seeing rust mangled symbols in addition to the ones that i want to export
T 1708718623 18<25dkg18>	hm, actually, as i look at it further, maybe not!  i think i was just seeing mangled symbols in the non-stripped shared object.  when i run "strip" on it, the only symbols that remain are the deliberately exported ones.
T 1708720189 19*	Now talking on 22##rust
T 1708720189 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708720189 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708726487 18<26ljhklhjl18>	hi
T 1708726557 18<26ljhklhjl18>	https://tr.cpabestoffer.click/redirect?aff_id=1153&offer_id=121
T 1708726567 18<26ljhklhjl18>	https://tr.cpabestoffer.click/redirect?aff_id=1153&offer_id=121
T 1708729097 18<27lolita18>	Ok, el trato... dame una membresía gratis y te enviaré 5 videos de coños calientes después de un chat de sexo en vivo gratis, ¿es bueno el trato? https://tr.cpabestoffer.click/redirect?aff_id=1153&offer_id=121
T 1708729123 18<27lolita18>	Ok, el trato... dame una membresía gratis y te enviaré 5 videos de coños calientes después de un chat de sexo en vivo gratis, ¿es bueno el trato? https://tr.cpabestoffer.click/redirect?aff_id=1153&offer_id=121
T 1708729155 18<27lolita18>	Soy una chica soltera. Busco diversion con gente real.. Si realement quieres conocerme, sigue mi perfil personal
T 1708729156 18<27lolita18>	Si este enlace no funciona, cópielo y péguelo manual en su navegador: https://tr.cpabestoffer.click/redirect?aff_id=1153&offer_id=121
T 1708772561 19*	Now talking on 22##rust
T 1708772561 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708772561 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708772567 18<20osse18>	Of course, need to wait for a new release of cargo-lockdiff since the current one segfaults
T 1708772697 18<20osse18>	With that said, if there is a newer/better/shinier way to get a easily digestible "diff" of Cargo.lock then I'm all ears
T 1708775378 18*	26zato slaps Jarrko Oikarinen around with a big nice tuna sandwich 
T 1708775400 18<20jbg18>	osse: i like `lockdiff`
T 1708775429 18<20jbg18>	https://lib.rs/crates/lockdiff
T 1708775472 18<20jbg18>	not a cargo 'plugin' but rather just a command you can point git to, so `git diff` gives nice diffs on lock files automatically
T 1708775481 18<20jbg18>	works for some python and JS lockfile formats too
T 1708775607 18<20osse18>	 Cool, I'll check it out
T 1708775643 18<20osse18>	At first glance this looks more like what I would have written myself. The big table you get from cargo-lockdiff sort of sticks out
T 1708781270 18<20osse18>	I need to act on the inner value of an enum if the enum is of a particular variant: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=20be5267fe0800bc46c21dd271668b43 - Is there a way to make maybe_reverse2() work the same as maybe_reverse() ?
T 1708781362 18<20osse18>	Ahh, I think macro hygiene is screwing me here. the matches!() itself compiles just fine (there's a typo in the playground)
T 1708782341 18<29yuri603718>	Hello, I have a question about the &str type: is there any way to refer to the &str type other than by using a type statement? I'm attempting to write a custom deserialize function for a proprietary format of date time and in that deserialize function I'd like to call &str::deserialize however it appears that in rust it's impossible other than by creating a type statement.
T 1708782419 18<28erk18>	yuri6037: You could look into the built-in trait FromStr, and if you want to replicate what that does you will have to make a trait and then implement it for &str
T 1708782440 18<20osse18>	<&str>::deserialize()   works
T 1708782511 18<29yuri603718>	osse: thank you never seen that weird type syntax before but works or is it just a variant of the <type as trait> syntax?
T 1708782628 18<20osse18>	yuri6037: I'm not really qualified to answer :P But I *think* it's essentially the same as <type as trait> yes.
T 1708782640 18<29yuri603718>	ok
T 1708782650 18<29yuri603718>	thank you anyways
T 1708783165 18<20osse18>	yuri6037: tested a bit on the playground and I feel I know less than I did. the < > seem to be just to scope the &.
T 1708783191 18<29yuri603718>	ok I see
T 1708783198 18<20osse18>	&T::foo() is a reference to T::foo()  <&T>::foo() calls &T'
T 1708783206 18<20osse18>	ugh, whatever, you get what I mean.
T 1708783226 18<29yuri603718>	Oh ok that's like the parentheses in C casts
T 1708783272 18<20jbg18>	it's called a "qualified path"
T 1708783281 18<20jbg18>	and yeah it's basically like parens but for types
T 1708783289 18<29yuri603718>	Anyway that failed because the xml_serde_rs crate can't parse borrowed string it can only parse owned strings so it's gonna have to be more allocs
T 1708783292 18<20jbg18>	https://doc.rust-lang.org/reference/paths.html#qualified-paths
T 1708783307 18<20jbg18>	< Type (as TypePath)? >
T 1708783317 18<29yuri603718>	jbg: thanks for the name good to know
T 1708783372 18<29yuri603718>	I tried to reduce allocs but the lib I use does not appreciate
T 1708783386 18<20jbg18>	serde_xml_rs seems to be able to deserialize from &str
T 1708783424 18<29yuri603718>	apparently not: Failed to decode TTMD monitor data object: Custom { field: "invalid type: string \"05/06/2014 09:14:56\", expected a borrowed string" }
T 1708783452 18<20jbg18>	that error doesn't seem to say what you are saying it says though
T 1708783455 18<20jbg18>	in any case you'd have to show code
T 1708783858 18<29yuri603718>	Here is the code that failed with the error I gave you (note that the playground does not have serde_xml_rl): https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=581fd21d3150d2d6b7a4d87ce8c4a9f8
T 1708783956 18<20jbg18>	the error implies that serde_xml_rs is providing a String *that it allocated* while you are assuming it will provide a &str
T 1708783960 18<20jbg18>	i bet i know why as well
T 1708783963 18<20jbg18>	XML entities
T 1708783979 18<20jbg18>	it can't give a &str borrowed from the input because it has to interpret entities
T 1708784006 18<20jbg18>	best it could give is Cow<'a, str> -- the Borrowed variant if there are no entities and the Owned variant if there are. no idea if they implemented that or not
T 1708784030 18<20jbg18>	it's the same reason why serde_json can't reliably deserialize JSON strings into &str, only into String or Cow<'a, str>
T 1708784039 18<20jbg18>	because it needs to interpret backslash escapes
T 1708784455 18<19Alexendoo18>	It's based on xml-rs which doesn't borrow from the input
T 1708784536 18<19Alexendoo18>	You probably want quick-xml instead
T 1708784850 18<20jbg18>	quick-xml looks good. has the same setup as serde_json: you can deserialize strings into String, Cow<'a, str> or &str but &str will fail if the XML is non-UTF8, if there are any entities in the input, or if an element contains multiple cdatas
T 1708784894 18<29yuri603718>	Thanks for the tip
T 1708785355 18<20capitol18>	do anyone know if it's possible to check if you are in the context of a #[cfg(...)] conditional when writing a clippy lint? There is a stripped_cfg_items() function on the context object, but that is not what I want
T 1708785554 18<19Alexendoo18>	capitol: You can use any_parent_has_attr
T 1708785751 18<20capitol18>	Alexendoo: oh, thanks :)
T 1708787287 18<29yuri603718>	Does quick-xml support unordered readings?
T 1708787331 18<29yuri603718>	I.e. Does it support formats where objects may appear in any order in the tree and deserialize as a single structure with fields
T 1708788546 19*	Now talking on 22##rust
T 1708788546 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708788546 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708788723 19*	Now talking on 22##rust
T 1708788723 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708788723 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708788816 18<29yuri603718>	well I think there's no other choice at this point my input XML is unparseable in Rust
T 1708788869 18<19Alexendoo18>	Since you're in boring hyperbole mode I assume you're just using the library wrong
T 1708788895 18<19Alexendoo18>	As has been the case every other time
T 1708788902 18<20j`ey18>	lmao I really hate yuri6037's way of talking
T 1708788921 18<20j`ey18>	glad theyve been away for ages lol
T 1708788947 18<29yuri603718>	The problem is the library does not dcument anything about unordered items
T 1708788973 18<29yuri603718>	it appears nobody in Rust has through of unordered XML elements when parsing XML
T 1708789007 18<20j`ey18>	but apparently it's super common /s
T 1708789043 18<29yuri603718>	at least its common enough to be supported in C# and Jav
T 1708791425 18<20nullie18>	it was always a stupid idea to store structures in xml
T 1708791460 18<29yuri603718>	I ended finding something the quick_xml lib can do it but using very weird struct field names
T 1708791516 18<29yuri603718>	Like naming "monitor" instead of "monitors" in order to parse a Vec<Monitor> and naming "sensor" instead of "sensors" to parse a Vec<Sensor>
T 1708791532 18<29yuri603718>	This behavior is obviously not documented
T 1708791573 18<29yuri603718>	and error messages from the lib are misleading like saying that fields do not exist when they do on a standard text editor
T 1708791637 18<26danieldg18>	yes, if you want automatic things you'll need to use the right plurality; otherwise, you can generally rename them
T 1708791673 18<26danieldg18>	it's perfectly reasonable to have both <monitor> and <monitors> tags in XML
T 1708791691 18<24ksynwa18>	Is this the "correct" way to check a Path? `path == Path::new("filename.json")`
T 1708791700 18<26danieldg18>	ksynwa: define 'check'
T 1708791727 18<26danieldg18>	ksynwa: because that doesn't actually do anything but convert the type
T 1708791748 18<24ksynwa18>	I just wanna check if path points to filename.json
T 1708791783 18<24ksynwa18>	Don't care if there is a file there or not. Just what the string value is.
T 1708791810 18<26danieldg18>	ksynwa: ok, rephrasing: what do you want to *reject*?
T 1708792087 19*	Now talking on 22##rust
T 1708792087 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708792087 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708792254 18<20nullie18>	ksynwa: maybe path.to_str() == Some("filename.json")
T 1708792268 18<24ksynwa18>	Yeah that looks fine.
T 1708792278 18<20nullie18>	but why are you doing that?
T 1708792341 18<24ksynwa18>	nullie: I am reading the contents of a zip file. For certain filenames I want to handle the files differently.
T 1708792627 18<19Alexendoo18>	The == Path::new() allows skipping the UTF-8 check
T 1708794688 18<20nullie18>	yeah, could be faster
T 1708823390 19*	Now talking on 22##rust
T 1708823390 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708823390 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1708828544 18<24krez18>	hello :D
T 1708834319 18<22thegman18>	is set_read_timeout not a thing on TcpListener
T 1708834340 18<22thegman18>	i cant figure out how to notify a listener that the sender has finished sending stuff
T 1708834384 18<26danieldg18>	tcplistener is for new sockets
T 1708834405 18<26danieldg18>	it's normally used in an event loop, not with timeouts
T 1708834519 18<22thegman18>	i thought tcplistener was used to receive bytes from a tcp stream
T 1708834889 18<27Affliction18>	nope, it's used to listen on a port and accept connections.
T 1708834919 18<22thegman18>	how do i recieve data then
T 1708834928 18<22thegman18>	tcp listener works but it wont close afterwards
T 1708834929 18<27Affliction18>	It creates TcpStreams for incoming connections, which are bidirectional
T 1708837557 18<25Widdershins18>	listener sockets bind to a port & wait for incoming connections, they don't send or receive data themselves
T 1708840407 18<22Ademan_18>	since &str[i] isn't supported (I understand why), is there a way I can iterate over characters in the string and pull out regions as a slice? I started going down that path and I don't think I can do it without a useless enumerate() to keep track of character index (can't == compare Skip<Char<...>> apparently)
T 1708840451 18<22Ademan_18>	the approach I was going for was going to require me to collect() into a new String anyway, if I could get it working
T 1708840779 18<25Widdershins18>	Ademan_: pull out what regions?
T 1708840828 18<22Ademan_18>	oh, char_indices() looks promising, if I want to grab a slice from start = s.char_indices() to stop = s.char_indices().skip();  can I just do &s.as_bytes()[start.0..stop.0] ?
T 1708840858 18<22Ademan_18>	Widdershins: some region I've selected while parsing
T 1708840934 18<22Ademan_18>	wait I'm being dumb s.as_bytes()[...] is going to be a &[u8] and I can't just get the current index with .0 heh
T 1708841057 18<22Ademan_18>	oh start.offset()..stop.offset() would work if it wasn't experimental
T 1708841117 18<22Ademan_18>	I assume s.as_bytes()[start.offset()..stop.offset()] would result in a valid utf-8 byte slice so I ought to be able to turn that back into a string slice, but I'm hosed since offset() is experimental anyway
T 1708841577 18<22Ademan_18>	oh huh, since Chars is a DoubleEndedIterator maybe it does everything I need by itself...
T 1708841606 18<22Ademan_18>	will have to look again later though, night
T 1708852943 18<20polychromata{J}18>	Ademan_: you can't index a string with a single integer, but you /can/ slice it with a range
T 1708852955 18<20polychromata{J}18>	(put you've probably already figured that out)
T 1708853351 18<20jbg18>	thegman: most likely you are actually using TcpStream (returned by accept() on TcpListener) without realising it. to close the connection you can just drop the TcpStream
T 1708857124 18<27synapse18>	can my Cargo example have its own dependencies?
T 1708857192 18<25Widdershins18>	synapse: examples can use dev dependencies
T 1708882893 19*	Now talking on 22##rust
T 1708882893 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1708882893 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709072158 19*	Now talking on 22##rust
T 1709072158 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709072158 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709082580 19*	Now talking on 22##rust
T 1709082580 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709082580 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709164962 19*	Now talking on 22##rust
T 1709164962 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709164962 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709165582 20*	Disconnected (20)
T 1709165726 23*	28dacd is already in use. Retrying with 18david_...
T 1709165730 22*	26david_ sets mode 24+Z on 22david_
T 1709165730 22*	26david_ sets mode 24+i on 22david_
T 1709165730 22*	26david_ sets mode 24+w on 22david_
T 1709165730 -18SaslServ-	Last login from: ~dacd@newoobs.freeboxos.fr on Feb 29 00:02:35 2024 +0000.
T 1709165730 -18NickServ-	This nickname is registered. Please choose a different nickname, or identify via /msg NickServ IDENTIFY david_ <password>
T 1709165736 19*	Now talking on 22##rust
T 1709165736 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709165736 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709181363 18<20polychromata{J}18>	evalr: -0.0_f64
T 1709181365 -18evalr/22##rust-	polychromata{J}: -0.0
T 1709181438 18<20polychromata{J}18>	evalr: --nightly #![feature(float_next_up_down)] (0.0_f64.is_finite(), (-0.0_f64).is_finite())
T 1709181440 -18evalr/22##rust-	polychromata{J}: (true, true)
T 1709188597 18<19Chagall18>	Is anyone aware of a simple method for adding or parsing dakuten/handakuten in Japanese chars?
T 1709188630 18<19Chagall18>	(Simpler than writing lookup tables myself)
T 1709188720 18<19Chagall18>	IIRC it's possible by operating on the character codes depending on the encoding...
T 1709188752 18<19Chagall18>	But that's not very idiomatic(TM)
T 1709189317 18<22Arnavion18>	Parsing can be done by normalizing into whatever form separates the dakuten/handakuten (NFD?)
T 1709189343 18<22Arnavion18>	Adding can be done by the opposite normalization
T 1709189387 18<19Chagall18>	Ah, neat
T 1709189412 18<22Arnavion18>	evalr: use unicode_normalization::UnicodeNormalization; "ば".nfd().collect::<Vec<_>>()
T 1709189414 -18evalr/22##rust-	Arnavion: ['は', '\u{3099}']
T 1709189445 18<19Chagall18>	perfect, thanks
T 1709212532 20*	Disconnected (20)
T 1709212545 22*	26david_ sets mode 24+Z on 22david_
T 1709212545 22*	26david_ sets mode 24+i on 22david_
T 1709212545 22*	26david_ sets mode 24+w on 22david_
T 1709212545 -18SaslServ-	Last login from: ~dacd@newoobs.freeboxos.fr on Feb 29 13:15:37 2024 +0000.
T 1709212545 -18NickServ-	This nickname is registered. Please choose a different nickname, or identify via /msg NickServ IDENTIFY david_ <password>
T 1709212551 19*	Now talking on 22##rust
T 1709212551 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709212551 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709213993 19*	Now talking on 22##rust
T 1709213993 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709213993 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709216163 19*	Now talking on 22##rust
T 1709216163 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709216163 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709218715 18<22Ademan_18>	Just when I thought I was starting to figure lifetimes out... https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=2d1decc35a732b73a1a04340752d94dd why does the compiler want me to add 's (the lifetime of the &str CharIndices points to) to the result iterator? On the contrary the result lifetime 'r should be less than or equal to that, right?
T 1709218765 18<25cehteh18>	programmers rule #1 The compiler is always right :D
T 1709218800 18<22Ademan_18>	secondary question is: is there something that does what RefMap here does (wrap an iterator without owning it, and applying a map function to its elements results)
T 1709218908 18<19Alexendoo18>	.by_ref().map()?
T 1709218927 18<19Alexendoo18>	Or just .map if you already have a &mut Iterator
T 1709218985 18<22Ademan_18>	Alexendoo: thanks you're right!
T 1709219063 18<19Alexendoo18>	The trick being https://doc.rust-lang.org/std/iter/trait.Iterator.html#impl-Iterator-for-%26mut+I
T 1709219691 18<22Ademan_18>	so does ` -> impl Iterator<Item = char> + 's` express something other than "a type implementing iterator that lives *at least* as long as 's" ? If it means what I think, doesn't that mean the result could outlive the original string being referenced? (since we have CharIndices<'s>)
T 1709219740 18<25bertptrs18>	no, because CharIndices<'s> borrows the lifetime of the underlying string 's
T 1709219789 18<25bertptrs18>	I don't quite know why you're not allowed to unify the lifetimes into 'i; I would expect that to work
T 1709220011 18<22Ademan_18>	changing the lifetimes to simply be `'i: 'r + 's` appears to work but I still am really struggling why the lifetime of 'i should exceed 's. I feel like I missed something important not reading the rust book page by page or something.
T 1709220153 18<25bertptrs18>	ah now I understand, your relation was wrong
T 1709220277 18<25bertptrs18>	you wrote 's: 'i, but this is the wrong way around, it should be 'i: 's
T 1709220302 18*	20polychromata{J} frowns and flips through the Book yet again to confirm that `'a: 'b` means 'a lives at least as long as 'b
T 1709220593 18<20polychromata{J}18>	i'm confused too c.c
T 1709220594 18<22Ademan_18>	yeah so I am still confused lol, doesn't this indicate the the reference iter will borrow for 'i, which is now longer than 's, which is the lifetime of the underlying &str of CharIndices<> ? Maybe the key is me not understanding "no, because CharIndices<'s> borrows the lifetime of the underlying string 's" ?
T 1709220876 18<25bertptrs18>	Hmm, yeah, that makes no sense, even if it compiles
T 1709220890 18<22Ademan_18>	maybe it can be distilled further: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=c8fd35a844a20ce33ee9663bc6c9aa3c
T 1709220947 18<22Ademan_18>	hrm no, my modified version doesn't mind if 'i and 's are totally unrelated lifetimes, I guess *that* makes sense
T 1709221264 18<22Ademan_18>	HRM, this might be slightly enlightening https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=fdd7f10fad30b06b654c3f2c4bec67c8 as_str() returns a string reference with lifetime 's and the exact lifetime of 'i remains irrelevant. it's like it was "cut through". obvious but possibly relevant behavior
T 1709221272 18<22Ademan_18>	if anyone tires of me thinking out loud please tell me to shut up
T 1709221364 18<25cehteh18>	yoi can just remove 'i there :D
T 1709221416 18<25cehteh18>	well i'd only took a glimpse
T 1709221446 18<22Ademan_18>	yeah I think you're right, I'm kind of just exploring right now, though
T 1709221488 18<25cehteh18>	aim for minimal lifetime annotations, let the compiler infer as much and if possible use generic '_
T 1709221915 18<25cehteh18>	CharIndices::as_str()  returns the str with the same lifetime as CharIndices, theoretically it may be a longer lasting one, but that complicates things as it would need to expose another lifetime up
T 1709221940 18<25cehteh18>	you have some kindof artifical limit there, which makes sense
T 1709221962 18<25cehteh18>	impl<'a> CharIndices<'a> { pub fn as_str(&self) -> &'a str
T 1709222573 18<22Ademan_18>	is it fair to say that the return value of as_str()s lifetime is "up to 'a" ? Since typically I think of lifetimes as being "at least 'x"
T 1709222603 18<22Arnavion18>	No, it's "at least 'a"
T 1709222630 18<22Arnavion18>	The 'a is the lifetime of the original &str that .char_indices() was called on
T 1709222694 18<22Arnavion18>	The returned &str only borrows from that original &str and nothing from the CharIndices, so there's no reason to limit its lifetime to the CharIndices itself
T 1709223626 18<22Ademan_18>	Arnavion: the last part makes perfect sense, but I don't understand how you could borrow "at least 'a" if the lifetime of the original str is also 'a (which afaict it is, per what cehteh shared above)
T 1709223661 18<22Ademan_18>	or I guess the lifetime of the original string is *also* "at least 'a"
T 1709223690 18<22Ademan_18>	but then how could you borrow it safely longer than 'a? I wouldn't think you could.
T 1709224371 18<25cehteh18>	of course you cant
T 1709224736 18<29Beatussum18>	Hi! I'd like to write a function returning an iterator but what should I prefer to specify as return type ? 1) An `impl Iterator<Item = Something>` ? 2) The iterator type directly which could be therefore a bit long ?
T 1709224927 18<20j`ey18>	Beatussum: impl Iterator is good yeah
T 1709225053 18<29Beatussum18>	j`ey: if the iterator returned implements other traits (for example, Clone, Debug, etc.) should I specify them too?
T 1709225089 18<20j`ey18>	if they make sense
T 1709225232 18<22Ademan_18>	cehteh: then how can we say the lifetime is "at least 'a" ? longer than 'a would be longer than the known lifetime of the underlying string
T 1709225235 18<25cehteh18>	just specify what you need, no more no less
T 1709225304 18<25cehteh18>	Ademan_?
T 1709225314 18<29Beatussum18>	cehteh: okay I've got it
T 1709225319 18<29Beatussum18>	thanks :)
T 1709225527 18<27gastus18>	I tried .lines to count lines of a file found out that it's much slower than C fgets() function. Found rust-mio but I have issues compiling it on some systmes eg stdlib.h is missing (nixos) or OSX other error. Is there yet another solution I missed ? I am interested in using json-yy like very fast parsers cause I have to process like 3GB of JSON files.
T 1709225583 18<25cehteh18>	gastus: you use that with a BufReader ?
T 1709225841 18<29Beatussum18>	I've another question about the error `E0700`? I'm not sure to understand why a lifetime specifier is needed in the following case https://bpa.st/PG3A
T 1709226581 18<22Arnavion18>	Ademan_: We're talking about "at least" / "at most" from different points of view :)
T 1709226630 18<22Arnavion18>	A &'static str can be converted to a &'a str. So from the POV of the producer of the &'a str, the str lives at least as long as 'a (it could be living longer). From the POV of the consumer of the &'a str, the str lives at most as long as 'a
T 1709226686 18<22Arnavion18>	The consumer for example cannot put it in a variable of type &'static str, because the &str is only guaranteed to live at most as long as 'a
T 1709227131 18<22Arnavion18>	So in this case, CharIndices::as_str() could just return `"foo"` (str literals are &'static str) and it would compile fine. But when the caller of CharIndices::as_str() lost the original &str that they had called .char_indices() on, they would also lost the &str returned by CharIndices::as_str()
T 1709227466 18<29Guest1318>	Hi, how do I print the current enum variant as string, assuming its debug/display traits were changed to something unrelated(like a full error message), this output is what I'm looking for: https://play.rust-lang.org/?version=nightly&mode=debug&edition=2024&gist=9e002932cba05f4c386211e2356c9df2
T 1709228572 18<27gastus18>	cehteh: Looks like libc might do it as well. So google fooled me into using a maybe too complex library.
T 1709228599 18<25cehteh18>	huh?
T 1709228805 18<25cehteh18>	just using a BufReader should fix this, when you didnt do so already, while rust might be a bit more pedantic since it validates that the strings/lines are utf-8, when you need it really fast then you count the \n's
T 1709228810 18<25cehteh18>	byte wise
T 1709228851 18<27gastus18>	Yes, the UTF-8 might be the reason why it's slower. Cause the JSON parsing in C showed similar difference.
T 1709228873 18<25cehteh18>	i suspect the most slowdown comes when you dont do buffered io
T 1709228881 18<27gastus18>	I will try and report.
T 1709228918 18<25cehteh18>	reading each byte is then a syscall turnaround
T 1709228942 18<27gastus18>	In fact I was using BufReader (thanks GPT :-). So that's not the difference.
T 1709228962 18<25cehteh18>	ah ok, hence i asked, W/O would be slower
T 1709228973 18<25cehteh18>	maybe you use a bigger buffer as well
T 1709229008 18<27gastus18>	Maybe boost of my CPU is not setup correctly. Maybe RAM actually is the bottleneck. That would explain why UTF8 makes bigger difference than it should.
T 1709229019 18<19edgimar18>	What is the recommended way to compute an average and standard-deviation on a [f64]?  I'm looking for traits that are already defined, since I don't want to reinvent the wheel every time I need this.
T 1709229087 18<25cehteh18>	gastus: the utf-8 check adds certainly some penalty
T 1709229253 18<19Alexendoo18>	BufRead::lines allocates a new string for each line, there's read_line if you want to re-use the same buffer
T 1709229318 18<25cehteh18>	the fastest would be to mmap the file, some madvise hints and then iterate by bytes counting \n's .. possibly in few parallel threads :)
T 1709229329 18<19edgimar18>	And yes I can just do numbers.iter().sum / (numbers.len() as f64), but I want something like numbers.mean_and_std().
T 1709229336 18<25cehteh18>	of course thats the most involved was as well :)
T 1709230813 18<20consus18>	Documentation to From suggests that implementing From<T> for U also brings me Into<T> for U
T 1709230819 18<20consus18>	However, that's not happening
T 1709230830 18<20consus18>	What am I doing wrong?
T 1709230851 18<20j`ey18>	Into<U> for T
T 1709230856 18<20spb18>	implementing From<T> for U gets you Into<U> for T
T 1709230876 18<20consus18>	ah dammit
T 1709230898 18<20consus18>	shame :(
T 1709231084 18<29Guest1318>	If I try to find out type of 'e' by doing "let i:i64=e;", then I get ^ expected `i64`, found `Error`, but 'Error' is not good enough type information, whilst I know now it's an enum variant "pkg_config::Error::Command" at that spot in the code (through brute force means aka match over all variants but what if there's 100s?!). Is there some way to
T 1709231084 18<29Guest1318>	find that "pkg_config::Error::Command" type?
T 1709231393 18<20consus18>	given that I've implemented both From<T> for U and Into<T> for U, should I also imlement From<Vec<T>> and Into<Vec<T>>?
T 1709231403 18<20consus18>	Or these come for free?
T 1709231526 18<20spb18>	you generally shouldn't implement Into yourself
T 1709231543 18<20spb18>	if the conversion goes both ways, impl From<T> for U and From<U> for T
T 1709231556 18<20consus18>	sadly I cannot touch U
T 1709231559 18<20consus18>	that's foreign type
T 1709231625 18<20consus18>	Or it's possible to define From<U> if U is another crate?
T 1709231681 18<20spb18>	you can impl From<T> on U if you own T
T 1709231692 18<20consus18>	oh
T 1709231726 18<20spb18>	owning a type that's a generic param for the trait is enough to satisfy the orphan rule
T 1709231741 18<20consus18>	thanks
T 1709231745 18<20consus18>	    Ok(Json(list.into_iter().map(Into::into).collect()))
T 1709231760 18<20consus18>	So then I have this
T 1709231765 18<20consus18>	Vec<T> -> Vec<U>
T 1709231811 18<20consus18>	Is it possible to make it like this: Ok(Json(list.into())? Or this is not how things work?
T 1709231848 18<29Guest1318>	just making sure, can people see this message?
T 1709231849 18<20consus18>	I was under the impression that Into should work for T<U> -> T<F> conversions
T 1709231924 18<20spb18>	not in the general case
T 1709231932 18<20consus18>	:(
T 1709231950 18<29Guest1318>	hello?
T 1709231956 18<20consus18>	Guest13: Hi :)
T 1709231987 18<29Guest1318>	oh ok, sorry, i thought my messages weren't getting through, I guess then no one knows about my issue, which is fair
T 1709232020 18<20j`ey18>	Guest13: yes the compiler wont print the exact variant basically
T 1709232049 18<29nox18>	How would rustc know
T 1709232052 18<29Guest1318>	ok, thanks
T 1709232064 18<29Guest1318>	I don't know, I thought maybe macros
T 1709232073 18<29Guest1318>	but I'm too new
T 1709232105 18<29Guest1318>	I guess the way is through match after all
T 1709232121 18<20j`ey18>	or dbg!(e) if it supports Debug
T 1709232151 18<29nox18>	Guest13: e is an Error, rustc knows that, but it doesn't know which variant the value is, as that's known at runtime
T 1709232152 18<29Guest1318>	it does but it prints an explanation message, and I was trying to see which type it was so I can match against it instead
T 1709232166 18<29Guest1318>	nox, understood,. thanks
T 1709233371 18<20consus18>	spb: thanks, this pub trait VecExtInto<T, U> {
T 1709233371 18<20consus18>	    fn morf(self) -> Vec<U>;
T 1709233371 18<20consus18>	}
T 1709233371 18<20consus18>	impl<T,U> VecExtInto<T, U> for Vec<T>
T 1709233371 18<20consus18>	where
T 1709233372 18<20consus18>	    U: From<T>
T 1709233372 18<20consus18>	{
T 1709233373 18<20consus18>	    fn morf(self) -> Vec<U> {
T 1709233373 18<20consus18>	        self.into_iter().map(Into::into).collect()
T 1709233374 18<20consus18>	    }
T 1709233374 18<20consus18>	}
T 1709233375 18<20consus18>	does the trick
T 1709234370 18<27Ademan18>	Arnavion: thanks, that makes sense, now I just need to integrate that info haha
T 1709235556 18<27gastus18>	libc fopen returns FILE which is enum FILE {}. So there is no real way to check the result of an fopen call (trying to be unsafe to understand the speed difference). So looks like best way to go is write actual C code.
T 1709235951 18<20osse18>	gastus: Can call ptr.is_null() ?
T 1709236819 18<28_Vi18>	Is there already a feature proposal / pre-RFC about library compilation settings that are supposed to be adjusted only by a root crate, not intermediate dependencies? For example, `tokio_unstable`. Many rhai's Cargo-level features would look better as root-crate-only features.
T 1709254781 19*	Now talking on 22##rust
T 1709254781 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709254781 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709260299 18<26danieldg18>	is there a nicer-looking way of getting a String out of a HashMap<&str,&str> than map.get("key").map_or("", |s| s).into()?
T 1709260827 18<19She18>	danieldg: Consider https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_default instead of the map_or.
T 1709260915 18<26danieldg18>	She: can't; it's an Option<&&str>, which has no Default
T 1709261210 18<19She18>	Ooop, indeed, you'd also need to throw a cloned() into there.
T 1709261339 18<20polychromata{J}18>	evalr: <&str as Default>::default()
T 1709261341 -18evalr/22##rust-	polychromata{J}: ""
T 1709261351 18<20polychromata{J}18>	evalr: <&&str as Default>::default()
T 1709261352 -18evalr/22##rust-	polychromata{J}: error[E0277]: the trait bound `&&str: Default` is not satisfied ...
T 1709261353 -18evalr/22##rust-	polychromata{J}: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=18c5736f5e498008079eee3e407cea29
T 1709261359 18<20polychromata{J}18>	ah, that makes sense
T 1709261513 18<22Arnavion18>	Or get to Option<String> and then _or_default it, eg   .get().copied().map_or_else(Default::default, Into::into)
T 1709261727 18<26danieldg18>	sure.  Mine wins for code-golf, but I think I'll use .copied.unwrap_or_default.to_owned
T 1709261733 18<22Arnavion18>	Also   impl Default for &&T where &'static T: Default { fn default() -> Self { &Default::default() } }   would let &&str be Default, I think
T 1709261816 18<26danieldg18>	might fail due to str:!Sized
T 1709261868 18<26danieldg18>	I don't see the &&T impl in the docs
T 1709261871 18<25Mutabah18>	Nah, it'd fail due to `Default::default()` not being `const`
T 1709261876 18<26danieldg18>	ah
T 1709261928 18<22Arnavion18>	https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=bd3443fd171959867f0aa78d91bbb5a7   Bah
T 1709261988 18<22Arnavion18>	Yeah, makes sense, static promotion only works for const-evaluated exprs
T 1709268584 18<19mips64el18>	hi o/
T 1709273526 18<22Ademan_18>	are derived Clones inline? in general? with exception? always?
T 1709278979 18<25bertptrs18>	Ademan_: at present not defined, but you can use cargo-expand to see (it is)
T 1709285542 18<24Bish18>	whenever i use a stream i basicially HAVE to get the futures_util::StreamExt, why isn't that default? im guessing because stream is not a first class citizen in rust?
T 1709285547 18<24Bish18>	is it async streams that are not std::stream ?
T 1709286520 18<25bertptrs18>	std::stream does not exist yet, and currently the Stream trait is kept minimal to make future adoption easier
T 1709286988 18<24Bish18>	and where is "the" stream trait? is it in futures_util?
T 1709287189 18<25bertptrs18>	futures_core
T 1709287293 18<20nullie18>	is there a better way to do something n times (than for _ in 0..n)?
T 1709287411 18<20j`ey18>	(0..n).for_each(..) maybe
T 1709287456 18<20osse18>	std::iter::repeat(()).take(10).for_each(|()| do_something())  \O/
T 1709287472 18<20j`ey18>	heh
T 1709287495 18<20j`ey18>	thars more optimal since it doesnt need to count the numbers /s
T 1709287595 18<26dav1d18>	j`ey, https://rust-lang.github.io/rust-clippy/master/index.html#/needless_for_each
T 1709287657 18<26dav1d18>	Wait did they move that lint into pedantic 🤔
T 1709287658 18<20osse18>	Hmm, when is .for_each() more performant ?
T 1709287798 18<20j`ey18>	dav1d: not sure if that would apply here?
T 1709287862 18<26dav1d18>	can I make clippy pedantic on the playground?
T 1709287938 18<26dav1d18>	j`ey, yeah it doesn't
T 1709290054 18<20polychromata{J}18>	osse: probably never
T 1709290063 18<20polychromata{J}18>	all else being equal, just use for{}
T 1709290085 18<20polychromata{J}18>	IOW, `for _ in 0..n {}` /is/ the way to do that
T 1709290112 18<20polychromata{J}18>	(i'll accept for_each() if it's a lot nicer to write, e.g. at the end of a long iterator chain)
T 1709290127 18<20polychromata{J}18>	(at least until we get postfix control flow keywords c; )
T 1709292303 18<22prmthz18>	hello! does anyone know how can I set "cargo test" parameters like "--test-threads=2" in the .cargo/config.toml ?
T 1709293849 18<20curious-user18>	hi, is there an orm which can load nested one-to-many relations without jumping through hoops?
T 1709293924 18<20curious-user18>	sea orm can't do that at all, diesel can but requires a lot of grouped_by's and zip's
T 1709293981 18<20curious-user18>	it seems weird that such basic functionality is still missing from major orms
T 1709294097 18<20curious-user18>	(not bashing, just wondering maybe i've missed something)
T 1709295707 18<27sword_smith18>	How do I strip all special characters from a string? The concrete example I have right now is that I want to convert the string
T 1709295715 18<27sword_smith18>	"*a" into "a".
T 1709295747 18<27sword_smith18>	Or `&str`, I guess. I don't think that matters. But what I have now i of type `String`.
T 1709295858 18<20j`ey18>	hm, maybe .replace(&['a', 'b'....'z'], "")
T 1709295863 18<20j`ey18>	that seems a little annoying
T 1709295875 18<20j`ey18>	ah no, you can put a function there
T 1709295922 18<20j`ey18>	evalr: let a = String::from("a-z"); a.replace(|c|!c.is_alphabetic(), "")
T 1709295924 -18evalr/22##rust-	j`ey: error[E0282]: type annotations needed ...
T 1709295924 -18evalr/22##rust-	j`ey: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=8faea1028e4dbb8e42af3cf0ddd9caea
T 1709295953 18<20j`ey18>	evalr: et a = String::from("a-z"); a.replace(|c: char|!c.is_alphabetic(), "")
T 1709295955 -18evalr/22##rust-	j`ey: error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an ...
T 1709295955 -18evalr/22##rust-	j`ey: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=805e1fdc104003e093c03c105bf383df
T 1709295959 18<20j`ey18>	ffs lol
T 1709295983 18<19Lumpio-18>	...et?
T 1709296008 18<20j`ey18>	mis copy :)
T 1709296012 18<20polychromata{J}18>	evalr: let a = String::from("a-z"); a.replace(|c: char| !c.is_alphabetic(), "")
T 1709296014 -18evalr/22##rust-	polychromata{J}: "az"
T 1709296135 18<27sword_smith18>	j`ey: That seems to work :)
T 1709296327 18<27sword_smith18>	This is for the debugger of a VM. I'm auto-generating some type/variable name hints. The best solution would be to make the assembly-parser more permissive wrt. these names, but for now, j`ey's above snippet works.
T 1709296379 18<20polychromata{J}18>	eh, that's fair. :)
T 1709296391 18<20polychromata{J}18>	though perhaps…
T 1709296407 18<20polychromata{J}18>	evalr: let a = String::from("a**z%"); a.replace(|c: char| !c.is_alphabetic(), "_")
T 1709296409 -18evalr/22##rust-	polychromata{J}: "a__z_"
T 1709296441 18<20j`ey18>	yes _ is better, maybe
T 1709296463 18<20osse18>	polychromata{J}: i see. Then that performance claim in that clippy is a bit weird.
T 1709296500 18<20polychromata{J}18>	clippy makes a performance claim?
T 1709296534 18<20osse18>	Bad phrasing on my part, probably.
T 1709296546 18<20osse18>	I meant this, quoted from the link above: "for_each may be used after applying iterator transformers like filter for better readability and performance. It may also be used to fit a simple operation on one line. But when none of these apply, a simple for loop is more idiomatic."
T 1709296552 18<27sword_smith18>	All tests pass :) I'm going with the replacement with `_`.
T 1709296576 18<20polychromata{J}18>	i'd be surprised if `for bar in foo { $body }` and `foo.for_each(|bar| { $body });` compiled to any different code.
T 1709296731 18<20osse18>	Same
T 1709296744 18<20osse18>	Interesting, from the std docs: "In some cases for_each may also be faster than a loop, because it will use internal iteration on adapters like Chain."
T 1709296923 18<20osse18>	Aka. it can take some shortcut that doesn't involve literally calling next() I guess
T 1709296937 18<20osse18>	s/Aka\./IOW./
T 1709296974 18<19LDericher18>	hi, currently relearning rust on my stm32 "blue pill" thingy and ran into an ownership/borrowing problem. Code: https://bpa.st/EUEA Issue: Lines 72/73 work, but doing that inside the loop at L82/87 fails as `tx` and `buf` are moved into the loop. tx and buf are both okay to be made 'static if needed. how to proceed?
T 1709297195 18<19LDericher18>	also, changing `buf` to `&*buf` in L82 makes one error go away as the analyzer suggests, but doesn't that only give the first value to the `write` fn?
T 1709297978 18<20osse18>	LDericher: what is the signature of tx.write()
T 1709298076 19*	Now talking on 22##rust
T 1709298076 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709298076 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709298308 18<19LDericher18>	osse, `fn write(mut self, buffer: B) -> Transfer<R, B, Self>` and `B: ReadBuffer<Word = u8>`
T 1709298429 18<20spb18>	https://docs.rs/stm32f1xx-hal/latest/stm32f1xx_hal/serial/type.TxDma1.html
T 1709298439 18<20spb18>	that's the `tx` you're working with
T 1709298514 18<20spb18>	write() consumes self and presumably wraps it into the returned Transfer object so you have to wait for the operation to complete before using it again for a new one
T 1709298597 18<19LDericher18>	spb, yes and the error is: `stm32f1xx_hal::dma::WriteDma::write` takes ownership of the receiver `self`, which moves `tx`
T 1709298692 18<20spb18>	yes
T 1709298710 18<20spb18>	once you call tx.write() you cannot use tx any more because it is consumed by the write call
T 1709298760 18<19LDericher18>	but the `with_dma` call to initialize `tx` takes care of the DMA initialization, so I'd like to reuse tx
T 1709298782 18<20spb18>	you can't reuse tx, the api doesn't allow it
T 1709298805 18<20spb18>	what you can do is use the returned Transfer object to get a new tx out of it, once the transfer has completed
T 1709298854 18*	20polychromata{J} squints at that name.
T 1709298858 18<28null_ptr18>	osse: One problem with for loops is that the compiler cannot generate nested loops and needs additional state tracking. With internal iteration the iteration structure can be kept optimal.
T 1709298938 18<19LDericher18>	I don't see anything in the `xfer` that looks like "reinitiate this" ... on the other hand I just inspected the DMA init and it looks less complex than I assumed it to be
T 1709298971 18<20spb18>	LDericher: look at what's returned from wait()
T 1709299268 18<19LDericher18>	spb, looks fine https://bpa.st/ORDQ but only shifts the issue: `Tx::<stm32f1xx_hal::pac::USART1>::with_dma` takes ownership of the receiver `self`, which moves `serial.tx`
T 1709299326 18<20spb18>	that's not at all what i said to do
T 1709299371 18<19LDericher18>	and using wait() feels like a chicken-and-egg problem as I'd need a completed Transfer before starting one?
T 1709299471 18<20spb18>	once you start the transfer, you need to use wait(), get whichever type that particular variant returns in its tuple, call release() on that, and you get a new Tx
T 1709299487 18<20spb18>	set up dma again on that, and write it back over the top of `tx` so you can use it in the next loop
T 1709299599 18<20spb18>	i'm being vague here because i'm working purely from the rustdocs which are pretty hopeless
T 1709299617 18<20spb18>	hopefully there's some real documentation somewhere else to make actual sense of why all this dance is required
T 1709299748 18<19LDericher18>	well it works, idk why it is this convoluted, but the C(++) way is way more obscure btw
T 1709305277 19*	Now talking on 22##rust
T 1709305277 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709305277 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709312939 19*	Now talking on 22##rust
T 1709312939 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709312939 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709316253 19*	Now talking on 22##rust
T 1709316253 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709316253 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709345126 19*	Now talking on 22##rust
T 1709345126 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709345126 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709348632 18<29Sync0318>	Hi there -- I have am making a vim-like editor, and I am implementing functionality for buffers. Does an associated function exist for the iter type, that is similar to .next() but when the end of the iterator is reached, instead of returning None, it goes back to the start of the iterator. So it's effectively infinitely repeating? Is this a possibility? Cheers.
T 1709348736 18<26danieldg18>	sure; look at Iterator::cycle
T 1709348781 18<29Sync0318>	Thanks!
T 1709348783 18<26danieldg18>	it isn't used like you described but it does what you want
T 1709354580 18<26josh1929118>	¬¬LL
T 1709354811 18<26josh1929118>	Hi
T 1709356535 19*	Now talking on 22##rust
T 1709356535 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709356535 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709356629 19*	Now talking on 22##rust
T 1709356629 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709356629 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709362996 18<25Guest2718>	Iti
T 1709363025 18<25Guest2718>	YMEJWG
T 1709363074 18<25Guest2718>	Bn8
T 1709364424 18<19Wulf18>	How do I call posix_fadvise on an std::fs::File?
T 1709364958 18<20capitol18>	Wulf: https://docs.rs/nix/latest/nix/fcntl/fn.posix_fadvise.html maybe
T 1709365065 18<20capitol18>	Wulf: or did you mean how to get a rawfd? https://doc.rust-lang.org/std/fs/struct.File.html#impl-AsRawFd-for-File
T 1709365208 18<19Wulf18>	capitol: both. Why won't "use nix::fcntl::posix_fadvise;" not work? "no `posix_fadvise` in `fcntl`"
T 1709365250 18<20capitol18>	maybe "Available on crate feature fs only" have you enabled that feature?
T 1709365257 18<19Wulf18>	capitol: I have no idea what that means.
T 1709365334 18<20capitol18>	when you import it in Cargo.toml you can specify features
T 1709365423 18<20capitol18>	https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#choosing-features
T 1709365857 18<19Wulf18>	capitol: thanks, works.
T 1709366310 18<20capitol18>	Wulf: nice :)
T 1709369074 18<19Wulf18>	How do I declare a function parameter that is either a u64 or "nothing"? And how do I check for "nothing" in the code?
T 1709369104 18<27lambda18>	Wulf: Option<u64>?
T 1709369126 18<27lambda18>	that has a value of either `Some(n)` where `n` is a u64, or `None`
T 1709369187 18<27lambda18>	you can check which one it is with `match`, `if let`, or maybe there's an existing method on `Option` that does what you need - you'd need to explain a bit more about the problem you're trying to solve
T 1709369278 18<19Wulf18>	lambda: it's my second day with rust. Guess I'll look at each of them and see what looks more useful.
T 1709369358 18<27lambda18>	Wulf: FYI, Option isn't magic in any way, the definition at the top of this page is all it really is: https://doc.rust-lang.org/std/option/enum.Option.html
T 1709369388 18<27lambda18>	I'd recommend reading the relevant chapter in the book: https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html?highlight=option#the-option-enum-and-its-advantages-over-null-values
T 1709369581 18<19Chagall18>	anyone else notice a large drop in throughput and less stable measurements when using criterion with batched iterations?
T 1709369669 18<26dav1d18>	Is it feasible to have a macro_rules macro that accepts any enum without data in the variants and then just does something with the variants? I feel like this is proc macro territory
T 1709369954 18<27lambda18>	dav1d: should be possible, if a bit of a pain to cover all the things that can be in an enum definition (attributes and such)
T 1709370076 18<26dav1d18>	lambda, I remembered pin-project-lite does something like that for structs, doesn't seem terrible, just gotta figure out how to not discard docs
T 1709372576 18<20polychromata{J}18>	Wulf: `match{}` is the most general thing; all of Option's other operations can be implemented in terms of it
T 1709372585 18<25farnext18>	 /msg NickServ REGISTER farnext far.next@gmail.com
T 1709372635 18<20polychromata{J}18>	Option has a /ton/ of convenience methods; don't worry about learning them all at once. You'll gradually get to know what's best|prettiest to use in each situation, over time. :)
T 1709372649 18<20polychromata{J}18>	farnext: protip: don't set your password equal to your nickname c.c
T 1709372784 18<20polychromata{J}18>	I like Diceware. Although you can also just use [a-z]+ as long as it's long enough (e.g. 26.pow(11) is roughly equal to 7776.pow(4)).
T 1709372794 18<20polychromata{J}18>	And then, for IRC, there's client cert auth, of course.
T 1709374477 18<19Wulf18>	I'm quite confused with match, functions, error handling, etc. Could someone please translate this toy example to rust for me? https://paste.debian.net/1309229/
T 1709374825 18<20j`ey18>	Wulf: why dont you show us what you have so far
T 1709374991 18<20j`ey18>	Wulf: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021 is a good site for rust snippets
T 1709375631 18<26dav1d18>	ah right I remember, documentation is just an attribute in macro_rules
T 1709375788 18<19Wulf18>	j`ey: https://gist.github.com/rust-play/ef6118a1923a74cdefd328eb7b09a410
T 1709375832 18<20j`ey18>	alright, looks good so far
T 1709375841 18<19Wulf18>	j`ey: well, the error handling is missing.
T 1709375858 18<20j`ey18>	Wulf: then you need to return Result<Self, Error> instead of just Self
T 1709375874 18<20j`ey18>	fn new(foo: Option<u64>, bar: u64) -> Result<Self, YourErrorType> {
T 1709375889 18<19Wulf18>	j`ey: and what error type would that be?
T 1709375942 18<20j`ey18>	you have to make one up or use an exisiting error type
T 1709375950 18<20j`ey18>	or just ().. any type basically
T 1709375976 18<20polychromata{J}18>	The first counterquestion is…is this for a library or an application?
T 1709376040 18<20j`ey18>	Wulf: this extends the example, minimally, https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=4154763522c6ad453c327d76239b3169
T 1709376079 18<20polychromata{J}18>	If it's an app, you can play pretty fast and loose with error types.
T 1709376080 18<19Wulf18>	polychromata{J}: application, but it must not crash when a bad value is passed.
T 1709376091 18<20polychromata{J}18>	Right, of course.
T 1709376138 18<20polychromata{J}18>	So having proper error types isn't quite as important. You can use `Box<dyn Error>` or `anyhow::Error` or whatever—the latter is easy to get started with compared to alternatives, i believe
T 1709376143 18*	20polychromata{J} doublechecks this
T 1709376150 18<19Wulf18>	It will accept a TLS connection and receive the parameter through it. When it's bad, the connection is closed, but the application should keep running to handle other connections.
T 1709376189 18<20j`ey18>	we're not talking about crashing :)
T 1709376190 18<19Wulf18>	j`ey: thanks
T 1709376239 18<20polychromata{J}18>	Oh, wow, anyhow has a good amount of support for ad-hoc errors.
T 1709376245 18<20polychromata{J}18>	That's pretty nice.[^1]
T 1709376361 18<20polychromata{J}18>	So if you pull in anyhow and change the return type to `Result<Self, anyhow::Error>`, you can do things like `if foo > 9 { bail!("tried to construct a Hello with foo={foo:?} (foo must be less than 9)") }`
T 1709376390 18<20polychromata{J}18>	s/bail!/anyhow::bail!/
T 1709376408 18<20polychromata{J}18>	This is a few new things at once; what questions do you have? :)
T 1709376439 18<20j`ey18>	I wwould learn more about Result itself first
T 1709376442 18<19Wulf18>	polychromata{J}: I think throwing more libraries at me only increases my confusion ;-)
T 1709376478 18<20polychromata{J}18>	Well, personally i like to do proper error types everywhere, but that's a good bit more work. :)
T 1709376486 18<20polychromata{J}18>	(Also i use thiserror for that, which is another library.)
T 1709376495 18<20polychromata{J}18>	(Because it's more tedious to not.)
T 1709376526 18<20j`ey18>	I mean the easiest thing to do next is: struct WulfError {} and change the Result<Self, ()> to Result<Self, WulfError>
T 1709376527 18<20polychromata{J}18>	Rust's std tends to err on the minimal side, so if you try hard to avoid libraries, you're probably going to have a bad time. :)
T 1709376561 18*	20polychromata{J} notes that the Book introduces a library (rand) in chapter 2.
T 1709376578 18<20polychromata{J}18>	j`ey: The thing about that, though, is that it carries no information on what actually went wrong.
T 1709376586 18<20j`ey18>	sure
T 1709376589 18*	20polychromata{J} gestures to her error message. It's detailed.
T 1709376597 18<20j`ey18>	but this is like their second day of rust :P
T 1709376625 18*	20polychromata{J} tailswishes.
T 1709376628 18<20polychromata{J}18>	You may be right. :P
T 1709376751 18<20polychromata{J}18>	So yes, `struct WulfError;` is easy…
T 1709376868 18<29saati18>	enum WulfError{}; and the compiler proves you make no errors :)
T 1709376892 18<20polychromata{J}18>	Tch. Uninhabited types on day 2?
T 1709376903 18<20j`ey18>	hah
T 1709377639 18<26dav1d18>	Result::into_ok when 😡
T 1709377648 18<20polychromata{J}18>	never
T 1709377664 18<26dav1d18>	noooooooooooooo :(
T 1709377673 18<20polychromata{J}18>	i know right ;-;
T 1709377683 18<26dav1d18>	!
T 1709379615 18<25Diablo-D318>	you know, its kinda sad that microsoft is this huge big company thats tried to fix directwrite several times (and tbf, they have, its way better than it used to be)....
T 1709379631 18<25Diablo-D318>	but they cant catch up to a bunch of random dudes on the internet who made freetype.
T 1709391486 18<29Beatussum18>	Hi! I would like to implement a "symetric" trait e.g. if I implement MyTrait<A> is implemented for B, therefore MyTrait<B> is also implemented for A by using the previous implementation. What is the best way to achieve this?
T 1709391828 18<19tokie18>	Beatussum: look at From/Into. If you impl From you get the reverse Into trait from a blanket impl
T 1709391917 18<19tokie18>	https://doc.rust-lang.org/src/core/convert/mod.rs.html#747-749
T 1709391999 18<19tokie18>	oh, that's two different traits though
T 1709392544 18<29Beatussum18>	tokie: Yeah, I would like to have the same trait implemented `MyTrait<A>` and `MyTrait<B>` because `MyTrait` provide one method which should be used by an instance of `A` or `B`
T 1709392558 18<29Beatussum18>	`From` and `Into` provide two different method
T 1709393312 18<26josh1929118>	A
T 1709393316 18<26josh1929118>	/hwlp
T 1709394940 18<20polychromata{J}18>	evalr: trait MyTrait<T> {} impl<A, B> MyTrait<B> for A where B: MyTrait<A> {}
T 1709394941 -18evalr/22##rust-	polychromata{J}: ()
T 1709395018 18<20polychromata{J}18>	evalr: trait MyTrait<T> { fn method(&self, other: &T); } impl<A, B> MyTrait<B> for A where B: MyTrait<A> { fn method(&self, other: &B) { other.method(self) } }
T 1709395020 -18evalr/22##rust-	polychromata{J}: ()
T 1709395066 18<20polychromata{J}18>	Beatussum: a cursory check says that it works, but i have a sneaking feeling that there's some subtle reason why it'll break c.c
T 1709402548 19*	Now talking on 22##rust
T 1709402548 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709402548 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709451377 19*	Now talking on 22##rust
T 1709451377 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709451377 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709451483 18<25Widdershins18>	ok the distance from where i was at to the associative key-value version that we've been talking about was pretty short
T 1709451498 18<25Widdershins18>	this passes MIRI https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=a70e90eabeab883b7229a9c4f062f45b
T 1709451526 18<25Widdershins18>	probably a good idea to make it so this panics less when you ask for keys that aren't there or whatever but the underlying mechanism is sound
T 1709451708 18<25Widdershins18>	the symbol repo version of this would have a slightly different api, probably like add_clown but not accepting a value
T 1709452109 18<25Widdershins18>	or, this could be combined with the vec-of-vecs to make a type that doesn't need to be StableDeref itself... so many possibilities
T 1709456979 18<20polychromata{J}18>	Widdershins: passes miri huh
T 1709456993 18<20polychromata{J}18>	do you have yarn tests? do those pass miri?
T 1709459280 18<25Widdershins18>	polychromata{J}: no idk that. yarn is a dep manager for javascript that i avoid looking at, too me. just saying that this doesn't complain when i run that program under miri, so it does seem like the unsafety is pretty much legal
T 1709459299 18<20polychromata{J}18>	not the JavaScript yarn!
T 1709459363 18<20polychromata{J}18>	oh, i misremembered. it's called loom.
T 1709459368 18<25Widdershins18>	i'm unable to find what you're looking for then
T 1709459404 18<20polychromata{J}18>	different textileish word. ^.^;
T 1709459407 18<25Widdershins18>	based on the readme of loom miri is WAY more comprehensive
T 1709459451 18<25Widdershins18>	it also runs a godzillion times slower, and is made to test more of the things i care about here (i am personally a lot more worried about memory UB than the concurrency violation. the concurrency part is simple)
T 1709459531 18<25Widdershins18>	miri makes it so if you so much as accidentally create an intermediate reference when you shouldn't by spelling something in a basically equivalent but different way, it will throw up
T 1709460494 18<26dav1d18>	How can I `cfg(test)` expose something for doctests? Having `#[cfg(any(test, doctest))] pub mod test;` doesn't seem to do it
T 1709460520 18<25Widdershins18>	it doesn't?
T 1709460575 18<26dav1d18>	nope, module not found
T 1709460587 18<26dav1d18>	`unresolved import `enumap::test``
T 1709460601 18<25Widdershins18>	:(
T 1709460636 18<26dav1d18>	:( https://github.com/rust-lang/rust/issues/67295#issuecomment-568287766
T 1709460683 18<26dav1d18>	guess I'll just copy paste into every doctest
T 1709463061 18<26dav1d18>	What trickery am I missing to implement an iterator which yields mutable references form an array? https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=28afe7124468d51f23c63898bfe75944
T 1709463206 18<26dav1d18>	Seems like I'll have to go to unsafe, but meh
T 1709463658 18<26dav1d18>	I finessed it, I think? https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=0cc5e250dc61ce32044e4db239e0d45b
T 1709464322 18<25bertptrs18>	yeah, something like that
T 1709464349 18<25bertptrs18>	there's a reason the default slice iterators use unsafe, to avoid your dance overhead
T 1709464981 18<22gastus_18>	@ polychromata{J}  Want to get the prototype done. Might want to care about arena allocation like etc later. In fact I used C and wrote my own inc based allocation which crashed rust but worked for C and the benefit was small (which was I was told upfront here). Need to proof that merging data from CSV this way actually is faster and worth the effort first compared to eg database. It should be.
T 1709465038 18<22gastus_18>	There is another thing I dont' get yet and that's the unwind to catch panics. Eg when searching there might be unknown symbols which means that find won't find anything (in fact its actually a speedup). So pattern is like try { ..  return true/false} catch { return false }.
T 1709465051 18<22gastus_18>	Maybe passing mut to lambda or such is the way to go.
T 1709465079 18<22gastus_18>	Just sometimes missing the convenience of other languages like ruby begin .. code rescue false end done.
T 1709465115 18<20j`ey18>	you would return a Result, not panic there usually
T 1709465170 18<22gastus_18>	But then I have to write catching the none Some cases..
T 1709465188 18<22gastus_18>	And that's the cool thing about exceptions you don't have to.
T 1709465213 18<20j`ey18>	with the ? operator it's pretty easy to add early returns on Errors
T 1709465404 18<22gastus_18>	So it means Result is to be used instead of Some.
T 1709465450 18<20j`ey18>	Result is used if there could be an error.
T 1709465455 18<20j`ey18>	whereas option is just some or none
T 1709465569 18<22gastus_18>	None in my case means error. So ok_or is the way to go.
T 1709465878 18<22gastus_18>	But then need to turn error case into false. Then need a block within which ? is caught. Then I can use Some and patern matching
T 1709465990 18<20j`ey18>	you cant currently use ? in blocks
T 1709465992 18<20j`ey18>	only functions
T 1709466080 18<20j`ey18>	I guess you could use ? in a closure
T 1709466111 18<22gastus_18>	But then I still need to convert and for two ? its not worth the effort.
T 1709466734 18<25Widdershins18>	you definitely should not be using unwinding for that
T 1709467051 18<22gastus_18>	Widdershins: depends on whether speed or programmers time is important :-/ And that's what annoys me you either have srcipting or compiled. But you cannot mix depending on the part of a project you're working. Not everything is most important. And sometimes its ok to be fast and done and option to optimize later.
T 1709467070 18<22gastus_18>	But let's say you rewriting Dart/js/wahtever to Rust later is huge effort.
T 1709467076 18<25Widdershins18>	dav1d: i'd probably just delegate to core::slice::IterMut
T 1709467120 18<25Widdershins18>	gastus_: i'm saying you're going to waste time and cause lots of problems down the line if you try to it this way instead of learning more ergonomic spellings for these things that already exist
T 1709467147 18<25Widdershins18>	you aren't the only person in the world who needs the kind of control flow you're trying to write. the tools already exist, you just haven't actually asked questions about it yet
T 1709467184 18<22gastus_18>	https://dpaste.com/AU66MTVRY line 72 is one of the stuff I wrote for JS. It basically can create it's own bash completion. It allows to have multiple lazy nested commands done fast.  async ()  or () => or just {} -> it eats everything.
T 1709467217 18<22gastus_18>	Widdershins: which keywords do you suggest me looking up ?
T 1709467242 18<25Widdershins18>	i don't know because i don't know what you're trying to do. you're talking about how results aren't ergonomic to write but you haven't explained what you have
T 1709467304 18<22gastus_18>	I have many CSV files. which contain name/phone .. and they a date like 'company-2023-01-01'. I want to merge all data so that I can query and mix and filter them. Like a person is the same person if they have the same company numebr, the same mobile phone number or have similar name and same zip (this last thing is fuzzy).
T 1709467351 18<22gastus_18>	And because I mostly have like 8 different keys attached I thought that actually representing the data as numbers person is list of attributes. List of attributes is (key, value, list of sources it was found) kinda gets the job done and is memory efficient.
T 1709467387 18<22gastus_18>	Because there are many different ways to query (by GPS location from address, by region such as state, by company) I didn't find a way to make mysql always be fast. So I really was wonedring whether just using 8 threads and filter is easier cause not many users.
T 1709467396 18<25Widdershins18>	sure so what's the issue. i don't see what about this requires intentionally catching unwind
T 1709467418 18<25Widdershins18>	certainly the fact that you have mysql involved is part of your problem. it is a very poor database
T 1709467468 18<22gastus_18>	So searching a phone number which I represent as symbols cause I expect phone numbers to be presented in 20+ csvs the symbol might not exist. So the fun thing is in that case I don't have any work to do to say not found :-) And that was what the case was about mixing the symbol not found with iterating over the people and the attributes.
T 1709467510 18<22gastus_18>	The project is like 10y old and that time I didn't know better. And that's why I investigate bare metal approach to learn from it.
T 1709467564 18<25Widdershins18>	i mean you are just mostly describing indexing all these attributes in memory and skipping the rows with something not-found
T 1709467585 18<26dav1d18>	Widdershins, I'll have to try again, but I think I also needed the Option dance for that to work
T 1709467619 18<22gastus_18>	And because the fuzzy part matching by name / zip depends on task wanted the mixer to be fast and maintainable and adjustable to the task. And loading 300K lines into mysql was like 4h. Now there are 10+ such files. Now thought let me learn Rust and retry using it to learn understand whether the different solution is better and get hands dirty with Rust cause will not go away. And once I understand might
T 1709467625 18<22gastus_18>	get an impression whether I even want to throw away my TS code. Not there yet.
T 1709467629 18<25Widdershins18>	so start with a column that's always unique, iterate over it, and use .filter_map(|..| ...). it's really easy, because the closure returns Option and you can just skip all the ones with not-found using ?
T 1709467632 18<19Wulf18>	I'm stuck with this code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=a74eb6335c9f9de18829bbdd83368e82 . How to fix it?  If it's too large, I can create a smaller testcase for the error.
T 1709467699 18<22gastus_18>	Widdershins: but talking about DBs which one do you consider to be better ? I mean there are som any PG, DuckDB, to name just 2. Each ahvinvg its own sweet spot. PG has geo index mysql doesn't but mysql has cache. So for some stupid cache based workload mysql actually might be a good choice and fast choice without much work.
T 1709467752 18<22gastus_18>	Widdershins: And you hit the nail. I feel like TS has some nice concepts such as typing 'objects' and wonder why nobody misses is using Rust/Java cause some simple fetch as Promise<type here> use scripting like use cases might exist for such languages, too.
T 1709467779 18<22gastus_18>	https://github.com/automerge/automerge-repo.git solve it by having typed and untyped documents and converting between them.
T 1709467798 18<25Widdershins18>	Wulf: you've written code that tries to capture a unique reference to self in not just one but ten different threads
T 1709467821 18<25Widdershins18>	gastus_: postgres is a thousand times better than mysql
T 1709467831 18<25Widdershins18>	mysql does not "have cache"
T 1709467846 18<25Widdershins18>	mysql is almost categorically worse than postgres.
T 1709467852 18<22gastus_18>	https://dev.mysql.com/doc/refman/5.7/en/query-cache.html
T 1709467863 18<19Wulf18>	Widdershins: and I don't know what to do about it. I'm new to rust.
T 1709467864 18<25Widdershins18>	it is very, very hard to come up with any type of scenario where mysql performs better than postgres
T 1709467927 18<25Widdershins18>	gastus_: you've linked to a "feature" that was deprecated 7 years ago in an EOL release line
T 1709467939 18<28darkling18>	It used to be faster than Postgres IIRC, but that was something over 20 years ago. (MySQL prioritised speed; Postgres prioritised correctness).
T 1709467976 18<25Widdershins18>	it hasn't been truly faster than postgres in any typical database scenario any time in the last decade
T 1709467994 18<22gastus_18>	Gonna shut up and listen more.
T 1709467996 18<25Widdershins18>	it's some of the worst software i've ever had the displeasure of being required to use
T 1709468025 18<28darkling18>	Oh, I think there's much worse under the false bottom of that particular barrel. :)
T 1709468030 18<25Widdershins18>	and i've been a senior data engineer for like 7 years now working with quite a few different ones
T 1709468039 18<25bertptrs18>	Saw a beautiful article that tried to establish what exactly it was that the transaction isolation levels in mysql do guarantee, because it surely wasn't what the ANSI SQL spec required
T 1709468042 18<25Widdershins18>	darkling: maybe but you'd be surprised
T 1709468069 18<25bertptrs18>	Found it, this one https://jepsen.io/analyses/mysql-8.0.34
T 1709468070 18<25Widdershins18>	mysql doesn't even have reliable prepared statements in the latest version
T 1709468076 18<22gastus_18>	Widdershins: If you have use cases such as sales with different use currencies. I mean you either can have struct {EUR: currency, USD: currency} or a hash lik thing. Now you want to store and sum in database ? What's the best way to share such datatype with a database without having to implement sum multiple currencies twice ?
T 1709468081 18<25Widdershins18>	and they're not going to fix it
T 1709468121 18<25Widdershins18>	gastus_: sum numeric values grouped by currency
T 1709468154 18<25Widdershins18>	if you want the conversions that combine them to happen inside the database too, no you don't
T 1709468481 18<25bertptrs18>	I try to actively fight including currency conversions in my code. the finance guys can figure that one out
T 1709468642 18<22gastus_18>	I had in mind writing something like a booking platform for campers. And for tihs and others reasons I thought it would be fun to have documents with history builtin. So that wehn merges happens (offline usage) you know what changed and can guide conflict resolution. Kind of key/value store with git like history. So you find branches, you know state last synced with server and changes by user and what
T 1709468648 18<22gastus_18>	has'nt been synced etc. Now with TS everything is an object. You add typing. Done. With Rust ? Now how to store with PG ? Yes you can use JSON and query it. And you can reformat the docs to have final state and reversed history. But querying nested JSON keys kinda feels awkward. And then I wonder over and over again what if a database was a library and I could just share types with my app ? Why do I have
T 1709468654 18<22gastus_18>	to learn multiple programming languages and stored procedures ? You're right PG allows to create my own libraries. But then I am at the issue which is the most convenient way to package and distribute ? And that's a different story if you have a better tahn rust channel to discuss this I'd be interested in your opinion whether I am reinventing the wheel, too. Cause looking at the many github readmes (if
T 1709468660 18<22gastus_18>	youh ave hardawer, then otherwise, .. if you use conda otherwise pip otherwise ubuntu otherwise, ...) kinda sucks and feels like standardised glue code might be missing.
T 1709468663 18<22gastus_18>	And about summing -> you have to take care about rounding of database which could be different from your app.
T 1709468696 18<22gastus_18>	Liek PHP/JS didn't find a way to make both round the same way. I tried hard like 5+ different ways. Then I concluded Haskell like typeclasses might just fix it, but within DB? back at what if DB was a library ..
T 1709468706 18<20j`ey18>	this sounds quite off topoc tbh
T 1709469081 18<25Widdershins18>	you're storing well-structured data as json objects and wondering why it's harder to work with?
T 1709469114 18<25Widdershins18>	we have tools for that, it's called "having a relational schema"
T 1709469150 18<22gastus_18>	But they don't have history :-) So I could derive 'relational data' from it.
T 1709469449 18<25Widdershins18>	Wulf: as it is it looks like every thread is trying to share the whole `self` including the File. most of this will probably work if each worker has its own file handle
T 1709469514 18<22gastus_18>	@ Wulf Do you think its a wise idea to share a file handle across threads have each call read_exact and have it working ? To my knowledge which is limited a file handle gets loned. so if thread 10 seeks it'll gonna change location for running thread 1 ?
T 1709469537 18<25Widdershins18>	gastus_: it doesn't compile at all because the threads are capturing mutable self
T 1709469557 18<25Widdershins18>	that capture by the closure requires self to outlive static
T 1709469591 18<25Widdershins18>	and the fact it's mutable means it can't work at all with multiple threads
T 1709469597 18<19Wulf18>	gastus_: the threads don't seek the file, and reading is protected by the mutex. So there's only one read at a time.
T 1709469650 18<25Widdershins18>	why so many threads then
T 1709469692 18<19Wulf18>	Widdershins: for the hashing part.
T 1709469722 18<19Wulf18>	maybe I'll need to have one thread do the reading and pass blocks into hasher threads?
T 1709469735 18<22gastus_18>	Threads make sense if hashing is slower than loading data from disk which in the future might be the case cause they developed non volatile RAM like SSDs having speed of RAM. When they will be used by majority is a different question.
T 1709469737 18<25Widdershins18>	i guess i don't expect one thread's i/o to be that much faster than the hashing part
T 1709469794 18<19Wulf18>	I can read about 1.5 GiB from my disk, but a single thread can't hash that fast.
T 1709469800 18<19Wulf18>	(per second)
T 1709469818 18<25Widdershins18>	regardless the issue is that while you're getting the ids via the arc, you are using `self.file` without any kind of synchronization, and have a plain &mut ref to `self` captured, which must be unique
T 1709469866 18<19Wulf18>	any way to tell rust that my file is not mutable, while in fact, it is?
T 1709469883 18<25Widdershins18>	i recommend trying to make it so that the information needed for the work done by each thread is encapsulated entirely in a struct which you move deliberately
T 1709469936 18<22gastus_18>	Wulf: Why not use English to describe what you want to do using one sentence such as within a file witihn a region read blocks and hash each one within a thread summing up the results ? The question is interesting like if the disk is the bottleneck one thread is enough. Reading in a sequence is the fastest you can do on physical disks unless you have high fragmentation which might be the only case when
T 1709469942 18<22gastus_18>	asking OS to find the closest chunk which might not be worth it. Ok let's assume youh ave a RAM based disk so reading is fast and digesting is the bottleneck, then .. we're at what you try to do ?
T 1709469966 18<25Widdershins18>	gastus_: read_exact requires a mutable reference to the file
T 1709470006 18<25Widdershins18>	it's not about whether the contents of the file on disk are changing; it's about the fs::File object, in memory, having exclusive access by you which makes writes safe
T 1709470037 18<25Widdershins18>	but you aren't guaranteeing that only one of those references exists. quite the opposite
T 1709470081 18<19Wulf18>	gastus_: For now, I'm trying to create a multi-threaded file hasher. Reads must be sequential for best speed. Hashing must occur in multiple threads because otherwise that's the bottleneck.
T 1709470088 18<19Alexendoo18>	It requires &mut access to the thing that implements Read, &File does implement Read so you don't strictly need exclusive access to File since &mut &File works
T 1709470115 18<25Widdershins18>	Alexendoo: ah
T 1709470119 18<19Alexendoo18>	It may or may not be a bad idea to use
T 1709470131 18<25Widdershins18>	i think then that leaves just the lifetime issue then
T 1709470158 18<25Widdershins18>	in that this is capturing references and then starting in a thread, which isn't allowed
T 1709470166 18<25Widdershins18>	that might have to be an rc
T 1709470233 18<25Widdershins18>	https://doc.rust-lang.org/std/thread/fn.spawn.html requires that the closure be 'static
T 1709470481 18<19Alexendoo18>	since all the handles are being joined std::thread::scope would be a choice
T 1709470585 18<22gastus_18>	@ Wulf after 3 chat gpt iterations you end up with https://dpaste.com/6YTFRSV5C but I am still new to rust. But if you look at such code and move the file reading part up before caling into_par_iter would this just be clean readable code getting the job done ?
T 1709470627 18<22gastus_18>	The question I don't know yet wether into_par_iter will consume all items before starting or will start as fast as the items arrive.
T 1709470752 18<19Alexendoo18>	That wouldn't compile, but rayon is probably what I would use here. Create a synchronous iterator of chunks and then use rayon to process in parallel
T 1709470759 18<22gastus_18>	So typicall such eventually could be done with pipes and back pressure. Eg the thread pool saying 'all busy, don't deliver more items' But not sure what's the right Rust library for that.
T 1709470858 18<22gastus_18>	https://medium.com/@polyglot_factotum/rust-concurrency-a-streaming-workflow-served-with-a-side-of-back-pressure-955bdf0266b5 is from 2020 might be an alternative read to get an idea.
T 1709471397 18<22gastus_18>	@ Wulf tokio might lead to code looking something like this :  https://dpaste.com/GCPTUAYHD   And now you have abstracted away the multi threading part, you have eventually (unchecked) back pressuring and this all is done by tokio / async code which handles the waiting nicefully for you. Not saying its the perfect solution yet. But gives you some ideas. Now the feeding and receiving results is still
T 1709471403 18<22gastus_18>	lacking some abstraction. There might be some .async_map_paralell_iter() whatever ? But you might have the properties you want the main thread reading the bytes, handing the mover to the pool doing teh work and getting back the results.
T 1709471461 18<26dav1d18>	can you stop with this chat gpt garbage?
T 1709471520 18<22gastus_18>	dav1d: Can yout tell me what's garbage about the idea of using iterator, having bytes, backpressure and using async ? Sry truly believed it would be a nice way to turn the task into readable code.
T 1709471569 18<26dav1d18>	gastus_, the code is garbage, just look at `receive_chunk`. If you want to help someone but not write the code, then describe the algorithm or behaviour, don't add garbage code to it that will confuse and mislead readers.
T 1709471645 18<19Alexendoo18>	also tokio to read one file is kinda pointless
T 1709471713 18<19Wulf18>	gastus_: there are lots of subtle bugs. Usually the last block is smaller than the block size. My code handled this, the GPT one doesn't. And I need to use the block hashes as they are computed (and in order). The GPT code collects them all, which means e.g. unbounded memory usage.
T 1709471762 18*	26dav1d thinks copy pasting from chat gpt should be a bannable offense 
T 1709471763 18<19Wulf18>	Alexendoo: I will probably use tokio. The finished program will be a client/server model where one server can handle multiple clients and files.
T 1709471821 18<26dav1d18>	Wulf, you might still want to consider a separate thread (pool) for CPU bound work. Also file io just uses a blocking thread behind the scenes anyways
T 1709471861 18<22gastus_18>	Let me try showing pseudo code :-) which I think is very readable cause it talks about what it does: https://dpaste.com/6DFNHMB97 Whether it can be done with what version of Tokio or similar I lack experience yet.
T 1709471928 18<22gastus_18>	https://dpaste.com/5473YVRCA (indentation fixed sry)
T 1709471998 18<22gastus_18>	line 14 should be using do_work
T 1709472261 18<22gastus_18>	Wulf: That's why I said there is some abstraction missing on top. Like passing the idx for ordering or such. And the last pseudo code would allow to put a buffering stream component in between in case IO turns busy you have like 10 blocks in memory to continue processing cause CPU /calculation might be the bottlenick. Could all be overkill though.
T 1709472366 18<19Wulf18>	Learning rust is hard. I'll go for a walk.  Thanks so far!
T 1709474030 18<22gastus_18>	@Wulf https://users.rust-lang.org/t/does-async-have-a-notion-of-priority/81199 mind the link to "Reducing tail latencies with automatic cooperative task yielding". Wanting to say if you run multiple 'hashing' reqeusts the rest might suffer (?). I've been wondering about prioritizing about JS Promises / networking / Quic etc, too. According to changelog (nov 27 2023) nothing has been added (?).
T 1709523463 19*	Now talking on 22##rust
T 1709523463 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709523463 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709523581 19*	Now talking on 22##rust
T 1709523581 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709523581 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709537703 18<27gastus18>	Wulf:     let (tx, mut rx) = mpsc::channel::<u8>(10);
T 1709537727 18<27gastus18>	Is all you need you can send async/sync to it and it keeps eg 10 items thus once you filled those 10 will apply backpressure.
T 1709546538 18<29neiluj18>	Hiu! Getting the following error for a call to a derive macro: https://bpa.st/AFFA. I'm hesitating between implementing the CanonicalSer/Deser trait for the entire struct or only the E::G1Prepared types, though they would then have to be wrapped in a new struct
T 1709546579 18<29neiluj18>	which option (or other option) you think is best in terms of easy to write?
T 1709547604 18<29neiluj18>	went with a new struct with serializable types only and a function to map the previous struct to the serializable one
T 1709547613 18<29neiluj18>	let's keep it simple
T 1709549304 18<25elichai218>	Is it possible to tell `#[tracing::instrument]` to use the Display impl for the arguments?
T 1709549543 18<26dav1d18>	elichai2, yes, by using %field
T 1709549554 18<26dav1d18>	elichai2, https://docs.rs/tracing/latest/tracing/#recording-fields
T 1709549585 18<20jbg18>	yes, verbosely
T 1709549595 18<20jbg18>	skip_all and then %field for each field
T 1709549599 18<25elichai218>	got it, i'll skip all and manually add back
T 1709557694 18<19nlaerema18>	hello
T 1709557795 18<25bertptrs18>	o/
T 1709561632 18<29alip18>	> warning: dropping unsupported crate type `cdylib` for target `x86_64-unknown-linux-musl`
T 1709561647 18<29alip18>	can i somehow force it to build a dylib or is there just no way?
T 1709561661 18<29alip18>	i mean without installing a glibc toolchain
T 1709561730 18<29alip18>	and/or is there a way to detect this so i can skip tests that dep on the cdylib?
T 1709562160 18<29alip18>	ah nvm figured it out, building with distro rustc works
T 1709563270 18<20jbg18>	alpine has a patch that changes the musl target
T 1709563281 18<20jbg18>	so if your distro is alpine or alpine based, that's why it works
T 1709563331 18<20jbg18>	rust made the questionable early decision to make -unknown-linux-musl targets default to enabling the crt-static target feature, i think because they were focused on the use-case of making 0-dependency binaries
T 1709563350 18<20jbg18>	you can probably build with standard rustc if you disable the crt-static target feature
T 1709564786 18<29alip18>	thanks for the explanation
T 1709566677 18<26dav1d18>	Can I have iter.any or iter.all which separately tells me wether the iterator was empty?
T 1709566690 18<26dav1d18>	Cause I need the exact opposite behaviour of any/all
T 1709566700 18<26dav1d18>	all but if it's empty return false
T 1709566857 18<29phy172918>	Just curious why do you need that? all of nothing being true preserves monoidish properties
T 1709567020 18<26dav1d18>	phy1729, I have an iterator of matching limits, I want to drop a certain item if all of the limits are "passive" (just a bool), but I need to keep it if there is no matching limit
T 1709567099 18<26dav1d18>	I could do peekable and then check for empty I guess
T 1709567103 18<26dav1d18>	but not sure if that's better
T 1709568232 18<25bertptrs18>	any does return false if the iterator is empty
T 1709568275 18<25bertptrs18>	since existance on the empty set is always false, and universality on the empty set is always true
T 1709569894 18<27Ademan18>	is there a good way to make an iterator own some data? I produce some owned data down in a flat_map(), something like `flat_map(|x| { let y = calculate(x); z.thing_that_produces_another_iterator(&y) }` and it needs to live as long as the iterator itself (or at least, the relevant parts of the flat mat?)
T 1709570014 18<29phy172918>	Maybe turn it into an Iterator of Iterators and then flatten?
T 1709570306 18<25bertptrs18>	Ademan: add a move to that closure?
T 1709570711 18<27Ademan18>	isn't y already owned by that closure since it's scoped to it? hrm, this is pretty difficult I think, I couldn't even make like a `struct OwningIterator<T, U, I: Iterator<Item=U> { owned: T, iter: I }` to bundle them together since it would be self referential
T 1709572969 18<25bertptrs18>	ah I misread something, you construct y and then borrow it for your inner iterator
T 1709573101 18<20polychromata{J}18>	dav1d: you can fold() it
T 1709573997 18<26dav1d18>	bertptrs, any is the same as all, if I use any I need to invert the condition, which means I need to invert the result, same problem
T 1709574003 18<26dav1d18>	polychromata{J}, try_fold right?
T 1709574013 18<26dav1d18>	I want to short circuit
T 1709574029 18<20polychromata{J}18>	ah, yeah, you're right.
T 1709574079 18<26dav1d18>	My "solution" https://p.dav1d.de/8Yl.rs
T 1709574087 18<26dav1d18>	I have yet to test it (keep getting side tracked)
T 1709574157 18<25bertptrs18>	Oh I have an even worse idea, thanks for reminding me of filter()
T 1709574199 18<26dav1d18>	lol
T 1709574211 18*	26dav1d waits in anticipation
T 1709574424 18<25bertptrs18>	https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=057e53c5c9ba1e698b21b0b94bd47ec5
T 1709574447 18<25bertptrs18>	using find_map instead of find so the closure can take by value
T 1709574485 18<26dav1d18>	lol
T 1709574504 18<26dav1d18>	I might just use that and confuse everyone, love it
T 1709574580 18<25bertptrs18>	It works and it short circuits, those were my requirements
T 1709574835 18<26dav1d18>	yeah, it's a pretty smart solution, I did think of using find() but discarded it because I never thought about inverting the condition and then checking for none
T 1709574874 18<20polychromata{J}18>	evalr: use std::ops::ControlFlow::{self, *}; fn check<I: Iterator<Item = u128>>(iter: I) -> Option<ControlFlow<bool>> { iter.try_fold(None, |o, n| if n < 159936340279099635845489784282289365899 { Some(Continue(true)) } else { Some(Break(false)) }) }
T 1709574875 -18evalr/22##rust-	polychromata{J}: error[E0271]: type mismatch resolving `<Option<ControlFlow<bool, ...
T 1709574876 -18evalr/22##rust-	polychromata{J}: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=6d4fe0ec41b0c4d5313de7b59fd7ef57
T 1709575118 18<26dav1d18>	`159936340279099635845489784282289365899` that's a big number :D
T 1709575197 18<19int-e18>	close to 2^127 hmm and not prime.
T 1709575929 18<20polychromata{J}18>	evalr: use std::ops::ControlFlow::{self, *}; fn check<I: Iterator<Item = u128>>(iter: I) -> Option<bool> { iter.try_fold(None, |o, n| if n < 159936340279099635845489784282289365899 { Continue(Some(true)) } else { Break(Some(false)) }) } check([].into_iter())
T 1709575931 -18evalr/22##rust-	polychromata{J}: error[E0308]: mismatched types ...
T 1709575932 -18evalr/22##rust-	polychromata{J}: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=cbf42709499938b8cd2878de88126743
T 1709575995 18<20polychromata{J}18>	ah, yeah, and then you have to flatten the `ControlFlow<T, T>`
T 1709576064 18<26dav1d18>	int-e, do you have all primes up to 2^127 in your head? :p
T 1709576084 18<20polychromata{J}18>	evalr: use std::ops::ControlFlow::*; fn check<I: Iterator<Item = u128>>(iter: I) -> Option<bool> { let short_circuit = iter.try_fold(None, |o, n| if n < 159936340279099635845489784282289365899 { Continue(Some(true)) } else { Break(Some(false)) }); match short_circuit { Continue(value) | Break(value) => value } } check([].into_iter())
T 1709576086 -18evalr/22##rust-	polychromata{J}: error[E0596]: cannot borrow `iter` as mutable, as it is not decl ...
T 1709576087 -18evalr/22##rust-	polychromata{J}: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=a4520d439000162fedf13b8f27c3bcc9
T 1709576093 18<20polychromata{J}18>	for Celestia's sake
T 1709576099 18<25bertptrs18>	I don't know about them but factor is in coreutils
T 1709576133 18<20polychromata{J}18>	evalr: use std::ops::ControlFlow::*; fn check<I: Iterator<Item = u128>>(mut iter: I) -> Option<bool> { let short_circuit = iter.try_fold(None, |_, n| if n < 159936340279099635845489784282289365899 { Continue(Some(true)) } else { Break(Some(false)) }); match short_circuit { Continue(value) | Break(value) => value } } check([].into_iter())
T 1709576135 -18evalr/22##rust-	polychromata{J}: None
T 1709576137 18<20polychromata{J}18>	there
T 1709576146 18<26dav1d18>	bertptrs, :o that's neat!
T 1709576198 18<19int-e18>	Hmm `factor` used to be limited to 64 bits or so, so I trained myself to use pari/gp instead.
T 1709576236 18<19int-e18>	(which has a factor() function)
T 1709576246 18<26dav1d18>	polychromata{J}, I appreciate the solution but if that's not hidden away in a dusty module it's quite ugly :p
T 1709576266 18<25bertptrs18>	I used to use it for programming contests and those rarely need primes larger than that
T 1709576307 18<20polychromata{J}18>	dav1d: it would be a lot nicer if there was a ControlFlow::merge(), yeah c.c
T 1709576321 18<20polychromata{J}18>	huh, Result doesn't have such a method either
T 1709576333 18<20polychromata{J}18>	though you can at least do `.unwrap_or_else(identity)`
T 1709576363 18*	20polychromata{J} would probably just write an extension providing merge()
T 1709576367 18<20polychromata{J}18>	(bikeshed the name)
T 1709576407 18<20polychromata{J}18>	…or you could package the whole thing up into an extension on Iterator providing maybe_any() and maybe_all() :P
T 1709576418 18<20polychromata{J}18>	since that's what you really want, after all
T 1709576559 18<26dav1d18>	actually surprised there isnt anything in Itertools 🤔
T 1709576596 18<26dav1d18>	I guess find_or_first would simplify bertptr_s' solution a bit
T 1709576721 18<20polychromata{J}18>	find_or_first() wouldn't distinguish the empty case though
T 1709576794 18<26dav1d18>	polychromata{J}, on empty it would return None right?
T 1709576806 18<26dav1d18>	otherwise it always returns an element
T 1709576816 18<26dav1d18>	actually maybe doesn't even make it easier
T 1709576817 18<20polychromata{J}18>	oh right
T 1709576825 18<20polychromata{J}18>	it doesn't distinguish the /other two/ cases from each other.
T 1709576906 18<20polychromata{J}18>	wow itertools sure has a lot of methods
T 1709576911 18<20polychromata{J}18>	this is more than i remember, too
T 1709577252 18<26dav1d18>	yeah, e.g. I dont remember ever seeing the position_min/max/... ones
T 1709577278 18<26dav1d18>	nvm they exist since at least 0.9
T 1709580265 18<19edgimar18>	What is the best practice related to specifying a consistent version of a crate for use across a cargo workspace.  I have a workspace where one of the crates has a cdylib target that is a facade for functions in several of the other crates.  Is there a good way to ensure that when there is more than one crate that shares the same dependency, the dependencies use the same version?
T 1709580380 18<20polychromata{J}18>	cargo tries to do that automatically. but sometimes crates in the dependency tree depend on incompatible versions of the same crate, and those of course can't be unified
T 1709580399 18<25bertptrs18>	there are workspace dependencies too, where every crate in the workspace gets a certain dependency
T 1709580405 18<26dav1d18>	edgimar, if the versions are semver compatible then they will use the same version, if they aren't then I can't think of anything better than checking the Cargo.lock for duplicates or using cargo tree
T 1709580440 18<25bertptrs18>	https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#inheriting-a-dependency-from-a-workspace
T 1709580719 18<19edgimar18>	bertptrs: thanks, that looks promising.  Maybe unrelated, but I'm trying to diagnose a strange error that just started happening when trying to build, but I can't determine what change would be repsonsible for it:  there are several error messages "cannot find macro println in this scope" for a crate I'm depending on (rstar) - I'm not getting any traceback, besides the line in the rstar code with
T 1709580721 18<19edgimar18>	the println! - wasn't seeing these before, so I'm confused about what I might have changed in my code that would cause that error to occur.
T 1709580776 18<25bertptrs18>	edgimar: are you by chance doing a no_std build on a crate that doesn't support it
T 1709580969 18<19edgimar18>	That would have required changing something in a Cargo.toml file I assume?  I am not building any differently than before.  I did add an nalgebra = "*" dependency in one of my crates where rstar was already a dependency - hm. maybe a clue?
T 1709620790 19*	Now talking on 22##rust
T 1709620790 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709620790 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709622913 18<26daddy18>	Oh, bindgen enables runtime as a default feature, and *insert every sys crate in my stack* uses bindgen with default features
T 1709624425 18<26daddy18>	Is there a way I can build `build.rs` files with a set of RUSTFLAGS that are separate from RUSTFLAGS used on non-build.rs ?
T 1709627166 18<22Arnavion18>	Yes, by not using RUSTFLAGS. Use target.rustflags in .cargo/config.toml instead
T 1709627735 18<26daddy18>	target.<cfg>.rustflags ? what would I use for `cfg()` ?
T 1709627782 18<26daddy18>	I don't think <triple> gives me any way to specify build.
T 1709628069 18<26daddy18>	I'm building on the same system I'll be running it on so I can't specify different triples.
T 1709638053 18<25elichai218>	is there a way with tracing::instrument to bypass rust's fmt machinery and use something faster?
T 1709638369 18<20osse18>	elichai2: to log the files, e.g. args to functions you meaǹ?
T 1709638416 18<25elichai218>	osse: yes, ideally with things like `#[instrument(field(...))]` and `tracing::debug!(...)`
T 1709638427 18<25elichai218>	but the debug/info etc macros I can replace with my own
T 1709638444 18<20osse18>	elichai2: if it's your own type i suppose you can implement the Value trait yourself
T 1709638487 18<25elichai218>	osse it is Sealed though: https://docs.rs/tracing/latest/tracing/trait.Value.html
T 1709638541 18<20osse18>	huh
T 1709638546 18<20osse18>	I don't know, then
T 1709638555 18<20osse18>	the Visit trait isn't, but I don't know if that helps
T 1709638620 18<25elichai218>	but the visitor will still call `record_debug`
T 1709638634 18<25elichai218>	maybe if I directly use the `valuable` crate I could do it
T 1709638817 18<20osse18>	yeah but it's up to use to implement it
T 1709638834 18<20osse18>	I figured you could avoid the implementation of Debug inside it somehow
T 1709639576 18<26dav1d18>	Ignoring endianness issues etc. Am I even allowed to transmute &[f64] to &[u8]?
T 1709639622 18<26dav1d18>	I guess slice length would break, so from_raw_parts 🤔
T 1709639841 18<29neiluj18>	Hey! Trying to implement the Serialize/Deserialize trait for a type implementing the following trait: https://docs.rs/ark-serialize/latest/ark_serialize/trait.CanonicalSerialize.html
T 1709639854 18<25elichai218>	dav1d: no, the length would not match
T 1709639860 18<29neiluj18>	not sure how to turn the writer into a serializer
T 1709639870 18<25elichai218>	you need to deconstruct the slice, multiply the length, and construct a new slice
T 1709639905 18<26dav1d18>	elichai2, yeah, see my second sentence. looking at bytemuck, it should be safe https://docs.rs/bytemuck/latest/src/bytemuck/internal.rs.html#353-372
T 1709639917 18<26dav1d18>	but probably should just use bytemuck in the first place
T 1709639921 18<25elichai218>	yep, f64 has no padding
T 1709639929 18<25elichai218>	so if it's initialized it's safe to read as u8
T 1709639945 18<25elichai218>	all primitives except `bool` don't have paddings
T 1709639955 18<26dav1d18>	and alignment is fine, since u8. The other way probably is not fine
T 1709639963 18<26dav1d18>	right?
T 1709639972 18<26dav1d18>	&[u8] -> &[f64]
T 1709640017 18<25elichai218>	yep
T 1709640026 18<25elichai218>	the other way you need to check and offset alignment
T 1709640060 18<26dav1d18>	Thanks! Always good to have a second opinion on this
T 1709640141 18<25elichai218>	always run your unsafe code through miri ;)
T 1709653736 18<26jess18>	if i'm casting from a u64 and a u32 and would like it to overflow, is there a more correct way to do it that tells clippy that overflow is desired?
T 1709653743 18<26jess18>	from a u64 to a u32*
T 1709653861 18<26jess18>	for context this is for using a u64 siphash as an array index usize for a bloom filter, so overflow is not really a problem for me. it'll get modulo too regardless
T 1709653895 18<25bertptrs18>	you can #[allow(clippy::cast_possible_wrap)] but by default Clippy already allows those
T 1709653910 18<26jess18>	i'm on clippy pedantic
T 1709653947 18<25bertptrs18>	or #[allow(clippy::cast_possible_truncation)] which is more correct imo
T 1709653955 18<26jess18>	just thought there might be some magic function or trait that is "cast this with wrapping please" that would satisfy clippy
T 1709654145 18<26danieldg18>	maybe clippy could learn that (some_u64 & 0xFFFF_FFFF) as u32 can't truncate?
T 1709654201 18<26jess18>	^ no implementation for `u64 & u32`
T 1709654202 18<26danieldg18>	not sure if doing constant-propagation to make that rule nicer is beyond clippy or not
T 1709654203 18<26jess18>	boo sadface
T 1709654221 18<26danieldg18>	well yes, you have to upcast the mask
T 1709654231 18<26danieldg18>	or, you know, literals
T 1709654250 18<25bertptrs18>	you're missing the point, & could automatically downcast since the result should be equivalent
T 1709654279 18<25bertptrs18>	uX & u32 fits in an u32 regardless of X
T 1709654301 18<25bertptrs18>	but automatic conversions are bad™ so I'm happy it doesn't work lioke that
T 1709654301 18<26jess18>	yes, indeed
T 1709654303 18<26danieldg18>	right.  The bitwise and/or ops could easily be implemented for arbitrary sizes
T 1709654309 18<26jess18>	but the compiler doesnt seem to know it
T 1709654351 18<26danieldg18>	I think libcore could impl it
T 1709654365 18<26danieldg18>	but it'd probably break things if you do it now
T 1709654366 18<26jess18>	i can apparently right shift a u64 to a u32
T 1709654377 18<26danieldg18>	I don't think you can
T 1709654384 18<25bertptrs18>	you can shift any int with any other int for some reason
T 1709654401 18<26danieldg18>	isn't it only u32 and maybe u8 on the rhs of the shift?
T 1709654408 18<26danieldg18>	or maybe usize?
T 1709654425 18<26jess18>	oh, im reading the impl wrong
T 1709654441 18<25bertptrs18>	danieldg: no pretty much everything https://doc.rust-lang.org/std/primitive.u128.html#impl-Shl%3C%26i128%3E-for-%26u128
T 1709654449 18<26danieldg18>	huh
T 1709654520 18<25bertptrs18>	there's no reason it works like this, but there is also no reason it shouldn't work so they just did it
T 1709654540 18<26danieldg18>	I guess it's not symmetric, so there's no gain from trying to propagate types through it
T 1709654603 18<26danieldg18>	for | you could have takes_u64(x | y) and it'd end up inferring both x and y are u64 now, but if widening or happens then y could easily get inferred to be i32
T 1709654609 18<26danieldg18>	or maybe u32
T 1709655385 18<22gastus_18>	I want to store pointers to vecs which I eventually want to remove (set to NULL). Now I could be using Option but will take more memory. Would it make sense to have special Option<> type for pointers if they are NULL meaning "no value" so not having to use an enum ?
T 1709655424 18<20j`ey18>	gastus_: do you mean pointers or references?
T 1709655430 18<20j`ey18>	*const T or &T?
T 1709655476 18<26danieldg18>	gastus_: std::ptr::NonNull
T 1709655498 18<26danieldg18>	references already do it
T 1709655534 18<26danieldg18>	Option<NonNull> or Option<&T> are guaranteed to fit in a usize
T 1709655539 18<25bertptrs18>	danieldg: Option<&T> and *const T have the same size
T 1709655585 18<27rendar18>	i always wondered something, if i have `fn myfn(&self) {   for i in &self.data { .. }  .. }`  <- why here we have to use &self.data, if self is already of &Self type ?
T 1709655589 18<20j`ey18>	but not Option<*const T>
T 1709655606 18<26danieldg18>	rendar: self is the object
T 1709655608 18<25bertptrs18>	rendar: because otherwise self.data would attempt to move out of self, which it can't
T 1709655634 18<25bertptrs18>	and if it can, you might not want it to
T 1709655672 18<27rendar18>	bertptrs, ok, right, so it's just a further notation to remark the user: look you're traversing and not moving out
T 1709655695 18<27rendar18>	it would be very messy code in the other way, indeed
T 1709655725 18<25bertptrs18>	well you could move data out of self and then traverse it, which does something different, but unless data is Copy you can't
T 1709655766 18<26danieldg18>	"let Self { data, .. } = self; for i in data { .. }" does the same thing as &self.data
T 1709655778 18<27rendar18>	oh right
T 1709658822 19*	Now talking on 22##rust
T 1709658822 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709658822 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709660283 18<27n118>	 is here a way how to tell compiler that a method should be included only for "lib" use? i mean the #[cfg...
T 1709660316 18<26segfaultfizzbuzz18>	suggestions for a rust library for transforming markdown into an html form, or for a markdown parser which i could easily extend (as a bad programmer) to have form elements?
T 1709660380 18<20j`ey18>	n1: what do you mean for 'lib' use?
T 1709660397 18<20j`ey18>	if it's part of a non-binary crate, it's always for a library?
T 1709660438 18<27n118>	j`ey: i use my rust app as a dependency in another project - i suppose it turns into a "lib" mode (dunno how to phrase it better) when tne intrypoint in lib.rs instead of main.rs
T 1709660488 18<20j`ey18>	n1: yes
T 1709660532 18<27n118>	the thing is this... i have a method that is not used in binary mode (thus i get unused warning) but it's used in lib mode
T 1709660537 18<27n118>	does if make sense j`ey ?
T 1709660541 18<27n118>	it*
T 1709660553 18<20j`ey18>	n1: what file is that method in?
T 1709660607 18<27n118>	src/config.rs
T 1709660636 18<20j`ey18>	n1: and you have mod config in src/lib.rs?
T 1709660679 18<27n118>	yes
T 1709660689 18<27n118>	pub mod config; to be exact
T 1709660699 18<27n118>	re-export
T 1709660716 18<26danieldg18>	n1: you should *not* have 'mod config' in main.rs then
T 1709660730 18<26danieldg18>	you should 'use yourcrate::config' in main.rs
T 1709660755 18<29JordiGH18>	Hey, any of you use Prisma? What are your impressions? I'm trying to find a fun Rust project to work on that people enjoy using and care about. Prisma came to mind, but I'm not sure if it's loved or not.
T 1709660769 18<27n118>	danieldg: i need that line there because i use that file in both modes - only one particular method is not used in binary mode
T 1709660833 18<20j`ey18>	n1: no dont have mod config in main.rs
T 1709660842 18<20j`ey18>	n1: you should 'use' the library crate from the binary one
T 1709660994 18<27n118>	im lost ... i removed the "mod config;" line from my main.rs - now im getting tons of errors of "unresolbed import"
T 1709661015 18<26danieldg18>	n1: remove all 'mod' lines in main.rs
T 1709661022 18<20j`ey18>	'use <yourcratename>::config;'
T 1709661023 18<26danieldg18>	unless the module is only for the binary
T 1709661146 18<27n118>	j`ey: done - but now im getting another couple of errors that weren't there before
T 1709661175 18<20j`ey18>	tell us, and we can help fix it
T 1709661178 18<20j`ey18>	otherwise, we cant :P
T 1709661321 18<27n118>	sure ... but that seems like a random error of "cannot fined a method from a trait" or value of this type cannot be build from that type
T 1709661334 18<27n118>	looks like someone just f'ked my code :)
T 1709661361 18<26danieldg18>	n1: if you are still duplicating 'mod' lines, then you'll get that
T 1709661378 18<26danieldg18>	because you will define two different types with the same name
T 1709661389 18<27n118>	so i guess the real question is what the "substitude 'mod config' with 'use <cratename>::config;'" really does
T 1709661425 18<26danieldg18>	it removes the duplication
T 1709661457 18<27n118>	https://dpaste.com/B6LW487LG head of my main file before the errors
T 1709661476 18<27n118>	once i comment out line 3 and uncommet line 10 i get the errors
T 1709661494 18<26danieldg18>	... read what I said
T 1709661499 18<26danieldg18>	17:50:15 < danieldg> n1: remove all 'mod' lines in main.rs
T 1709661525 18<27n118>	just like that? not needed anymore?
T 1709661541 18<26danieldg18>	you may need to replace them with 'use' lines
T 1709661571 18<27n118>	okay i didnt get that
T 1709661573 18<27n118>	will try
T 1709661676 18<27n118>	https://imgur.com/a/1EZ6H4c
T 1709661686 18<27n118>	even worse lol
T 1709661723 18<26danieldg18>	no, you now have a TODO list for fixing your lib
T 1709661735 18<26danieldg18>	make things you need public, or remove the use if you don't need it
T 1709661930 19*	Now talking on 22##rust
T 1709661930 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709661930 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709662034 18<27n118>	that sounds like "to make that one particular method hidden from bin-mode you have to rewrite all the imports"
T 1709662040 18<27n118>	thats nuts to me
T 1709662086 18<26danieldg18>	the problem is that the way you were doing it was wrong
T 1709662112 18<26danieldg18>	it worked, but you had two copies of your code
T 1709662119 18<27n118>	what exactly was wrong? i was acting based on tutorials where every part of my app needs to be "mod"ed
T 1709662141 18<27n118>	>two copies of your code - what do you mean exactly?
T 1709662144 18<26danieldg18>	that's true if you only have a main.rs
T 1709662148 18<26danieldg18>	or only a lib.rs
T 1709662163 18<26danieldg18>	having both means you're making two crates, one that depends on the other
T 1709662213 18<20spb18>	you put all of your library code into the library crate. you make your binary crate depend on the library crate. things in the library that aren't used by the binary are not dead code because they're exported from the library
T 1709662219 18<20spb18>	it's quite simple
T 1709662322 18<27n118>	okay so instead of one monolith i need to separate (it is but probably imported wrongly) my code - right?
T 1709662389 18<20spb18>	the best answer depends on what you're actually doing and the specifics of your particular design
T 1709662489 18<27n118>	i guess i will just go with that one warning ig
T 1709662526 18<27n118>	but ... im curious whats the difference between mod and use thing that you suggested
T 1709662563 18<26danieldg18>	the tutorial should tell you about them
T 1709662568 18<26danieldg18>	or the docs do
T 1709662569 18<27n118>	my guess it's that moding hard-"imports" all the stuff but on the other hand the "use" really imports what i need
T 1709662580 18<20spb18>	your library and your binary are different crates. the binary implicitly depends upon the library. by writing 'mod' in both, you are including the code of those files into both crates and duplicating it
T 1709662596 18<20spb18>	by writing 'use' in the binary, you just refer to the version that was already built as part of the library
T 1709662673 18<27n118>	makes sense
T 1709662690 18<27n118>	do i need to ad some stuff to cargo too? or just update my "imports"?
T 1709662731 18<20spb18>	first you need to stop using "import" to refer to something that is not importing
T 1709662768 18<20spb18>	and no, you do not need to change anything in cargo because, as i said above, the binary crates within a project implicitly depend on the library crate
T 1709662804 18<27n118>	so once a lib.rs exists the binary is suddenly dependend on the lib - right?
T 1709662833 18<20spb18>	yes
T 1709662892 18<27n118>	maybe i got enlighted - i try it once again - the thing is i need to move all my mods to lib.rs and then use what i actually need in my main.rs - right?
T 1709662909 18<27n118>	so basically my lib is the library and main comes in and says what it needs
T 1709662930 18<27n118>	and the libs knows all the "books" thanks to "mod"s
T 1709662935 18<27n118>	am i right?
T 1709663013 18<20spb18>	any code that is a part of the library should be included only in the library, i.e. a 'mod' declaration for it should appear only in lib.rs or something included from lib.rs
T 1709663026 18<27n118>	right
T 1709663028 18<20spb18>	any code that is a part of *only* the binary, you can declare the 'mod' in main.rs
T 1709663046 18<20spb18>	and any code which is a part of the library and is used by the binary, you 'use' in the binary code
T 1709663111 18<20spb18>	note that if you have multiple modules in play, then using src/main.rs and src/lib.rs will be very confusing because you can't tell from just the folder structure whether a given module is in the lib or the bin
T 1709663146 18<27n118>	the code is 99% used in binary ... actually it was 100% as long as the whole app was a cli app - now i did add a few stuff so i can use the app as a dependency and use the functionality programatically instead of from CLI - so thats why i did add a few methods which are use in "dependecy" mode only
T 1709663207 18<20spb18>	if you want to make the code usable as a library, then you need to go all in on the idea and make your binary just be another consumer of that library
T 1709663231 18<27n118>	i see
T 1709663236 18<27n118>	damn it :)
T 1709663245 18<27n118>	thx for your time spb
T 1709667679 19*	Now talking on 22##rust
T 1709667679 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709667679 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709674383 19*	Now talking on 22##rust
T 1709674383 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709674383 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709674611 18<20nullie18>	What can I do here to pass store correctly: https://gist.github.com/nullie/d5f02dcd8ae84b1b94a128ee66155984
T 1709676051 18<20polychromata{J}18>	nullie: not familiar with wasm, but it looks like binding is keeping the borrow of store around. Since you seem to need binding throughout, you'll have to find a way to get it to not keep the borrow past the call to exports(), or else use shared ownership of store.
T 1709676198 18<25chairs18>	maybe you don't need to use the same `store` everywhere? (I'm also not familiar with wasm so don't know)
T 1709676363 18<20nullie18>	no, it panics if you pass other store
T 1709676497 18<20nullie18>	I don't get why does it need store for those calls
T 1709676559 18<25chairs18>	another guess: maybe you're supposed to save the output of `.func()` and only use it later after `binding` has gone out of scope
T 1709676621 18<20nullie18>	yeah, looks like .func() result is copiable
T 1709676812 18<25chairs18>	s/gone out of scope/can be dropped/ # I don't think you need to play explicit scoping games here, but doing so might help with understanding the issue as usual with lifetimes
T 1709676886 18<20nullie18>	yeah, I have to drop binding before I can use store again
T 1709686297 19*	Now talking on 22##rust
T 1709686297 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709686297 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709686745 18<25Widdershins18>	danieldg: I'm curious what makes Cheri pointers and size ints different widths
T 1709686808 18<26danieldg18>	cheri pointers are 128 bits; they store validity information in addition to the usual 64-bit start position
T 1709686941 18<26danieldg18>	so technically you could just declare usize to be u128, but that's really inefficient as the maximum allocation is still well below u64::MAX
T 1709687128 18<25Widdershins18>	oh man it's architecturally capability-based?
T 1709688763 18<20polychromata{J}18>	danieldg: why so? why not just `size.next_multiple_of(align) * len`?
T 1709688774 18<20polychromata{J}18>	(. You broke `slice::from_ref()`.)
T 1709688782 18<20polychromata{J}18>	…ahh
T 1709688848 18<26danieldg18>	yep
T 1709688853 18<20polychromata{J}18>	and you /could/ require padding after every allocation of a T, but at that point `{ size: 5, align: 4 }` is kind op meaningless.
T 1709688882 18<26danieldg18>	requiring padding after every allocation is exactly today
T 1709688906 18<26danieldg18>	since you can't actually use the padding, if your memcpy could overwrite it
T 1709688916 18<20polychromata{J}18>	yep.
T 1709688988 18<20polychromata{J}18>	just not worth it to save a few bytes here and there when you have some `struct(u8, u32);`s.
T 1709689015 18<26danieldg18>	better support for repr(packed) is about the best we could do
T 1709689031 18*	20polychromata{J} nods.
T 1709689067 18<20polychromata{J}18>	That way, the usecases that really want to squeeze bytes out, and are okay trading cycles to get them, can make that decision.
T 1709689109 18<26danieldg18>	and with modern cpu and memory speeds, that's true a lot more of the time than you might think
T 1709689180 18<26danieldg18>	if your data is >1MB you will likely get a speedup from packing it
T 1709689204 18<26danieldg18>	unless you're doing a lot more compute than usual on it
T 1709690265 18<20polychromata{J}18>	really? huh.
T 1709690275 18*	20polychromata{J} imagines a PackedVec…
T 1709690292 18<20polychromata{J}18>	the iterators would have to be streaming though.
T 1709690420 18<26danieldg18>	yes, it makes all your code ugly and doesn't work well if you want atomics or anything like that
T 1709690482 18<26danieldg18>	often performance isn't that critical, or you aren't actually saturating the memory bus, or other reasons
T 1709696328 18<25Widdershins18>	you can already get the best packing possible other than alignment overhead by just reordering fields (by descending alignment requirement), but if the fields themselves have alignment overhead the waste starts to add up
T 1709696367 18<26danieldg18>	yes, and that's pretty common
T 1709696380 18<25Widdershins18>	mhm
T 1709705791 19*	Now talking on 22##rust
T 1709705791 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709705791 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709711813 18<22shamelessshill18>	Hello, good folks. I have a rather simple but strange question.
T 1709711839 18<22shamelessshill18>	So in my project, I have a bunch of crates... and I have a script that bumps up versions.
T 1709711878 18<20osse18>	So far so good
T 1709711888 18<22shamelessshill18>	So, my question is this - if my script bumps up the version in the Cargo.toml files for each of my crates, it should be fine if the same script bumps up the versions in Cargo.lock as well, yes?
T 1709711913 18<22shamelessshill18>	We check in Cargo.lock into version control, and the version update step is done as a separate commit (no dependencies added, etc.)
T 1709711934 18<22shamelessshill18>	I thought of running a build and the adding the generated Cargo.lock, but that seems like overkill?
T 1709711987 18<22shamelessshill18>	Otherwise right now I observe that the crate versions (my own crates) in the lockfile are falling behind the toml versions because people keep forgetting to check in the lock file (nor should they have to, imho).
T 1709712044 18<22shamelessshill18>	and overkill since all the changes are for my own crates (not deps) and only the version string would change to match that in the TOML file... I'm not adding any dependencies during this version bumping step.
T 1709712048 18<22shamelessshill18>	Thoughts?
T 1709712078 18<22shamelessshill18>	I thought of checksum issues, but we don't track checksums in the lock file for our own crates, do we? Only for external dependencies.
T 1709712105 18<22shamelessshill18>	Any other issues that come to mind?
T 1709712534 18<20polychromata{J}18>	shamelessshill: simplistic editing of the lockfile sounds like a good way to break things
T 1709712573 18<20polychromata{J}18>	do you know what happens if the lockfile specifies a crate with a version that has a dependency, but doesn't say anything about that dependency?
T 1709712575 18<20polychromata{J}18>	(I don't.)
T 1709712589 18<20polychromata{J}18>	how about `cargo generate-lockfile`?
T 1709712663 18<22shamelessshill18>	Hmmm
T 1709712683 18<20polychromata{J}18>	actually…isn't the overall thing you're trying to do just `cargo update`?
T 1709712709 18<22shamelessshill18>	It is true that right now the script is run as a separate independent "version change only" step, but that __requires__ developer discpline. You're right - I don't like the idea myself.
T 1709712732 18<22shamelessshill18>	polychromata{J}: Wouldn't `cargo update` update the dependencies as well?
T 1709712741 18<22shamelessshill18>	Even minor/patch versions, I mean.
T 1709712749 18<25bertptrs18>	correct, so you don't want that
T 1709712751 18<22shamelessshill18>	I think cago generate lockfile looks promising... polychromata{J} ... TIL
T 1709712794 18<22shamelessshill18>	bertptrs: Yes, indeed. Let me experiment with generate lockfile and see...
T 1709712855 18<22shamelessshill18>	Oops... looks like generate-lockfile also updates
T 1709712857 18<22shamelessshill18>	:(
T 1709713114 18<25bertptrs18>	so it does, that's annoying
T 1709713129 18<25bertptrs18>	I guess you could get awaym with `cargo check` instead of a full build?
T 1709713207 18<22shamelessshill18>	Actually, I found something that does appears to work: `cargo update --workspace`
T 1709713219 18<25bertptrs18>	that should still update deps if I read the docs?
T 1709713224 18<22shamelessshill18>	"--workspace Attempt to update only packages defined in the workspace. Other packages are updated only if they don’t already exist in the lockfile. This option is useful for updating Cargo.lock after you’ve changed version numbers in Cargo.toml.
T 1709713228 18<22shamelessshill18>	"
T 1709713231 18<25bertptrs18>	ooooh
T 1709713232 18<22shamelessshill18>	__Seems__ to work
T 1709713233 18<25bertptrs18>	that's brilliant
T 1709713239 18<22shamelessshill18>	Let me double-check! :)
T 1709713245 18<25bertptrs18>	somewhat misnamed but w/e
T 1709713247 18<22shamelessshill18>	bertptrs: Yeah... beautiful indeed!
T 1709713259 18<22shamelessshill18>	Yeah, I would never have guessed with that flag name.
T 1709713299 18<22shamelessshill18>	Yup... appears to work! So polychromata{J} was right after all. Hehehe.
T 1709713333 18<20polychromata{J}18>	…that's a really bad name for that flag.
T 1709713338 18<20polychromata{J}18>	Good find though.
T 1709713364 18<22shamelessshill18>	Indeed... I only happened to even go to that doc page because the generate-lockfile docs said that `update` had more options... so pure luck!
T 1709714493 18<27gastus18>	I want to experiment with non utf-8 fast csv parsing and wanted to create ffi bindings to zsv now bindgen fails to find some definitions. Is it best to manually convert or is bindgen supposed to understand all header files and my configuration is incomplete ?
T 1709714545 18<25bertptrs18>	bindgen doesn't understand all header files, and you usually have to make it ignore things
T 1709715593 18<27rendar18>	in your experience, do you think exist one crate which abstracts Box<&str> and adds useful traits (e.g. From, etc) ?
T 1709715611 18<27rendar18>	i mean, Box<Rc<&str>>
T 1709715664 18<27rendar18>	i want to create |1 ptr size poiting to| --->  |ref_count|my string data|
T 1709715710 18<25Mutabah18>	`Rc<str>` is a fat pointer to counts and string data
T 1709715714 18<25bertptrs18>	That's just Rc<str>
T 1709715720 18<25Mutabah18>	although, maybe you'd want a string interning crate
T 1709715786 18<25bertptrs18>	nvm, Rc<str> is two pointer size because of the fat pointer
T 1709716189 18<27rendar18>	Mutabah, no, i don't want a global state to check
T 1709716238 18<27rendar18>	i wish to get only 1 pointer size, like a Box, but also a ref counter for cheap cloning
T 1709716250 18<27rendar18>	can i combine the 2 things?
T 1709716268 18<27rendar18>	having only 1 heap allocation that contains both ref counter and string data
T 1709716350 18<25bertptrs18>	Not right now, there is no nice way to create DSTs from rust
T 1709716386 18<25bertptrs18>	your allocation would have to store |len|rc|data|
T 1709716529 18<27rendar18>	bertptrs, yes sorry, i meant just that one
T 1709716537 18<27rendar18>	rc+len+data
T 1709716544 18<27rendar18>	in one unique block, isn't that possible?
T 1709716567 18<25bertptrs18>	Creating dsts yourself is annoying but it's not impossible I guess
T 1709716577 18<25bertptrs18>	You have to basically do it without language support
T 1709716598 18<27rendar18>	what you mean with DSTs?
T 1709716605 18<25bertptrs18>	dynamically sized types
T 1709716610 18<27rendar18>	i see
T 1709716612 18<25bertptrs18>	types that do not have a fixed size\
T 1709716614 18<25bertptrs18>	such as str
T 1709716658 18<25bertptrs18>	or slices
T 1709716680 18<27rendar18>	bertptrs, well, Box<str> is not dinamically sized type, because sizeof(Box<str>) is 8 (1 pointer size), then it allocates N bytes on heap, just like Vec<u8> which is 24 in sizeof, but then it allocates N bytes on heap, am i wrong?
T 1709716704 18<25bertptrs18>	wrong, sizeof Box<str> is 16
T 1709716715 18<25bertptrs18>	because str is a DST
T 1709716715 18<27rendar18>	because of the fat pointer?
T 1709716718 18<25bertptrs18>	Correct
T 1709716721 18<27rendar18>	yeah
T 1709716726 18<27rendar18>	what about Box<&str> ?
T 1709716734 18<25bertptrs18>	That one is indeed size 8
T 1709716752 18<27rendar18>	indeed, but Box<&str> is a pointer pointing to |len|data..| ?!
T 1709716757 18<27rendar18>	or just data?
T 1709716794 18<27rendar18>	or is a pointer pointing to |len|ptr_to_data|    which in turn points to |data..| ?
T 1709716794 18<25bertptrs18>	Box<&str> is pointing to an &str which is contains a length and a pointer to the data
T 1709716812 18<27rendar18>	so with Box<&str> i get 2 heap allocations per string?
T 1709716830 18<25bertptrs18>	not necessarily heap allocations (can use a static str after all) but yes two indirections
T 1709716845 18<27rendar18>	oh gosh :| i see
T 1709717028 18<27rendar18>	now i get the purpose of a crate that tried to fix this problem, and had strings of 2 pointer size
T 1709717213 18<27rendar18>	https://crates.io/crates/tendril
T 1709717228 18<27rendar18>	that's is! i found it, doesn't this crate does what i need?
T 1709717328 18<25Mutabah18>	Maybe it is
T 1709717338 18<25Mutabah18>	Depends on why you want those single-pointer strings
T 1709717356 18<25Mutabah18>	What you were asking for reminds me of the `RcString` type I have in mrustc (... in C++, but same idea)
T 1709717370 18<25Mutabah18>	A pointer to a refcount, length, and then string data
T 1709717509 18<27rendar18>	Mutabah, that's simple: consider a very large hasmap with strings as keys, i don't need them to be mutable, still i will spare a lot of memory not having 24 bytes for each string
T 1709717522 18<27rendar18>	what is mrust?
T 1709717586 18<25bertptrs18>	Mutabah's Rust Compiler
T 1709717728 18<27rendar18>	really?
T 1709718047 18<27synapse18>	I have a colleague who uses Result<(), ()> instead of bool. in a way, I kinda get why 'return Err(());' is more readable than 'return false;' :P
T 1709718065 18<25Mutabah18>	`Result` carries more semantic information than a `bool`
T 1709718085 18<25Mutabah18>	is `false` "operation failed" or is it "don't worry about me"?
T 1709718096 18<27synapse18>	yeah, it's answering a generic question
T 1709718106 18<27synapse18>	whereas Result<(), ()> is always whether some operation went well
T 1709718962 18<20mkoncek118>	and allows ? shortcut
T 1709719216 18<27Affliction18>	Caller probably still needs to map_err it into something sane, but yeah, I might start using that pattern
T 1709719237 18<25bertptrs18>	nothing matches! can't fix
T 1709719245 18<27Affliction18>	true
T 1709719245 18<25bertptrs18>	Or just is_ok()
T 1709720984 18<26kpcyrd18>	I'd still use anyhow::Result<T>, then provide a simple message for bail!. the few bytes in the binary for a &'static str shouldn't hurt.
T 1709721019 18<26kpcyrd18>	I use anyhow::Result<()> quite often
T 1709722802 18<20mkoncek118>	no method named `poll` found for mutable reference `&mut (dyn Future<Output = ()> + 'static)` in the current scope
T 1709722829 18<20mkoncek118>	i have a vector of Box<dyn Future>
T 1709722864 18<20mkoncek118>	also, should i be using PollFn instead?
T 1709722874 18<26dav1d18>	Is there a nice way to just take the first item from a &mut [T]?
T 1709722918 18<26dav1d18>	`take_first` is of course nightly
T 1709722938 18<25bertptrs18>	split_at_mut can kind of do it but it's not perfect
T 1709722939 18<26dav1d18>	guess I'll just have to do split_first :(
T 1709722948 18<25bertptrs18>	oh split_first too
T 1709723032 18<26dav1d18>	aight thanks
T 1709723034 18<25bertptrs18>	mkoncek1: is the Future trait in scope? Not sure if it's part of the prelude
T 1709723228 18<20mkoncek118>	oh right, poll is not a member function
T 1709723237 18<20mkoncek118>	fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;
T 1709723245 18<20mkoncek118>	the first arg is not a reference to self
T 1709724341 18<25bertptrs18>	No it's a pin, because the requirements for Future are slightly stronger. poll is a member though
T 1709724377 18<25bertptrs18>	Members are allowed to take Pin, Arc, Rc, Box, or any combination of them as their self
T 1709725321 18<20mkoncek118>	really? didn't know about that
T 1709725343 18<25Widdershins18>	and don't forget native references that counts too
T 1709725365 18<25Widdershins18>	altho idk how much you can layer it actually
T 1709725459 18<25Widdershins18>	&&self isn't allowed, but self: &Box<Self> is
T 1709725481 18<25Widdershins18>	i guess that's 'cause && just decays to &
T 1709725482 18<20spb18>	https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=90eec5e4a7a77b0663fd3db944c5a929
T 1709725499 18<20spb18>	`a.foo()` doesn't compile in that case
T 1709725526 18<25Widdershins18>	ah you can do it then it just doesn't let you implicitly type it like &self
T 1709725584 18<20spb18>	i'm not sure in what situation this would be useful, mind
T 1709725600 18<25Widdershins18>	ok yeah even deranged types like &Rc<&Box<&&Self>> are allowable for method receivers. but yeah not very useful, you won't see it much
T 1709725630 18<25Widdershins18>	usually it is like `self: Box<Self>` so that you can take ownership of the value via a box instead of the value itself
T 1709725661 18<25Widdershins18>	otherwise anything that would receive &Box<Self> you can just let it decay to &self by dereferencing
T 1709725914 18<25bertptrs18>	There's the Wake trait that takes Arc<Self> and &Arc<Self>
T 1709725971 18<25Widdershins18>	&arc so you don't have to mess with the count by cloning it
T 1709725990 18<25bertptrs18>	Exactly
T 1709726114 18<25bertptrs18>	but rather than making an arbitrary decision on what makes sense, the standard just allows all combinations
T 1709728181 19*	Now talking on 22##rust
T 1709728181 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709728181 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709731269 18<20mkoncek118>	*const () is a synonym for *const std::ffi::c_void?
T 1709731352 18<25Mutabah18>	no, although they are sometimes used interchangably
T 1709731367 18<25Mutabah18>	`()` is an empty tuple, a zero-sized type`
T 1709731388 18<25Mutabah18>	`c_void` is the de-facto representation of C's `void` type, and is iirc an enum
T 1709732011 18<25bertptrs18>	that's a strange representation of void https://doc.rust-lang.org/src/core/ffi/mod.rs.html#209-224
T 1709732128 18<20j`ey18>	one variant I can maybe understand... but 2??
T 1709732132 18<25Mutabah18>	See the comment above
T 1709732156 18<20j`ey18>	ah
T 1709732231 18<25bertptrs18>	I read the comment but I don't know enough LLVM internals to make sense of it
T 1709732895 18<20mkoncek118>	do i need the futures create to await a future? is there nothing like block_on in the vanilla Rust?
T 1709733134 18<25bertptrs18>	there isn't
T 1709733160 18<20mkoncek118>	well, async_std has one
T 1709733161 18<25bertptrs18>	you can try my minimal executor, beul, which is 84 lines and does the absolute minimum
T 1709733169 18<25bertptrs18>	async std isn't std
T 1709733179 18<20mkoncek118>	i know but i am already using it
T 1709733209 18<25bertptrs18>	you asked about vanilla ¯\_(ツ)_/¯
T 1709733357 18<25bertptrs18>	std doesn't offer one because it is unclear what a general purpose executor should do
T 1709733380 18<25bertptrs18>	tokio and async_std both offer much more than just futures execution, and most of the things they offer only work on their own runtimes
T 1709733853 18<20mkoncek118>	well... execute an asynchronous function as a synchronous one in the current thread is not an unreasonable request is it?
T 1709733869 18<25bertptrs18>	it doesn't sound unreasonable
T 1709733886 18<25bertptrs18>	but tokio::time::sleep() cannot be executed by any runtime other than tokio
T 1709733936 18<25bertptrs18>	and it's not the only one, many futures require some specialized plumbing from their runtime to do anything useful
T 1709733955 18<26danieldg18>	mkoncek1: by the time you have a non-trivial future, you already need some kind of reactor running to cause the wakeups
T 1709733971 18<20mkoncek118>	i am starting to wonder if i should try to use async at all
T 1709733988 18<26danieldg18>	so delegating the wait to that just makes sense.  Tokio, for example, supports a single-thread model which would deadlock forever if you had and used that method.
T 1709734036 18<25bertptrs18>	std needs to be very conservative in what it adds, because everything included stays forever. it's not impossible that one day std does have an executor, but until people agree what it should do, it won't be added any time soon
T 1709734068 18<26danieldg18>	it's very likely it would end up pluggable like the allocator in std anyway
T 1709734118 18<25bertptrs18>	I have my doubts, since the allocator story isn't moving either
T 1709734123 18<26danieldg18>	there are more reasons to want to change how task scheduling works than changing how allocation works after all
T 1709734138 18<26danieldg18>	I'm talking about GlobalAlloc which has been stable for quite a while
T 1709734156 18<26danieldg18>	and has already switched between jemalloc and system malloc
T 1709734160 18<25bertptrs18>	Ah yeah that works, mostly
T 1709734224 18<26danieldg18>	similar to having one allocator for the process, having one executor for the process is normal
T 1709734249 18<26danieldg18>	yes it's possible to have more than one of each, but that's pretty niche
T 1709734249 18<20mkoncek118>	we had a task at uni comparing 4 allocators: GNU, jemalloc, Intel something and one more, i don't exactly remember but i think jemalloc was the best whereas GNU was consistent
T 1709734294 18<20mkoncek118>	what is the price jemalloc pays for its speed tho?
T 1709734326 18<25bertptrs18>	jemalloc is huge, which is why rust switched back to system malloc
T 1709734405 18<28erk18>	rust the compiler still uses jemalloc as well.
T 1709734437 18<28erk18>	bertptrs: jemalloc is already system malloc (if you use FreeBSD which I think is rather unlikely)
T 1709734662 18<25bertptrs18>	I think also on macOS making it a bit more common
T 1709734800 18<25bertptrs18>	On the other hand, if you're building for Alpine it's a good idea to use jemalloc because musl's allocator isn't built for performance
T 1709735024 18<27Guest1118>	Hola
T 1709735452 18<20mkoncek118>	is std::ops::Fn treated specifically by the compiler syntax-wise?
T 1709735473 18<20mkoncek118>	help: use parenthetical notation instead: `FnMut() -> ()`
T 1709736722 18<25bertptrs18>	Fn/FnOnce/FnMut have special syntax to write out the function signature, yesa
T 1709737117 18<27n118>	spb: hey ... to our yesterday conversation about "imports" bin vs lib .... i looked into the problem again with fresh mind and it's indeed pretty much straighforward and works nice ... i was probably tired more than i thought that i couldn't get it .... so once again thanks for your help
T 1709739812 18<27rendar18>	Rust uses jemalloc by default?
T 1709739825 18<25bertptrs18>	it doesn't AFAIK
T 1709739896 18<26dav1d18>	no it does not
T 1709739924 18<26dav1d18>	most (all?) our systems at $job have it explicitly configured though
T 1709739926 18<20j`ey18>	(it did in the past)
T 1709739946 18<25bertptrs18>	(until people complained loudly that the 2MB binary wasn't worth it)
T 1709740235 18<29saati18>	didn't it perform pretty suboptimal on some workloads?
T 1709740412 18<25bertptrs18>	AFAIK the size was the main argument, and it has a slightly larger memory footprint than libc while not performing better in single-threaded context
T 1709743423 18<27rendar18>	mimalloc is pretty neat
T 1709747312 18<25Mikachu18>	i thought that shadowing a variable in the same scope it was declared would drop it, turns out i was wrong
T 1709747384 18<19tokie18>	Mikachu: thankfully no. it is VERY useful in rust :)
T 1709747399 18<20polychromata{J}18>	try `let mut foo = a(); foo = b();` :)
T 1709747498 18<25Mikachu18>	in my case i had a refcell foo, let foo_inner = foo.borrow_mut(); let foo_inner = foo_inner.clone(); or so (i also wanted to assign it so i did need to use borrow_mut), and was surprised to get a panic later, explicit drop fixed it
T 1709747604 18<19tokie18>	usually i wouldn't do something like let foo_inner ..., since shadowing lets you let foo = foo.borrow_mut();
T 1709747618 18<19tokie18>	like, unlike C++ you don't have to keep coming up with names for inner parts of things
T 1709748097 18<26danieldg18>	it's always a good idea to explicitly drop locks if you care about when they unlock
T 1709748703 18<26dav1d18>	rendar, thanks that's interesting
T 1709748714 18<26dav1d18>	I have an urge to try it out
T 1709748752 18<27rendar18>	dav1d, good! let me know
T 1709748802 18<26dav1d18>	gonna pitch to to some colleagues cause I am pretty swamped with other stuff atm :(
T 1709749079 18<27rendar18>	no probl
T 1709749095 18<27rendar18>	dav1d, what kind of software is that, if i may ask?
T 1709749156 18<26dav1d18>	rendar, processing pipeline and first API layer from Sentry
T 1709749175 18<26dav1d18>	e.g. symbolication of stacktraces is one big part, the other is just the API which accepts all traffic
T 1709749184 18<27rendar18>	i see
T 1709749210 18<27rendar18>	so do you work for sentry.io?
T 1709749244 18<26dav1d18>	rendar, yep
T 1709749255 18<27rendar18>	great, where are you based?
T 1709749419 18<26dav1d18>	rendar, Vienna
T 1709749431 18<27rendar18>	very cool
T 1709749445 18<26dav1d18>	if you mean me, Sentry also has an office in canada and sf
T 1709749463 18<27rendar18>	yeah i saw it in their website
T 1709749527 18<26dav1d18>	unfortunately we dont seem to have any results of jemalloc vs system alloc but overall it fixed a memory fragementation issue we were seeing while also improving performance
T 1709749558 18<27rendar18>	yeah, i think mimalloc will further improve perf
T 1709749606 18<19tokie18>	dav1d: you work for sentry/
T 1709749608 18<19tokie18>	?
T 1709749636 18<26dav1d18>	tokie, yes
T 1709749640 18<19tokie18>	cool !:D
T 1709749643 18<26dav1d18>	:D
T 1709749650 18<19tokie18>	i know sentry!:D
T 1709749661 18<26dav1d18>	I hope only good memories
T 1709749671 18<19tokie18>	it catches my panics
T 1709749685 18<26dav1d18>	it also catches our own panics lol
T 1709750010 18<19tokie18>	well, it's cool to know sentry is a rust shop!
T 1709750498 18<26dav1d18>	tokie, and we're moving a lot more to Rust!
T 1709750529 18<19tokie18>	oh cool!
T 1709750541 18<26dav1d18>	recently replaced a bunch of kafka consumers already
T 1709750545 18<19tokie18>	so are we!:D
T 1709750546 18<26dav1d18>	more to come
T 1709750577 18<19tokie18>	i'm at CF and lots of rust going on
T 1709750618 18<26dav1d18>	CF as in cloudflare? Another one :D
T 1709750646 18<19tokie18>	yeah
T 1709750662 18<26dav1d18>	cool
T 1709750763 18<28erk18>	It is getting out of hand, now there are two of them
T 1709750810 18<25Mikachu18>	let state = &mut *state.borrow_mut(); why on earth does this work?
T 1709750815 18<19tokie18>	erk: two of who?
T 1709750842 18<28erk18>	Cloudflare people on irc
T 1709750847 18<19tokie18>	oh there's more than that
T 1709750942 18<26bwidawsk18>	I'm having some trouble deciding between anyhow (eyre), thiserror crates. I'm writing a test harness (ie. library like). Generally speaking, most test clients will not care about the specific type of error, and mostly just report out what the error was as part of the test suite. I started off with anyhow, then switched to thiserror, but now feel like thiserror might not actually be necessary here. Any thoughts?
T 1709751008 18<28erk18>	Mikachu: You are doing a reborrow of it, which is something that can give a bit of a headache sometime
T 1709751030 18<25Mikachu18>	get_mut() refused to give me a &mut T because i only have a & on the refcell, but somehow i can get one anyway?
T 1709751053 18<20spb18>	bwidawsk: those two crates solve quite different problems, and anyhow's doc suggests using thiserror alongside it
T 1709751055 18<28erk18>	What you are doing is essentially &mut *(&mut bla)
T 1709751109 18<28erk18>	ahh Mikachu it is the borrow_mut on refcell and not in the trait.
T 1709751113 18<25bertptrs18>	Mikachu: RefCell allows you to get an &mut from an &, and it will enforce at runtime that only one of those is ever live
T 1709751116 18<26bwidawsk18>	spb: sure, though I feel like the more anyhow integration I get, the less thiserror actually does anything for me
T 1709751122 18<26dav1d18>	Mikachu, borrow_mut doesn't give you a mut pointer directly, it gives you a type which implements DerefMut
T 1709751128 18<28erk18>	that borrow_mut will panic if you are not allowed to do that https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.borrow_mut
T 1709751143 18<26bwidawsk18>	spb: aiui, you really want thiserror if you want to be able to disambiguate errors
T 1709751154 18<26bwidawsk18>	and anyhow if you don't really care
T 1709751169 18<25bertptrs18>	well, you can care with anyhow
T 1709751183 18<25bertptrs18>	but in general: anyhow (eyre) for binaries, thiserror for libraries
T 1709751195 18<26bwidawsk18>	yeah, I'm just sort of a hybrid
T 1709751217 18<26bwidawsk18>	I suppose it might make sense to keep using both for me
T 1709751245 18<25Mikachu18>	erk: but when i do this, the RefMut immediately goes out of scope (it was never even given a binding), so how do i still have a &mut to the data?
T 1709751249 18<26bwidawsk18>	internal APIs - thiserror. public APIs that are used directly by tests, anyhow
T 1709751297 18<20spb18>	anyhow and relatives are for when you just want to propagate "an error occurred" upwards and maybe print it for human consumption, but don't care about calling code being able to programmatically handle different error types
T 1709751303 18<25Mikachu18>	i'll just accept it as magic for now
T 1709751315 18<20spb18>	this usually happens in application code, and usually shouldn't be in a library's public api
T 1709751391 18<28erk18>	Mikachu: That is the part that is the reborrow, you can find some blogs and similar about it, but it is one of the features of the borrow system that is harder to wrap your head around
T 1709751589 18<20spb18>	Mikachu: i think the magic phrase you're looking for is 'temporary lifetime extension' - see e.g. https://blog.m-ou.se/super-let/
T 1709751672 18<20spb18>	tl;dr: sometimes, if a relatively simplistic set of rules are met, the lifetime of a temporary created inside a 'let' statement will be extended to match the binding created by the let
T 1709751695 18<25Mikachu18>	i see
T 1709752757 18<20Guest018>	Come have sex with me on my profile phone
T 1709752831 18<20Guest018>	Primero haga clic en este enlace > https://ln.run/3zIyD
T 1709752832 18<20Guest018>	Y completa todas las opciones y luego muestra tu tarjeta, pero no te preocupes, es totalmente gratis.
T 1709752872 18<20Guest018>	hello darling
T 1709756888 18<26daddy18>	i'm getting "undefined symbol" a bunch of times for a specific library, when linking statically to a library even though I have `cargo:rustc-link-lib=static=gmp`. What can I use to see where that linking is happening/failing ?
T 1709757842 19*	Now talking on 22##rust
T 1709757842 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709757842 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709759057 18<25bertptrs18>	weird bug, after upgrading axum to 0.7 (and fixing all the breaking changes) my laptop no longer has enough RAM to compile my project
T 1709759195 18<25bertptrs18>	Memory usage jumped from a peak of 500MB to a over 6GB, that ain't right
T 1709759269 18<25bertptrs18>	how do you even debug this
T 1709759302 18<25bertptrs18>	eh, I'll update everything but axum for now, then
T 1709759399 18<29alip18>	can someone please tell me why .map(drop) is used here: https://docs.rs/nix/latest/src/nix/unistd.rs.html#3095-3110 i don't get why it's needed
T 1709759490 18<25bertptrs18>	alip: from looking at some other stuff, it's their preferred way to go from Result<T, E> to result<(), E>
T 1709759497 18<19tokie18>	bertptrs: yikes
T 1709759504 18<19tokie18>	i run out of memory if i try to do a coverage build
T 1709759508 18<19tokie18>	with 16GB dedicated ...
T 1709759524 18<25bertptrs18>	tokie: also axum? ouch, that's one heck of a regression
T 1709759529 18<29alip18>	bertptrs: ah makes sense, thank you
T 1709759536 18<19tokie18>	bertptrs: not axum, but a big tokio project
T 1709759556 18<25bertptrs18>	tokio is not being bumped in my case
T 1709759560 18<25bertptrs18>	hyper is tho
T 1709759564 18<19tokie18>	hrm
T 1709759671 18<25bertptrs18>	If I had time I'd go to their discord and figure it out, but I have a deadline to meet
T 1709759686 18<25bertptrs18>	and a bedtime I guess but the deadline wins
T 1709761941 18<25Widdershins18>	thus far i've successfully avoided going to anyone's discord to try to get anything fixed. miserable platform, the howling void at the end of knowledge, the enclosure in which history dies
T 1709761967 18<25Widdershins18>	discord is for shitposting with my weird friends, not for collecting knowledge
T 1709763042 18<29mefistofeles18>	whereas IRC is for shitposting with randoms
T 1709763050 18<29mefistofeles18>	:P
T 1709763169 18<26daddy18>	IRC is for solving the toughest problems known to man via shitposting with randoms.
T 1709774324 19*	Now talking on 22##rust
T 1709774324 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709774324 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709777424 18<26swansone18>	simple question I'm having a surprisingly hard time googling: In the scope of a function, is there a way to do something like `use MyLongNamedEnum::{*}` so I don't have to keep typing MyLongNamedEnum::SomeVariant?
T 1709777482 18<26danieldg18>	yes
T 1709777497 18<26swansone18>	Oh wait, that just literally works, doesn't it
T 1709777504 18<26danieldg18>	:)
T 1709777508 18<26swansone18>	That's what I get for not trying it
T 1709777671 18<25Mutabah18>	:D
T 1709777702 18<25Mutabah18>	IMO, better would be to `use MyLongNamedEnum as En;`
T 1709777719 18<25Mutabah18>	just becuase then it's clearer what each name refers to, and you avoid accidentally making a bind pattern.
T 1709777735 18<25Mutabah18>	... One day, I'll write up a RFC for inferred enum names
T 1709777744 18<25Mutabah18>	`match foo { _::BarVariant => ... }`
T 1709777801 18<29phy172918>	That'd be handy because it should be obvious
T 1709777842 18<25Mutabah18>	I think last time I tried I also got nerd-sniped into `_::new(...)` too
T 1709777968 18<26swansone18>	An alias is a great suggestion Mutabah, thanks! I'll do that.
T 1709786353 19*	Now talking on 22##rust
T 1709786353 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709786353 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709787188 19*	Now talking on 22##rust
T 1709787188 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709787188 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709790361 19*	Now talking on 22##rust
T 1709790361 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709790361 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709808329 19*	Now talking on 22##rust
T 1709808329 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709808329 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709810810 19*	Now talking on 22##rust
T 1709810810 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709810810 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709810905 18<28lmat18>	Affliction: Thank you, very helpful!
T 1709811590 19*	Now talking on 22##rust
T 1709811590 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709811590 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709812293 18<29nox18>	I don't remember what Servo uses
T 1709815474 18<28erk18>	nox: Now it uses tungstenite through the async_tungstenite crate.
T 1709816620 18<29Guest6718>	hey
T 1709816697 18<20osse18>	teacher
T 1709816702 18<20osse18>	leave those kids alone
T 1709817348 19*	Now talking on 22##rust
T 1709817348 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709817348 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709821317 18<29Luisa1418>	hey
T 1709823986 18<25bertptrs18>	not going to do it again
T 1709824195 18<26dav1d18>	lol
T 1709824864 18<27n118>	i would like to cross compile for my Samsung Exynos5422 ARM - how do i exactly detect the architecture "name" for cargo target?
T 1709824898 18<20j`ey18>	aarch64-unknown-linux-gnu
T 1709824938 18<27n118>	how did u figure?
T 1709824985 18<20j`ey18>	because I do arm stuff :P
T 1709825016 18<20j`ey18>	but tbh, Im not sure it's that easy, if youre running android. maybe termux will allow you to run stuff
T 1709825047 18<27n118>	it's my odroidhc2
T 1709825058 18<27n118>	from what i know it's 32bit
T 1709825061 18<27n118>	thats why i asked
T 1709825090 18<20j`ey18>	oh I googled and thought it was 64-bit
T 1709825152 18<27n118>	i know it's armv7
T 1709825157 18<27n118>	LE
T 1709825162 18<20j`ey18>	then I dont know, probably: arm-unknown-linux-gnueabhf or something
T 1709825162 18<27n118>	thats all i know
T 1709825194 18<27n118>	um...how do i decide between gnuabi and musleabi?
T 1709825256 18<25bertptrs18>	generally if you're on musl, you know
T 1709825288 18<27n118>	i was thinking exactly the same :)
T 1709825302 18<19tokie18>	bertptrs: lol
T 1709825306 18<19tokie18>	"you know. ugh."
T 1709825366 18<27n118>	so last question - if i choose wrong target for compilation do i get the error right away on app startup or it can run and fail later because of wrong architecture (mainly gnu vs musle)?
T 1709825400 18<25bertptrs18>	yeah, it will fail to load shared libs and crash
T 1709825424 18<27n118>	cool
T 1709825457 18<25bertptrs18>	if it doesn't crash at that stage (or before that, if you got the ABI very wrong and the thing isn't even recognized as an executable)  it should work
T 1709825466 18<27n118>	looks like i narrowed down the list to 2 candidates: armv7-unknown-linux-gnueabi and armv7-unknown-linux-gnueabihfOD
T 1709825477 18<27n118>	(without the OD)
T 1709825486 18<25bertptrs18>	hf stands for hardware float
T 1709825506 18<25bertptrs18>	some arm chips don't have hardware support for floating point numbers and must emulate it in software
T 1709825527 18<27n118>	since dpkg says the architecture is armhf should i go for the later one?
T 1709825567 18<25bertptrs18>	yes. and if not, I still would've guessed hf since I can't imagine a vendor selling an android phone that doesn't need to deal with floats
T 1709825626 18<27n118>	so hf is almost always the case?
T 1709825652 18<25bertptrs18>	basically, I think the original pi didn't have hardware float but that's about it
T 1709825659 18<25bertptrs18>	it's rare
T 1709825669 18<25bertptrs18>	armv8 stopped making the distinction
T 1709825690 18<27n118>	cool thanks
T 1709829179 18<22gastus_18>	https://dpaste.com/78F84NYEJ Line 19 / 29  already borrowed. The borrow is no longer needed there ? Is there a simple fix?
T 1709830027 18<25Mikachu18>	gastus_: if let Some(ref h) = *(*my....borrow() { ... } else { // borrow_mut should be fine in here }
T 1709830105 18<22gastus_18>	That's nice ! :-)
T 1709830189 18<27sword_smith18>	Damn! Compilation takes forever now :( https://github.com/TritonVM/triton-vm
T 1709830202 18<27sword_smith18>	When faster rustc?
T 1709830236 18<20j`ey18>	sword_smith: rustc is gettng faster!
T 1709830263 18<27sword_smith18>	j`ey: I just saw a YouTube video about that, that it was faster on nightly :)
T 1709830337 18<27sword_smith18>	CI takes 46 minutes on ubuntu, 87 on macos.
T 1709830426 18<22gastus_18>	But also failed :-(
T 1709830440 18<27sword_smith18>	gastus_: yikes!
T 1709830445 18<27sword_smith18>	I don't think so...
T 1709830798 18<27jbowen18>	I have a program where I'd like to have a small list of primes defined as a constant, but it feels gross sticking it at the top of my src/main.rs. In C I'd have some file that I'd #include at the top of my main.c
T 1709830838 18<27jbowen18>	What's the idiomatic way to do that within a Rust simple source tree?
T 1709830840 18<20j`ey18>	jbowen: make a module
T 1709830855 18<20j`ey18>	src/primes.rs, 'mod primes' at the top of main.rs
T 1709830994 18<27jbowen18>	Cool, thank you, j`ey!
T 1709831026 18<27jbowen18>	I think I was initially put off by the word "module" feeling like a much heavier weight solution
T 1709831090 18<20j`ey18>	nope :)
T 1709836956 18<26dav1d18>	sword_smith, https://github.com/Swatinem/rust-cache 👀
T 1709836990 18<26psyprus18>	Q
T 1709837003 18<26psyprus18>	sorry ignore
T 1709846652 18<27sword_smith18>	dav1d: thanks. But it's not dependencies that are slow to build, but the repo itself.
T 1709846671 18<27sword_smith18>	however, other repos depend on it. So there might be something there.
T 1709934726 19*	Now talking on 22##rust
T 1709934726 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709934726 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709934879 18<25Diablo-D318>	https://rolldown.rs/
T 1709934885 18<25Diablo-D318>	remember when I said dont use rust for evil?
T 1709934896 18<25Diablo-D318>	this is somewhere on the evil continuum
T 1709934898 18<20polychromata{J}18>	ugh
T 1709934916 18<25Diablo-D318>	people, please, dont feed the javascript trolls
T 1709935464 19*	Now talking on 22##rust
T 1709935464 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709935464 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709935634 19*	Now talking on 22##rust
T 1709935634 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709935634 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709936054 19*	Now talking on 22##rust
T 1709936054 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709936054 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709966630 19*	Now talking on 22##rust
T 1709966630 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709966630 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709969040 19*	Now talking on 22##rust
T 1709969040 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709969040 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709975301 19*	Now talking on 22##rust
T 1709975301 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709975301 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709975326 18<20polychromata{J}18>	Ah, never mind. Looks like i just had to change the /sort metric/ dropdown.
T 1709975355 FiSHLiM plugin unloaded
T 1709975561 19*	Now talking on 22##rust
T 1709975561 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709975561 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709975717 18<29nox18>	danieldg, daddy: Re: TLS overhead: just do RPK
T 1709975761 18<29nox18>	https://datatracker.ietf.org/doc/html/rfc7250#section-1
T 1709978956 19*	Now talking on 22##rust
T 1709978956 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709978956 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709979069 18<25Widdershins18>	nox: oh man is there a rust TLS library that has mutual RPK support
T 1709979116 18<25Widdershins18>	i want it so bad. x509 is suffering
T 1709979128 18<29nox18>	Widdershins: boring ha a rpk feature
T 1709979202 18<25Widdershins18>	i suppose that would work. i had a lot of trouble a year (or two?) ago when i was trying to figure out how to do this in boringssl directly
T 1709979398 18<28lmat18>	I am computing an average of one property of a vec of structs:   data.iter().map(|e| e.val).sum() / data.len()   The error I get is, "
T 1709979430 18<28lmat18>	"cannot infer type of the type parameter `S` declared on the method `sum`". I tried    sum<f64>  (f64 being the type of e.val), but that appears to be bad syntax.
T 1709980395 19*	Now talking on 22##rust
T 1709980395 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709980395 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709980607 18<28lmat18>	How do I print a tab character? I tried  print!("{}  ", val);  and print!("{}{}", val, "  "); but both are getting the tab expanded.
T 1709980616 18<28lmat18>	This is in the context of a unit test
T 1709980631 18<28lmat18>	(I'm printing a table that I would like to paste into libre-office --calc.
T 1709980787 18<26dav1d18>	evalr, println!("\tfoo\tbar\t123")
T 1709980789 -18evalr/22##rust-	dav1d: 	foo	bar	123
T 1709980804 18<28lmat18>	dav1d: Thank you!
T 1709981536 18<29nox18>	Widdershins: Btw https://github.com/rustls/rustls/issues/423
T 1709981564 18<25Widdershins18>	nox: eyes emoji
T 1709981686 18<25Widdershins18>	> I don't know if it's theoretically possible to send a valid 1GB certificate during the handshake phase, and I don't want to have to know this, I'd rather just avoid X509. We don't need a self-driving car to crack a nut.
T 1709981689 18<25Widdershins18>	lol same brother
T 1709981793 18<20polychromata{J}18>	lmat: I don't see any reason why tabs in the source file should get transformed. Are you sure it's not your editor doing that? :)
T 1709981841 18<28lmat18>	polychromata{J}: I'm pretty sure it's not my editor (vim with :set noexpandtab), but I would guess it's happening at another layer.
T 1709981881 18<26dav1d18>	Widdershins, you can borrow these 👀
T 1709981885 18<20polychromata{J}18>	evalr: let tab = '	'; (tab, u32::from(tab))
T 1709981887 -18evalr/22##rust-	polychromata{J}: error: character constant must be escaped: `\t` ...
T 1709981888 -18evalr/22##rust-	polychromata{J}: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=71740193290e88d342282b37fa9d0840
T 1709981923 18<20polychromata{J}18>	evalr: let tab = "	"; tab.chars().next()
T 1709981925 -18evalr/22##rust-	polychromata{J}: Some('\t')
T 1709985357 18<19Wulf18>	Is that the right syntax to move a value out of an inner block?   { let x: u32; { x = something(); }  workon(x); }
T 1709985678 18<20polychromata{J}18>	Yeah, that works.
T 1709985746 18<20polychromata{J}18>	Sometimes `let x = { other_things(); x }; work_on(x);` is nicer.
T 1709985857 18<19Wulf18>	indeed, that's nicer. And I didn't know I could do this. Thanks!
T 1709986027 18<20polychromata{J}18>	something something most things are expressions :)
T 1709986275 18<25Widdershins18>	blocks? expressions. if conditionals? expressions. for loops? return statements? expression. module? ok actually that's an item
T 1709986358 18<19Wulf18>	There is no ++ operator like in C, right?  let foo = { *bar++ }; won't work?  let foo = { *bar += 1; *bar - 1 }; works, but I don't like it.
T 1709986374 18<25Widdershins18>	`let` declarations aren't expressions but assignments to those variables are
T 1709986440 18<25Widdershins18>	Wulf: postfix incr/decr is deeply discouraged in c++ these days for a reason :) *especially* if you care to use it as a value expression
T 1709986476 18<19Wulf18>	Widdershins: suggestions how I can rewrite above code?
T 1709986513 18<25Widdershins18>	i don't know, what type is bar
T 1709986519 18<19Wulf18>	Widdershins: u32
T 1709986634 18<25Widdershins18>	Wulf: why not `let foo = *bar; *bar += 1;
T 1709986650 18<25Widdershins18>	don't get fancy
T 1709986659 18<19Wulf18>	Widdershins: I need to acquire a mutex in the inner scope.
T 1709986688 18<25Widdershins18>	well, have you shown me that? was i supposed to guess?
T 1709986787 18<19Wulf18>	Widdershins: I was hoping that you'd guess that I somehow need that inner scope.
T 1709986808 18<25Widdershins18>	you're hoping that i'll answer a question you haven't asked
T 1709986816 18<25Widdershins18>	you should ask it, and present the problem
T 1709986967 18<25Widdershins18>	inner scopes like that are rarely truly needed due to how the borrow checker works, they are just nicer to spell
T 1709988023 19*	Now talking on 22##rust
T 1709988023 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709988023 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709989839 18<25yziquel18>	Really weird issue. appears only with rust code (other languages seem to be fine) when dealing with virtiosfd filesystems on guest machines with --cache=never on host.
T 1709989881 18<25yziquel18>	https://github.com/cross-rs/cross/issues/1313#issuecomment-1986847352
T 1709990400 18<29saati18>	do the other programs try to mmap it?
T 1709990415 18<29saati18>	ENODEV on mmap means the fs does not support memory mapping
T 1709991215 19*	Now talking on 22##rust
T 1709991215 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1709991215 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1709997465 18<25yziquel18>	seems rust tend to use MAP_SHARED in mmap more than MAP_PRIVATE. I see that by comparing git and gix.
T 1709997508 18<26danieldg18>	this really depends on what you're mapping more than just counting things
T 1709997562 18<26danieldg18>	also, the two are basically identical unless you (the mapper) are writing to the file
T 1709997620 18<26danieldg18>	if someone else is writing, MAP_PRIVATE has some nasty undefined behavior corner cases
T 1709998102 18<25yziquel18>	danieldg your assumption (almost identical) is violated in my setup: I running rust code in a VM on a filesystem using virtiofs with a zfs backend on the host.
T 1709998156 18<25yziquel18>	and disabling caching in virtiofsd. (with caching, seems like coherency is not enforced enough for the "No such device" error to pop up in the guest)
T 1709998226 18<25yziquel18>	MAP_SHARED seems to ask for more than MAP_PRIVATE than qemu is prepared to hand over in terms of memory mapping of files.
T 1709998280 18<26danieldg18>	yes, MAP_SHARED wants better guarantees with regards to modifications
T 1709998344 18<25yziquel18>	danieldg this make rust code more difficult in a VM with virtiofs and no caching.
T 1709998383 18<25yziquel18>	more difficult to run
T 1709998402 18<26danieldg18>	I have no idea why you would want to do that, but ok
T 1709998423 18<26danieldg18>	mostly it's the linker that does this, for shared objects
T 1709998432 18<25yziquel18>	danieldg disaster recovery ? my last CPU died in a bang. I'm mounting my former computer as a VM.
T 1709998435 18<26danieldg18>	so not rust's problem at all
T 1709998455 18<26danieldg18>	virtiofs is *not* the preferred way to do that
T 1709998472 18<25yziquel18>	danieldg and what is the prefered way ?
T 1709998484 18<26danieldg18>	hand the VM the actual block devices
T 1709998491 18<26danieldg18>	or images thereof
T 1709998511 18<25yziquel18>	danieldg I've been bugging the incus / lxd chat room to pass the block device. They basically told me to shut up.
T 1709998532 18<26danieldg18>	virtiofs is for sharing files you want to access on both systems
T 1709998585 18<26danieldg18>	I have no idea what incus is
T 1709998596 18<25yziquel18>	incus = fork of lxd.
T 1709998600 18<26danieldg18>	and isn't lxd a container thing?
T 1709998613 18<25yziquel18>	danieldg yes. a container, with some support for vm.
T 1709998628 18<26danieldg18>	so your problem is that you aren't using a real VM
T 1709998641 18<26danieldg18>	yes, a container should be using a shared FS like this
T 1709998654 18<26danieldg18>	but a container is not the solution to "run my old system in a VM"
T 1709998660 18<25yziquel18>	danieldg perhaps. my problem is that no one gives advice.
T 1709998673 18<26danieldg18>	have some advice: use a VM
T 1709998677 18<25yziquel18>	no. I'm using a QEMU vm managed by incus.
T 1709998682 18<25yziquel18>	not a container.
T 1709998697 18<26danieldg18>	it's pretty easy to pass block devices to a VM
T 1709998717 18<26danieldg18>	you can't have them mounted in the host if you do that, though
T 1709998733 18<20spb18>	in every setup i've used it's pretty difficult *not* to pass block devices to a VM
T 1709998737 18<25yziquel18>	danieldg I haven't had any clue as to how mount the block device with incus,
T 1709998745 18<26danieldg18>	this feels like an incus bug
T 1709998755 18<25yziquel18>	Spawns_spb try it with incus. good luck.
T 1709998758 18<25yziquel18>	spb
T 1709998758 18<26danieldg18>	use libvirt or one of the nice gui frontends to it
T 1709998781 18<25yziquel18>	danieldg ok. one more month toying with ANOTHER vm framework. cool,
T 1709998785 18<26danieldg18>	if incus is meant to be a container thing, their VM support is probably half-baked
T 1709998796 18<20spb18>	i'd really rather not, if it's all the same to you
T 1709998803 18<20spb18>	if you want a VM, use a VM solution
T 1709998804 18<25yziquel18>	danieldg i kind of figured that out indeed.
T 1709998845 18<25yziquel18>	spb well, I want a container feel to it. will look at kata containers at one point.
T 1709998880 18<26danieldg18>	then this is a limitation of virtiofsd
T 1709998892 18<26danieldg18>	or a bug there
T 1709998894 18<25yziquel18>	still, the MAP_SHARED issue remains an issue with rust + no caching virtiofs. This isn't going away just because I use something else.
T 1709998910 18<26danieldg18>	it will go away if you don't use virtiofs with no caching
T 1709998915 18<26danieldg18>	(why no caching?)
T 1709998917 18<25yziquel18>	danieldg seems that it is a virtiofs bug.
T 1709998936 18<26danieldg18>	rust is by far not the only thing using MAP_SHARED
T 1709998951 18<26danieldg18>	if virtiofs can't do it, virtiofs is not ready for use
T 1709998956 18<25yziquel18>	danieldg no caching matters because I can't index the VM with things like sudo updatedb is caching is allowed. it blows up the number of file descriptors on the host.
T 1709998987 18<26danieldg18>	... so I'm reading virtiofs is buggy again
T 1709998994 18<25yziquel18>	danieldg i'll try to bother a virtiofs chatroom then.
T 1709999001 18<26danieldg18>	it's not hard to not blow up fd counts
T 1709999011 18<26danieldg18>	samba servers, NFS servers, etc all do it
T 1709999025 18<26danieldg18>	you could also just raise that limit
T 1709999044 18<25yziquel18>	danieldg I've been unable to find the correct limit to raise and where to raise it.
T 1709999054 18<25yziquel18>	danieldg spent a month on it.
T 1709999068 18<26danieldg18>	/etc/security/limits.conf, ulimit, or the /proc/sys setting
T 1709999078 18<20spb18>	that's still not a rust problem, and therefore quite off-topic for here
T 1709999091 18<26danieldg18>	the virtiofs people should know what to do about *their* bug
T 1709999110 18<25yziquel18>	danieldg I did try all that. something is not clear. and I won't ask people to help me again on that since they obviously think I bother them.
T 1709999122 18<26danieldg18>	ok
T 1709999168 18<25yziquel18>	spb it's a problem that occurs specifically for rust code. and that does impact people doing things in vms. on apple mostly, it seems, from what I gathered.
T 1709999224 18<26danieldg18>	you'll hit it in C code too
T 1709999235 18<25yziquel18>	danieldg haven't yet.
T 1709999291 18<26danieldg18>	ok
T 1709999977 18<20spb18>	yziquel: no, it's nothing specific to rust code. it just happens that the first time you encountered it was in rust code, which is not the same thing at all
T 1710001106 18<25yziquel18>	spb I'm not sure. I'm wondering if the rust stdlib is not overly restrictive.
T 1710001112 18<25yziquel18>	spb we'll see
T 1710001421 18<26dav1d18>	yziquel, what dose that have to do with the std lib
T 1710001483 18<26danieldg18>	rust std doesn't mmap at all
T 1710001516 18<25yziquel18>	dav1d as many many many rust code fails, I suspect it should be somewhere down the stack. possibly in stdlib.
T 1710001536 18<26dav1d18>	yziquel, it's not, there is no mmap in the std lib
T 1710001537 18<25yziquel18>	danieldg then it should be somewhere down the stack not in stdlib
T 1710001637 18<26danieldg18>	you also never said how it fails
T 1710001647 18<26danieldg18>	but whatever, I already pointed you to how to solve it
T 1710001935 18<20capitol18>	is there a way to differentiate in build.rs if your crate is being built as a dependency or as the "final target"? When the crate is a library
T 1710001973 18<26danieldg18>	print out the various environment variables, I suspect there's a CARGO_* one that might be relevant
T 1710002030 18<20capitol18>	i have been trying to investigate CARGO_PKG_NAME and CARGO_CRATE_NAME, but without success
T 1710002040 18<20capitol18>	but good idea to print all of them
T 1710002339 18<25yziquel18>	danieldg I did say how it fails.
T 1710002358 18<25yziquel18>	danieldg https://github.com/cross-rs/cross/issues/1313#issuecomment-1986847352
T 1710002369 18<25yziquel18>	danieldg up in the chat log.
T 1710002433 18<26danieldg18>	oh, so it's not a rust bug, it's a gix bug
T 1710002458 18<25yziquel18>	daniel it also occurs in cargo build
T 1710002460 18<25yziquel18>	danieldg
T 1710002485 18<25yziquel18>	danieldg and people running rust in a VM report that kind of bug in bug reports.
T 1710002503 18<26danieldg18>	right; the bug is "various things assume that mmap works and don't have a fallback"
T 1710002519 18<25yziquel18>	danieldg yes.
T 1710002537 18<25yziquel18>	a "somewhere in rust ecosystem" + virtiosf bug.
T 1710002540 18<26danieldg18>	no
T 1710002557 18<26danieldg18>	it's just people using mmap that don't want to handle the failure
T 1710002569 18<26danieldg18>	mostly because it doesn't happen on normal filesystems
T 1710002582 18<26danieldg18>	it happens in C code too
T 1710002590 18<25yziquel18>	danieldg I'll have to hunt down things to the source code before pointing fingers about people not handling the failure.
T 1710002611 18<26danieldg18>	yziquel: you've done so already
T 1710002630 18<25yziquel18>	danieldg no. I've used strace. I haven't seen the corresponding source code.
T 1710002653 18<26danieldg18>	ok
T 1710002686 18<26danieldg18>	but yes, rust has an mmap wrapper that lets you specify shared or private mapping
T 1710002723 18<26danieldg18>	and I suppose the default is probably shared
T 1710002819 18<26danieldg18>	yeah, memmap2 supports both private and shared - it calls it map_copy and map, respectively
T 1710002834 18<25yziquel18>	danieldg well, I guess I won't understand the issue till 1. i see where the mmap wrapper is and 2. understand how madness like the DAX window in virtiofs works. Until then, I'm in the dark.
T 1710002837 18<29nox18>	The mmap crate is unsound, the memmap crate properly marks the function that allows you to build one from a file as unsafe
T 1710002855 18<26dav1d18>	danieldg, good guess https://docs.rs/memmap2/latest/src/memmap2/unix.rs.html#232-241
T 1710002911 18<29nox18>	Ah there is a memmap2 crate now, ugh
T 1710002936 18<26danieldg18>	nox: if you want to call that unsound you need to also call File::open unsound.  There's a limit to soundness when you iteract with the OS.
T 1710002956 18<29nox18>	danieldg: If you mean /proc, that's on Linux, not on Rust
T 1710002973 18<26danieldg18>	nox: no, I mean opening any of your dependencies
T 1710002981 18<29nox18>	That doesn't cause memory unsafety
T 1710002986 18<26danieldg18>	yes it can
T 1710002989 18<29nox18>	How?
T 1710003000 18<26danieldg18>	if you write to the executable file
T 1710003014 18<29nox18>	I have no idea what you mean
T 1710003030 18<26danieldg18>	you can open a shared library, for write, and overwrite the executable code
T 1710003043 18<26danieldg18>	that's about as unsafe as it gets
T 1710003047 18<29nox18>	What shared libraries
T 1710003064 18<26danieldg18>	any one you use
T 1710003106 18<29nox18>	That you dynamically loaded with unsafe code?
T 1710003120 18<26danieldg18>	well, std depends on libc
T 1710003125 18<29nox18>	But anyway that's very different from a process truncating a file that you mmapp'd
T 1710003142 18<26danieldg18>	getting a SIGBUS is safe
T 1710003157 18<26danieldg18>	it's generally not something you want, just like a deadlock or whatever, but it's safe
T 1710003161 18<29nox18>	https://docs.rs/memmap2/latest/memmap2/struct.Mmap.html#method.map
T 1710003195 18<26danieldg18>	yes, I'm aware that people mark it as unsafe
T 1710003256 18<29nox18>	Because it is, "those other things can lead to unsoundness in Rust" isn't a counterargument to it being an unsafe operation
T 1710003367 18<26danieldg18>	I'm not arguing it's unsafe
T 1710003384 18<26danieldg18>	I'm saying that maybe it shouldn't be called unsound for no reason
T 1710003433 18<29nox18>	I called it unsound because it's not marked as unsafe
T 1710003447 18<22Ademan_18>	so I have a `struct Foo<'a> { bar: &'a bar, } ` and everything is fine, except I hit a point where I want to mutate bar when I have a mutable Foo. Is there a way to do this without making a duplicate MutableFoo, or making Foo *always* require an &'a mut Bar ?
T 1710003458 18<22Ademan_18>	&'a Bar *
T 1710003499 18<26danieldg18>	Ademan_: no, not really.  You can do other things like have an enum between the two ref types, or make Foo generic defaulting to &'a Bar
T 1710003544 18<29nox18>	Ademan_: There may be a better way to design your stuff altogether but we can't see that from a Foo/Bar example
T 1710003623 18<22Ademan_18>	danieldg: hrm thanks, making Foo generic might work out ok
T 1710003659 18<26danieldg18>	warning: that can easily make your code pretty ugly
T 1710003691 18<22Ademan_18>	nox: probably. Basically I'm "extending" Bar with some extra data in Foo. As I wrote that I realized, maybe I should just make Foo own a Bar, and worry less about potential duplication
T 1710003711 18<22Ademan_18>	although Bar *is* potentially pretty big
T 1710003787 18<26danieldg18>	owning an Arc might work
T 1710003795 18<22Ademan_18>	I've never used Cow before, maybe that's actually viable?
T 1710003811 18<26danieldg18>	Cow is basically the enum solution, but with owned instead of &mut
T 1710003824 18<26danieldg18>	Arc::get_mut can be useful
T 1710003872 18<26danieldg18>	(or even make_mut)
T 1710003977 18<22Ademan_18>	hrm, maybe I'll just KISS (I'm stupid) and own the Bar, and revisit if I get reports of memory usage issues
T 1710004156 18<22Ademan_18>	thanks for talking me through it
T 1710004167 18<29nox18>	Yeah I would just own Bar probably
T 1710004325 18<19tokie18>	poor Foo always gets left out for Bar
T 1710007260 18<25Diablo-D318>	man, I wish more apps were written the rusty way
T 1710007277 18<25Diablo-D318>	just one binary and thats all you need
T 1710007383 18<26danieldg18>	hmm, not sure that's the rusty way; it happens plenty with other languages and also not with rust plenty of the time too
T 1710007387 18<26danieldg18>	but I agree it's nice
T 1710007510 18<25Diablo-D318>	well, ever try to do that on c/c++? some libraries are outright hostile to static linking
T 1710007526 18<25Diablo-D318>	or you got ones that do really weird hacks due to OS fuckery
T 1710007547 18<26danieldg18>	true; glibc is a major culprit there
T 1710007582 18<25Diablo-D318>	like, SDL used to, and I think still does, have SDLmain.a and SDL.dll on windows, it hijacks main() and ld loads sdl.dll
T 1710007597 18<25Diablo-D318>	glibc is a culprit on rhel, not so much other distros
T 1710007633 18<26danieldg18>	is that just because other distros decide they don't care about making getpwnam() work with LDAP-ish systems?
T 1710007633 18<25Diablo-D318>	sadly, a lot of people build binaries on there =/
T 1710007660 18<26danieldg18>	because iirc that's the main reason you have trouble static linking glibc
T 1710007692 18<25Diablo-D318>	I dont know; on debian, symbol poisoning only happens if you call a function that depends on newer glibcs (so, header defines your libc call, but its a macro that calls the actual symbol)
T 1710007712 18<25Diablo-D318>	so if you never call one of those, your binary may very well work on every libc6 system ever
T 1710007753 18<25Diablo-D318>	rust culture seems to like building binaries on alpine just to stop contamination entirely
T 1710007768 18<25Diablo-D318>	or at least, Ive seen a lot of rust programs distro binaries like that
T 1710007872 18<25Diablo-D318>	but no, what started my rant is actually the overhead of electron
T 1710007903 18<25Diablo-D318>	I am 100% anti-weirdo packaging formats
T 1710007909 18<26danieldg18>	... you know, people could just ship a .html file too
T 1710007912 18<25Diablo-D318>	like, flatpak can go fuck itself, appimage aint really any better
T 1710007918 18<26danieldg18>	if you're talking about electron
T 1710007926 18<25Diablo-D318>	hahah I wish they would
T 1710007975 18<25Diablo-D318>	like, fun fact: we all hate discord, right? if you're not using desktop/window capture for streaming in calls, its a shitload smoother in firefox
T 1710008003 18<25Diablo-D318>	its not an electron issue (such as discord using a out of date electron due to private vendored fork bullshit), because its equally as jank in chrome
T 1710008013 18<25Diablo-D318>	in firefox, its great
T 1710008041 18<25Diablo-D318>	imagine, a world where single file PWAs were how shit-apps were distributed
T 1710008091 18<25Diablo-D318>	no, instead, I have like 50 copies of chrome running, all different
T 1710008783 18<25Diablo-D318>	obsidian is actually pretty good as a note taking app. it actually leverages electron in its favor due to using normal conventional js in plugins to extend itself.
T 1710008815 18<25Diablo-D318>	a lot of markdown shit is in js, so a lot of plugins just drop the existing in-browser markdown transnformers into obsidian, and it just magically works
T 1710008831 18<26FireFly18>	using JS in plugins to extend things is something we had 10 years ago too :p
T 1710008868 18<26FireFly18>	but ye obsidian seems fine-ish
T 1710013239 18<28_Vi18>	Is there some drawing abstraction crate where I can draw lines, rectangles, polygons, texts and so on and render them into HTML canvas from wasm, rasterize and save to png, or save as svg (e.g. using different downstream crates)?
T 1710014214 18<26danieldg18>	_Vi: tiny-skia
T 1710014285 18<26danieldg18>	it doesn't do text (directly) though; you could use resvg to do that I think
T 1710014306 18<26danieldg18>	resvg will do svg stuff
T 1710014494 18<28_Vi18>	Will it allow placing text as a text (not a path or rasterized bitmap) into svg while still allowing to render it for immediate displaying?
T 1710014544 18<26danieldg18>	I think usvg (the resvg backend) might support that.  Not tried the svg output part though.
T 1710014651 18<26danieldg18>	if your goal is to export to svg, you'd want to do all your drawing by modifying the svg tree
T 1710014651 18<28_Vi18>	Will it skip those XML things in case where svg is not involved (e.g. just directly paint things on a HTML canvas)?
T 1710014673 18<26danieldg18>	no
T 1710014808 18<28_Vi18>	Or maybe closer to "yes"? "... strongly-typed tree structure", "... layer between an XML library and a potential SVG rendering library". If something renders to usvg tree (without actually being a real svg file), then rendering can be simpler and involve less overhead?
T 1710014874 18<26danieldg18>	maybe
T 1710014911 18<26danieldg18>	if you're in a browser, having the browser do the rendering is likely to do better (it can use the gpu, for one)
T 1710014976 18<26danieldg18>	and it'll also do things like support links in your svg documents, which usvg calls out as not supported
T 1710015028 18<20capitol18>	and javascript :P
T 1710015062 18<26danieldg18>	right, you'd have to have a wasm engine in your wasm engine to do that
T 1710015071 18<28_Vi18>	Can resvg or usvg or tiny-skia provide something that looks like a canvas API, but that will actually produce a SVG file at the end?
T 1710015077 18<26danieldg18>	no
T 1710015115 18<26danieldg18>	maybe usvg could do that, but I don't think it has editing support
T 1710015180 18<26danieldg18>	for that you'd want an svg creation or editing crate
T 1710015206 18<28_Vi18>	Or is there some other "easy mode" API to create new SVG files without dealing with tricky SVG details? Is svg file -> usvg tree a one-way conversion or compatible svg files can be round-tripped though usvg tree?
T 1710015268 18<26danieldg18>	'svg' crate might do it.  I've not used it.
T 1710015344 18<28_Vi18>	OK. Thanks for the advices.
T 1710015409 18<26danieldg18>	yeah, 'svg' looks pretty simple but exactly what you'd want
T 1710016938 18<27TimMc18>	Oh man, coding stuff up in Rust is so slow... and yet it feels really rewarding.
T 1710016962 18<27TimMc18>	I think it's taking me back to when I was first learning to program (in anything).
T 1710017206 18<27lambda18>	in my experience, the extra time I spend writing Rust as opposed to e.g. C or python, I get back severalfold by not having to debug it - it just works
T 1710017442 18<27TimMc18>	Oh, no doubt.
T 1710017685 18<26pflanze18>	Is there a way to specify for a type that it shall never implement Clone (nor Copy, of course) in the future? I.e. a way to make compilation fail if someone does.
T 1710017736 18<26danieldg18>	no, negative trait bounds aren't stable
T 1710017750 18<26pflanze18>	Ah, so something's in the making, amazing.
T 1710017766 18<26danieldg18>	not sure if that one will ever be stable
T 1710017778 18<26danieldg18>	specialization could do it too (another unstable feature)
T 1710017784 18<26pflanze18>	OK.
T 1710017808 18<26danieldg18>	for !Copy, you could require that it impl Drop
T 1710017840 18<26danieldg18>	!Clone doesn't really restrict anything; you can always write a "fn clone(&self)" after all
T 1710017874 18<26danieldg18>	what are you actually trying to do?
T 1710017930 18<26pflanze18>	I've just been pondering how to make sure nobody breaks something by haphazardly adding #[derive(Clone)] to some type I know can't be cloned.
T 1710017944 18<26danieldg18>	pflanze: you could always write a must-compile-fail test that tries to pass your thing to an f<T:Clone>()
T 1710017955 18<26pflanze18>	Ah, good idea.
T 1710017978 18<26pflanze18>	Hmm, how would you do that though?
T 1710017988 18<26pflanze18>	Via build.rs or something?
T 1710018010 18<26danieldg18>	not sure.  Someone has done it, I've see it in testing proc macros
T 1710018031 18<26pflanze18>	OK. I'll keep those answers in mind, it's nothing urgent.
T 1710018044 18<19Alexendoo18>	trybuild or ui_test
T 1710018057 18<26pflanze18>	Thanks!
T 1710018174 18<26danieldg18>	you could also add a field whose type is deliberately not Clone
T 1710018193 18<26danieldg18>	you could call it PhantomNonClone to be blatant
T 1710018363 18<26pflanze18>	Heh, true
T 1710020543 18<28lmat18>	{ let me : f64 = 2.0; if &me == 3.0 { println!("equel"); } }
T 1710020545 18<28lmat18>	What does this mean?
T 1710020571 18<28lmat18>	evalr: { let me : f64 = 2.0; if &me == 3.0 { println!("equel"); } }
T 1710020573 -18evalr/22##rust-	lmat: error[E0277]: can't compare `&f64` with `{float}` ...
T 1710020574 -18evalr/22##rust-	lmat: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=c86fda5dca001431500188a78171f92b
T 1710020609 18<28lmat18>	In my code, this is a function:   fn fun(me : &f64) { if me == 0.0 .... }
T 1710020609 18<20j`ey18>	just use me, not &me
T 1710020610 18<20j`ey18>	?
T 1710020624 18<20j`ey18>	why are you passing &f64?
T 1710020631 18<20j`ey18>	why not f64?
T 1710020654 18<26danieldg18>	lmat: if you want to do that, use *me
T 1710020667 18<26danieldg18>	lmat: but passing f64 is basically always more efficient than passing &f64
T 1710020695 18<28lmat18>	j`ey: I don't know... the function is actually more like this:     avgs.iter().zip(others).map(|(lhs, rhs)| { if lhs == 0.0 ... }   avgs and others is a Vec<f64>.
T 1710020719 18<20j`ey18>	|(&lhs, &rhs)|
T 1710020723 18<26danieldg18>	right, then use *, or annotate the closure args like that ^^
T 1710020727 18<20j`ey18>	stop changing your question :P
T 1710020756 18<28lmat18>	j`ey: Sorry, I'm trying to to give you my whole codebase and say, "fix it" :-P
T 1710020763 18<28lmat18>	s/to to/not to/
T 1710020794 18<20j`ey18>	basically you cant compare &f64 to f64, so you have to deref it
T 1710020802 18<28lmat18>	(&lhs, &rhs) is a pattern that says "get the value of the first element in the tuple and assign it to lhs (same for rhs)"?
T 1710020897 18<20j`ey18>	something like that yeah
T 1710020986 18<28lmat18>	https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=4f70c225f58a01aa4383bd976fdcbb16  but that only goes for one of the arguments???
T 1710021033 18<20j`ey18>	because you wrote zip(others)
T 1710021039 18<20j`ey18>	not zip(others.iter())
T 1710021071 18<28lmat18>	:-D
T 1710021121 18<28lmat18>	j`ey: Ahh, zip takes (a:A, b:B), not (a:&A, b:&B). I didn't expect that.
T 1710021162 18<20j`ey18>	yeah because with a: A, you can pass &A
T 1710021168 18<20j`ey18>	but you cant pass A to a: &A
T 1710021419 18<28lmat18>	j`ey: nice
T 1710021470 18<26pflanze18>	The "backtrace" crate has stopped giving me useful output. I last used it a while ago and it was fine in one of the compilation modes (release or debug, not sure which anymore), but now it won't give me line numbers except for core files, and it won't give me a full backtrace in debug mode at all. I've upgraded to the newest version, still same.
T 1710021500 18<26pflanze18>	I'm on Debian stable, rustc from Debian. Anyone seen anything similar, any idea?
T 1710021812 18<26pflanze18>	Hmm, getting line numbers now in latest backtrace version *in debug mode with mold as linker*
T 1710022353 18<22evaloop18>	pflanze: l'l use -C link-args=-fuse-ld=mold and any kind cargo command with -vvv, also if BACKTRACE=1 disabled or not prowided as option for debug or just can use DEBUG_RUSTFLAGS="-C debuginfo=2 :) or l'm not exact mean what :D
T 1710022633 18<22evaloop18>	pflanze: mb I was wrong about that, but for me that worked. Mine rust
T 1710022633 18<22evaloop18>	Version: 1:1.76
T 1710022694 18<22evaloop18>	*provided
T 1710022746 18<22evaloop18>	mistake correction after send D:
T 1710022882 18<22evaloop18>	Also can pass that backtrace before cmd command
T 1710022950 18<22evaloop18>	like that maybe BACKTRACE=1 crabgo build/test/install/orelse somecrap -vvv
T 1710023009 18<26pflanze18>	I'm using the "backtrace" crate, I'm not referring to the panic feature, which may use different code (the backtrace crate seems to say so)
T 1710023034 18<28Beladona18>	HI
T 1710023037 18<28Beladona18>	Any clue here? https://imgur.com/ydOcc8g.png
T 1710023059 18<26pflanze18>	(evaloop, I'm referring to "backtrace" crate version 0.3.69)
T 1710023195 18<26pflanze18>	(I am recompiling with -C debuginfo=2 to see how that goes)
T 1710023606 18<22evaloop18>	pflanze: also suggest maybe, sometime's l'l use xargo because maybe now is no-std crate, xargo mostly nice for no-std custom action.
T 1710023707 18<26pflanze18>	Adding debuginfo=2 doesn't make a difference for me now (with newest 'backtrace' and mold), both debug and release outputs are unchanged, release remains broken. But whatever, it's ok for me to have to use debug mode right now.
T 1710024187 18<22evaloop18>	mold is just linker for speed-up and size, great tool, -vvv expand view of borrow checker at compile/link time, maybe best way for mkae review or debug is use -vvv (max verbosive output)
T 1710024334 18<20j`ey18>	pflanze: and your rustc didnt change?
T 1710024383 18<20j`ey18>	nvm strip isnt by default, I thought it was for release
T 1710024466 18<22evaloop18>	rustc 1.76.0 --version
T 1710024473 18<26pflanze18>	j`ey, I did move to different hardware (both intel amd64 though); same Debian release, though, although the first was in a chroot and possibly not up to date
T 1710024517 18<26pflanze18>	Also, using nested threads now (scoped thread pool); larger code base.
T 1710024518 18<22evaloop18>	oh D:
T 1710025695 18<28Beladona18>	fixed
T 1710026477 19*	Now talking on 22##rust
T 1710026477 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1710026477 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1710026566 19*	Now talking on 22##rust
T 1710026566 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1710026566 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1710026858 19*	Now talking on 22##rust
T 1710026858 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1710026858 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1710027101 19*	Now talking on 22##rust
T 1710027101 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1710027101 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1710028235 18<29neiluj18>	Hi! Got a function parametrized by these traits: https://bpa.st/QJ7A. Except a function I'm calling would require further type constraints:  ScalarField = G2Cfg::ScalarField additionally. Is it possible to enforce this?
T 1710030342 18<26pflanze18>	neiluj, G2Cfg::ScalarField is a type, not a trait, right?
T 1710031100 19*	Now talking on 22##rust
T 1710031100 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1710031100 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1710031125 18<29neiluj18>	now getting the error `T` cannot be shared between threads safely for a struct containing a PhantomData<T> field
T 1710031928 19*	Now talking on 22##rust
T 1710031928 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1710031928 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1710032945 18<27TimMc18>	Is there some sort of abstraction in Rust's ecosystem for "pull from a stream until you've got all the data"?
T 1710032957 18<29neiluj18>	fixed my issue
T 1710032964 18<27TimMc18>	\o/
T 1710032981 18<29neiluj18>	just followed the compiler's instructions xD
T 1710033019 18<27TimMc18>	I want to send a series of msgpack objects over TCP but it would be cool to not have to precede each with a length header. Theoretically this should be fine since msgpack has its own internal length headers, but I'm just not really sure how to hook everything up.
T 1710033606 18<26danieldg18>	TimMc: tokio used to have a decoder abstraction on top of Stream
T 1710033666 18<26danieldg18>	or just collect what's available into a buffer and run a msgpack decoder on it.  If the decoder returns "message truncated", then collect some more bytes
T 1710033715 18<26danieldg18>	if the decoder doesn't tell you truncated vs malformed, then the header length fields aren't good enough
T 1710033904 18<26danieldg18>	it doesn't look like msgpack has a fast length field/header
T 1710033944 18<27TimMc18>	Each msgpack object tells you how long it is, but not necessarily in bytes. :-)
T 1710033966 18<27TimMc18>	So an array says "I'm 100 elements long" but you don't know how large those are.
T 1710034030 18<27TimMc18>	I guess I could write a msgpack decoder that knows how to await more bytes on a stream... meh.
T 1710034133 18<26danieldg18>	you could certainly write the decoder as an async fn that takes an async buffered reader that it reads byte by byte
T 1710034162 18<26danieldg18>	it's more efficient to just have a length field
T 1710034181 18<26danieldg18>	plus it helps reject overlong messages before you start to parse them
T 1710036100 18<25Widdershins18>	yeah that's one of the weaknesses of msgpack
T 1710036110 18<25Widdershins18>	it's one of the It's Just JSON Except Binary encodings
T 1710036150 18<25Widdershins18>	because the whole thing is schemaless they didn't bother to design it in a way that can be skip-parsed
T 1710036197 18<26danieldg18>	original json can't be skip-parsed either, so it didn't lose anything
T 1710036219 18<25Widdershins18>	yeah. potentially a missed opportunity, potentially a pain in the ass. it's a tradeoff
T 1710036235 18<25Widdershins18>	looking at my recent adventures in What If We Encoded Backwards
T 1710036316 18<25Widdershins18>	because TLV encodings that have a lot of nesting have a lot of advantages for being able to see the "future"
T 1710049342 19*	Now talking on 22##rust
T 1710049342 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1710049342 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1710069699 18<26pflanze18>	When implementing a self-referential struct via unsafe, if I never give public write access to the self-referenced data, do I need to Pin it?
T 1710069718 18<26pflanze18>	Or am I correct in understanding that Pin just prevents swap in the case that it must be writable?
T 1710069756 18<26pflanze18>	I.e. Pin isn't also acting as some kind of move prevention indication to the compiler itself, or is it?
T 1710069875 18<25Mutabah18>	pflanze: `Pin` prevents you from getting `&mut` effectively
T 1710069888 18<25Mutabah18>	while still allowing ownership
T 1710069901 18<25Mutabah18>	it ensures reference/pointer stability
T 1710069951 18<26pflanze18>	I have experience with C and C++, so I understand the pointer stability.
T 1710069969 18<26pflanze18>	But I get pointer stability by using Box, not Pin.
T 1710069990 18<25Mutabah18>	Pin is how unsafe code can assume a pointer is stable, without needing it to be on the heap
T 1710069990 18<26pflanze18>	Pin is just to prevent the contents of the box from being replaced. Right?
T 1710070019 18<25Mutabah18>	If you make a `Pin<&mut T>` you promise that the `T` won't change addresses until it is dropped
T 1710070022 18<26pflanze18>	Hmm, okay, I haven't tried to not put things onto the heap.
T 1710070119 18<26pflanze18>	My understanding was that Pin prevents the API users from messing up. Not me promising.
T 1710070149 18<25Mutabah18>	It's both kinda
T 1710070195 18<25Mutabah18>	`Pin::new_unchecked` is where you promise, and then the user (API or whoever) of the `Pin<Ptr>` can assume that they can take the address/raw-pointer and it'll stay valid until the data is dropped
T 1710071243 18<26pflanze18>	Is there any problem with my unsafe usage here?: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=9cb76688f8417ad91003ff0ff5724af2
T 1710071319 18<20j`ey18>	miri thinks so
T 1710071322 18<26pflanze18>	(My followup question will be, I could leave away the Pin here and the external API would still be safe, no? Although I'll admit the Pin may be useful to protect to some extent from people changing the insides of StringSplit's implementation)
T 1710071372 18<26pflanze18>	How are you running miri if it's simple enough to say (if it's involved, I'll go read the docs)
T 1710071400 18<20j`ey18>	click miri on the playground :P
T 1710071409 18<26pflanze18>	Aha, ok :)
T 1710071410 18<20j`ey18>	tools -> Miri
T 1710071417 18<26pflanze18>	Now, miri of course won't tell whether my API *could* be misused.
T 1710071435 18<20j`ey18>	miri thinks there *is* a problem
T 1710071445 18<26pflanze18>	Oh!
T 1710071840 18<26pflanze18>	Is there something fundamentally unsafe in my program (i.e. if I used ASAN instead and tried to mis-use the API could I trigger an ASAN violation?), or is it "just" that I should do things slightly differently so that miri is happy?
T 1710073164 18<25narodnik218>	is there a way to specify a trait const usize which is a multiple of some value?
T 1710073208 18<25narodnik218>	struct Foo<const N: usize> where N = 2^k for some k
T 1710073218 18<25narodnik218>	or is the only way to make k the parameter?
T 1710073376 18<29saati18>	if it has private fields you could assert it's popcount is 1 in all it's constructors
T 1710078258 18<25Widdershins18>	you could also just specify the power-of-2 instead
T 1710078293 18<25Widdershins18>	maybe that would look worse though
T 1710078420 18<29saati18>	still have to ensure it's lower than 64
T 1710078782 18<25yziquel18>	Hi. I just rebuilt rust and cargo from source. anyone knows where the binaries are ?
T 1710078805 18<25yziquel18>	there are multiple cargo binaries. stage0, stage 2, etc... what's that ?
T 1710079061 18<20j`ey18>	stage0 is built with the existing cargo binary, stage1 is built by stage0
T 1710079591 18<19Alexendoo18>	https://rustc-dev-guide.rust-lang.org/building/bootstrapping.html
T 1710079620 18<19Alexendoo18>	they'll be in build/host/stage1
T 1710079897 18<19Alexendoo18>	bootstrap prints a message telling you what rustup link command to use, usually you want that so you don't have to set LD_LIBRARY_PATH (or whatever platform equivalent) yourself
T 1710081229 18<25yziquel18>	Alexendoo for cargo binary, I only see build/x86_64-unknown-linus/[stage0/bin/cargo|stage0-sysroot/bin/cargo|stage2-tools-bin/cargo] and one in src/tools/rust-installer/test/inage3/bin/cargo. No stage 1.
T 1710081244 18<25yziquel18>	I did ./x.py build after a ./configure on a raw git checkout.
T 1710081601 18<19Alexendoo18>	cargo is not built by default
T 1710081778 18<25yziquel18>	urgh. I'd need to build cargo, Alexendoo. Does ./x.py build do incremental builds ? seems so.
T 1710081851 18<25yziquel18>	not quite incremental...
T 1710081878 18<19Alexendoo18>	Not by default, but e.g. the compiler profile has it on
T 1710081976 18<19Alexendoo18>	What are you after build wise?
T 1710082050 18<25yziquel18>	Alexendoo I want to fix a virtualisation issue with rustc as it misbhaves it a given setup for an os level reason. I'm hunting down all the wrong calls in the rust codebase.
T 1710082062 18<25yziquel18>	on a given setup.
T 1710082081 18<26dav1d18>	you're looking at the wrong thing
T 1710082096 18<25yziquel18>	dav1d tell me more.
T 1710082115 18<26dav1d18>	you're building the compiler when your binary produced by the compiler is failing
T 1710082128 18<26dav1d18>	the compiler doesn't magically add mmap calls to binaries
T 1710082139 18<25yziquel18>	dav1d no. it is the compiler itself that fails.
T 1710082150 18<25yziquel18>	dav1d since 2016.
T 1710082151 18<26dav1d18>	ah okay, my bad, misremembering the issue then
T 1710082179 18<19Alexendoo18>	You wouldn't need to build cargo in that case, rustup will fall back to your own cargo when you use rustup link
T 1710082199 18<25yziquel18>	Alexendoo I need to build cargo because I need to run cargo build to test.
T 1710082199 18<26dav1d18>	thought your problem was gix or w/e
T 1710082207 18<19Alexendoo18>	you can set `profile = "compiler"
T 1710082207 18<19Alexendoo18>	` in config.toml to get incremental and other things
T 1710082225 18<25yziquel18>	dav1d my problem is across the whole rust ecosystem.
T 1710082236 18<19Alexendoo18>	cargo +stage1 build will work if you use rustup link without building cargo
T 1710082255 18<26dav1d18>	yeah the source is gonna be the memmap* crates
T 1710082277 18<25yziquel18>	dav1d yes.
T 1710082309 18<25yziquel18>	Alexendoo what will rustup do for me ??
T 1710082309 18<26danieldg18>	yziquel: just make an LD_PRELOAD hook for mmap that changes everything to MAP_PRIVATE
T 1710082357 18<26dav1d18>	^
T 1710082366 18<19Alexendoo18>	yziquel: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#creating-a-rustup-toolchain
T 1710082376 18<25yziquel18>	danieldg intervene on the github issue if you claim this does not need fixing. For now, I'm fixing it if only for me. here you go: https://github.com/rust-lang/rust/issues/122262
T 1710082381 18<26danieldg18>	or, you know, just learn how to use libvirt.  That's *way* less effort than changing every program you use to not use MAP_SHARED
T 1710082398 18<25yziquel18>	danieldg or, you know, fix your 2016-old bug.
T 1710082405 18<26danieldg18>	not my bug
T 1710082415 18<25yziquel18>	danieldg bug in rust.
T 1710082428 18<25yziquel18>	anyway. coffee. flame war -> guthub issue. thx.
T 1710082466 18<26dav1d18>	jfc
T 1710083390 18<29saati18>	lol sure a shitty fs not supporting MAP_SHARED is a rustc bug
T 1710083517 18<26danieldg18>	I'm actually surprised it supports mmap at all
T 1710083578 18<26danieldg18>	I guess it'd have to if you wanted to run binaries off it
T 1710083649 18<25yziquel18>	saati it's not a rust bug. It's a bug that impacts anyone wanting to virtualise. and there are many.
T 1710083661 18<25yziquel18>	saati you can keep denying it has an impact. It has one.
T 1710083680 18<26danieldg18>	yziquel: 99.9% of people who virtualize don't hit this bug
T 1710083681 18<25yziquel18>	saati and it may be a riust bug. to me, it's 1/3 a rust bug, 2/3 a virtiofs bug.
T 1710083701 18<25yziquel18>	danieldg indeed. and the happy few who do do not recognise it.
T 1710083754 18<25yziquel18>	danieldg it hits various filesystems since 2016. vboxfs. virtiofs with --cache=never (which is becoming the default in kata containers), and people iusing github actions use workarounds they just copy paste.
T 1710083817 18<25yziquel18>	danieldg and i hit it. so i fix it.
T 1710083839 18<26danieldg18>	right, I think it's a good feature to add
T 1710083843 18<26danieldg18>	but it's more of a feature than a bug
T 1710083883 18<26danieldg18>	it's a workaround for filesystems that don't support MAP_SHARED
T 1710083988 18<20polychromata{J}18>	pflanze: i think your Pin doesn't cover enough—you need to pin the big string and the little strings together
T 1710083999 18<26danieldg18>	but that's nitpciking I guess
T 1710084002 18<20polychromata{J}18>	and i think the first error is about your 'static lie?
T 1710084053 18<20polychromata{J}18>	but i can't speak to whether it's a violation or a flaunt of the unsafe rules
T 1710084157 18<25yziquel18>	danieldg for your sore eyes that will make you cry tears of blood: 99% of people who virtualise do not hit this bug, I did. https://github.com/openzfs/zfs/issues/14989
T 1710084194 18<25yziquel18>	https://github.com/openzfs/zfs/issues/14989#issuecomment-1980137649
T 1710084252 18<25yziquel18>	shitty CPU. Just throw the computer through the window.
T 1710084341 18<26danieldg18>	yeah, that's a bug: if you use a register you didn't tell the kernel to save/restore, then of course it can get corrupted
T 1710084366 18<26danieldg18>	no different than using a thing protected by a lock without locking it
T 1710084367 18<25yziquel18>	danieldg no. It's a bug in the CPU. Not in ZFS. Intel is at fault. Not openzfs.
T 1710084380 18<26danieldg18>	huh
T 1710084389 18<26danieldg18>	ah
T 1710084463 18<25yziquel18>	intel defecated on themselves when implementing avx512f and fell short of their specs on a vmexit event.
T 1710084480 18<26danieldg18>	well that looks like one of the dumber errata I've seen
T 1710084502 18<26danieldg18>	usually such things require more moving parts to break stuff
T 1710084528 18<26danieldg18>	I guess vmexit is probably complex enough for them to screw it up
T 1710084572 18<25yziquel18>	yeah. well, so is MAP_SHARED on virtiofs where the memory mapping goes through qemu's own memory.
T 1710084594 18<26danieldg18>	that's merely a missing feature
T 1710084600 18<25yziquel18>	¨...
T 1710085734 18<25yziquel18>	I still do not see how to build cargo from the rust source repo.
T 1710085734 18<28Vorpal18>	I'm trying to figure out a good approach to error handling in command line programs and libraries for command line programs. Anyhow is great, but leads to type-erased errors. That is not always appropriate. thiserror is cumbersome and I haven't gotten backtrace reporting to work great on stable rust for nested errors. That last issue (good error causes with backtraces on stable rust) I consider an absolute requirement. If it weren't for that, snafu would look
T 1710085736 18<28Vorpal18>	pretty good for example.
T 1710085759 18<28Vorpal18>	so, anyone have any suggestions for what to use?
T 1710085868 18<28Vorpal18>	I tried error-stack, but I ran into two major issues: It doesn't play well with other error reporting (so transitioning gradually to it is difficult). It has some support for converting anyhow errors, but that looses backtraces. Also I couldn't figure out how to use an error stack report as an Error type for a TryFrom trait impl
T 1710085890 18<19tokie18>	why do you need backtraces ?
T 1710085909 18<28Vorpal18>	tokie: I consider them essential for debugging and for bug reports.
T 1710085986 18<25yziquel18>	Vorpal indeed.
T 1710086024 18<28Vorpal18>	So yeah, anyhow is great (and it is easy to attach additional context on the way up), but not great if there are some cases that you actually want to handle instead of just report.
T 1710086067 18<26dav1d18>	Vorpal, you can downcast errors with anyhow
T 1710086074 18<19tokie18>	yeah, i would go with anyhow
T 1710086075 18<26dav1d18>	in case you havent seen
T 1710086094 18<19tokie18>	i've found in practice the "i may need to distinguish between errors!" never usually happens
T 1710086117 18<19tokie18>	but i write daemons and not command-line programs, so maybe it's more common ...
T 1710086138 18<28Vorpal18>	dav1d: hm I do remember seeing something about it, but didn't try it out since it looked hackish. Not good for a public API in a library (I'm making a tool + a reusable library for some of the functionality of that tool).
T 1710086164 18<28Vorpal18>	[16:54] <tokie> i've found in practice the "i may need to distinguish between errors!" never usually happens <-- rare, but certain IO errors. That is usually handled locally though
T 1710086171 18<26dav1d18>	Vorpal, then there isn't much left other than writing your own error types, with our without thiserror
T 1710086178 18<19tokie18>	Vorpal: lol, yeah, i was about to write that
T 1710086216 18<28Vorpal18>	another issue with anyhow is that it's error type can't be serialised. As I will be splitting some functionality into a part that is executed via sudo and then doing unix socket IPC back and forth this kind of matters down the road
T 1710086235 18<28Vorpal18>	very niche thing, I know
T 1710086285 18<28Vorpal18>	dav1d: is there a way to get backtraces to work well with thiserror though? Essentially I want the full on anyhow error handler with "foo, caused by bar, caused by quux, here is a helpful stacktrace if you ran with RUST_BACKTRACE=1"
T 1710086305 18<19tokie18>	Vorpal: not so niche! are we coworkers? lol
T 1710086379 18<28Vorpal18>	tokie: I'm basically doing a rewrite of https://github.com/CyberShadow/aconfmgr in rust (and with pluggable support for other distros, not just arch). Or that is the plan. So far I wrote some more basic tools that I will need (https://github.com/VorpalBlade/paketkoll)
T 1710086403 18<28Vorpal18>	but yeah I use anyhow there, and I'm running into the serialisation issue
T 1710086438 18<28Vorpal18>	as well as, the paketkoll_core library having anyhow in it's public API (that API is very much WIP currently)
T 1710086443 18<19tokie18>	ohh god, that's all bash
T 1710086445 18<19tokie18>	good luck
T 1710086478 18<28Vorpal18>	tokie: despite it being bash (I'm probably going with rhai for user config) it actually works extremely well.
T 1710086569 18<28Vorpal18>	I wish the provider API got stabilised. Then all of this would just work with snafu etc.
T 1710086600 18<26dav1d18>	Vorpal, pretty sure you'd have to capture the backtrace yourself. But tbh might just write the error types yourself without thiserror
T 1710086616 18<26dav1d18>	also neat seeing something from CyberShadow
T 1710086625 18<28Vorpal18>	oh? you know them?
T 1710086646 18<28Vorpal18>	so much boiler plate. Maybe I'll make my own macro to generate error types. Wait a sec...
T 1710086668 18<26dav1d18>	yeah from my time doing D
T 1710086680 18<26dav1d18>	Vorpal, it's not that bad tbh
T 1710086700 18<26dav1d18>	but yeah nothing a macro_rules cant solve
T 1710086708 18<28Vorpal18>	mhm
T 1710086742 18<26dav1d18>	but thiserror also has #[backtrace], but I've never used it
T 1710086819 18<28Vorpal18>	think you still have to capture the backtrace yourself (or take it from a source error)
T 1710086844 18<19tokie18>	most of the stuff i write uses thiserror to format errors, but they eventually bubble up into a boxed error like anyhow anyway
T 1710086845 18<19tokie18>	so sorta a mix
T 1710086851 18<26dav1d18>	yep
T 1710086852 18<19tokie18>	but thiserror is nice for formatting the text
T 1710086861 18<26dav1d18>	but you can use it to generate the boilerplate
T 1710086863 18<28Vorpal18>	it indeed is
T 1710086864 18<19tokie18>	yep
T 1710086904 18<28Vorpal18>	not sure how to extract the causes and backtraces in the end (like when you return anyhow::Result from main)
T 1710086905 18<19tokie18>	just panic and let sentry manage the backtraces
T 1710086910 18<19tokie18>	:x
T 1710086916 18<28Vorpal18>	hah, nah thanks
T 1710086994 18<28Vorpal18>	Error handling in closures is awkward. I use rayon a lot in this project, so I keep running into that.
T 1710087025 18<19tokie18>	oh wow
T 1710087066 18<28Vorpal18>	Speaking of rayon: sensible backtraces is something it doesn't have. Something I notice when profiling with perf and try to find my own code in the mess of workstealing schedulers. Basically top down flamegraphs are unusuable
T 1710087077 18<28Vorpal18>	tokie: hm?
T 1710087169 18<19tokie18>	i just never see anyone using rayon. it's nice to see a use case !:P
T 1710087246 18<28Vorpal18>	tokie: doing many independent things as fast as possible is a use case
T 1710087282 18<28Vorpal18>	which perfectly fits what paketkoll is doing (loading package metadata from many separate files, calculating checksums, walking the the whole file system, etc)
T 1710087643 18<27TimMc18>	Oh man, my 300 line program worked perfectly on the first run!
T 1710087654 18<27TimMc18>	(Well, the first run where I didn't fat-finger the command line, haha)
T 1710087670 18<25yziquel18>	TimMc that's the kind of experience I initially had with OCaml before rust.
T 1710088508 18<25yziquel18>	fed up with these annoying git submodules.
T 1710088577 18<28Vorpal18>	yziquel: would you say that ocaml (or other MLs) have anything to offer if I learned Rust first?
T 1710088606 18<25yziquel18>	Vorpal you want a theological debate ?
T 1710088704 18<28Vorpal18>	yziquel: nah, just wondering if it has any neat ideas. I believe that learning more languages makes you a better programmer in all of them
T 1710088720 18<25yziquel18>	My opinion: I wish rust syntax was more ocaml like and ocaml could tackle the metal more. ocaml is quicker to develop prototype and has a nicer type-reasoning-feel to it. but it can't reason about lifetimes. Though it does not support some unique keywords allowing for type level resource management.
T 1710088722 18<28Vorpal18>	I don't code in scheme, but I think learning a LISP made me think differently
T 1710088727 18<27gastus18>	Vorpal: lanugage + ecosystem + knowledge => time to complete a task. You don't teven know your task.
T 1710088737 18<25yziquel18>	it does now support
T 1710088766 18<25yziquel18>	gastus there are other reasons to dive into a language. Languages are not only tools.
T 1710088769 18<28Vorpal18>	hm, interesting
T 1710088798 18<25yziquel18>	Vorpal I'd say library support is richer in rust. But I wish rust had ocaml's gc.
T 1710088803 18<25yziquel18>	as an option.
T 1710088826 18<28Vorpal18>	yziquel: as someone who do command line tools as well as full on embedded I'm so happy rust doesn't have a GC
T 1710088879 18<28Vorpal18>	at dayjob we are starting to eye rust (currently C++). With a GC that flat out wouldn't be an option (hard realtime, industrial equipment controller software)
T 1710088881 18<25yziquel18>	Vorpal yes. but I'd rather it have an OPTIONAL gc. though that would impact the ecosystem and it would be less friendly to embedded. so....
T 1710088904 18<27gastus18>	So Java OO (+ weaving, pointcutns), Python/JS (dynamic), TS = learn that you can type dynamic stuff so is good for tasks requiring such. Haskell/Nix => lazy expressions, Rust, borrowing, urweb shows how crazy you can go about type level, Nim shows that you can have multiple GC implementations within one language.
T 1710088909 18<28Vorpal18>	yziquel: it wouldn't be optional. Because a ton of crates you would want to use would suddenly depend on it
T 1710088913 18<25yziquel18>	Vorpal it is possible to have real time concurrent gcs. you just do not find them around much. except in the litterature.
T 1710088918 18<28Vorpal18>	yziquel: it would be worse than the async/blocking split
T 1710088948 18<27gastus18>	Talking about no GC: https://github.com/fitzgen/bumpalo seems to a link also talking about nightly option to pass allocator.
T 1710088953 18<25yziquel18>	Vorpal I disagree.
T 1710088971 18<25yziquel18>	gastus yes, I'm about to start using bumpaloo for my gc-like requirements
T 1710089002 18<27gastus18>	The question I have is more like how to write code which can do both. Like let X = fun(); and have fun use a throw away allocator. Like with with_throw_away do .. code here  and once the block is done have all data erased.
T 1710089013 18<25yziquel18>	gastus I need heavily recursive data structure, and rust rules that out without something like bumpaloo anyway.
T 1710089026 18<28Vorpal18>	bumpalo is not a GC, it is a bump arena allocator.
T 1710089032 18<27gastus18>	The pattern of rewriting libraries (haskell with / without monad) js (with without async) .. rust (with different GC) feels annoying.
T 1710089061 18<25yziquel18>	gastus I believe GC should be available but optional. But only later than now, as that would otherwise submerge the ecosystem with gc compatible libs and embedded world would be left dangling.
T 1710089065 18<28Vorpal18>	seems quite different to me. I have tried bumpalo in one single-threaded project that did lots of small allocations. Couldn't measure any statistically signficant speedup, so gave up on that
T 1710089134 18<27gastus18>	And that's what I was told, too. I wrote my .so file which rewrote malloc. Same for me. So looks like the typcial malloc implementaions do a good job.
T 1710089139 18<25yziquel18>	Vorpal try writing a custom lambda-calculus semi-compiled semi-interpreted nonsense. you'll see you'll need hairy memory management and bumpaloo is much like the small heap of ocaml's garbage collector anyway.
T 1710089142 18<28Vorpal18>	also bumpalo doesn't play nice with rayon from what I can tell. You could have a bump allocator per thread (bumpalo-heard implements this) but with rayon you don't really know which thread you are on at any time (and you are supposed to get the allocator at the start since that is expensive). Maybe with a thread local, but eww.
T 1710089188 18<20nullie18>	hi, which library can I use to make Cookie header from cookie values?
T 1710089188 18<28Vorpal18>	yziquel: yeah never done that, I have written a BrainFuck compiler, but that is quite different memory management wise
T 1710089192 18<25yziquel18>	Vorpal there is bumpaloo herd. or something like that for rayon support. Not on my roadmap for the moment.
T 1710089207 18<28Vorpal18>	yziquel: I just mentioned it?
T 1710089228 18<25yziquel18>	Vorpal ah. yes.
T 1710089313 18<28Vorpal18>	so yeah bumpalo-heard doesn't fit rayon par_iter() workflow. If you are managing your own long-lived scoped threads I think it could work though
T 1710089340 18<25yziquel18>	Vorpal I have other things in mind for that kind of stuff. but i'll say no more.
T 1710089341 18<28Vorpal18>	and I can't even begin to imagine the horrors of trying to deal with this in thread locals. The borrow checker won't be happy
T 1710089394 18<28Vorpal18>	yziquel: I ended up using lasso for a thread safer string interner instead. That works surprisingly well for heavily reused strings
T 1710089409 18<28Vorpal18>	thread safe* (I wonder what thread safer is!)
T 1710089509 18<25yziquel18>	Vorpal I don't believe rust's type checker should be force into doing some kind of LTA+ analysis.
T 1710089524 18<28Vorpal18>	LTA+?
T 1710089566 18<28Vorpal18>	brb, my 3D printer just signaled it finished
T 1710089805 18<25yziquel18>	LTA+ is an old specification language (and more) in which you can reason about temporal assignments and prove stuff about distributed computing. Like byzantine problems solutions such as Paxos or Raft. Rust's borrow checker is cool for type systems and language, but does not rise IMO to the standard of such old technologies.
T 1710089810 18<25yziquel18>	Vorpal
T 1710089850 18<19tokie18>	Vorpal: i wrote a scheme compiler and i write very little scheme ! i think just implementing scheme is an interesting exercise
T 1710089867 18<28Vorpal18>	yziquel: the thing with the borrow checker is that it is (somewhat) quick. I suspect the more complicated the slower it would be. Possibly undecidable even.
T 1710089876 18<28Vorpal18>	thanks to Rice's theorem
T 1710089881 18<25yziquel18>	Vorpal dunno. depends.
T 1710089908 18<25yziquel18>	many fragments of logic are suprisingly decidable.
T 1710089956 18<25yziquel18>	Much can be combined with Nelson-Oppen. so...
T 1710090189 18<25yziquel18>	Can't build rust because I can't fetch the gccjit git submodule. I'm feeling more and more murderous.
T 1710090252 18<28Vorpal18>	that is a weird non-standard backend isn't it?
T 1710090261 18<28Vorpal18>	you surely shouldn't need that for standard rust
T 1710090286 18<25yziquel18>	Vorpal. dunno. I tried the build instructions. ./x setup and ./x check. "can't fetch gccjit".
T 1710090336 18<25yziquel18>	Vorpal trying ./configure and ./x.py build. we'll see if it changes something.
T 1710090341 18<25yziquel18>	i hate these opaque build systems.
T 1710090400 18<25yziquel18>	seems to build something. but I want to get cargo to be built. I still do not know how to do that.
T 1710090569 18<25yziquel18>	and you have to log in to get to zulip. i'm annoyed.
T 1710090793 18<28Vorpal18>	yziquel: had to deal with hand written Makefiles earlier today, even worse
T 1710090811 18<25yziquel18>	Makefiles have been getting better nowadays.
T 1710091560 18<25yziquel18>	too long to build
T 1710091788 18<25yziquel18>	too long to build
T 1710093800 18<29neiluj18>	Hi! seeing that a portion of my application can take up to 80ms to acquire a lock on a mutex, is there a way to avoid waiting too long?
T 1710093814 18<20nullie18>	 Can I get raw HTTP request bytes from reqwest::Request?
T 1710093839 18<22rbox18>	 neiluj wait until the mutex is not locked b efore acquiring it
T 1710093919 18<25bertptrs18>	neiluj: std mutex doesn't offer anything useful for it, but parking_lot offers try_lock_for and try_lock_until which both effectively support some timeout
T 1710094005 18<26dav1d18>	neiluj, you can with a Condvar
T 1710094022 18<26dav1d18>	which has a wait_timeout method
T 1710094062 18<25bertptrs18>	dav1d: that requires you already having the guard
T 1710094151 18<26dav1d18>	bertptrs, I guess it's tricky
T 1710094163 18<25bertptrs18>	it does something entirely unrelated, rather
T 1710094174 18<26dav1d18>	you'd have the guard, unlock it with the condvar just to wait on it, probably not what you'd want
T 1710094233 18<26dav1d18>	yeah brainfart, thought you could make it work
T 1710094240 18<25yziquel18>	how does cargo select the rustc software to run ? how coupled is it to it ?
T 1710094276 18<25yziquel18>	yziquel because if I have to run cargo to debug rustc, I need to control that selection. otherwise, it's useless trying to make a fix and build it if i can'trun it.
T 1710094477 18<26dav1d18>	yziquel, RUSTC env var
T 1710094510 18<26dav1d18>	(or override it in .cargo/config.toml)
T 1710094818 18<29neiluj18>	oh nice thanks bertptrs!
T 1710094903 18<29neiluj18>	thanks rbox, too!
T 1710097355 18<25OwlWizard18>	ive just read about rust's matching and i have to say this seems like one of the most powerful parts of the langugae
T 1710097412 18<22rbox18>	its not that differnt from like switch
T 1710097418 18<25bertptrs18>	matching is so good most many major languages have started to incorporate it as well
T 1710097425 18<25bertptrs18>	rbox: it's much more powerful than a switch
T 1710097428 18<20polychromata{J}18>	It's pretty hecking different from switch as in C.
T 1710097433 18<20polychromata{J}18>	Or even switch as in JavaScript.
T 1710097444 18<25bertptrs18>	python and java introduced their own matching recently (ish)
T 1710097450 18<22rbox18>	guess i'm not that easily impressed
T 1710097450 18<20polychromata{J}18>	Rust didn't introduce it, though; Haskell and probably similar languages have had it for a while. :)
T 1710097466 18<25bertptrs18>	it's pretty common in functional langauges, yes
T 1710097476 18<20polychromata{J}18>	In every other language i try to use, i miss match{} /so bad./
T 1710097498 18<25OwlWizard18>	i find the match guard feature to be extremely cool
T 1710097519 18<20polychromata{J}18>	Swift actually beat Rust to that one by several years, heh.
T 1710097565 18<25bertptrs18>	If swift wasn't so hard to get working under linux I'd probably like it a lot. it makes a lot of nice choices
T 1710097565 18<20spb18>	matching is only the same as a switch statement if you never use enums with fields
T 1710097572 18<25OwlWizard18>	iirc the point of rust isnt to invent everything
T 1710097576 18<20j`ey18>	r nesting
T 1710097580 18<20j`ey18>	*or
T 1710097589 18<20spb18>	can't nest if your enums have no fields
T 1710097679 18<25bertptrs18>	even then you can still match on for example chars much more elegantly than it would be with a switch-case
T 1710097729 18<25bertptrs18>	match c { 'a'..='z' => Type::LowerCase, 'A'..='Z' => Type::UpperCase … etc
T 1710098049 18<20polychromata{J}18>	Is there a way to impl AsyncRead for a type where the data comes not from an underlying reader but rather from other tasks that push data in by calling async methods with /borrowed/ buffers?
T 1710098082 18<20polychromata{J}18>	I can conceptualise this in terms of rawpointers, and i feel like it's sound, but to write it with safe code i think i'd need like a channel over references with lifetimes i couldn't write.
T 1710098174 18<20polychromata{J}18>	Essentially the problem is transporting the borrow from the push method to where poll_read can get at it.
T 1710098220 18<25bertptrs18>	a VecDeque of pushed data and a mutex to guard it?
T 1710098351 18<26danieldg18>	polychromata{J}: you have to transfer ownership out of the writing task
T 1710098360 18<25bertptrs18>	Maybe I'm misunderstanding the problem
T 1710098362 18<26danieldg18>	even with unsafe you'd have to do that
T 1710098441 18<26danieldg18>	a shared buffer is a good way to do it, and pretty easy to do safely if you don't need to hold a lock on the buffer for long periods
T 1710098460 18<26danieldg18>	(that is, nothing like calling AsyncRead to fill the buffer)
T 1710098499 18<20polychromata{J}18>	bertptrs: That's the simple solution, right. The thing is that it introduces a third, intermediate buffer—and if my choice of size for this third buffer is too small for the usecase, it'll spin in async executor code a lot unnecessarily when it could have just copied straight from the source buffer to the sink buffer.
T 1710098541 18<26danieldg18>	polychromata{J}: move the buffer's ownership instead of the data
T 1710098557 18<20polychromata{J}18>	It's not an owned buffer.
T 1710098557 18<25bertptrs18>	polychromata{J}: you know what they same about the time to start optimizing
T 1710098568 18<25bertptrs18>	they say*
T 1710098727 18<20polychromata{J}18>	Unsafely, i could make the method that pushes data return a future that borrows the buffer, passes a rawpointer to it, wakes tasks that are waiting to read, and resolves after receiving a signal that the reads are done.
T 1710098774 18<20polychromata{J}18>	…maybe i should actually write this out and reframe my question as “how do i make this /safe/”?
T 1710098805 18<26danieldg18>	polychromata{J}: and if your push method gets cancelled halfway through?
T 1710098825 18<26danieldg18>	I bet that path is what would make things unable to be safe
T 1710098914 18<20polychromata{J}18>	hmmm.
T 1710098991 18<26danieldg18>	it's basically the same as sending a reference to another thread, which is unsafe without scoped threads
T 1710099030 18<26danieldg18>	in fact futures usually can run on another thread
T 1710099041 18<20polychromata{J}18>	Right. The thing is, the actual sharing is so short in scope that i figured there must be way to make it work?
T 1710099059 18<20polychromata{J}18>	The sharing only needs to last for the length of one poll_read call.
T 1710099069 18<20polychromata{J}18>	And that just copies a buffer.
T 1710099090 18<26danieldg18>	Arc<Mutex<Buffer>>
T 1710099101 18<20polychromata{J}18>	…where buffer = &[u8]
T 1710099116 18<26danieldg18>	no, Buffer = Vec<u8>
T 1710099120 18<20polychromata{J}18>	hence my “references with lifetimes i couldn't write”
T 1710099161 18<26danieldg18>	this is a reason the bytes::Bytes buffers are owned
T 1710099162 18<20polychromata{J}18>	See, but then i'm allocating a Vec, which takes us back to “introduces a third, intermediate buffer”
T 1710099242 18<26danieldg18>	so you can't get ownership of the first *or* last buffer in any way?
T 1710099327 18<26danieldg18>	then yeah, I agree, you can do it with unsafe but not with safe lifetimes
T 1710099333 18<20polychromata{J}18>	Right. The push calls work on borrowed data (&[u8], which is borrowed from some other struct, which is borrowed from something else), and poll_read reads into a borrowed buffer
T 1710099429 18<26danieldg18>	basically during the copy operation, you must ensure that both buffers are valid, but no single rust function will have more than one available as a parameter
T 1710099447 18<25bertptrs18>	You could try to lazily use the buffer. have asyncread mark the entire struct as "I've got a dest buffer for you", and then when a push comes, check if there's a reader waiting, if so, copy to reader, else copy to intermediate
T 1710099468 18<25bertptrs18>	Do some destructor magic to ensure the state remains valid
T 1710099484 18<26danieldg18>	that's one way to do it with unsafe, eys
T 1710099546 18<26danieldg18>	you can actually do it both ways: have enum ChannelState { ReaderHere(*const [u8]), WriterHere(*mut [u8]), OnlyDataHere(Vec<u8>), Empty }
T 1710099602 18<26danieldg18>	the push-data transitions Empty->ReaderHere; on Drop it copies and moves to OnlyDataHere
T 1710099612 18<25bertptrs18>	I think you have to have the buffer always, to deal with over and underflowing buckets
T 1710099622 18<26danieldg18>	the writer (not poll_read, an actual async read) can do the same
T 1710099684 18<26danieldg18>	if you insist on poll_read and poll_write, it's impossible; if you get async fn read+async fn write, you can use the full enum; one async + one poll is only that direction 'Here'
T 1710099717 18<26danieldg18>	it sounds like you have async write + poll_read right now
T 1710099725 18<20polychromata{J}18>	Yep.
T 1710099731 18<20polychromata{J}18>	Hmmmmm.
T 1710099773 18<20polychromata{J}18>	Alright. Thank you! ^.^
T 1710099787 18<26danieldg18>	and the ChannelState must go in an Arc<Mutex<, with Drop on a guard held by the writer locking the mutex
T 1710099809 18<20polychromata{J}18>	…oh, there /is/ still a mutex involved.
T 1710099812 18<26danieldg18>	yep
T 1710099819 18<20polychromata{J}18>	…that makes sense.
T 1710099831 18<26danieldg18>	atomics aren't good enough for this
T 1710099840 18<26danieldg18>	you need a wait capability
T 1710099857 18<20polychromata{J}18>	Yeah.
T 1710100704 18<28Vorpal18>	I tried the coz profiler (https://github.com/plasma-umass/coz) which seemed interesting, the idea is it that it can find things that won't stand out in other profilers. A pain to set up (bit rotted academic code, had to get various patches from PRs to make it work on modern Arch Linux with modern DWARF-5). But it found something that hadn't been on my radar. It told me that several functions in some [u8] with hex data -> decoded [u8] functions were slow. So I
T 1710100705 18<28Vorpal18>	went ahead and switched out the hex decoding to the faster-hex crate. Runtime went from 287 ms to 268 ms. So it works.
T 1710100757 18<28Vorpal18>	Quite a pain to manually add "progress points" etc to the code, and set it up as a looping thing.
T 1710100783 18<20capitol18>	this sounds like a nice blog post :)
T 1710100804 18<20nullie18>	Vorpal: is it even statistically significant improvement?
T 1710100886 18<28Vorpal18>	nullie: yes it is. My stdev is ~4 ms according to hyperfine
T 1710100897 18<28Vorpal18>	so 20 ms is well outside that
T 1710100966 18<28Vorpal18>	nullie: I'm writing a command line program that runs quite quickly (in this configuration, where it trust filesystem mtimes, when it check checksums this would not be statistically significant)
T 1710100972 18<20nullie18>	so less than required for declaring disovery?
T 1710100973 18<28Vorpal18>	https://github.com/vorpalblade/paketkoll in case you are interested
T 1710101093 18<28Vorpal18>	nullie: it is a repeatable improvement that is outside noise. If I rerun the hyperfine I get the same result. A single hyperfine run is indeed not 5 sigma as in science. But repeatability (across two different computers) I believe improves on that. Not sure how to do the maths on that though.
T 1710101197 18<28Vorpal18>	I also make sure to vary the test order between old and new (to try to minimise effects that are temporal such as CPU boost). I turn off as much CPU boosting and clock frequency scaling that I can in Linux also.
T 1710103399 18<20polychromata{J}18>	How do you lock an async mutex in a poll method?
T 1710103407 18<20polychromata{J}18>	tokio::sync::Mutex doesn't have a poll_lock()
T 1710103431 18<20polychromata{J}18>	Does the lock() future cancel the lock attempt if you drop it?
T 1710103463 18<20polychromata{J}18>	Do i…poll it, pass the context through, and then forget the future if it wasn't ready? that seems like a bad idea
T 1710103571 18<20polychromata{J}18>	There's an issue on the futures repo that was closed as a duplicate of another issue…which added `lock_owned()`? But i don't see how Arc<Mutex> vs &Mutex helps; there's still no poll_lock()
T 1710103611 18<26danieldg18>	polychromata{J}: don't use an async mutex for this
T 1710103623 18<26danieldg18>	use a *normal* mutex
T 1710103640 18<20polychromata{J}18>	And just count on there being low contention?
T 1710103645 18<26danieldg18>	you can't lock an async mutex in drop anyway, and that's also what you need
T 1710103654 18<26danieldg18>	count on? no
T 1710103713 18<26danieldg18>	you only hold the mutex momentarily by the push op, and during memcpy on the read
T 1710103770 18<26danieldg18>	neither of those are long operations, so contention isn't the problem
T 1710103791 18<26danieldg18>	also, only two users, so not much contention
T 1710103836 18*	20polychromata{J} nods slowly.
T 1710109467 19*	Now talking on 22##rust
T 1710109467 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1710109467 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1710109475 18<26pflanze18>	This version of my StringSplit runs cleanly with miri: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=1f9d4c4353bc997f45ad5c1403409c88
T 1710109491 18<26pflanze18>	It uses another Pin<Box< >> around the whole thing.
T 1710109508 18<26pflanze18>	I don't see a good reason for that need, though.
T 1710109573 18<26danieldg18>	agreed, that seems unneeded
T 1710109771 18<26pflanze18>	Actually, none of the Pin:s are needed now.
T 1710109796 18<26pflanze18>	miri is happy with just the outer Box. I guess that might change if I move it around outside, though.
T 1710109810 18<26danieldg18>	the outer box isn't needed either
T 1710109821 18<25Widdershins18>	i think it might be
T 1710109832 18<25Widdershins18>	hmmm
T 1710109834 18<26danieldg18>	why?  Other than being a miri limitation
T 1710109863 18<25Widdershins18>	mostly that, miri gets pissy about pointer tagging
T 1710109883 18<26danieldg18>	ok? That's not used here
T 1710109884 18<25Widdershins18>	i think it isn't effectively different with it
T 1710109925 18<26pflanze18>	miri didn't accept it without the outer Box
T 1710109925 18<25Widdershins18>	pointer tags as in attributes of the pointers at the IR level, not bit stuffing
T 1710109973 18<25Widdershins18>	pflanze: does removing the pin around the box and just including a phantompinned in the struct also satisfy miri
T 1710110003 18<26pflanze18>	Removing the pin around the box is fine as I mentioned. The box must stay.
T 1710110014 18<26pflanze18>	Phantompinned?
T 1710110047 18<26danieldg18>	just boxing seems worthless to me - you can unbox outside your module with safe code
T 1710110072 18<26danieldg18>	no idea why miri would insist on that
T 1710110076 18<26pflanze18>	BTW if I box it, return it, then on the user side remove it from the box, miri complains, too
T 1710110107 18<26danieldg18>	sounds like a miri limitation then
T 1710110113 18<26pflanze18>	miri is runtime only, so it insists that the pointer (the Box<str>) isn't moved, apparently
T 1710110178 18<26pflanze18>	I'm going through a pointer into the inner box (into the str), and apparently miri thinks that this entails going through the original pointer to the str (the one in the Box), and if this is moved, it is unhappy? Not sure.
T 1710110237 18<26pflanze18>	This seems like about the most basic example, so I'd be confused if miri accidentally doesn't handle this right.
T 1710110313 18<26pflanze18>	But Rust has a thing where a Box can't be moved if there's a reference inside, too, right? Or is it special cased for Vec or something, I don't remember.
T 1710110321 18<26pflanze18>	*a reference to inside
T 1710110476 18<26danieldg18>	that's not special cased for either - if you have a ref to a thing, you can't move that thing
T 1710110477 18<26pflanze18>	Confirmed, definitely can't move a Box when a reference to the thing it holds exists.
T 1710110502 18<26pflanze18>	So, doesn't miri just follow the same rules?
T 1710110547 18<26pflanze18>	Box is moved, hence my reference to its inside is now void.
T 1710110553 18<25Widdershins18>	i think there's basically no strict legal limitation that the contents of a box cannot move when the box moves
T 1710110575 18<26danieldg18>	except that it's impossible for it to do so
T 1710110575 18<26pflanze18>	Well, why does the outer Box help, then? :)
T 1710110581 18<25Widdershins18>	in practice it's the always the case today, but it's not allowed to be relied on
T 1710110595 18<25Widdershins18>	because then you aren't moving the inner box
T 1710110613 18<26pflanze18>	Yep, but if moving the outer box could mean that the inner Box is moved, then...?
T 1710110638 18<25Widdershins18>	like i think the fact that the inner box *doesn't actually* move is coming into play there
T 1710110657 18<26pflanze18>	But the inner box only doesn't move because the outer box protects it from being moved.
T 1710110665 18<26pflanze18>	Which is the point you're trying to contest.
T 1710110676 18<25Widdershins18>	it's not legally required to
T 1710110698 18<25Widdershins18>	and miri is an empirical emulator
T 1710110706 18<26pflanze18>	Ok.
T 1710110718 18<26pflanze18>	But the whole point of Box is so that the inner parts *aren't* moved, no?
T 1710110779 18<26pflanze18>	Besides dyn Box, and self-referential types, fair enough.
T 1710111085 18<25Widdershins18>	the point of box is that it "owns" the data and is responsible for deleting it when it's dropped
T 1710111097 18<25Widdershins18>	which is a semantic that miri doesn't know about
T 1710111125 18<25Widdershins18>	miri cares only whether the referred to data is guaranteed to stay in place or not
T 1710111149 18<26pflanze18>	Sure, but owning the data and being responsible is the case without Box, too.
T 1710111184 18<25Widdershins18>	i think miri does have a concept of the box containing the only unique pointer to the data
T 1710111187 18<26pflanze18>	Apparently miri also cares that the pointer I was going through to retrieve mine is staying in place.
T 1710111204 18<25Widdershins18>	which is what causes its destination to be potentially invalid..?
T 1710111277 18<26pflanze18>	Yes, I guess it derives from the pointer move that the lifetime of the pointed-to thing might have changed, hence "bad".
T 1710111297 18<26pflanze18>	(Pure guess)
T 1710111348 18<26pflanze18>	It doesn't know that if my inner Box disappears that this is when also the references disappear. (But then why not look at it lazily, what actually happens?)
T 1710111384 18<25Widdershins18>	soooooomething like that. miri currently operates on "stacked borrows" and when you move a box nothing else can be borrowing from that unique pointer, so the contents of the box could potentially actually be somewhere else after that move in some allowed optimization
T 1710111398 18<25Widdershins18>	having a pin inside the referenced structure prevents that optimization
T 1710111413 18<26pflanze18>	Anyway, my current hypothesis is that miri simply follows the borrowchecker rules dynamically, in some way. Even if not strictly making sense, perhaps.
T 1710111429 18<25Widdershins18>	that's more or less exactly what miri does
T 1710111438 18<25Widdershins18>	though it follows a different, slightly stricter interpretation
T 1710111449 18<25Widdershins18>	though the difference between one and the other is very narrow
T 1710111470 18<25Widdershins18>	it is one of the lifetime-agnostic models that does provide the same guarantees
T 1710111546 18<26pflanze18>	"having a pin inside the referenced structure prevents that optimization": why? how?
T 1710111566 18<26pflanze18>	Also miri still complained even if I have Pin inside (and outside)
T 1710111629 18<25Widdershins18>	pin declares that it will not move
T 1710111630 18<26pflanze18>	(I mean, Pin outside is irrelevant; as soon as I have a Box outside, miri is happy)
T 1710111686 18<26pflanze18>	I thought Pin is purely a library thing, with no effect on the compiler?
T 1710111698 18<26danieldg18>	it is
T 1710111859 18<26pflanze18>	Basically the self-referential data structure solution concept is: move the data structure (both pointed-at thing and pointers) inside a Box and Pin that to make sure nobody unboxes it; that makes the address not change. In my case, I have a str that needs boxing anyway, but I have to do that additionally.
T 1710111865 18<26pflanze18>	At least, to make miri happy.
T 1710111909 18<26pflanze18>	I also seem to remember having read that one of the self-referential infrastructure crate talked about boxing as solution to some reported UB.
T 1710111913 18<26pflanze18>	Might have been exactly this.
T 1710111953 18<26pflanze18>	(solution as in bug fix; the crate existed for year(s) before already)
T 1710111972 18<25Widdershins18>	if i'm playing with this i'm noticing that you're effectively reimplementing Yoke here
T 1710111978 18<25Widdershins18>	which is super duper tricky
T 1710112118 18<25Widdershins18>	https://manishearth.github.io/blog/2022/08/03/zero-copy-1-not-a-yoking-matter/
T 1710112235 18<25Diablo-D318>	hey guys, I remember someone making a matrix client in rust, but google is being a bitch, anyone know which one Im talking about?
T 1710112241 18<25Diablo-D318>	it doesnt seem to be on matrix.org's list of clients either
T 1710112357 18<26pflanze18>	Diablo-D3, the element.io people work on matrix-rust-sdk, and use it to implement iOS and Android apps (and possible parts of the web app, not sure)
T 1710112399 18<25Diablo-D318>	no, not them (also I thought they discontinued that specific sdk, since they're all js weirdos and allergic to actual code)
T 1710112564 18<26pflanze18>	Diablo-D3, the last commit to that repo was from a day ago. Also, https://element.io/blog/element-x-ignition/
T 1710112836 19*	Now talking on 22##rust
T 1710112836 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1710112836 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1710113061 19*	Now talking on 22##rust
T 1710113061 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1710113061 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1710113076 18<26pflanze18>	Widdershins, I tried owning_ref a while ago. Yoke just confuses me, it seems to be doing the same thing, with more complicated wording and interfaces?
T 1710113164 18<25Widdershins18>	yeah that's similar
T 1710113199 18<26pflanze18>	(But Yoke has 1M+ downloads and release in the last months, owning_ref is mostly unused.)
T 1710113260 18<25Widdershins18>	yoke seems very well thought out to me
T 1710113486 18<26pflanze18>	There are also fortify, self_cell, and pared
T 1710115258 18<20spb18>	i'm fairly sure the 'mostly unused' thing is because owning_ref was shown to be unsound quite a long time ago
T 1710115332 18<26danieldg18>	yeah, if you put a Cell in it you can extend lifetimes you shouldn't
T 1710115550 18<25Widdershins18>	i'm trying to rewrite this with yoke and yeah there's one little thing that i can't figure out to solve a lifetime compliant
T 1710115555 18<25Widdershins18>	complaint* even
T 1710116398 18<22rbox18>	Which statement is the best explanation for why Rust does not allow string indexing?
T 1710116401 18<22rbox18>	Indexing strings would make Rust too easy to use, and Rust developers need job security
T 1710116402 18<22rbox18>	HAHA!
T 1710116450 18<19tokie18>	is that from a poll?
T 1710116471 18<22rbox18>	https://rust-book.cs.brown.edu
T 1710116578 18<25Mutabah18>	rbox: Strings don't have good indexing boundaries that apply in all situations
T 1710116594 18<25Mutabah18>	do you want code units (UTF-8 bytes), codepoints, or graphemes?
T 1710116599 18<25Mutabah18>	it all depends on context...
T 1710116608 18<22rbox18>	well yes, i know what the correct answer to the equsetion was
T 1710116609 18<25Mutabah18>	and with UTF-8, finding the latter two is O(n)
T 1710116615 18<22rbox18>	i just thought that answer was hilarious
T 1710116619 18<25Mutabah18>	Ooooh
T 1710116630 18<25Mutabah18>	Your link wasn't quite clear
T 1710116636 18<26danieldg18>	clearly it should impl Index using an enum that allows all of those
T 1710116638 18<19tokie18>	it's because rust programmers want paid better
T 1710116638 18<22rbox18>	it was a mulitple choice question
T 1710116963 18<25Widdershins18>	ah! it lets you use `Vec` as the yokeable type but it doesn't implement yokeable quite right for it
T 1710117371 18<25Widdershins18>	well, miri still doesn't like it
T 1710117530 18<26danieldg18>	I'm no longer convinced that's a valuable opinion
T 1710117576 18<26danieldg18>	miri likes it -> maybe it's good, or maybe you didn't test it enough; miri doesn't like it -> maybe it's good, just assumes things miri doesn't model
T 1710117915 18<25Widdershins18>	it's certainly *a* test that catches a pretty wide class of things that wouldn't otherwise be caught. when it gets nuanced though it's really messy
T 1710117939 18<26danieldg18>	right, it's very useful in finding things you should look at
T 1710118026 18<25Widdershins18>	https://github.com/unicode-org/icu4x/issues/2095
T 1710118055 18<25Widdershins18>	newer default checks in miri seem to have issues with yoke regardless in this way
T 1710118065 18<25Widdershins18>	though they do have a goal to make it satisfy miri in general
T 1710118115 18<25Widdershins18>	the whole concept just turns out to be annoyingly difficult to express!
T 1710118387 18<25Widdershins18>	more here https://github.com/rust-lang/unsafe-code-guidelines/issues/194
T 1710118768 19*	Now talking on 22##rust
T 1710118768 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1710118768 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1710120367 18<26danieldg18>	hmm.  That means that none of the solutions with Box are valid at all
T 1710120395 18<26danieldg18>	(assuming the worst-case noalias)
T 1710121359 18<20LuxuryMode18>	In my FromRequest impl, when I examine `request.uri().query()`, I can see that there are params present. However, when I attempt to extract these parameters using `request.extensions().get::<Query<HashMap<String, String>>>()`, I consistently receive `None` and do not get any parameters. Any idea what I might be doing wrong here? Here is a snippet of the relevant code: https://gist.github.com/rust-play/71ae1883158be0e76515a457e7d2d715
T 1710121537 18<20LuxuryMode18>	Also works fine when I use directly as an extractor, i.e. `async fn my_handler(params: Query<HashMap<String, String>>...`
T 1710131041 19*	Now talking on 22##rust
T 1710131041 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1710131041 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1710133664 19*	Now talking on 22##rust
T 1710133664 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1710133664 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1710141890 18<20osse18>	I thought having three class to .flatten() in a row was a bit much. But then I remembered .and_then() exists. Praise be.
T 1710152285 19*	Now talking on 22##rust
T 1710152285 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1710152285 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1710153903 18<19safsf18>	quieres ver videos para adultos
T 1710153914 18<19Lumpio-18>	¿que?
T 1710153923 18<19safsf18>	¿Chat por cámara?
T 1710153938 18<19Lumpio-18>	no gracias
T 1710153944 18<19safsf18>	¿Yo por cámara?
T 1710153948 18<19safsf18>	chatear por cámara?
T 1710153962 18<19Lumpio-18>	no
T 1710153988 18<19safsf18>	Primero haga clic en este enlace > https://yourgirlsarcade.life/?u=vtgk60r&o=d7gpk40
T 1710153988 18<19safsf18>	Y completa todas las opciones y luego muestra tu tarjeta, pero no te preocupes, es totalmente gratis.
T 1710154004 18<19Lumpio-18>	Bruh nobody is looking for that here
T 1710154023 18<19safsf18>	Primero haga clic en este enlace > https://yourgirlsarcade.life/?u=vtgk60r&o=d7gpk40
T 1710154024 18<19safsf18>	Y completa todas las opciones y luego muestra tu tarjeta, pero no te preocupes, es totalmente gratis.
T 1710154045 18<19safsf18>	Primero haga clic en este enlace > https://yourgirlsarcade.life/?u=vtgk60r&o=d7gpk40
T 1710154046 18<19safsf18>	Y completa todas las opciones y luego muestra tu tarjeta, pero no te preocupes, es totalmente gratis.
T 1710154131 18<19safsf18>	Mi nombre de usuario es {Ella_Jennings}
T 1710154132 18<19safsf18>	No se requiere información de tarjeta, solo configure su cuenta https://yourgirlsarcade.life/?u=vtgk60r&o=d7gpk40
T 1710154228 18<19safsf18>	Ven a mi telgram >> @mariyacs
T 1710154234 18<19safsf18>	Ven a mi telgram >> @mariyacs
T 1710154605 18<25gahr18>	hi - new to rust, reading the book. I was curious about this example here: https://github.com/rust-lang/book/blob/main/listings/ch04-understanding-ownership/no-listing-19-slice-error/src/main.rs
T 1710154629 18<25gahr18>	it made me wonder: how does the compiler infers that the slice returned is linked in any way to the string ref passed in?
T 1710154644 18<25gahr18>	then I changed the body of the first word to be if s.is_empty() { "empty" } else { "full" }
T 1710154648 18<25gahr18>	and it still errors out the same way
T 1710154680 18<25gahr18>	then I added an explicit lifetime and the error went away
T 1710154680 18<25gahr18>	fn first_word<'a>(s: &String) -> &'a str {
T 1710154702 18<25gahr18>	so, does rust assumes that the lifetime of the return value depends on the lifetime of the argument, *unless told otherwise*?
T 1710154712 18<20j`ey18>	yes
T 1710154731 18<25gahr18>	where can I read more about it? I.e., under which situations it does so?
T 1710154756 18<25gahr18>	I guess if I return a slice into some other container, i.e., not into a string
T 1710154758 18<20j`ey18>	probably later on in the book?
T 1710154765 18<28null_ptr18>	https://doc.rust-lang.org/reference/lifetime-elision.html
T 1710154767 18<25gahr18>	heh ok I'll probably ahve to wait
T 1710154919 18<25gahr18>	thanks!
T 1710155264 18<25gahr18>	oh, so because both param and output lifetimes are elided, rust infers one for the param and assigns it to the output
T 1710155267 18<25gahr18>	that makes sense
T 1710155485 18<20polychromata{J}18>	That should actually be `-> &'static str` :3
T 1710155547 18<20polychromata{J}18>	<'a> -> &'a _ is almost never what you want: the caller can pick any lifetime and you'll return a reference with that lifetime?
T 1710155612 18<25gahr18>	I can't answer that yet, still on chapter 4 :)
T 1710155726 18<25gahr18>	is 'static a special lifetime?
T 1710155794 18<20polychromata{J}18>	Yeah.
T 1710155805 18<20polychromata{J}18>	It's a…keyword?
T 1710155808 18<20polychromata{J}18>	…is that right?
T 1710155810 18<29saati18>	https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html?highlight=static#the-static-lifetime
T 1710155980 18<20polychromata{J}18>	https://doc.rust-lang.org/reference/keywords.html#weak-keywords yep, weak keyword
T 1710157516 18<25gahr18>	alright I'll just continue reading the book, thanks all!
T 1710157549 18<20polychromata{J}18>	Send us any more questions! :3
T 1710158418 18<25elichai218>	Hi, I'm trying to do `println!("cargo:rustc-cfg=c_api");` in a build.rs and I see `--cfg c_api` in the build command, but the cfg is not enabled (I tried `#[cfg(c_api)] compile_error!("c_api")`)
T 1710158446 18<29neiluj18>	Hi! got an async function f that takes an Arc<lock_api::RwLock<RawRwLock, myType>>, but when calling this function in a new thread: tokio::task::spawn(async move { f(a) }) I get the error future created by async block is not `Send`
T 1710158459 18<29neiluj18>	not sure what is wrong here
T 1710158728 18<20spb18>	neiluj: somewhere in your async function, or somewhere down its call tree, you're creating a value of a type that isn't Send and which lives across an 'await'
T 1710158751 18<20spb18>	the detailed error message gives you more information to track it down, but takes a bit of careful unravelling to make sense of it
T 1710159013 18<29neiluj18>	many thanks spb, so basically I pass an Arc to the RwLock to the async function running in a dedicated tokio task, but use it elsewhere: let a=RwLock::new(..); tokio::task::spawn(aync move {f(a)}); g(a);
T 1710159039 18<29neiluj18>	and f mutates a by writing to it
T 1710159115 18<29neiluj18>	but I didn't have this error with a mutex instead of the RwLock
T 1710159171 18<29neiluj18>	oh just removed an tokio::time::sleep(..).await; and the code compiled
T 1710159173 18<29neiluj18>	:)
T 1710159263 18<29neiluj18>	the full error was future is not `Send` as this value is used across an await, so the .await made the returned future not Send somehow
T 1710159369 18<29saati18>	Sleep is Send, you have something else there that's not send but you drop it before the next await point
T 1710159618 18<29neiluj18>	thanks, will look into it
T 1710159941 18<20spb18>	neiluj: the reason this happens is that every time you await something, the async function can pause execution until the thing you're awaiting is ready. in the case of something you pass to tokio::spawn, the next time it wakes up might be on a different thread than the one on which it paused
T 1710159972 18<20spb18>	what this means is that any local variable in the function which is used on both sides of an await needs to be Send because it might be created on one thread and used on another
T 1710160267 18<29saati18>	or if you really need !Send values you can start a single threaded executor instead
T 1710160827 18<20polychromata{J}18>	neiluj: You can't hold sync locks across an await, because the guards are !Send
T 1710160902 18<20polychromata{J}18>	You have to unlock to await, and then (because of a compiler limitation) you have to structure your code so that the await happens outside of the scope that the lock was held in (just drop() or unlock() will produce the same error otherwise)
T 1710160979 18<20polychromata{J}18>	In the simplest case, `{ let guard = mutex.lock(); drop(guard); future.await; }` won't work, but `{ { let guard = mutex.lock(); } future.await; }` will
T 1710161103 18<20polychromata{J}18>	(Something about constructing the type for the async fn state machine happening in a pass before the liveness control flow analysis)
T 1710161108 18<29saati18>	holding a lock across an await is just asking for low performance and deadlocks anyway
T 1710164113 18<29neiluj18>	thanks a lot for the explanations, indeed the lock spanned across the sleep that was awaited
T 1710164122 18<29neiluj18>	it is no longer the case now
T 1710165648 18<25gahr18>	polychromata{J}: thanks, will do!
T 1710166046 18<29neiluj18>	argh, using a library relying on an older version of a framework I'm using, can't convert the returned types of the library to the new ones from the framework
T 1710168620 18<28lmat18>	I think I can get an element of a vec using notation like  my_vec[0];? Where can I find documentation on this operator[]?
T 1710168679 18<20osse18>	lmat: Vec implements the Index trait, which provides that operator
T 1710168708 18<28lmat18>	osse: Oh, nice seeing you here! I didn't know you were a rustacean...makes sense though.
T 1710168724 18<20osse18>	<3
T 1710168742 18<28lmat18>	osse: Looking at that trait, it looks like there is no operator[] separate from fn index, right?
T 1710168774 18<28lmat18>	So fn index should be about the same as fn get?
T 1710168835 18<20osse18>	Same as get() except it panics
T 1710168843 18<28lmat18>	sweet, thanks!
T 1710170160 18<28lmat18>	How does  my_slice[1..2] work? It looks like 1..2 will create a std::ops::Range, so it's like  my_slice[std::ops::Range{start: 1, end: 2}], and [] is index, so   my_slice.index(std::ops::Range{start: 1, end: 2});  but I don't see any index instance member function that takes a range.
T 1710170191 18<20j`ey18>	lmat: https://doc.rust-lang.org/std/primitive.slice.html#impl-Index%3CI%3E-for-%5BT%5D
T 1710170203 18<20j`ey18>	-> https://doc.rust-lang.org/std/slice/trait.SliceIndex.html
T 1710170218 18<28lmat18>	j`ey: Ah! There they are!
T 1710170244 18<28lmat18>	(I used std::ops::Range{start: 1, end: 2} "directly" because I don't see a ::new like I do in std::ops::RangeInclusive)
T 1710172006 18<22evaloop18>	Guys, about mold linker, after some update, mold cannot worked anymore
T 1710172041 18<22evaloop18>	-C link-arg=-fuse-ld=/usr/bin/mold
T 1710172135 18<22evaloop18>	him disappear from debug autput
T 1710172158 18<22evaloop18>	-flto=fat,-O3
T 1710172184 18<22evaloop18>	DEBUG_RUSTFLAGS="-C debuginfo=2"
T 1710172260 18<22evaloop18>	also I have in $PATH d mold
T 1710172260 18<22evaloop18>	ld.mold
T 1710172260 18<22evaloop18>	mold
T 1710172337 18<22evaloop18>	so, for now need manualy add string to build toml that can be work?
T 1710174874 18<22evaloop18>	how actualy fully disable -C linker-plugin-lto? I set -C linker-plugin-lto=false and that can't work why?
T 1710175371 18<22evaloop18>	also passing -C linker-plugin-lto=false worked, but what mold has gone from output
T 1710179490 18<22evaloop18>	oh lol, rustc boot section : linker-flavor
T 1710179490 18<22evaloop18>	This flag controls the linker flavor used by rustc. If a linker is given with the -C linker flag, then the linker flavor is inferred from the value provided. If no linker is given then the linker flavor is used to determine the linker to use. Every rustc target defaults to some linker flavor. Valid options are:
T 1710179490 18<22evaloop18>	em: use Emscripten emcc.
T 1710179490 18<22evaloop18>	gcc: use the cc executable, which is typically gcc or clang on many systems.
T 1710179491 18<22evaloop18>	ld: use the ld executable.
T 1710179493 18<22evaloop18>	msvc: use the link.exe executable from Microsoft Visual Studio MSVC.
T 1710179495 18<22evaloop18>	wasm-ld: use the wasm-ld executable, a port of LLVM lld for WebAssembly.
T 1710179497 18<22evaloop18>	ld64.lld: use the LLVM lld executable with the -flavor darwin flag for Apple's ld.
T 1710179499 18<22evaloop18>	ld.lld: use the LLVM lld executable with the -flavor gnu flag for GNU binutils' ld.
T 1710179501 18<22evaloop18>	lld-link: use the LLVM lld executable with the -flavor link flag for Microsoft's link.exe.
T 1710179539 18<22evaloop18>	and . . . not any word about mold, no way :(
T 1710179587 18<20j`ey18>	it can use 'ld'
T 1710179603 18<20j`ey18>	since its meant to have the same CLI options
T 1710179635 18<22evaloop18>	ok, ld, fine :|
T 1710179707 18<20j`ey18>	thats just the 'flavor', not what is actually used
T 1710184498 18<25Widdershins18>	i suppose you could symlink mold as ld
T 1710184553 18<25Widdershins18>	hm
T 1710185307 18<25Widdershins18>	oh it goes in config.toml not Cargo.toml
T 1710185325 18<28lmat18>	What's the point of building NOT a release build?
T 1710185336 18<25Widdershins18>	lmat: lots of reasons
T 1710185338 18<28lmat18>	In other words, why would I want to turn optimizations off?
T 1710185346 18<25Widdershins18>	because it builds faster
T 1710185356 18<25Widdershins18>	release mode also disables debug
T 1710185361 18<28lmat18>	Widdershins: What is debug?
T 1710185375 18<20j`ey18>	debug information
T 1710185381 18<20j`ey18>	stuff that gdb can use etc
T 1710185381 18<28lmat18>	Widdershins: (I'm a software developer, and I know what debugging is, I just don't know what it has to do with rust.)
T 1710185382 18<25Widdershins18>	debugging symbols and information
T 1710185389 18<28lmat18>	j`ey: I can debug rust in gdb?
T 1710185392 18<20j`ey18>	yes
T 1710185393 18<25Widdershins18>	yes?
T 1710185399 18<28lmat18>	j`ey: Enough said, thank you!
T 1710185403 18<25Widdershins18>	it works pretty much the same
T 1710185415 18<25Widdershins18>	rust builds objects very much like c/++ do
T 1710185419 18<28lmat18>	Widdershins: same as C++, I assume
T 1710185428 18<25Widdershins18>	it mangles names differently but after the code is emitted it's almost identical
T 1710185439 18<28lmat18>	I've been using println! (with a "todo" to implement proper logging), but maybe a debugger will be useful someday!
T 1710185471 18<25Widdershins18>	there's also stuff like the debug_assert! macro that only emits code in #[cfg(debug)]
T 1710185535 18<25Widdershins18>	frequently tests will always be run in debug. a library of mine builds 30 seconds faster and only runs tests 5 seconds slower for example
T 1710185554 18<25Widdershins18>	even though the tests are running like 100x faster in release, it doesn't save time
T 1710185583 18<25Widdershins18>	if this isn't what you want you can change optimization modes, debug settings, etc. in the "dev" and "release"
T 1710185587 18<25Widdershins18>	profiles, in cargo.toml
T 1710185598 18<28lmat18>	Makes sense, thanks for the pointers!
T 1710185607 18<25Widdershins18>	so *by default* the dev profile does little optimization, no LTO, etc. but you can change that
T 1710185616 18<25Widdershins18>	https://doc.rust-lang.org/cargo/reference/profiles.html
T 1710185671 18<28lmat18>	Widdershins: Right, to cook up your own custom profile. nice.
T 1710185673 18<26dav1d18>	lmat, I have yet to actually need a debugger to debug something in Rust
T 1710185703 18<26dav1d18>	it would have been useful plenty of times but never useful enough where I would have "required" it
T 1710185712 18<25Widdershins18>	i've used it because it's super extremely easy to do in jetbrains ides
T 1710185713 18<28lmat18>	dav1d: Right, the compiler pretty much takes care of any typos and "simple" errors. What is left is high-level aggregate-type errors which logging seems to address nicely.
T 1710185722 18<25Widdershins18>	i literally just click the beetle icon instead of the play button
T 1710185723 18<26dav1d18>	Yeah, really comfortable
T 1710185740 18<26dav1d18>	and I used to always launch with debugger when I was doing Java for $work
T 1710185740 18<25Widdershins18>	i will learn a debugger console when i have to :)
T 1710185747 18<25Widdershins18>	which so far is never
T 1710185754 18<25Widdershins18>	i have already forgotten pdb
T 1710185758 18<28lmat18>	Widdershins: Makes sense. I use vim and tmux, so I would have to `cd target/debug && cgdb ./my_app` or whatever
T 1710185766 18<26dav1d18>	yeah jetbrains is nice when it comes to debugging
T 1710185777 18<26dav1d18>	lmat, vim or neovim?
T 1710185781 18<28lmat18>	dav1d: vim.
T 1710185788 18<25Widdershins18>	lmat: i would say you could at least give a shot at the ides, jetbrains has a best-in-class first-class vim mode
T 1710185800 18<26dav1d18>	kk, there is a cool neovim plugin with debugger integration which I wanna setup
T 1710185800 18<25Widdershins18>	but that's just me. some people hate it ymmv
T 1710185804 18<28lmat18>	dav1d: I haven't found a reason to switch to nvim. When I heard that Bram died, I considered it, but it looks like vim development carries on as usual.
T 1710185816 18<28lmat18>	dav1d: That could be really sweet!
T 1710185817 18<26dav1d18>	I already had it working somewhat but wasnt comfortable enough yet for me
T 1710185856 18<28lmat18>	Widdershins: I've used ideas. I've used Jetbrains IntelliJ, eclipse, Microsoft Visual Studio (a long time ago), arduino. I hate all of them.
T 1710185865 18<26dav1d18>	lmat, https://github.com/rcarriga/nvim-dap-ui
T 1710185868 18<28lmat18>	oops s/ideas/ides/
T 1710185869 18<25Widdershins18>	evaloop: where did you try putting your rustflags config? i'm able to get rustc to use any linker i want, by putting it in "./.cargo/config.toml" with, for example, `[target.'cfg(all())'] \n linker = "/usr/bin/wabl"` and then it fails because it can't find /usr/bin/wabl
T 1710185900 18<25Widdershins18>	lmat: something for everyone i guess. i've always got huge mileage out of having an ide
T 1710185912 18<26dav1d18>	IntelliJ is awesome
T 1710185941 18<25Widdershins18>	if your editing is vim brained you can do that there too but i've always been a mouse, keyboard, multi-cursor, ide rename, and regex replace type of guy
T 1710185945 18<25Widdershins18>	and it's never slowed me down
T 1710185976 18<25Widdershins18>	and all the searches, outlines, jump to definition and list usages keys are top notch stuff to have
T 1710185983 18<28lmat18>	but it takes so long to start up...
T 1710185985 18<25Widdershins18>	not to mention diff views and three-way resolver ui my god
T 1710185991 18<25Widdershins18>	it really doesn't though
T 1710186010 18<28lmat18>	Widdershins: "it's never slowed me down" ... that's sort of meaningless.
T 1710186010 18<25Widdershins18>	i mean compared to a terminal yeah but you can also just not close it
T 1710186019 18<25Widdershins18>	no it isn't?
T 1710186046 18<25Widdershins18>	that's the whole justification for doing it a different way: ease and expediency
T 1710186056 18<28lmat18>	Widdershins: What matters to me is: would it slow me down. If you've "always been a ... ide ... type of guy", and it's "never slowed you down", there's no control group, my friend.
T 1710186090 18<25Widdershins18>	that's why i didn't say you should personally do it. nobody has a control group because everyone is n=1
T 1710186090 18<26dav1d18>	<lmat> but it takes so long to start up... | I never understood this complaint. It's a onetime cost, you don't even have to close it ever! And from my experience, it's not significantly slower than rust analyzer for me
T 1710186106 18<28lmat18>	Widdershins: The important comparison is: you can type 130 wpm, you know vim, grep, and tmux like the back of your hand, you're just as comfortable working 500 miles away from your computer as right next to it, THEN you switch to IDEs and it never slows you down. That would be meaningful ;-)
T 1710186115 18<28lmat18>	Widdershins: yeah.
T 1710186159 18<25Widdershins18>	i type 140wpm, i know idea grep and tmux like the back of my hand, and i never have to work 500 miles away from my computer and if i did i have a laptop with just as much ram
T 1710186186 18<25Widdershins18>	and i've never run into a task that takes me meaningfully longer to solve than doing it the vim way would be
T 1710186207 18<25Widdershins18>	software development is not the process of text production. most of your time is thinking and communicating anyway
T 1710186220 18<25Widdershins18>	as long as your editor is low friction and lets you do the text transforms you want it's fine
T 1710186235 18<25Widdershins18>	i was just suggesting it since it sounds like there are a few useful things missing from your tooling setup
T 1710186238 18<28lmat18>	dav1d: If I only work on one project, okay, but I have maybe 8 clients. Is it so snappy that I can have maybe 5 of them running all the time with no sweat? Also, I use tmux to hold each client's work (tmux at -t <client1>; connects me back to that client's terminal session with vim, grep, less, or whatever tools I was running last time.) And I can access it all remotely just as easily as locally <3
T 1710186257 18<25Widdershins18>	don't ask me how many ide windows i have running at any given moment
T 1710186271 18<28lmat18>	Widdershins: yup, good reasoning.
T 1710186279 18<22evaloop18>	Widdershins: that options in/from makepkg.conf, I'm cannot put any in config.toml, maybe because in another one project toml file writed author, and so, I think maybe better use global config, for compile software, but maybe I was wrong, and something won't know about that. ofc
T 1710186373 18<25Widdershins18>	evaloop: https://doc.rust-lang.org/cargo/reference/config.html i was able to make this do things so ymmv
T 1710186381 18<25Widdershins18>	it will look in the global config too
T 1710186404 18<25Widdershins18>	it seems you can provide rustc flags, i think
T 1710186456 18<25Widdershins18>	anyway lmat the startup time being really fast is nice and all. i find ides very snappy nowadays and even though people complain that it uses 3 gigs instead of 10 megabytes i would also observe that that's 3 gigabytes of ram mostly lying fallow
T 1710186461 18<25Widdershins18>	ram is meant to be used
T 1710186491 18<25Widdershins18>	as long as your pagecache is not starving it's great
T 1710186521 18<28lmat18>	sure, most of the time that's fine...until it isn't
T 1710186535 18<25Widdershins18>	when's that tho
T 1710186563 18<25Widdershins18>	i have like a hundred browser tabs, 3 ides, and numerous miscellania open and i'm sitting at like 16% resident ram
T 1710186586 18<28lmat18>	Widdershins: Depends...never know! I write several financial applications and sometimes they like a lot of RAM..
T 1710186643 18<25Widdershins18>	i've had memory leaks eat 33 gigabytes of ram before and it was mostly just annoying
T 1710186643 18<22evaloop18>	Widdershins: wow, great, THX for expensive answer
T 1710186661 18<25Widdershins18>	haha
T 1710186674 18<25Widdershins18>	it's cheaper than it used to be! i find it a very expedient solution
T 1710186687 18<25Widdershins18>	i do this for a living after all
T 1710186715 18<25Widdershins18>	you can get away with like 16 gigs of ram no problem
T 1710186729 18<25Widdershins18>	which is like 'found in a trash can' type of memory capacity these days
T 1710186766 18<20spb18>	unless you're a mac user, then it's mortgage your house type
T 1710186768 18<25Widdershins18>	i don't give the ide jvms half that much
T 1710186781 18<25Widdershins18>	oh god yeah i mean if you're a mac user you kinda brought that on yourself though right
T 1710186903 18<28lmat18>	spb: :-D
T 1710186940 18<25Widdershins18>	i feel real bad for people who actually feel trapped in the mac ecosystem. it seems nightmarish
T 1710186970 18<29saati18>	i'm afraid in a decade it will be like that for everyone, ram will move in package and there won't be upgrades separate from the cpu
T 1710186990 18<28lmat18>	saati: Why?
T 1710187307 18<29saati18>	lmat: ram outside the package won't be able to give the latencies and bandwith of silicon interposers and other new in package interconnects
T 1710187346 18<28lmat18>	saati: Oh, I see
T 1710187368 18<25Widdershins18>	saati: are they gonna upcharge by 20x though
T 1710187374 18<25Widdershins18>	(yes)
T 1710187379 18<26dav1d18>	lmat, I have no intention to tell you what you should use, though I feel like there is some misconceptions here. I've ran IntelliJ (Java/Go/Python projects) consistently with 4+ windows open, each having somewhere between 3-6 projects loaded with 24gb of RAM
T 1710187384 18<25Widdershins18>	so i don't think it will win
T 1710187386 18<26dav1d18>	and a piece of shit cpu
T 1710187411 18<28lmat18>	dav1d: Rock on, my man!
T 1710187416 18<26dav1d18>	and plenty of RAM to spare for chrome
T 1710187421 18<28lmat18>	dav1d: And you leave it open for weeks? ^_^
T 1710187425 18<25Widdershins18>	maybe that's a tragedy but there's massive consumer value for the interchangeability
T 1710187453 18<25Widdershins18>	lmat: yeah why not. the heap is sandboxed so they actually have to fix memory leaks
T 1710187462 18<26dav1d18>	lmat, usually only the first instance loads slower, new instances are almost instant. But yeah I tend to just leave the laptop in standby/hibernation
T 1710187494 18<28lmat18>	dav1d: And a very important aspect to me is remote access. I have a machine at home that is much more powerful than any of my laptops and I SSH to it to do any coding while I'm out. What would that look like with an IDE like that?
T 1710187502 18<26dav1d18>	these times are over, pretty much exclusively on vim now, but not because of memory consumption or startup times
T 1710187536 18<25Widdershins18>	they're working on it, maybe in a couple years it'll be buttery smooth to attach remotely
T 1710187553 18<26dav1d18>	lmat, the intellij remote stuff is actually surprisingly good
T 1710187562 18<26dav1d18>	not made for this specifically but it is quite good
T 1710187572 18<25Widdershins18>	dav1d: not vim mode? wait you're *no longer* using the ides?
T 1710187612 18<26dav1d18>	Widdershins, nah, purely vim now. Once upon a time I decided to learn vim and do all my rust projects exclusively in vim and if I miss a feature, I'll add it to vim. Now I gave up all the other shit but Rust -> Only vim left
T 1710187646 18<25Widdershins18>	ahh, the dotfile horizon
T 1710187653 18<26dav1d18>	although I do miss Intellij at times with the builtin db browser, rest client, easy debugging, ...
T 1710187667 18<19tokie18>	i use rust rover
T 1710187672 18<26dav1d18>	and obviously excellent editing, but that's just a given
T 1710187680 18<19tokie18>	correction: i'm using rust rover with the remote stuff
T 1710187683 18<19tokie18>	it mostly works OK
T 1710187785 18<24SoF18>	does Rust do any loop unrolling before LLVM?
T 1710188245 18<25Widdershins18>	i doubt it
T 1710188254 18<25Widdershins18>	it's just an IR emitter
T 1710188795 18<20j`ey18>	Widdershins: nah theyre adding more optimisations to 'MIR' now
T 1710188807 18<20j`ey18>	(not sure if that includes loop unrolling though, doubt it)
T 1710188818 18<25Widdershins18>	:o
T 1710188860 18<25Widdershins18>	needs more layers https://blog.rust-lang.org/2016/04/19/MIR.html
T 1710188876 18<20polychromata{J}18>	lmat: You can instantiate types directly like that if all their fields are pub.
T 1710188910 18<28lmat18>	polychromata{J}: I was surprised there's no "new" like there is for the other type :-D
T 1710188923 18<25Widdershins18>	proc macros -> macros -> rust -> HIR -> MIR -> IR -> machine code -> ucode
T 1710189073 18<20polychromata{J}18>	It would be kind of redundant. :)
T 1710189089 18<20polychromata{J}18>	You do see that sometimes.
T 1710189429 18<20j`ey18>	Widdershins: of course LLVM IR actually has 2-3 stages of IR too :P
T 1710189737 18<25Widdershins18>	j`ey: https://twitter.com/at_tcsc/status/1573770109537386496
T 1710189821 18<20j`ey18>	hehe
T 1710195009 18<27TimMc18>	Can I bundle an existing non-Rust executable into a Rust binary so that I can call either one, somehow?
T 1710195067 18<27TimMc18>	(I'd like to take an existing Go program and include its functionality in my program.)
T 1710195284 18<20j`ey18>	probably not that easy, maybe better to just require they have it in PATH
T 1710195418 18<22Arnavion18>	include_bytes + memfd_create + fexecve
T 1710195558 18<20polychromata{J}18>	snrk
T 1710195963 18<27TimMc18>	This would be for a single, standalone binary.
T 1710196024 18<27TimMc18>	Arnavion: That would just be jumping into a big byte array, right? :-)
T 1710196030 18<20j`ey18>	baically yeah
T 1710196037 18<22Arnavion18>	Yes
T 1710196063 18<27TimMc18>	I mean, I'm not above doing something like that. :-P
T 1710196086 18<20j`ey18>	could also write it out to a tmp file
T 1710196087 18<22Arnavion18>	The cross-platform way would be to create a tempfile and executing that and hoping you don't get TOCTOUd
T 1710196089 18<20j`ey18>	and then exec it
T 1710196158 18<22Arnavion18>	... and, depending on the method used to create said tempfile, that the underlying filesystem isn't mounted noexec
T 1710196685 18<27TimMc18>	...I kind of want to try this just to see what exciting things happen.
T 1710196715 18<25yziquel18>	Is it possible to implement a cyclic chained list in safe rust (i don't mind bumpalo). if you ask me why, it's a very specific kind of datastructure that is supposed to be "intepreted" very fast. I really need the cyclicity.
T 1710196750 18<25yziquel18>	i don't mind using an arena like bumpalo. i just want to know if it is possible in safe rust or if unsafety is required
T 1710196925 18<25Widdershins18>	yziquel: the common way is to refer to indices in a vec and do it that way
T 1710196946 18<25Widdershins18>	otherwise it is technically possible to do safely with pointers and so on it's just really hard
T 1710196967 18<25yziquel18>	Widdershins it will boil down to that, but i do not the pattern matching as that structure will end up rather involved.
T 1710196982 18<25Widdershins18>	you do what the pattern matching?
T 1710197025 18<25yziquel18>	implement a weird generalisation of lambda calculus verging towards logic programming. the structures i need for that are involved and cyclic.
T 1710197065 18<25Widdershins18>	that's fine
T 1710197093 18<25yziquel18>	before going full array of pointers with weird semantics, i need to prototype it with cyclic algebraic datatypes to make it understandable.
T 1710197116 18<25Widdershins18>	i'm saying you don't need pointers if you just use indices
T 1710197117 18<25yziquel18>	any safe rust implementation of cyclic chained list would be a good prototype to build upon.
T 1710197132 18<25yziquel18>	Widdershins i will need pointers.
T 1710197141 18<25Widdershins18>	you can represent a structure without making its ownership physically dependent on the cycles
T 1710197148 18<25Widdershins18>	you don't ever "need" the pointers
T 1710197162 18<25yziquel18>	sigh. i do need the pointers for what i intend.
T 1710197167 18<25Widdershins18>	which is?
T 1710197186 18<25yziquel18>	an abstract execution machine for that calculus. with pointers.
T 1710197209 18<25Widdershins18>	if your hidden premise is that you have to use pointers and not any other method then that's cheating
T 1710197226 18<25yziquel18>	? why. that's my spec.
T 1710197241 18<25Widdershins18>	you have a collection of objects that want to refer to each other, yes?
T 1710197312 18<25yziquel18>	Widdershins more than that. for now, i need cyclic algebraic data types to prototype. Later, I'll need vectors of pointers and rather involved treatment of them.
T 1710197332 18<25Widdershins18>	you're skipping a step mate
T 1710197336 18<25yziquel18>	?
T 1710197371 18<25yziquel18>	Widdershins which step ?
T 1710197380 18<25Widdershins18>	the step where you think about whether pointers are required or not
T 1710197394 18<25Widdershins18>	because you can get the exact same effect in other ways, without worrying about unsafety
T 1710197423 18<25yziquel18>	Widdershins pointers WILL be required.
T 1710197438 18<25yziquel18>	it's the whole point of the exercise.
T 1710197440 18<25Widdershins18>	you keep saying this but until i know why they're required i can't really say anything new
T 1710197539 18<25yziquel18>	Widdershins because I intend to generalise Krivine's machine for semantics of lambda calculus as it pertains to set theory (see Luminy slides 2004 and later) and adapt it to a logic programming setting by revisiting some works in logic about existential quantification as dual to the substitutional fragment of first order logic. And that machine
T 1710197539 18<25yziquel18>	will need pointers.
T 1710197563 18<25yziquel18>	I tend to be annoyed by people always questioning what I plan to do.
T 1710197570 18<25yziquel18>	I already have a mother.
T 1710197606 18<25Widdershins18>	you've come here to ask how to do something safely, and i offered a way to do something that has the exact same effect and is trivially safe
T 1710197635 18<25yziquel18>	What I have asked is: cyclic chained list in safe rust. nothing else.
T 1710197647 18<25Widdershins18>	if this is a school assignment that you flunk if you don't use pointers i suggest not using rust because it's very easy to create extremely invalid programs doing pointer dances like that
T 1710197656 18<25yziquel18>	Widdershins no. it's research.
T 1710197670 18<25yziquel18>	Widdershins i'm a logician by training.
T 1710197675 18<25Widdershins18>	rust's guarantees can make programs invalid and invoke UB much sooner when doing pointer traversal than e.g. c++
T 1710197679 18<25yziquel18>	i want to implement some ideas of mine.
T 1710197700 18<25yziquel18>	I want to try the pointer dance.
T 1710197722 18<20j`ey18>	any actual (raw) pointer in rust is unsafe
T 1710197768 18<25yziquel18>	j`ey whch is precisely why I'm asking about cyclic algebraic datatypes safe.
T 1710197774 18<25Widdershins18>	well i'll warn you it's a real pain. the safer-ish way is to use Rc<RefCell<T>> instead of pointers, such that it will actually immediately explode with runtime checks if you do something invalid
T 1710197783 18<25yziquel18>	if there is an example of a cyclic chained list, I take it.
T 1710197790 18<20spb18>	what you are doing requires pointers, if you are using 'pointer' as shorthand for 'a way to persistently reference another object of a given type without lifetime bounds'
T 1710197809 18<20spb18>	but there are ways to do that which are not literally `*const T`
T 1710197809 18<25yziquel18>	Widdershins i know it's a pain. already in OCaml it's a pain.
T 1710197889 18<25Widdershins18>	well if you are set upon using exactly pointers and nothing else you can certainly write that code
T 1710197892 18<25yziquel18>	spb if i need a thunk of unsafety to tie the cyclicity, I'm fine with it. If I can do it safely, I'm more fine with it. I intend to eschew most lifetime issues by using an arena like bumpalo.
T 1710197937 18<25yziquel18>	Widdershins I want an algebraic data types whose representation is pointers. not indices with lookups.
T 1710197939 18<25Widdershins18>	unsafety still requires following the rules, it is only for the purpose of enforcing the unbreakable rules that define a valid rust program in ways that the compiler cannot check for you
T 1710197962 18<25Widdershins18>	and it can get very difficult to do that correctly
T 1710197986 18<25yziquel18>	Widdershins I did a C level binding with OCaml and R with two GC's stepping over one another. I'm well aware that unsafety has rules.
T 1710197988 18<25Widdershins18>	subtle things that cause references to coexist illegally can make the program invalid or even misbehave even if they don't appear to interact
T 1710198063 18<25yziquel18>	Widdershins ok. now. anyone knows of a not too ugly implementation of cyclic chained list in rust ?
T 1710198077 18<25Widdershins18>	the main thing you get performancewise by using pointers instead of indices is that deleting incrementally doesn't leave allocated dead space in the backing array. otherwise indices pointing to indices is, performance-wise, pretty much equivalent
T 1710198095 18<25Widdershins18>	maybe you want https://rust-unofficial.github.io/too-many-lists/
T 1710198115 18<25yziquel18>	Widdershins memory management will be a later stage. my machine is quite simple but hairy in details such as that.
T 1710198135 18<20j`ey18>	from a quick crates.io look it doesnt look like there is, but maybe there's better search terms
T 1710198151 18<25Widdershins18>	ok well good luck with the contraption
T 1710198152 18<25yziquel18>	Widdershins i skimmed over too many lists. i haven't seen cyclic chained list. will reread.
T 1710198167 18<20j`ey18>	https://crates.io/crates/cdl-list-rs uses rc/refcell
T 1710198331 18<25Widdershins18>	the deque in https://rust-unofficial.github.io/too-many-lists/fourth-layout.html is effectively cyclic, the List type has pretty much the same fields as the Node type does
T 1710198413 18<25yziquel18>	j`ey I'm fine using RefCell if I need to build the structure. What I want in the end is an immutable algebraic data type. cyclic.
T 1710198438 18<25yziquel18>	I really need 1. immutable 2. algebraic 3. cyclic. But only as end result.
T 1710198452 18<25yziquel18>	lifetime can be tied to a wider arena to avoid issues.
T 1710198524 18<25yziquel18>	Widdershins reference counted. not what I want.
T 1710198547 18<27TimMc18>	yziquel: Any chance you can just avoid garbage collection and let program termination take care of everything for you? :-P
T 1710198549 18<19LDericher18>	please check out another borrow/lifetime issue I'm currently facing, any suggestions? https://bpa.st/2CDQ
T 1710198814 18<19LDericher18>	I don't get why the buffer "escapes the closure body" if I only use an immutable borrow, once
T 1710198827 18<25Widdershins18>	LDericher: it's not once, it's inside a loop so it'll live on to the next iteration
T 1710198867 18<25Widdershins18>	and you're reassigning tx at which point it must be cleaned up because there's nowhere else to put it, but the new tx you're assigning to it depends on the old one
T 1710198880 18<25Widdershins18>	that's what it looks like
T 1710198894 18<25yziquel18>	TimMc no garbage collection matters. I just want to construct an immutable circular chained list.
T 1710199031 18<25yziquel18>	from what I see, I have to fool the compiler with unsafety. i hate that, but i see no other way around it.
T 1710199104 18<26dav1d18>	LDericher, what type is xfer and is it tied to the reference that was passed in?
T 1710199157 18<19LDericher18>	xfer holds references to both the "tx" used to transfer and the "buffer" it's transmitting
T 1710199232 18<26dav1d18>	LDericher, what does xfer.wait() return, a TX which is still tied to the buffer?
T 1710199268 18<19LDericher18>	wait() returns the (buffer, tx), both untied
T 1710199301 18<25yziquel18>	Is it possible, in unsafe rust to cast struct with a mutable pointer to the same struct without the mutability of the pointer ?
T 1710199309 18<25yziquel18>	or in safe rust even ?
T 1710199386 18<20j`ey18>	*mut T I think can be used in place of *const T already?
T 1710199437 18<20j`ey18>	evalr: fn bar(a: *const u32){} fn foo(a: *mut u32) {bar(a)}
T 1710199439 -18evalr/22##rust-	j`ey: ()
T 1710199461 18<20j`ey18>	but https://doc.rust-lang.org/std/primitive.pointer.html#method.cast_const also exists
T 1710199536 18<26dav1d18>	Widdershins, am I missing something, if the new tx is not tied to the buffer, it should be fine right?
T 1710199598 18<25Widdershins18>	i think xfer is borrowing tx...?
T 1710199626 18<25Widdershins18>	i'm not sure :/
T 1710199628 18<26dav1d18>	Yeah, but the wait should consume it and return a new tx without a lifetime to the buffer?
T 1710199739 18<26dav1d18>	Looks fine to me, but clearly it's not, hard to guess without actual type info. Already past my bed time, gl
T 1710199767 18<25Widdershins18>	yeah need to see more of the crate for this
T 1710199998 18<25yziquel18>	Widdershins this seems to allow what I need, though I'd like to see if it works with Enums and not only structs. https://github.com/dtolnay/readonly
T 1710200032 18<25Widdershins18>	enums work the same as structs
T 1710200072 18<20j`ey18>	also seems quite unrelated to anything you talked about
T 1710200085 18<25Widdershins18>	yeah this is about visibility
T 1710200146 18<19LDericher18>	Widdershins, I pushed the crate to my git, the last commit is the changes I'm trying to make: https://code.yavook.de/jmm/bluepill-rust-blinky/src/branch/irc
T 1710200282 19*	Now talking on 22##rust
T 1710200282 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1710200282 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1710200283 18<20polychromata{J}18>	<yziquel> I tend to be annoyed by people always questioning what I plan to do.
T 1710200283 18<20polychromata{J}18>	<yziquel> I already have a mother.
T 1710200283 18<20polychromata{J}18>	off-topic, but i feel like somecreature should mention that this is not normal
T 1710200291 18<20polychromata{J}18>	you are gently encouraged to surround yourself with people who respect your autonomy. things tend to be much better that way.
T 1710200305 18<20polychromata{J}18>	(speaking from personal experience)
T 1710200310 18<25yziquel18>	polychromata{J} you want to go down that lane ?
T 1710200350 18<20polychromata{J}18>	depends on what you mean by that? i'll be in ##rust-offtopic
T 1710200384 18<25Widdershins18>	cdhowie: as far as i can tell based on its implementation (which is very funny btw) there's no reason it *can't* work on enums
T 1710200424 18<20cdhowie18>	Widdershins: i don't see how it could work with enums at all
T 1710201345 19*	Now talking on 22##rust
T 1710201345 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1710201345 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1710201393 18<20polychromata{J}18>	like a lot of std types do that, things like `pub struct Foo(crate::sys::imp::Foo);`, where that module is #[cfg] based on platform. or something like that
T 1710201394 18<25Widdershins18>	explicit privacy is a thing, including by convention a la python's prefixing with an underscore (or with two underscores, for the magic mangle)
T 1710201406 18<25Widdershins18>	buuuut we're down the other road now a good ways with rust
T 1710201475 18<25Widdershins18>	perhaps you could put `pub(partial)` as the visibility of the enum, and then the variants and fields therein would only have visibility as declared
T 1710201640 18<25yziquel18>	Is OnceCell a way to tie the knot of an immutable cyclic (singly) linked list ?
T 1710201678 18<26danieldg18>	it could be, though you need to solve the freeing problem too
T 1710201699 18<25yziquel18>	danieldg i plan to use bumpalo to eschew that problem.
T 1710201737 18<25yziquel18>	doable ?
T 1710201758 18<26danieldg18>	sure
T 1710201777 18<26danieldg18>	you could use a normal cell too
T 1710201780 18<25yziquel18>	danieldg good to know. that will save me some time w/r investigation.
T 1710201787 18<26danieldg18>	but yeah, oncecell is probably nicer
T 1710201815 18<25yziquel18>	danieldg an normal cell has a runtime penalty, no ?
T 1710201868 18<26danieldg18>	no, it's just more annoying to use
T 1710201882 18<26danieldg18>	unless the type is Copy
T 1710201908 18<26danieldg18>	Cell<Option<T>> and OnceCell<T> are basically identical if T is copy
T 1710201920 18<26danieldg18>	other than the ability to write multiple times w/ Cell
T 1710201973 18<20cdhowie18>	RefCell<T> has a runtime penalty (unless the optimizer can prove the refcounting redundant), but Cell<T> does not
T 1710201979 18<25yziquel18>	and i get get a T out of it, if i understand right ?
T 1710201988 18<26danieldg18>	you get &T
T 1710201988 18<25yziquel18>	i can get
T 1710202000 18<25yziquel18>	danieldg ok. just what I need.
T 1710202007 18<25yziquel18>	i'll try it.
T 1710202512 18<25Widdershins18>	i think OnceCell<&'a Self> would work to populate a cyclic network of direct references between values as long as all of the values' ownerships outlive 'a
T 1710202529 18<25Widdershins18>	and it maintains a trivial drop
T 1710202599 18<25Widdershins18>	actually would 'a have to be exactly equal to the lifetime of their ownership. is that allowed? maybe 'a has to outlive the ownership and you must be forced to drop them all before 'a is done actually
T 1710202611 18<25yziquel18>	Widdershins kind of what i plan to do for my cyclic lambda terms.
T 1710202651 18<25Widdershins18>	you could actually make the ownership arbitrarily extensible with constant references using the dumb clown thing i made the other week that i keep bringing back up
T 1710202656 18<26danieldg18>	Widdershins: I think you end up with &'a Node<'a> for everything
T 1710202666 18<25Widdershins18>	danieldg: yeah
T 1710202674 18<26danieldg18>	it might forbid you from implementing Drop on Node
T 1710202706 18<25Widdershins18>	i can imagine that would be the case
T 1710202908 18<25Widdershins18>	is this allowed at all? i don't know how it's possible to take apart e.g. a btree of these when deleting a single one would invalidate literally all the rest and make them un-look-at-able
T 1710202922 18<26danieldg18>	actually maybe that would just be bumpalo's stipulation, it doesn't Drop at all
T 1710202955 18<26danieldg18>	that makes it much simpler
T 1710204472 18<25yziquel18>	Where is the value retrieved by OnceCell.get() allocated in memory ?
T 1710204486 18<26danieldg18>	inside the cell itself
T 1710204493 18<26danieldg18>	you can look at the impl
T 1710204506 18<26danieldg18>	it's a thin wrapper around UnsafeCell<Option<T>>
T 1710204748 18<25yziquel18>	https://docs.rs/once_cell/latest/once_cell/#lateinit
T 1710204760 18<25yziquel18>	but not quite what i seek.
T 1710204778 18<26danieldg18>	yziquel: this is in std now
T 1710204825 18<26danieldg18>	clarify your question then
T 1710204885 18<25Widdershins18>	wondering if there's a reachable soundness hole around this
T 1710204888 18<25yziquel18>	wel, i wonder. thinking.
T 1710204930 18<25Widdershins18>	or if there's some dance that has to happen or straight up precludes what I'm thinking of
T 1710204943 18<25Widdershins18>	taking a nap will look later
T 1710204982 18<26danieldg18>	Widdershins: I think it could only happen with Drop impls, but yeah, it does feel like you could get to dead objects after making a self-referential struct
T 1710205025 18<25Widdershins18>	if you put them in 2 vecs, make a cycle, and drop one vec. what then
T 1710205049 18<25Widdershins18>	is that illegal, do you have to drop both. are the refs present but unlookable
T 1710205070 18<26danieldg18>	this is related to #[may_dangle]
T 1710205115 18<25yziquel18>	danield it seems it works. the memory layout is just pointers to pointers to pointers. no overhead. what i was looking for.
T 1710205117 18<20cdhowie18>	Widdershins: The compiler should not let you do that.  That's effectively a textbook self-referential struct.
T 1710205125 18<25yziquel18>	danieldg it seems it works. the memory layout is just pointers to pointers to pointers. no overhead. what i was looking for.
T 1710205227 18<26danieldg18>	Widdershins: yep, it rejects it
T 1710205247 18<25Widdershins18>	danieldg: where does the crime occur exactly
T 1710205253 18<26danieldg18>	on drop
T 1710205275 18<25Widdershins18>	do you have to drop both vecs or is the whole thing illegal
T 1710205284 18<26danieldg18>	evalr: use std::cell::OnceCell; struct S<'a>(OnceCell<&'a S<'a>>); let x = S(OnceCell::new()); x.0.set(&x); drop(x); impl<'a> Drop for S<'a> { fn drop(&mut self) {}}
T 1710205286 -18evalr/22##rust-	danieldg: error[E0597]: `x` does not live long enough ...
T 1710205287 -18evalr/22##rust-	danieldg: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=5896d72b18bb347398fa9b37707bf7c7
T 1710205308 18<26danieldg18>	having more than one x just makes it longer
T 1710205339 18<25Widdershins18>	i don't need an impl drop though I'm just wondering how they can be owned
T 1710205359 18<20cdhowie18>	They'd be owned by the arena
T 1710205361 18<26danieldg18>	if you remove the impl Drop it'll compile
T 1710205378 18<26danieldg18>	evalr: use std::cell::OnceCell; struct S<'a>(OnceCell<&'a S<'a>>); let x = std::mem::ManuallyDrop::new(S(OnceCell::new())); x.0.set(&x); impl<'a> Drop for S<'a> { fn drop(&mut self) {}}
T 1710205380 -18evalr/22##rust-	danieldg: ()
T 1710205387 18<26danieldg18>	that one kinda surprised me
T 1710205417 18<26danieldg18>	it's fine but I expected rustc to reject it anyway
T 1710205436 18<25Widdershins18>	hah
T 1710205475 18<25Widdershins18>	you have to forget it? or can you actually do the drop because you have to do it unsafely
T 1710205492 18<26danieldg18>	you have to forget it if you want to be safe
T 1710205494 18<25yziquel18>	danieldg lateinit is not in stdlib.
T 1710205503 18<25yziquel18>	i think
T 1710205525 18<26danieldg18>	yziquel: lateinit is just a "how do I use this", not an actual feature
T 1710205537 18<25yziquel18>	stupid me
T 1710205890 18<25yziquel18>	ok. got it. perfect. happy evening.
T 1710206275 18<26danieldg18>	evalr: #![feature(dropck_eyepatch)] use std::cell::OnceCell; struct S<'a>(OnceCell<&'a S<'a>>); let x = S(OnceCell::new()); x.0.set(&x); unsafe impl<#[may_dangle] 'a> Drop for S<'a> { fn drop(&mut self) {}}
T 1710206277 -18evalr/22##rust-	danieldg: error[E0554]: `#![feature]` may not be used on the stable releas ...
T 1710206278 -18evalr/22##rust-	danieldg: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=9f6a30f272664760faa91cbe66e4b4e0
T 1710206285 18<26danieldg18>	evalr: --unstable #![feature(dropck_eyepatch)] use std::cell::OnceCell; struct S<'a>(OnceCell<&'a S<'a>>); let x = S(OnceCell::new()); x.0.set(&x); unsafe impl<#[may_dangle] 'a> Drop for S<'a> { fn drop(&mut self) {}}
T 1710206287 -18evalr/22##rust-	danieldg: error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an ...
T 1710206287 -18evalr/22##rust-	danieldg: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=85e1c619e50b0f35d243829b1fefa800
T 1710206297 18<26danieldg18>	evalr: --nightly #![feature(dropck_eyepatch)] use std::cell::OnceCell; struct S<'a>(OnceCell<&'a S<'a>>); let x = S(OnceCell::new()); x.0.set(&x); unsafe impl<#[may_dangle] 'a> Drop for S<'a> { fn drop(&mut self) {}}
T 1710206299 -18evalr/22##rust-	danieldg: ()
T 1710206373 18<26danieldg18>	so you can actually do the drop, you just have to promise not to look at the ref when you are in the drop impl
T 1710207178 18<25Widdershins18>	danieldg: ohhh
T 1710207555 18<25Widdershins18>	yeah ok so
T 1710207577 18<25Widdershins18>	i can use the circus impl to add vecs full of self-referential whatsits
T 1710207597 18<26danieldg18>	yep
T 1710207612 18<25Widdershins18>	but nothing self-referential or containing anything self-referential can be moved or dropped except in-place
T 1710207614 18<26danieldg18>	rustc will stop you if you do it wrong
T 1710207626 18<26danieldg18>	also yes
T 1710207652 18<26danieldg18>	self-referential things are annoying to use because of this
T 1710207670 18<25Widdershins18>	and if dropping is all done implicitly i guess that is sufficient to prove that it happens automatically, effectively instantaneously, and by the book
T 1710207674 18<25yziquel18>	seems a cool discussion.
T 1710207737 18<25Widdershins18>	for some reason i thought labeled blocks could be named as lifetimes
T 1710207763 18<26danieldg18>	they do use the same syntax
T 1710207794 18<25Widdershins18>	it would make sense to have 'a: { .. } and anything in that block could name 'a as "promised to live at least as long as the end of this block"
T 1710207804 18<25yziquel18>	yes
T 1710207805 18<25Widdershins18>	seems that can't be spelled though
T 1710207818 18<25Widdershins18>	'a is just a label here, and lifetimes can only be created via parameter
T 1710207933 18<25Widdershins18>	i guess fair enough since encouraging people to spell explicit lifetimes can only bake in the current borrowck model annoyingly hard
T 1710208068 18<25Widdershins18>	https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=107daf6585e4fe9259be22d109207e61
T 1710208643 18<25Widdershins18>	those could probably be Box<[ScaryClown]> but it's surprisingly annoying to turn Box<[T; N]> into Box<[T]>. unless i'm forgetting an easy way to do it
T 1710208660 18<26danieldg18>	I think it's just an as?
T 1710208696 18<25Widdershins18>	:o you can `as` a Box?
T 1710208732 18<25Widdershins18>	or do you `as` the sized array in place without taking it as a reference
T 1710208740 18<25Widdershins18>	i wasn't aware you could do either of those things
T 1710208770 18<26danieldg18>	it's the same as making a Box<dyn Foo>
T 1710208773 18<26danieldg18>	which is also via as
T 1710208774 18<25Widdershins18>	wow you can as the box
T 1710208781 18<25Widdershins18>	is this a compiler carve-out
T 1710208802 18<26danieldg18>	it's an unsizing coersion
T 1710208818 18<26danieldg18>	I think it just works for things that are generic with <T:?Sized>
T 1710208864 18<25Widdershins18>	interesting... and that goes straight through the generics and makes it a different concrete type you're holding?
T 1710208880 18<26danieldg18>	basically it just widens the pointer
T 1710208911 18<25Widdershins18>	yeah but if this isn't special for box that's wild, since you could use that to widen any generic pointers within any struct
T 1710208921 18<26danieldg18>	it might require CoerceUnsized
T 1710208936 18<26danieldg18>	no, you don't widen the pointer *in* the struct
T 1710208946 18<26danieldg18>	you widen the pointer to the struct
T 1710208962 18<25Widdershins18>	you get a new struct with the same values and the same pointer but now the pointer is wide
T 1710208980 18<25Widdershins18>	i can as the box without any features
T 1710209026 18<25Widdershins18>	vec also automatically coerces to Box<[T]> apparently, but Box<[T; N]> does not
T 1710209038 18<25Widdershins18>	or at least whatever `vec!` spits out does
T 1710209041 18<25Diablo-D318>	[19:16:04] <pflanze> Diablo-D3, the last commit to that repo was from a day ago. Also, https://element.io/blog/element-x-ignition/
T 1710209059 18<25Diablo-D318>	I guess its good news they didnt fuck this up
T 1710209252 18<25Diablo-D318>	btw, apparently I may have been thinking of fractal
T 1710209318 18<25Diablo-D318>	sadly, its gnome's own client
T 1710209319 18<25Widdershins18>	danieldg: not having any luck applying it to a type containing a ref
T 1710209325 18<25Diablo-D318>	so thats super doa
T 1710209336 18<25Widdershins18>	even with the feature
T 1710209383 18<25Widdershins18>	or do you have to impl the feature
T 1710209386 18<25Widdershins18>	trait*
T 1710209412 18<26danieldg18>	Widdershins: I think you have to have the boxlike impml CoerceUnsized
T 1710209508 18<25Widdershins18>	> implement CoerceUnsized<Ptr<U>> for Ptr<T> where T: Unsize<U>, U: ?Sized
T 1710209517 18<25Widdershins18>	i see how it is ok
T 1710209648 18<25Widdershins18>	and it won't let you implement it on an enum. bummer
T 1710210049 18<25Widdershins18>	so the coercion only works if it always knows precisely what to do, you can't have branches in there
T 1710210402 18<29cowboy86118>	hey hey
T 1710210885 18<25Widdershins18>	haha
T 1710210894 18<25Widdershins18>	pro tip: don't actually derive Debug for a self-referential type
T 1710212525 18<19int-e18>	Widdershins: why not why not why not why not why not why not why not why not why not why not why not why not why not why not stack overflow?
T 1710212549 18<25Widdershins18>	bilbo.jpg
T 1710212640 18<27TimMc18>	haha RIP
T 1710212673 18<25Widdershins18>	printing to the terminal was actually slow enough, since it tries to pretty print it with indentation and becomes quadratic, that i could just ctrl+C
T 1710212705 18<25Widdershins18>	no segfaults today just a normal program don't worry about it
T 1710212718 18<27TimMc18>	It's a good thing your computer was slow, otherwise it might have been slower.
T 1710212720 18<19int-e18>	boring!
T 1710212752 18<27TimMc18>	(or OK yeah, probably a segfault and not a memory gobbler)
T 1710225221 19*	Now talking on 22##rust
T 1710225221 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1710225221 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1710234722 18<26dav1d18>	Widdershins, I was gonna order one with `-Wall -Werror -pedantic` or something like that, but I never did :(
T 1710235819 18<27mkoncek18>	package maintainers compiling your project with a different version of the compiler love -Werror
T 1710238972 18<25Widdershins18>	IN THIS HOUSE WE BELIEVE -Wall -Werror -pedandic #[allow(unsafe_code)] -flto=true -Cpanic=abort
T 1710239461 18<20polychromata{J}18>	<Widdershins> idea: live laugh love kitsch that says "read eval print line"
T 1710239477 18<20polychromata{J}18>	shouldn't that be `print eval read line`
T 1710239488 18<20polychromata{J}18>	or just `print eval read`
T 1710239503 18<25Widdershins18>	right. also it's supposed to be "loop" isn't it
T 1710239510 18<25Widdershins18>	that's better
T 1710239524 18<20polychromata{J}18>	(loop (print (eval (read))))
T 1710239557 18<25Widdershins18>	READ through the ditches and EVAL through the witches and PRINT in the back of my dragula
T 1710240587 18<27mkoncek18>	print eval read line - perl
T 1710240784 18<25narodnik218>	for a trait's associated type like: trait T { type X }, how when specifying the trait, i can specify trait bounds for the associated type? for example:
T 1710240813 18<25narodnik218>	impl<T> for MyClass<T> where T::X : From<u32> { ... }
T 1710240827 18<25narodnik218>	when i try that, the compiler says: "error[E0223]: ambiguous associated type
T 1710240830 18<20jbg18>	your impl is supposed to specify the associated type
T 1710240865 18<25narodnik218>	i don't want the impl to specify the associated type, i just want to add an additional trait bound
T 1710240893 18<20jbg18>	that's not how associated types work
T 1710240900 18<20jbg18>	what type would you expect X to have inside the impl block?
T 1710240900 18<25narodnik218>	yes they are, impl<T> for MyClass<T> { ... } compiles fine for me
T 1710240909 18<20jbg18>	that's because that is not an associated type
T 1710240933 18<25narodnik218>	MyClass is not a specialization of T, it contains an object of type T
T 1710240944 18<20jbg18>	again, that is not an associated type
T 1710240947 18<25narodnik218>	struct MyClass { t: T }
T 1710240952 18<20jbg18>	just because you have decided that these things are the same does not make them the same
T 1710240957 18<20jbg18>	T is a type parameter
T 1710240972 18<20jbg18>	trait T { type X } X is an associated type
T 1710240973 18<25narodnik218>	yes but i want MyClass to specify that the associated type for T has the trait bound From<u32>
T 1710240988 18<25narodnik218>	impl<T> for MyClass<T> where T::X : From<u32> { ... }
T 1710240990 18<25narodnik218>	like this
T 1710241003 18<20jbg18>	first of all, this is not valid syntax; what trait are you implementing?
T 1710241024 18<20jbg18>	maybe you just want to remove the 'for'?
T 1710241048 18<25narodnik218>	https://agorism.dev/uploads/foo.rs.txt
T 1710241083 18<20jbg18>	okay, this bears very little resemblence to the code soup you were writing above
T 1710241086 18<25narodnik218>	this line works: impl<F: FieldElement, H: FieldHasher<F, 2>, const N: usize, S: StorageAdapter<Value=F>> SparseMerkleTree<F, H, N, S> {
T 1710241096 18<20jbg18>	yes. this is not a trait impl, you will notice
T 1710241113 18<20jbg18>	it's implementing methods on the type SparseMerkleTree, which has some type parameters
T 1710241150 18<20jbg18>	and it's putting bounds on those type parameters, and one of the traits mentioned in those bounds has an associated type
T 1710241214 18<25narodnik218>	trait T { type X; }
T 1710241216 18<25narodnik218>	struct MyClass { t: T }
T 1710241218 18<25narodnik218>	impl<T> MyClass<T> where T::X : From<u32> { }
T 1710241234 18<20jbg18>	okay, now you have got rid of the 'for' it's more clear what you are trying to do
T 1710241235 18<25narodnik218>	in this example T = StorageAdapter, MyClass = SparseMerkleTree, and X = Key
T 1710241253 18<25narodnik218>	ah my apologies
T 1710241255 18<20jbg18>	the problem with the line you just wrote is that there is no bound on T
T 1710241287 18<20jbg18>	assuming StorageAdapter is a trait, maybe you want `where T: StorageAdapter, T::X: From<u32>`
T 1710241335 18<25narodnik218>	ohhh ofc
T 1710241341 18<25narodnik218>	thanks a lot, that was the issue
T 1710241344 18*	25narodnik2 bows
T 1710243191 18<20jbg18>	why is this a compiler warning? pub enum MyEnum { Field(InnerType) } struct InnerType(i32);
T 1710243204 18<20jbg18>	warning: type InnerType is more private than the item MyEnum::Field::0
T 1710243229 18<20jbg18>	i did this deliberately because all enum fields are public
T 1710243350 18<20j`ey18>	InnerType can be pub witbout that u32 being pub though?
T 1710243363 18<20jbg18>	sure, but why is it a warning for it not to be?
T 1710243587 18<20spb18>	the warning is there because on anything except an enum field it's almost always an error - if a pub fn takes an argument of a private type then nothing outside the module can ever call it and the fn should probably be private too
T 1710243613 18<20spb18>	the lint just doesn't account for the fact that enum fields are the one place you might deliberately want to do it
T 1710243716 18<20jbg18>	mm ok
T 1710246338 18<27TimMc18>	Am I missing something, or is this error from the compiler weird and misleading? https://gist.github.com/timmc/1346e695afbe2ba179543a6249d337aa (just the error on line 1 -- the errors for lines 2 and 3 make sense to me)
T 1710246432 18<27TimMc18>	It's like it has the error and note highlighting reversed, and the message is confusing. And it only happens if I have the *same* error on lines 2 and 3 -- if only one of them is present, the first error highlight disappears.
T 1710246434 18<19Lumpio-18>	You're asking about the fact that in the second case the "^^^^ not mutable" is gone or?
T 1710246481 18<19Lumpio-18>	I wouldn't say it's misleading, just the hint about where the immutable variable was declared is missing
T 1710246610 18<27trenka18>	TimMc: do you mix immutable `data` as reference to mutable Vec with mutable reference to `data`?
T 1710246831 18<20spb18>	TimMc: when you type `&mut data` you're creating an `&mut &mut Vec<u32>`, i.e. you're trying to mutably borrow the reference, and the reference itself isn't mutable
T 1710246969 18<27TimMc18>	I understand the error now, but I'm still confused about why the compiler said line 1 has an error.
T 1710246979 18<27TimMc18>	It's only lines 2 and 3 that have the error!
T 1710247055 18<20j`ey18>	yes I think that's wrong
T 1710247106 18<27TimMc18>	Maybe I should check a newer version of the compiler, though.
T 1710247133 18<20spb18>	https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=195352ba4352214a2bfaa3a67d908d7e
T 1710247148 18<20spb18>	shows the same behaviour, with two different errors both related to 'not mutable'
T 1710247164 18<20jbg18>	line 1 does have the error though
T 1710247176 18<20jbg18>	the binding isn't declared as mut
T 1710247197 18<20spb18>	i suspect there's a heuristic there that says if you try to mut borrow a mut borrow once then it's probably that you need to just use the borrow, but if you do it twice then maybe you do need to declare it mut
T 1710247198 18<28xkr4718>	heh I searched for kmerge up and down in crates.io only to find it in std :D
T 1710247257 18<28xkr4718>	no wait, it's from itertools, and I already had that imported
T 1710248622 18<27TimMc18>	(OK yeah, nightly still gives the same errors.)
T 1710248685 18<27TimMc18>	Or very similar. spb, I think you're right about that heuristic.
T 1710252998 18<27xx18>	how do I write this simple program in rust, to demonstrate how rust works compared to C? https://0x0.st/HhIy.c
T 1710253083 18<29mefistofeles18>	xx: well, you just write it in Rust :P you can get familair with Rust syntax with the rust book
T 1710253170 18<20osse18>	Like so? https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=b46ca4597963c981ee056a8215b37bb4
T 1710253176 18<27xx18>	which one is the "rust book"?
T 1710253426 18<20osse18>	https://doc.rust-lang.org/book/
T 1710253541 18<20j`ey18>	osse: it looks identical!
T 1710253785 18<25narodnik218>	lets say i have a struct which takes several trait params like <X, Y>. when calling new(), we can infer Y from passed in values, but X needs to be specified explicitly
T 1710253792 18<25narodnik218>	how can i make a new method like that?
T 1710253808 18<25narodnik218>	something like:
T 1710253810 18<25narodnik218>	    fn new<const N: usize>(x: X) -> Self { Self { y: [0; N], x } }
T 1710253819 18<25narodnik218>	which you call with:     let s = S::new::<2>(7u32);
T 1710253848 18<20j`ey18>	try with Type<X, _>
T 1710253904 18<25narodnik218>	yeah that works, but isn't it possible to get rid of the _?
T 1710253907 18<25narodnik218>	    let s = S::<2, _>::new(7u32);
T 1710253932 18<25narodnik218>	(my code has more like X, Y, Z, W and only X must be specified explicitly)
T 1710254033 18<25narodnik218>	https://agorism.dev/uploads/main.rs
T 1710256499 18<19LDericher18>	is there a way in (unsafe) rust to say "give me a new immutable/readonly reference to this variable - I'll make sure it exists and is in a sane state"?
T 1710256542 18<20j`ey18>	&variable ?
T 1710256554 18<19LDericher18>	… regardless if other references to that variable exist, even mutables?
T 1710256570 18<20j`ey18>	that's not possible in rust, even unsafe
T 1710256580 18<19LDericher18>	so basically, "exclude this one from borrow checking"?
T 1710258287 18<20spb18>	LDericher: you can take a reference to it before any mutable borrows happen, store that reference as a pointer, do your mut borrowing, then unsafely turn the pointer back into a reference
T 1710258308 18<20spb18>	you shouldn't, but you can
T 1710259231 19*	Now talking on 22##rust
T 1710259231 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1710259231 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1710261267 18<20cdhowie18>	spb: that's undefined behavior
T 1710261398 18<20cdhowie18>	note this is UB even with UnsafeCell<T>
T 1710262229 18<20spb18>	it's UB if the value is mutated while the reconstituted reference exists
T 1710262659 18<20cdhowie18>	which basically means "it's UB" because it allows unsound stuff to happen in safe code
T 1710262719 18<20cdhowie18>	"it's only UB if safe code doesn't do something" is IMO a distinction without a difference.  regardless of whether it's technically immediately UB, it allows safe code to cause UB, so it's definitely not sound.
T 1710262782 18<27lambda18>	cdhowie: you mean "unsound", not UB
T 1710262798 18<20cdhowie18>	ok.  fine.  yes, either way it's bad.
T 1710263677 18<27alepzi18>	how can i add "/" to a PathBuf? join and push replace if it's absolute which is shit
T 1710263813 18<27lambda18>	alepzi: you want to convert `foo/bar` to `foo/bar/`?
T 1710263817 18<27alepzi18>	yep
T 1710263844 18<27lambda18>	I don't think PathBuf is really set up for that
T 1710263875 18<27lambda18>	what do you need it for?
T 1710263878 18<27alepzi18>	sorry but that's a shit API. makes total sense to wanna do it
T 1710263879 18<20capitol18>	that replace if absolute is a really annoying behaviour that makes it easy to generate vulnerabilies
T 1710263905 18<27alepzi18>	to take a /foo var and then build off of it to make a bunch of others, sometimes adding /
T 1710263913 18<27alepzi18>	ya it's not good design
T 1710263943 18<20capitol18>	maybe: convert to an osstring, do alterations, convert back
T 1710263945 18<27lambda18>	alepzi: but you can just .push() to that to add more components?
T 1710263980 18<27alepzi18>	no
T 1710264519 18<27alepzi18>	realize /foo/bar and /foo/bar/ are different, but there's no way to make the latter if i start with /foo/bar
T 1710264539 18<27alepzi18>	so i have to make unterminated and terminated versions of the path it's just stupid
T 1710264561 18<27alepzi18>	it matters when using the paths with external stuff, like unix commands like tar, rsync, etc
T 1710264577 18<20nullie18>	are they different for the os or only for some external tools?
T 1710264584 18<20nullie18>	yeah
T 1710264611 18<29phy172918>	Only some tools and I hate that UI because I never can remember with or without means what
T 1710264628 18<27alepzi18>	no idea. i'll bet if i use the rust api to delete files from /foo/bar and /foo/bar/ it probably does the same thing because internally it knows it's a dir
T 1710264649 18<27alepzi18>	"only some" yea like most unix tools
T 1710264662 18<27alepzi18>	dir vs dircontents/, simple
T 1710264776 18<20spb18>	cdhowie: i mean that's the entire point of the unsafe keyword though. it lets you do stuff that could cause UB, and it's on you to satisfy yourself that it won't because the compiler can't
T 1710264786 18<20nullie18>	Does PathBuf maintains it as /foo/bar/ sometimes?
T 1710264811 18<27alepzi18>	ya if i make and print out 2 pathbufs, /foo/bar and /foo/bar/, they print like that (different)
T 1710265628 18<26dav1d18>	evalr, std::path::PathBuf::from("/foo/bar").join("baz")
T 1710265631 -18evalr/22##rust-	dav1d: "/foo/bar/baz"
T 1710265656 18<27alepzi18>	ya now try to make a version trailing with the path separator, /
T 1710265777 18<20j`ey18>	evalr, std::path::PathBuf::from("/foo/bar").join("baz/")
T 1710265779 -18evalr/22##rust-	j`ey: "/foo/bar/baz/"
T 1710265785 18<20j`ey18>	evalr, std::path::PathBuf::from("/foo/bar").join("/")
T 1710265787 -18evalr/22##rust-	j`ey: "/"
T 1710265811 18<27alepzi18>	and if you have /foo/bar, how do you make /foo/bar/ from it?
T 1710265862 18<29HeTo18>	evalr: std::path::PathBuf::from("/foo/bar").join("")
T 1710265864 -18evalr/22##rust-	HeTo: "/foo/bar/"
T 1710265908 18<27alepzi18>	omfg king
T 1710265948 18<27alepzi18>	WINNER
T 1710266709 18<22Arnavion18>	The fact that they "print different" is just because they retain the original string they were created from. It makes no difference to how they behave. They both have the same components
T 1710266729 18<22Arnavion18>	If you're relying on how they print you may be doing something wrong
T 1710266754 18<27alepzi18>	it matters when passing as an arg to Command when that's going to unix commands
T 1710266784 18<27alepzi18>	like cp
T 1710266870 18<22Arnavion18>	What cp command are you running that it makes a difference
T 1710266951 18<27lambda18>	Arnavion: `cp foo bar/` fails if `bar` isn't a directory, that's the only difference I know
T 1710266983 18<22Arnavion18>	Right, and if bar does exist as a directory then `cp foo bar` would still succeed
T 1710266993 18<22Arnavion18>	so that's why I'm asking
T 1710266994 18<19nCrazed18>	yeah, I'd imagine there are a number of cases where the behaviour changes between file vs. directory, if for no other reason than the original authors didn't know any better
T 1710267107 18<26dav1d18>	dont symlinks behave differentely?
T 1710267233 18<22Arnavion18>	`touch a; mkdir d; ln -s d d2; cp a d2` copies a into d/ instead of replacing d2
T 1710267514 18<20spb18>	`ls -l foo` and `ls -l foo/` behave differently if foo is a symlink to a directory
T 1710267554 18<20spb18>	similarly for `stat`
T 1710267566 18<22Arnavion18>	ls is not cp
T 1710267600 18<20spb18>	right, but the underlying point that sometimes it matters when you're passing the path to an external command is valid, even if cp isn't a good example
T 1710267718 18<22Arnavion18>	I never said that general commands wouldn't behave differently
T 1710267735 18<20spb18>	cp will also behave differently if the source argument is a symlink to a directory
T 1710267741 18<27alepzi18>	"It makes no difference to how they behave"
T 1710267758 18<22Arnavion18>	"They" == PathBuf in a Rust context, yes
T 1710267776 18<27alepzi18>	ya and i disagree
T 1710267841 18<22Arnavion18>	<spb> cp will also behave differently if the source argument is a symlink to a directory   < Example? `mkdir d; mkdir d2; ln -s d d3; cp d2 d3` fails asking for `-r`, just like it would with a source directory
T 1710267865 18<22Arnavion18>	Err, that's `cp d3 d2` of course
T 1710267912 18<22Arnavion18>	<alepzi> ya and i disagree   < I didn't ask if you agree. I asked if you have a cp command where the / makes a difference
T 1710267977 18<27alepzi18>	i'll make 1 later and it'll either be cp or tar or another unix util that shows it because i've run into it before
T 1710267999 18<22Arnavion18>	So "No", okay. Thanks
T 1710268023 18<20capitol18>	wow, snarky
T 1710268024 18<27alepzi18>	ah the arrogant asshole stage of rust
T 1710268030 18<27alepzi18>	i remember that from java
T 1710268032 18<22Arnavion18>	To your original point, rather than rely on .join(""), it would be better to make a wrapper that appends `/` when printified
T 1710268045 18<22Arnavion18>	I'm not being arrogant or snarky...
T 1710268060 18<27alepzi18>	"cool"
T 1710268078 18<22Arnavion18>	Who are you quoting?
T 1710268108 18<27alepzi18>	you're dismissive about obviously counterintuitive api behavior. if you want drama go beat your gf
T 1710268117 18<27alepzi18>	sorry, sex worker*
T 1710268140 18<20j`ey18>	I mean, being an arrogant asshole is not as bad was what you just said soo..
T 1710268170 18<20capitol18>	alepzi: that wasn't very cool either
T 1710268173 18<20polychromata{J}18>	alepzi: Wow
T 1710268189 18<20polychromata{J}18>	I can't even figure out what's wrong with that sentence
T 1710268228 18<20polychromata{J}18>	(. Implying inferiority for being customer of sex work is still disparaging sex work?)
T 1710268241 18<20polychromata{J}18>	yeah something like that probably
T 1710268301 18<20spb18>	Arnavion: https://bpa.st/45SQ
T 1710268391 18<22Arnavion18>	Indeed, thanks
T 1710268423 18<22Arnavion18>	Also, "when printified" won't work because we want OsStr's ...
T 1710268550 18<27alepzi18>	ya need os str
T 1710269178 18<22Arnavion18>	https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=bed379637c4e3a98b257e97e44fbde8d   Ugh
T 1710269393 18<27alepzi18>	C vibes
T 1710269653 18<22Arnavion18>	(Less allocy and unsafe:   https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=1f99ad96eb662eb13c7058995521a841   )
T 1710269782 18<27alepzi18>	we'd wanna use path::MAIN_SEPARATOR too ya?
T 1710269833 18<22Arnavion18>	Forgot about OsString::push, derp   https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=bdbd1236ced99df6296583cc7458b7f8
T 1710270014 18<27alepzi18>	and https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=6bafdc7ffb89614b1caa7270a8810f61 ?
T 1710270091 18<27alepzi18>	still have 1 on line 10 tho
T 1710270930 18<27alepzi18>	dunno how to fix that 1
T 1710270986 18<20j`ey18>	that doesnt allocate, if thats what you meant
T 1710271302 18<27alepzi18>	replacing the b'/' on line 10 with MAIN_SEPARATOR(_STR) so it's windows compatible is right ya?
T 1710271437 18<25chairs18>	Arnavion: rsync cares about trailing /, if it's missing it'll copy the dir *and* contents, if it's there it'll only copy contents (IIRC, possible I have it reversed)
T 1710271482 18<22Arnavion18>	Again, I was asking about cp
T 1710271723 18<25chairs18>	`cp -d foo bar/` gets different behavior from `cp -d foo bar` if `bar` is a symlink. But `-d` is kind of asking for it.
T 1710271825 18<22Arnavion18>	Yeah
T 1710273743 18<22valve18>	ls
T 1710275543 18<27alepzi18>	ok https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=f2206463ad6ecd4b6599060f5be6ff07 is that all good? if so Arnavion make a crate from it so i can use it?
T 1710275751 18<19Lumpio-18>	Is there a reason this is not a function
T 1710275866 18<25bertptrs18>	having a newtype with the specific invariant is kinda nice, but yeah, this might as well be a single function, and is hardly worth being a crate
T 1710275916 18<25bertptrs18>	code reuse is great but we don't need to emulate https://www.npmjs.com/package/is-odd
T 1710275961 18<25bertptrs18>	or rather https://www.npmjs.com/package/is-even, which of course depends on the previous one
T 1710276039 18<19tokie18>	version 3.0.1, lol
T 1710276112 18<29phy172918>	I appreciate the usage example could be replace with checking for an int instead of a string
T 1710276517 18<27alepzi18>	phy1729: what example?
T 1710276543 18<29phy172918>	For is-even
T 1710276606 18<25bertptrs18>	phy1729: that's why this package depends on is-odd, which in turn depends on is-number
T 1710276612 18<25bertptrs18>	I stopped checking there
T 1710276671 18<27TimMc18>	tokie: I can't tell if that's funnier than 0.3.1 would be.
T 1710276685 18<19tokie18>	TimMc: 0.3.1 could just be a few bugs ...
T 1710276695 18<27TimMc18>	Speaking of which, what is *with* Rust crates being 0.x?
T 1710276696 18<19tokie18>	i guess that's equally funny
T 1710276842 18<25bertptrs18>	TimMc: people being hesitant to commit to a 1.0, then the whole universe starts depending on it, and depending on the specific crate, bumping might've become impossible
T 1710276843 18<27alepzi18>	situation.is_equally(funny)
T 1710276970 18<27TimMc18>	Oh I see, so it's not "why are these fundamental packages at 0.x", it's "they're at 0.x because they're now fundamental". Amazing.
T 1710277020 18<27TimMc18>	because there's probably a bunch of crates out there constraining to <1
T 1710277127 18<29phy172918>	You don't want to commit to an API before you have some users to find the sharp points, but also once you have a good API you might have enough users that bumping just to mark as 1.0 would be a non-trivial impact.
T 1710277134 18<19tokie18>	it's also because of how semver works. if you bump the first digit then people won't pickup your fixes until they change their Cargo.toml probably
T 1710277151 18<19tokie18>	so there's really no reason to do it unless you actually intend on a new major version
T 1710277281 18<25bertptrs18>	TimMc: there are probably hyper-corporate environments that will indeed restrict to >= 1.0 but most environments will be more sensible. And it's not all bad, quite a few of the big ones have gone 1.0. regex, hyper, serde
T 1710277336 18<29phy172918>	serde is mildly amazing in that it's pushing 1.0.200
T 1710277471 18<29phy172918>	Does dtolnay have any crates that aren't either 0.x or 1.0.x?
T 1710277611 18<25bertptrs18>	had to search for it but his indoc crate is at 2.0.4
T 1710277627 18<29phy172918>	and syn is also 2.0 but that's fair considering rust's changes
T 1710277893 18<28BtbN18>	So, I'm cross compiling for the same target, which seems to massively confuse cargo. i.e. it's using the wrong linker for the build script. How do I change the linker used for that script specifically?
T 1710279436 18<28BtbN18>	Or is there a simple way to add a mock-target, something akin to x86_64-my_custom-linux-gnu? So that I can then "cross" compile to that, with its own set of tools, while having other stuff properly use the host tools?
T 1710280918 18<25bluss18>	phy1729: yes, it's amazing how he's managed to add features to serde 1.0 for so long
T 1710280988 18<28BtbN18>	https://github.com/rust-lang/cargo/issues/8147 this seems to describe the same/a similar issue, with no solution...
T 1710281728 18<20jbg18>	BtbN: it's not cross compiling if the host and target are the same target spec
T 1710281757 18<28BtbN18>	It is though, they're very different flavours of Linux that can't run binaries of one another
T 1710281770 18<28BtbN18>	But both are x86_64-unknown-linux-gnu
T 1710281772 18<20jbg18>	i understand that you want to cross compile
T 1710281779 18<20jbg18>	but it is not cross compiling if the targets are the same
T 1710281800 18<20jbg18>	what you are saying is that one of your Linuxes is not actually targeted by x86_64-unknown-linux-gnu
T 1710281805 18<28BtbN18>	Well, what should I do then? I need cargo/rust to build tools to run on the "host" with a different linker than the ones for the target.
T 1710281819 18<28BtbN18>	Both are normal linux with glibc
T 1710281824 18<28BtbN18>	One is just really dang old
T 1710281848 18<20jbg18>	the target is older than the host or vice versa?
T 1710281857 18<28BtbN18>	The target is really really old glibc
T 1710281865 18<20spb18>	so what you want is not to cross compile but to compile using a different libc than the system one
T 1710281865 18<20jbg18>	and the host can't run binaries intended for the target?
T 1710281867 18<28BtbN18>	to produce binaries that run on ancient CentOS on a modern host
T 1710281901 18<28BtbN18>	The host can run them fine. But would need special linker options. It's complicated, and boils down to: I'm cross compiling to the same arch tripple
T 1710281945 18<28BtbN18>	The issue is that cargo tries to link the build-script with the target compiler, but fails horribly, cause the env is super old and is lacking libraries the build script expects.
T 1710281955 18<20jbg18>	it's not cross compiling, and you will get much better help if you stop pretending it is
T 1710281958 18<28BtbN18>	There would be no issue if it's simply call normal gcc to build the build-script
T 1710281964 18<20jbg18>	if i understand correctly you need to link an old libc
T 1710281977 18<28BtbN18>	I successfully do, that part works fine
T 1710281986 18<28BtbN18>	But I need the build-script to NOT link that old libc
T 1710281991 18<20jbg18>	yes
T 1710281993 18<20jbg18>	i understand
T 1710282002 18<20spb18>	https://kobzol.github.io/rust/ci/2021/05/07/building-rust-binaries-in-ci-that-work-with-older-glibc.html might be relevant to you
T 1710282024 18<20jbg18>	by far the easiest paths to doing this are either a) build in a container (can be automated with tools like `cross`) or b) forget about it and statically link musl instead
T 1710282041 18<28BtbN18>	I already am building in a container. That is the whole point of this endeavour
T 1710282041 18<20j`ey18>	the build script should be built for the host though?
T 1710282051 18<20spb18>	(a) is the solution that author settled on
T 1710282059 18<28BtbN18>	For rust, host and target are the same though, j`ey
T 1710282063 18<28BtbN18>	For gcc they aren't.
T 1710282071 18<20jbg18>	if you're building in a container, why isn't your container running your ancient environment too?
T 1710282073 18<20spb18>	BtbN: so make a container using the ancient libc and build in that
T 1710282078 18<20jbg18>	that's the whole point of building in a container
T 1710282085 18<20jbg18>	(for this purpose)
T 1710282088 18<28BtbN18>	jbg: Because it's too old and can't run or build other stuff I need.
T 1710282095 18<20jbg18>	so use another container for the other stuff
T 1710282109 18<28BtbN18>	Yeah, not that easy
T 1710282138 18<28BtbN18>	This setup is building over two dozen libraries for the old-glibc target, but with a modern compiler.
T 1710282140 18<20j`ey18>	BtbN: ok then maybe a custom target is the way to go
T 1710282165 18<28BtbN18>	Actually just dug out this, which seems to address exactly my issue: https://doc.rust-lang.org/cargo/reference/unstable.html#host-config
T 1710282183 18<28BtbN18>	Annoying that it needs nightly though
T 1710282199 18<20jbg18>	needing nightly is not that big a deal
T 1710282205 18<20jbg18>	if you are doing something unusual it's common to end up on nightly
T 1710282221 18<28BtbN18>	Odd that it's marked unstable though, the PR that's listed there is quite old
T 1710282235 18<20jbg18>	why would the age of the PR have anything to do with it not being in stable?
T 1710282250 18<28BtbN18>	I'd imagine stuff eventually is not nightly anymore, but makes it into a normal release
T 1710282271 18<20jbg18>	stuff doesn't just end up in stable because it's been around long enough
T 1710282285 18<28BtbN18>	It can still be marked unstable, but be in there
T 1710282297 18<20jbg18>	that's not how these things work; unstable features are only available on nightly
T 1710282306 18<28BtbN18>	odd choice, but okay
T 1710282307 18<20jbg18>	otherwise they become de-facto-stable
T 1710282329 18<20jbg18>	imagine you let them through the gate into stable without any process just because they were around a few years
T 1710282334 18<20jbg18>	then 40% of your user base uses them
T 1710282336 18<28BtbN18>	At least on ffmpeg we have a bunch of features in stable releases you need to opt into experimental-mode for, but they are in normal releases.
T 1710282348 18<20jbg18>	you are now responsible for taking care of those 40% even though you never followed the process to stabilise the feature
T 1710282369 18<28BtbN18>	Nah, if you opt into "unstable mode", you got only yourself to blame if stuff breaks
T 1710282380 18<20jbg18>	that argument breaks down as soon as enough of your users use the feature
T 1710282389 18<20jbg18>	anyway, using nightly is not that big a deal
T 1710282395 18<20j`ey18>	BtbN: you can always just pin  a nightly version
T 1710282395 18<20jbg18>	it's a compiler, not something you're running in production
T 1710282401 18<20jbg18>	if it fails to produce your code, roll back to yesterday's
T 1710282412 18<28BtbN18>	The compiler _is_ the production in this case :D
T 1710282427 18<28BtbN18>	So I do tend to like stuff to not randomly break
T 1710282439 18<20jbg18>	i don't suggest blindly updating nightly every night
T 1710282442 18<20j`ey18>	thats why you pin it!
T 1710282454 18<20jbg18>	even if the name makes you tempted
T 1710282481 18<20jbg18>	you can also make a custom target, but you'll have to build core, and that itself requires nightly
T 1710282529 18<28BtbN18>	I've looked into that, but found no good documentation on how to do it. Given that option exists, it also seems unneccesary.
T 1710282626 18<20jbg18>	it would avoid you needing to use nightly for your builds (only once per each time you update rust, to produce your custom rust toolchain)
T 1710282656 18<20jbg18>	some documentation here (focused on embedded but should still be relevant) https://docs.rust-embedded.org/embedonomicon/custom-target.html
T 1710282661 18<28BtbN18>	I thought it needs nightly anyway?
T 1710282671 18<20jbg18>	you need nightly to build core, you don't need nightly to use your custom target
T 1710282704 18<20jbg18>	you would build a stable rust toolchain with your custom target added, using nightly
T 1710282711 18<20jbg18>	and then use that stable toolchain to build your code
T 1710282742 18<20jbg18>	but if it was me i'd just use a pinned nightly version to build my code
T 1710282821 18<27jonored18>	at $previous-employer, we tended to build "nightly" builds from the commit of stable versions for what we pinned as the compiler.
T 1710282857 18<20jbg18>	yeah, we did the same at $previous-employer for several years when async was new. it's a good approach
T 1710284533 18<28BtbN18>	How would I tell cargo to install the standard lib it built globally? All the docs just refer to permanently using the nightly toolchain, with -Zbuild-std
T 1710285005 18<28BtbN18>	Yeah, for all I can tell, that's not possible? So I'd be stuck with nightly nevertheless
T 1710285571 18<25Widdershins18>	are those std libs not tied to the toolchain they come with?
T 1710285603 18<28BtbN18>	They don't come with the toolchain
T 1710285635 18<28BtbN18>	It's build-std stuff
T 1710292263 18<19nlaerema18>	hello
T 1710292280 18<19nlaerema18>	q
T 1710297122 18<22rbox18>	what happens if you take a rust program and decompiel it with like ghidra or smethign and tell it its C?
T 1710297123 18<22rbox18>	lol
T 1710297750 18<27Affliction18>	iirc it tries, and produces weird code
T 1710297755 18<27Affliction18>	But then, that's just decompilation in general
T 1710297772 18<27Affliction18>	I have an old install of ghidra, let's give it a go
T 1710297961 18<22rbox18>	it has C++ style mangeld symbols
T 1710297966 18<22rbox18>	i wonder if it'd do better as saying its C++
T 1710298336 18<27Affliction18>	Looking at a binary, LTO, with symbols, it's not awful
T 1710298627 18<27Affliction18>	I found https://research.checkpoint.com/2023/rust-binary-analysis-feature-by-feature/ interesting, too.
T 1710298667 18<27Affliction18>	Even for those who don't plan to reverse engineer, but are interested in how rust's higher level concepts work.
T 1710298701 18<22rbox18>	wtf, thats like a novel
T 1710298768 18<22rbox18>	"Twenty minutes later you wish you had never been born."
T 1710298769 18<22rbox18>	lol
T 1710303072 18<20polychromata{J}18>	evalr: dbg!(f64::MAX.log10())
T 1710303074 -18evalr/22##rust-	polychromata{J}: 308.25471555991675
T 1710306414 18<25Widdershins18>	rbox: i think the mangling actually works slightly differently than c++? not sure though. i know `rustfilt` is its own thing separate from c++filt
T 1710308285 19*	Now talking on 22##rust
T 1710308285 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1710308285 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1710308296 FiSHLiM plugin unloaded
T 1710340572 19*	Now talking on 22##rust
T 1710340572 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1710340572 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1710343036 19*	Now talking on 22##rust
T 1710343036 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1710343036 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1710346529 19*	Now talking on 22##rust
T 1710346529 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1710346529 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1710347504 19*	Now talking on 22##rust
T 1710347504 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1710347504 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1710351789 19*	Now talking on 22##rust
T 1710351789 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1710351789 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1710352269 18<25bertptrs18>	is there a nice way to ensure a path does not contain shenanigans like ".."?
T 1710352294 18<26danieldg18>	iterate its components
T 1710352402 18<25bertptrs18>	yeah figured
T 1710352409 18<24DeeEff18>	bertptrs: you can usually canonicalize the path https://doc.rust-lang.org/std/fs/fn.canonicalize.html
T 1710352419 18<25bertptrs18>	it's a relative path, so no canonicalization
T 1710352431 18<26danieldg18>	canonicalization solves a different set of problems
T 1710352458 18<26danieldg18>	that can even make it worse if you just do it blindly
T 1710352481 18<25bertptrs18>	you can check if path.canonicalize()? == path but that's tedious
T 1710352533 18<26danieldg18>	just path.components.any(|c| c == ParentDir)
T 1710352563 18<26danieldg18>	it's way faster than canonicalize and also doesn't break if you use symlinks
T 1710352643 18<25bertptrs18>	I want to be slightly stricter than that, also exclude hidden files, so that doesn't quite work
T 1710352648 18<26danieldg18>	or even any(|c| !matches!(c, Normal(_))
T 1710352660 18<25bertptrs18>	need to actually inspect the string
T 1710352677 18<26danieldg18>	hidden as in unix '/.*'?
T 1710352698 18<26danieldg18>	because DOS hidden requires pulling up metadata :)
T 1710352726 18<25bertptrs18>	I don't support DOS in my free time ;)
T 1710352787 18<26danieldg18>	if unix only, just convert Path to [u8] and search for b"/."
T 1710352798 18<26danieldg18>	that'll catch all but an initial "../"
T 1710354134 18<26dav1d18>	that would be nice in Rust https://docs.python.org/3/library/os.path.html#os.path.normpath
T 1710354257 18<26danieldg18>	there's likely a crate for it
T 1710354617 18<25bertptrs18>	https://crates.io/crates/normpath there is
T 1710354624 18<25bertptrs18>	things are easy to find once you know what to look for
T 1710354901 18<26dav1d18>	*in the rust std lib
T 1710355345 18<26danieldg18>	dav1d: getting things in std mostly needs a lot of people to be using the out-of-std implementation
T 1710355437 18<26danieldg18>	but I guess you could propose it for std anyway
T 1710355514 18<26dav1d18>	Without reading the issue contents: https://github.com/rust-lang/rust/issues/59117
T 1710355537 18<26dav1d18>	And https://github.com/rust-lang/rfcs/issues/2208
T 1710358614 18<20polychromata{J}18>	hmm, lots of creatures misunderstand what std is for
T 1710358800 18*	26dav1d prefers having footguns with platform dependent behaviour like canonicalize instead
T 1710358809 18<25bertptrs18>	people have expectations from other languages, and if you're coming from python which includes the kitchen sink, rust is pretty lacking. not saying rust should emulate python in that regard, but it could do more
T 1710359011 18<26danieldg18>	basically I don't think canonicalize should have been in std, it's not very commonly the right thing to use
T 1710359034 18<26dav1d18>	^
T 1710359084 18<26danieldg18>	but given we can't take it out, I agree we should probably put in the more useful variations
T 1710359111 18<25bertptrs18>	and preferably variations not filled to the brim with footguns
T 1710359247 18<26danieldg18>	having actual support for O_NOFOLLOW would fix a lot of the bugs that canonicalize tries to fix, but without the TOCTOU bug that it encourages
T 1710359268 18<26danieldg18>	right now you can use it, but you have to use custom_flags of OpenOptionsExt
T 1710360596 18<27TimMc18>	bertptrs: DOS also delights like not being allowed to name files things like "COM1".
T 1710360600 18<27TimMc18>	*also has
T 1710360647 18<25bertptrs18>	I can't say I've ever had the need to
T 1710360710 18<20capitol18>	i should have registered a com1 crate while I had the chance
T 1710360807 18<25bertptrs18>	then make it a dep of all projects you touch so they won't build on Windows?
T 1710360917 18<20capitol18>	:P
T 1710361330 18<24enoq18>	what is Pin? is it a thing that you can lock and unlock manually?
T 1710361355 18<29ct18>	no
T 1710361369 18<29ct18>	pinning something to a fixed memory address
T 1710361377 18<24enoq18>	what does that mean
T 1710361387 18<26danieldg18>	it's a marker that says a thing can depend on not changing its address
T 1710361402 18<24enoq18>	when would it change it's address?
T 1710361408 18<24enoq18>	its*
T 1710361416 18<26danieldg18>	Box::new(thing) changes the address of thing
T 1710361432 18<26danieldg18>	along with many other operations, like std::mem::swap
T 1710361448 18<24enoq18>	ah I see, what about copy
T 1710361456 18<26danieldg18>	yes, that's one
T 1710361478 18<24enoq18>	so that type prevents all of those uses?
T 1710361511 18<26danieldg18>	it prevents them on objects that are pinned, unless that object implements Unpin
T 1710361555 18<26danieldg18>	most things implement Unpin (just like most things are Send)
T 1710361644 18<24enoq18>	how would unpinning make sense in the case of async? don't you want to hold onto a thing until you complete?
T 1710361674 18<26danieldg18>	it makes sense
T 1710361688 18<26danieldg18>	more concrete examples are useful
T 1710361711 18<24enoq18>	maybe I need to really read up rather than waste everyone's time, any recommendations?
T 1710361748 18<24enoq18>	I've taken a look at https://fasterthanli.me/articles/pin-and-suffering but it was more of a rant than an explanation
T 1710361749 18<26danieldg18>	the std docs, or some of the async how-to-build-an-executor things
T 1710361775 18<24enoq18>	thank you!
T 1710362054 18<25bertptrs18>	I watched a great talk at RustNL 2023 that explained this, let me see if I can find the recording
T 1710362081 18<25bertptrs18>	enoq: https://www.youtube.com/watch?v=cVvZ0mJTkZ0
T 1710362133 18<25bertptrs18>	the short version: self referential types need a stable address or things go very wrong, and futures are often self-referential because of reasons
T 1710362249 18<24enoq18>	thank you
T 1710362601 18<22olk18>	hello, I'm a newbie and I need an advice on how to use a function in a different file without passing around the same argument 20 times. here's the definition: https://git.sr.ht/~olk/eds/tree/dev/item/src/gui.rs#L69
T 1710362642 18<22olk18>	use crate::gui::show_popup worked for pub fn, but if defined with let inside another function, this doesn't work
T 1710362670 18<26danieldg18>	if you want to use it as a function, defined it as a function and not a closure
T 1710362674 18<20spb18>	because the let inside the function is scoped to inside that function
T 1710362686 18<20spb18>	the name only has meaning in that scope
T 1710362706 18<19tokie18>	olk: are you coming from javascript as a primary language?
T 1710362778 18<22olk18>	danieldg, spb: got it, thanks
T 1710362785 18<22olk18>	tokie: no, why?
T 1710362789 18<19tokie18>	just curious!
T 1710362851 18<20spb18>	javascript is the only popular language i can think of that regularly defines publicly exported functions using closure-type syntax
T 1710362899 18<26danieldg18>	I think you can get away with it in python
T 1710362911 18<26danieldg18>	it makes for good code golf at least
T 1710362913 18<20spb18>	probably, but it's not common
T 1710363011 18<19tokie18>	spb: yeah, that's where i was going
T 1710363018 18<22olk18>	I'm sorry, this is a stupid question: can I pass an argument from a function to a global scope so I don't have to pass the same ApplicationWindow 20 times?
T 1710363048 18<20spb18>	you *can*, but that doesn't mean you should
T 1710363055 18<26danieldg18>	only if you use a global variable, but that's discouraged
T 1710363066 18<26danieldg18>	though GUI is perhaps a good use for it
T 1710363109 18<22olk18>	thanks for replying. how should I deal with this problem, in your opinion?
T 1710363114 18<20spb18>	you can define a global OnceCell or OnceLock, then initialise it from whichever function gets the appropriate object constructed
T 1710363128 18<26danieldg18>	^^ that's a pretty good way to do it
T 1710363154 18<26danieldg18>	or a global Mutex if you need to write to the value
T 1710363172 18<26danieldg18>	OnceLock is a lot more flexible, but you can't write to it
T 1710363191 18<26dav1d18>	enoq, https://www.youtube.com/watch?v=DkMwYxfSYNQ
T 1710363194 18<22olk18>	thanks again, I'll try that
T 1710363242 18<19tokie18>	i love OnceLock <3
T 1710363338 18<26dav1d18>	tokie, btw passed on your positive messages about Sentry/the Rust SDK to some of our SDK people and they were very delighted
T 1710363369 18<19tokie18>	aww <3
T 1710363410 18<26dav1d18>	especially after there were some discussions last week on why the Rust SDK sucks :D
T 1710363425 18<25bertptrs18>	dav1d: you work at Sentry?
T 1710363431 18<26dav1d18>	bertptrs, yeh
T 1710363435 18<19tokie18>	dav1d: yeah, i bet the people working on the glue we use for sentry have opinions
T 1710363447 18<25bertptrs18>	good software. most reliable thing in our stack tbh
T 1710363461 18<19tokie18>	oh wait, i think we just integrate directly with sentry
T 1710363488 18<26dav1d18>	tokie, it's unfortunately a low(er) priority SDK not many people use it and our Rust devs currently are busy with other stuff, so while JS/Python/PHP get a bunch of stuff Rust is a bit left behind
T 1710363500 18<26dav1d18>	bertptrs, <3
T 1710363533 18<26dav1d18>	but there is beginning to be an effort to have rust catch up
T 1710363701 18<24enoq18>	what sdk are we talking about?
T 1710363703 18<19tokie18>	yeah, i can imagine there's way more js/python/php customers ...
T 1710363706 18<25bertptrs18>	we don't use it for rust yet, but it works pretty well for Python (the things that don't are mostly our fault) and we rolled our own stuff for Haskell
T 1710363706 18<24enoq18>	the aws one?
T 1710363738 18<26dav1d18>	enoq, https://github.com/getsentry/sentry-rust
T 1710363746 18<25bertptrs18>	the pricing for performance tracing is ridiculous, but that's not an engineering fault
T 1710363757 18<26dav1d18>	bertptrs, I really hate that
T 1710363770 18<24enoq18>	thanks
T 1710363791 18<19tokie18>	bertptrs: yeah, i'm just using it for panic alerts
T 1710363811 18<26dav1d18>	We're gonna have metrics go public beta next week and I really hope they come up with a good pricing and a generous free budget
T 1710363841 18<24enoq18>	wow, n+1 query detection
T 1710363846 18<19tokie18>	dav1d: are you doing a metrics frontend too?
T 1710363854 18<24enoq18>	last time I've seen that in Hibernate, it was very error prone
T 1710363862 18<26dav1d18>	tokie, yes!
T 1710363867 18<19tokie18>	oh, that's cool
T 1710363891 18<26dav1d18>	I can get you into the alpha 👀 - but gonna be open beta on monday anyways
T 1710363917 18<25bertptrs18>	I will remember this when I have more pricing complaints ;)
T 1710363925 18<25bertptrs18>	also very offtopic, please join ##rust-offtopic
T 1710363985 18<26dav1d18>	:D
T 1710364197 18<22olk18>	when I try to use static WINDOW: OnceLock<ApplicationWindow> = OnceLock::new(); I get this: https://paste.rs/eYTrE.txt. what should I do?
T 1710364255 18<25bertptrs18>	You're finding all the corners of Rust today
T 1710364256 18<26danieldg18>	if the ApplicationWindow is not Send (that's what that error complains about) you need to instead use a thread_local
T 1710364269 18<26danieldg18>	thread_local and OnceCell
T 1710364301 18<25bertptrs18>	which of course will break when it's no longer a single-threaded application
T 1710364305 18<26dav1d18>	Seems like a good thing, windowing and threads is usually a delicate thing
T 1710364330 18<26danieldg18>	it'll actually work just fine: only on the gui thread can you get the object
T 1710364354 18<26danieldg18>	you just have to structure your app to handle that limitation
T 1710364372 18<24DeeEff18>	usually the "gui" thread is just the main thread anyways
T 1710364384 18<24DeeEff18>	I think on some platforms that's actually necessary (i.e. Apple)
T 1710364400 18<26danieldg18>	yeah, that's normal: one gui thread, and then maybe some worker threads
T 1710364840 18<22olk18>	this got complicated quickly :) I just wanted not to pass the same window a lot of times, but I've just introduced so much complexity for that
T 1710364954 18<19tokie18>	olk: yes
T 1710364977 18<19tokie18>	dav1d: yeah, i'm not in any decision making areas around that as you can imagine ....
T 1710365245 18<26kpcyrd18>	today I learned about 1114112 and how it relates to Option<char>, it was quite a journey :3
T 1710365248 18*	29ct remmebers a application where every gui thing has its own thread, hey even blinking the cursor is done in a thread :D 
T 1710365252 18<29ct18>	of course its C++
T 1710365508 18<19int-e18>	bonus points if the cursor blinking thread uses 99% CPU
T 1710365579 18<26dav1d18>	tokie, that's the better area to be in
T 1710367872 18<29demize18>	Well how would you make the blinking frame-perfect without busy-waiting.  ;)
T 1710367948 18<20dsmith18>	A hardware timer?
T 1710367965 18<29demize18>	Bah, fancy nonsense.
T 1710370368 19*	Now talking on 22##rust
T 1710370368 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1710370368 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1710379561 19*	Now talking on 22##rust
T 1710379561 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1710379561 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1710381885 18<25Widdershins18>	don't forget to enable the serde_json feature that lets numbers round trip (:
T 1710398043 18<26dav1d18>	Widdershins, what does it actually do, I expected some nan/inf stuff but it seems it messes with precision too?
T 1710407198 19*	Now talking on 22##rust
T 1710407198 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1710407198 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1710407468 19*	Now talking on 22##rust
T 1710407468 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1710407468 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1710407754 19*	Now talking on 22##rust
T 1710407754 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1710407754 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1710408857 19*	Now talking on 22##rust
T 1710408857 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1710408857 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1710412436 18<22archtanger18>	Hey folks, I have on my hands an app that converts some kind of DSL written in python and runs it in Rust for some (ideally) real time gains performance wise. I've run some baic benchmarking and I'v put a fire graph together to see where most of the processing goes to. Because I'm doing some complex matching (like matching a vec of particular enum structures), most of the processing seems to be being done by tbe match statements.
T 1710412474 18<22archtanger18>	Has anyone got any general tips for optimizing matches? I'm gonna delve into code and docs, but a starting point is better than none, haha
T 1710412691 18<27alepzi18>	getting a weird behavior running a command: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=1484d1e5804c40a425bbf6e212c0b6e0
T 1710413284 18<29saati18>	something something login vs non-login shells
T 1710413311 18<27alepzi18>	is the problem happening on local or remote machine?
T 1710413315 18<29saati18>	on the remote
T 1710413337 18<27alepzi18>	but that means the problem is in rust then no? because it works from command line on local machine
T 1710413386 18<27alepzi18>	i mean when i run that command on local machine, either on command line or using rust, it makes same connection to remote system
T 1710413402 18<29saati18>	my theory is that the ssh from the command line invokes a login shell which runs .profile or .bash_profile that sets the right PATH
T 1710413407 18<20nerdypepper18>	a little thought experiment: would it be possible to implement "anonymous enum returns" with just macros? i am thinking something like `-> Result<T, Err1 | Err2 | Err3>`
T 1710413419 18<20nerdypepper18>	internally, it could create an enum type, it would just be impossible to name this type in code
T 1710413419 18<29saati18>	vs a non login shell for the one launched from rust
T 1710413431 18<29saati18>	that does not
T 1710413441 18<20jbg18>	alepzi: when you run it from the shell, are you escaping the quotes in --rsync-path="sudo rsync" ?
T 1710413443 18<27alepzi18>	doesn't that mean the problem is happening on the local machine?
T 1710413451 18<27alepzi18>	no
T 1710413455 18<20jbg18>	because otherwise the shell is going to interpret those
T 1710413468 18<29saati18>	rsync-path is the path for the remote machine's rsync
T 1710413469 18<20jbg18>	and rsync won't see them
T 1710413470 18<27alepzi18>	i had to escape them when putting it in the arg " "
T 1710413488 18<20jbg18>	right but rsync is not being passed any double quotes if you run it like that on the shell
T 1710413499 18<20jbg18>	it's getting one argv with the string "--rsync-path=sudo rsync"
T 1710413517 18<29saati18>	oh yeah that makes much more sense
T 1710413519 18<20jbg18>	whereas the way you're invoking it in rust, it is getting double quotes inside the argv
T 1710413643 18<27alepzi18>	hmm kinda getting it but not totally
T 1710413660 18<20jbg18>	the shell interprets quotes and doesn't pass them through, unless you escape them
T 1710413668 18<20jbg18>	if you run this on the shell: somecommand "some arg"
T 1710413677 18<20jbg18>	there is only one argument passed to somecommand, and it doesn't include the quotes
T 1710413708 18<20jbg18>	i would do it like this to make it more clear: .arg("--rsync-path").arg("sudo rsync")
T 1710413758 18<27alepzi18>	THAT FIXED IT
T 1710413773 18<20jbg18>	.arg("--rsync-path=sudo rsync") should also work but it's a bit ugly
T 1710413791 18<27alepzi18>	ugly because of the space?
T 1710413813 18<27rendar18>	https://godbolt.org/z/n4zqKr7dT -- why it doens't show me assembly?
T 1710413848 18<20jbg18>	just ugly to look at yeah. it's your choice
T 1710413863 18<20jbg18>	two separate args is also much nicer if you want to make the rsync path come from a variable
T 1710413863 18<27alepzi18>	tyvm
T 1710413874 18<27alepzi18>	ya
T 1710413894 18<20j`ey18>	rendar: pub
T 1710413936 18<27rendar18>	pub?
T 1710413959 18<20j`ey18>	pub main
T 1710414142 18<27rendar18>	oh!
T 1710414255 18<26kpcyrd18>	does somebody know why `let Some('A') = x else { return };` explicitly checks for None instead of just testing for 65 (ascii for 'A')? they are stored in the same number, so if that number is 65 the 1114112 case would also be known to be false
T 1710414452 18<20j`ey18>	kpcyrd: huh
T 1710414478 18<20j`ey18>	the codegen Im seeing just checks 65
T 1710414587 18<26kpcyrd18>	ah, meant to paste this: https://rust.godbolt.org/z/WxWh3xE9h
T 1710414619 18<20jbg18>	seems that would be optimisation and might vary based on "stuff" though. since PartialEq (or is it StructuralPartialEq here?) on char doesn't come into play if x is None and thus contains no char
T 1710414785 18<20j`ey18>	kpcyrd: that's without optimisations though
T 1710414786 18<20j`ey18>	try -O
T 1710414840 18<26kpcyrd18>	oh well, thanks
T 1710414891 18<20j`ey18>	but .. where does it return 200
T 1710414927 18<20j`ey18>	o_O
T 1710414946 18<20j`ey18>	oh
T 1710414951 18<26kpcyrd18>	at the bottom. I've accidentally made two code branches with 200 even
T 1710414998 18<20j`ey18>	well no, if it's not A it returns 100
T 1710415017 18<20j`ey18>	but then the next says if it's not B.. return 101, which will always be true once we know it's A
T 1710415170 18<26kpcyrd18>	I just noticed this too after I was very confused by the release output. In my original code it's `let Some('j') = chars.next()` and I over-simplified the code.
T 1710421095 18<25Widdershins18>	dav1d: it forbids nan and inf as the format does, but has at least three precision levels: lossless (keep all digits), 64 bit (will round trip whatever fits in a f64 or i think i64), and lossy (slightly faster, parses f64 inaccurately. would you believe, the default)
T 1710421124 18<26dav1d18>	Widdershins, forbids = serialization error?
T 1710421152 18<25Widdershins18>	yes it refuses to represent it in the number type
T 1710421199 18<25Widdershins18>	would you believe the inaccurate parsing is also a default feature of rapidjson
T 1710421217 18<25Widdershins18>	and exhibited by mysql
T 1710421233 18<25Widdershins18>	because they didn't bother not to
T 1710421425 18<25Widdershins18>	it's dismaying to me that lossy parsing is so widely considered worthwhile
T 1710421887 18<29ct18>	just train a AI to parse anything :D
T 1710422792 18<27TimMc18>	I'd like to parse some msgpack and map it to structs, ignoring unexpected keys. What should I be reaching for? I see a bunch of options.
T 1710423109 18<25bertptrs18>	TimMc: rmp appears to be the most common one
T 1710423131 18<25bertptrs18>	rmp-serde if you want a more convenient API
T 1710424018 18<25Widdershins18>	ct: now that's synthesis... slow AND wrong
T 1710424041 18<29ct18>	:)
T 1710424576 18<27TimMc18>	Oh good, a serde integration!
T 1710425704 18<25bertptrs18>	anyone can recommend a connection pool thingy that works with tokio-postgres?
T 1710426254 18<25Widdershins18>	bertptrs: pgbouncer?
T 1710426288 18<25bertptrs18>	Widdershins: I meant in-process
T 1710426294 18<25bertptrs18>	deadpool-postgres looks pormising
T 1710433613 18<20eddybilley18>	jk/quit
T 1710437670 18<26palindrome18>	actix-web question, how do I register a handler that besides the Request I want to receive a custom type on my signature?
T 1710445639 18<27Ademan18>	sadly I can't get into the dioxus discord (blech) without giving discord my phone number (no chance) so I'm forced to ask here. Does dioxus have anything like a "virtual list" like react has? (something like https://github.com/developerdizzle/react-virtual-list ) which is important for displaying lists with large numbers of items
T 1710445781 18<27Ademan18>	I don't know if there's another term for the pattern, but "virtual list" tends to end up with search results about the virtual dom
T 1710447397 18<25Widdershins18>	Ademan: ohhh...discord-only support regime huh. that's icky
T 1710447429 18<26dav1d18>	so you're saying we're just your 2nd choice? D:
T 1710447840 18<27Ademan18>	Widdershins: front-end people smh
T 1710447858 18<27Ademan18>	dav1d: well, I feel weird asking library-specific things in a general channel
T 1710447901 18<27Ademan18>	also hopefully my /s on the front-end dev joke was implied
T 1710448408 18<19int-e18>	 somebody has to work the reception desk
T 1710449268 18<27Ademan18>	oh ho, it seems they relaxed their server entry requirements, I'm in!
T 1710449525 18<27Ademan18>	still don't like being forced to use discord but this is like the 5th or 6th technical server I've joined, seems unavoidable these days...
T 1710452493 18<25Widdershins18>	Ademan: discord delenda est
T 1710452511 18<25Widdershins18>	Discord Search Is Not A Wiki
T 1710470451 19*	Now talking on 22##rust
T 1710470451 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1710470451 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1710470700 19*	Now talking on 22##rust
T 1710470700 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1710470700 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1710470701 FiSHLiM plugin unloaded
T 1710473940 18<26bwidawsk18>	Can someone help me understand why these both print false?
T 1710473947 18<26bwidawsk18>	```
T 1710473947 18<26bwidawsk18>	println!("is sorted?: {}", line.chars().collect::<Vec<_>>().is_sorted());
T 1710473947 18<26bwidawsk18>	line.chars().into_iter().collect::<Vec<_>>().sort_unstable();
T 1710473947 18<26bwidawsk18>	println!("is sorted?: {}", line.chars().collect::<Vec<_>>().is_sorted());
T 1710473947 18<26bwidawsk18>	```
T 1710474352 18<26bwidawsk18>	(`sort` is the same`
T 1710475181 18<27Affliction18>	bwidawsk: 2nd line won't alter "line", so you're effectively doing the same thing twice.
T 1710475224 18<27Affliction18>	You're pretty much collecting it into a temporary vec and throwing it away.
T 1710475234 18<26bwidawsk18>	how do I do this properly?
T 1710475362 18<27Affliction18>	I'd assign line.chars().collect() a variable, do the is_sorted() test, call sort_unstable() on that vec, then do is_sorted() again.
T 1710475395 18<26bwidawsk18>	hmm I thought I tried, hang on
T 1710475398 18<27Affliction18>	I believe there's an iterator combinator that can test if sorted too...
T 1710475428 18<26bwidawsk18>	the is_sorted was just to demonstrate the issue
T 1710475443 18<27Affliction18>	Yeah, don't need the collect then.
T 1710475457 18<27Affliction18>	evalr: "dabc".chars().is_sorted();
T 1710475459 -18evalr/22##rust-	Affliction: error[E0658]: use of unstable library feature 'is_sorted': new A ...
T 1710475459 -18evalr/22##rust-	Affliction: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=8302d371758f4c428733032120f68839
T 1710475572 18<27Affliction18>	SO yeah, that'd work for the first case. For the second, yeah, collecting into a vec, sorting, and doing that same test should work, too.
T 1710476785 18<26bwidawsk18>	Affliction: thank you
T 1710479006 19*	Now talking on 22##rust
T 1710479006 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1710479006 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1710501318 20*	Disconnected (20)
T 1710501469 23*	28dacd is already in use. Retrying with 18david_...
T 1710501469 22*	26david_ sets mode 24+Z on 22david_
T 1710501469 22*	26david_ sets mode 24+i on 22david_
T 1710501469 22*	26david_ sets mode 24+w on 22david_
T 1710501469 -18NickServ-	This nickname is registered. Please choose a different nickname, or identify via /msg NickServ IDENTIFY david_ <password>
T 1710501475 19*	Now talking on 22##rust
T 1710501475 22*	Topic for 22##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
T 1710501475 22*	Topic for 22##rust set by 26bertptrs!~quassel@user/bertptrs (24Mon May 22 14:11:18 2023)
T 1710505748 18<26dav1d18>	Is there anything that makes cargo package the crate source files into a zip file and put them next to the binary in the target directory?
T 1710507227 18<26dav1d18>	nvm found what I was looking for, wasn't related to cargo
T 1710507694 18<29tazjin18>	dav1d: there is a cargo-native way though (`cargo package`, it's what it does before publishing to e.g. crates.io)
T 1710507959 18<26dav1d18>	problem was I had a binary.src.zip in my target dir and wasnt sure where it's coming from
T 1710508499 18<27TimMc18>	oh hah
T 1710510947 18<26jemius18>	I can't enter the Matrix rust room, getting a 403: you're not invited :O
T 1710510967 18<26jemius18>	3 years ago there was just a public room. No idea why that has been closed
T 1710513756 18<26dav1d18>	I hate cross compiling
T 1710513797 18<26dav1d18>	have it work with cross 0.2.5, but I need a feature from master for something else, now the binary doesnt build anymore because cmake can't find zlib even if I install it
