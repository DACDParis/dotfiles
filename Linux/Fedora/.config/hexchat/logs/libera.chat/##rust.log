**** BEGIN LOGGING AT Mon Feb 12 13:08:45 2024

fÃ©vr. 12 13:08:45 *	Now talking on ##rust
fÃ©vr. 12 13:08:45 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
fÃ©vr. 12 13:08:45 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** BEGIN LOGGING AT Mon Feb 12 14:01:09 2024

fÃ©vr. 12 14:01:08 *	Now talking on ##rust
fÃ©vr. 12 14:01:08 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
fÃ©vr. 12 14:01:08 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
fÃ©vr. 12 14:04:44 <bertptrs>	dav1d: Error has a couple of methods that you can only call on "dyn Error + 'static"
fÃ©vr. 12 14:05:14 <bertptrs>	Which are (I think) inherited from Any requiring 'static
fÃ©vr. 12 14:12:08 <Bish>	if i wanted to serialize datastructures of crates with serde im pretty much screwed, right?
fÃ©vr. 12 14:12:22 <Bish>	in this case i want to use http::* things in my struct and it should be serializable
fÃ©vr. 12 14:12:38 <Bish>	i could wrap it in my own type, but i can't magicially make it serializible via macro, right?
fÃ©vr. 12 14:12:45 <Bish>	i could ofcourse write my own serializer, correct?
fÃ©vr. 12 14:12:54 <spb>	https://serde.rs/remote-derive.html
fÃ©vr. 12 14:13:29 <Bish>	cool
fÃ©vr. 12 14:13:30 <Bish>	thanks
fÃ©vr. 12 14:14:12 <Bish>	is this "dangerous" as in, what happens if i the 2 structs differ
fÃ©vr. 12 14:14:50 <spb>	if you consider compiler errors dangerous
fÃ©vr. 12 14:21:50 <Bish>	it bothers me i have to copy the definition of the thing i want to serialize
fÃ©vr. 12 14:22:37 <Bish>	and what if they go deep?
fÃ©vr. 12 14:23:03 <Bish>	then i'd have to provide many many of those?
fÃ©vr. 12 14:26:55 <demize>	What from the http crate do you want to be able to de/serialize?  The http-serde crate might provide everything you need already.
fÃ©vr. 12 14:27:34 <Bish>	guess it does, yeah
fÃ©vr. 12 15:25:53 <dav1d>	bertptrs, that is unfortunate :(
fÃ©vr. 12 15:31:13 <bertptrs>	I expect it to be related to Sentry's error sniffing logic. I haven't worked with them in Rust but in Python they try to downcast your uncaught exceptions to be more helpful in the reporting. I imagine that's why they want to touch the downcast methods
**** BEGIN LOGGING AT Sat Feb 17 17:08:29 2024

Feb 17 17:08:29 *	Now talking on ##rust
Feb 17 17:08:29 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 17 17:08:29 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** BEGIN LOGGING AT Tue Feb 20 15:07:42 2024

Feb 20 15:07:42 *	Now talking on ##rust
Feb 20 15:07:42 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 20 15:07:42 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** BEGIN LOGGING AT Tue Feb 20 15:32:27 2024

Feb 20 15:32:26 *	Now talking on ##rust
Feb 20 15:32:26 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 20 15:32:26 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** BEGIN LOGGING AT Tue Feb 20 15:37:56 2024

Feb 20 15:37:56 *	Now talking on ##rust
Feb 20 15:37:56 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 20 15:37:56 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Feb 20 15:59:10 <Ademan_>	presumably in some cases, Fromiterator::from_iter() might do something more efficient than a naive for loop might. would it be valid for <HashMap as FromIterator>::from_iter() to take only the first value for a given key and discard the rest? I've written my code assuming that the resulting hash map will use the *last* value for a given key (the behavior you'd get with a naive `for (k, v) in i {
Feb 20 15:59:16 <Ademan_>	map.insert(k, v); }` ).
Feb 20 16:06:59 <spb>	the trait documentation doesn't say anything about how situations like that should be handled, so you should assume that any reasonable implementation is possible
Feb 20 16:31:47 <Ademan_>	spb: makes sense, thanks!
Feb 20 16:36:17 <belst>	FH_thecat: did u build in release mode? the github releases are all less than 10mb
Feb 20 16:42:22 <FH_thecat>	belst: I build it using "cargo build --release"
Feb 20 16:49:03 <rendar>	if i'm using thiserror, and i have `enum MainError { #[error("Math Error")] MathError(#[from] MathError),  ... }`   when i print the error from MainError with "{}" i only get "Math Error" string, but since its a nested enum, shouldn't thiserror automatically prints the real MathError string instead of that one?
Feb 20 16:49:29 <spb>	only if you tell it to
Feb 20 16:49:44 <spb>	#[error("Math Error: {0}")]
Feb 20 16:49:54 <rendar>	hmm, i see
Feb 20 16:51:18 <rendar>	of course, it takes the same parameter id as other errors which has String or whatever, ok
Feb 20 16:52:45 <spb>	all the fields of that enum variant are available to use in any normal format expression
Feb 20 16:53:15 <spb>	based on whether they impl Display or Debug
Feb 20 19:41:44 <bertptrs>	FH_thecat: late reply but looking at the binary most of it appears to be tree-sitter parsers for various languages. It's a bit silly to statically link treesitter dozens of times, but it does, and depending on the language (*cough* sql) those parsers are pretty damn big
Feb 20 19:48:24 <bertptrs>	in other words, the extensive langauge highlighting that difftastic does
Feb 20 19:49:17 <FH_thecat>	bertptrs: can I disable some parsers for languages that I don't need ?
Feb 20 19:49:34 <FH_thecat>	and why does it have to be statically linked anyway?
Feb 20 19:50:42 <FH_thecat>	I basically just need shell (sh,zsh), python and c
Feb 20 19:51:02 <bertptrs>	I'd have to RTFS it, but from an initial glance, it compiles everything unconditionally
Feb 20 19:51:51 <FH_thecat>	what a monstrosity !
Feb 20 19:52:15 <bertptrs>	soft disagree, you want a swiss army knife, you get a swiss army knife
Feb 20 19:52:53 <bertptrs>	It's kinda funny, rust (rightfully) gets blamed for large binaries but most of this is C :P
Feb 20 19:53:17 <j`ey>	https://github.com/Wilfred/difftastic/tree/master/vendored_parsers oh yeah lotsa parsers
Feb 20 19:54:35 <FH_thecat>	why can't the parsers be modular
Feb 20 19:54:42 <FH_thecat>	ie, just install those that I need
Feb 20 19:54:51 <bertptrs>	because the devs didn't bother to do it, since it's a maintenance and testing hassle
Feb 20 19:54:58 <bertptrs>	or so I'd guess
Feb 20 19:55:08 <bertptrs>	modular features make exponential testing and such
Feb 20 19:55:35 <FH_thecat>	I thought modular approach is "cleaner"
Feb 20 19:55:54 <j`ey>	it is but requires more code / maintainenace
Feb 20 19:57:18 <FH_thecat>	then, at least there should be configuration for the build, which ones to include
Feb 20 19:57:43 <FH_thecat>	that would not add any extra complexity
Feb 20 19:57:59 <j`ey>	it would
Feb 20 19:58:10 <bertptrs>	I very much encourage you to raise these concerns upstream (though in a friendlier tone). None of us develop this tool, I was just curious how the binary could be so large. Now I have an answer
Feb 20 19:58:44 <FH_thecat>	thank you
Feb 20 20:10:42 <Odin-LAP>	bertptrs: C also gets an unwarranted assumption of its binaries being small, with enormous amounts of its runtime support libraries being considered "just the operating system".
Feb 20 20:11:20 <consus>	because it usually is :D
Feb 20 20:12:12 <consus>	having stdlib in each binary and still relying on libc is really stoopid
Feb 20 20:12:56 <dav1d>	ðŸ˜¬
Feb 20 20:15:53 <Odin-LAP>	consus: But it means a comparison with a binary that _does_ contain all of that stuff isn't exactly apples to apples.
Feb 20 20:15:55 <Odin-LAP>	:)
Feb 20 20:16:55 <consus>	Odin-LAP: who cares? you have a hello world with 386k weigh that still does not qualify as a static binary because of it's reliance on libgcc and libc
Feb 20 20:17:05 <consus>	That's stoopid
Feb 20 20:17:21 <consus>	No amount of Rust copium will help you justify this
Feb 20 20:17:55 <bertptrs>	consus: you got warned yesterday, hereby your second warning, please behave a bit more professional
Feb 20 20:18:25 <consus>	bertptrs: I've missed the first one
Feb 20 20:18:39 <consus>	what exactly are you accusing me of?
Feb 20 20:18:58 <bertptrs>	<bertptrs> but that's not a reason to be this negative as it's counterproductive
Feb 20 20:19:22 <consus>	how should I phrase it then?
Feb 20 20:20:38 <bertptrs>	avoid "stoobid" and "copium" while discussing people's hard work
Feb 20 20:20:43 <consus>	why?
Feb 20 20:20:50 <consus>	copium is really a good word
Feb 20 20:20:57 <consus>	it's not offending
Feb 20 20:21:04 <consus>	I'm not calling people names
Feb 20 20:21:14 <consus>	but the end result is really suboptimal
Feb 20 20:22:13 <consus>	for example it forces projects like uutils to create a really large binary with HUGE attack surface
Feb 20 20:24:15 <nCrazed>	"inflamtory language" comes to mind
Feb 20 20:24:29 <consus>	fair enough
Feb 20 20:24:33 <bertptrs>	I was struggling to put it into words but yeah, that's what I meant
Feb 20 20:25:34 <cehteh>	uutils is stil at 0.0.x stage, i would guess that binary size optimization isnt even considered yet
Feb 20 20:26:08 <cehteh>	there are ways to reduce rust executables sizes, eventually
Feb 20 20:26:19 <consus>	They went busybox-like route
Feb 20 20:26:22 <consus>	With a single binary
Feb 20 20:26:31 <cehteh>	which is good
Feb 20 20:26:32 <j`ey>	but are you sure that's due to size?
Feb 20 20:26:40 <consus>	one of the reasons
Feb 20 20:26:57 <consus>	cehteh: which also creates a huge gadget space
Feb 20 20:27:36 <cehteh>	i would like if rust had better support for dynamic linking, but that opens other cans of worms
Feb 20 20:29:38 <cehteh>	https://github.com/johnthagen/min-sized-rust  there are these tips, bit outdated but many are ok, still applying that would be the icing on the cake when you are ready for production releases
Feb 20 20:31:54 <consus>	it does not help much
Feb 20 20:31:59 <consus>	you win like ~50k
Feb 20 20:32:17 <consus>	well, strip helps, but that's obvious
Feb 20 20:32:28 <consus>	no distro will let a binary without striping
Feb 20 20:32:43 <cehteh>	this is not a process you can blindly apply, you have to look at your project and see what benefit it most
Feb 20 20:33:07 <consus>	strip does 80% of the work :)
Feb 20 20:33:12 <cehteh>	lto for example usually reduces code size, somtimes significantly, but in some cases it bloats
Feb 20 20:33:22 <consus>	not that much in my experience
Feb 20 20:33:26 <consus>	you may win 20%
Feb 20 20:33:30 <consus>	even 30%
Feb 20 20:33:34 <consus>	but still
Feb 20 20:33:37 <cehteh>	it depends on the exact project
Feb 20 20:34:00 <consus>	the thing is... it does not help small projects because of unconditional stdlib
Feb 20 20:34:15 <cehteh>	removing all the panic stuff/info should save a bit, but only when combined with the build_std thing
Feb 20 20:34:17 <consus>	and if you're writing something like a webapp
Feb 20 20:34:22 <consus>	who cares?
Feb 20 20:34:37 <consus>	it can 500M, that won't be an issue
Feb 20 20:34:40 <cehteh>	you where talking about uulib
Feb 20 20:34:44 <consus>	yeah
Feb 20 20:35:20 <consus>	total busybox on my system is 1.3M
Feb 20 20:35:28 <consus>	lemme check the uutils
Feb 20 20:36:11 <cehteh>	i wont be surprised when its at this stage magnitudes larger
Feb 20 20:38:58 <cehteh>	oh they have a release-small target already
Feb 20 20:39:28 <consus>	8.5 with release
Feb 20 20:39:34 <consus>	actually not bad
Feb 20 20:39:41 <consus>	less than 10x
Feb 20 20:40:07 <cehteh>	5.3 with the release-small profile
Feb 20 20:40:20 <consus>	comparable then
Feb 20 20:40:25 <cehteh>	so just stop ranting :D
Feb 20 20:40:31 <consus>	why?
Feb 20 20:40:46 <j`ey>	does uutils try to do anything better?
Feb 20 20:40:48 <cehteh>	its annoying
Feb 20 20:40:49 <consus>	that's exactly why they decided to do that
Feb 20 20:40:53 <j`ey>	or is it just 1:1?
Feb 20 20:41:17 <consus>	because otherwise the size would be (clap + stdlib) * n_utils
Feb 20 20:41:26 <consus>	j`ey: more colors
Feb 20 20:41:31 <j`ey>	heh
Feb 20 20:41:33 <consus>	j`ey: some other imprrovements
Feb 20 20:41:39 <consus>	if you like colors that is
Feb 20 20:41:50 <cehteh>	there where people here with an actual problem that their binary was too big, if only code golfing, usually they got helped
Feb 20 20:42:31 <cehteh>	ranting about potential other project could be too big .. and then find out that its actually not the case, is stupid
Feb 20 20:42:43 <consus>	errr
Feb 20 20:42:50 <consus>	you misread
Feb 20 20:43:04 <consus>	I was citing uutils as an example of why projects decide to do single binary
Feb 20 20:43:13 <cehteh>	<consus> for example it forces projects like uutils to create a really large binary with HUGE attack surface
Feb 20 20:43:18 <consus>	yeap
Feb 20 20:43:55 <consus>	the C coreutils does not have a single binary
Feb 20 20:44:01 <consus>	it has a lot of small tools
Feb 20 20:44:14 <consus>	it works because of the dynamic linking
Feb 20 20:44:40 <cehteh>	thats just a implementation/deployment detail
Feb 20 20:44:44 <consus>	uutils cannot do that because then the total sum would be (stdlib + clap + other common deps) * N-Utils
Feb 20 20:45:07 <cehteh>	i think you can build it (mostly) statically linked with some efforts
Feb 20 20:45:22 <consus>	true, but then you have a problem with tools like ping
Feb 20 20:45:38 <consus>	because ping, for example, requires special flags
Feb 20 20:45:45 <consus>	and/or suid
Feb 20 20:46:30 <cehteh>	sure, so what? ..
Feb 20 20:46:53 <j`ey>	consus: do you have the uutils grep vs coreutils grep?
Feb 20 20:47:04 <consus>	j`ey: in terms of features?
Feb 20 20:47:39 <j`ey>	sizes
Feb 20 20:47:40 <consus>	I'm not sure uutils aims at full posix compatibility
Feb 20 20:48:01 <bertptrs>	it aims to pass GNU coreutils tests
Feb 20 20:48:52 <consus>	huh, strange, cannot find grep in applets
Feb 20 20:49:00 <cehteh>	which is probably more demanding :D posix requirements on some tools are surprisingly minimal
Feb 20 20:49:07 <consus>	nah
Feb 20 20:49:15 <consus>	the level of compatibility is a nigthmare
Feb 20 20:49:21 <j`ey>	consus: oh, well some other binary will do
Feb 20 20:49:23 <j`ey>	find or whatever
Feb 20 20:49:46 <consus>	it took openbsd 8 years or so to write grep that worked for them
Feb 20 20:49:56 <bertptrs>	grep is not in coreutils, is it?
Feb 20 20:50:14 <consus>	not sure actually
Feb 20 20:50:22 <spb>	not last i knew
Feb 20 20:50:24 <consus>	nope, it's a separate thing
Feb 20 20:50:26 <consus>	as is find
Feb 20 20:50:31 <cehteh>	woudnt ping be in netutils? i dunno
Feb 20 20:50:36 <consus>	ping netutils
Feb 20 20:50:36 <bertptrs>	not on my system
Feb 20 20:50:40 <consus>	find findutils
Feb 20 20:50:46 <consus>	grep is grep :D
Feb 20 20:50:54 <j`ey>	grr
Feb 20 20:51:16 <bertptrs>	la la, la la la
Feb 20 20:51:26 <consus>	yeah, busybox provides a lot more
Feb 20 20:51:26 <bertptrs>	lababadap dap dap grep
Feb 20 20:52:05 <dav1d>	I think bertptrs broke :(
Feb 20 20:52:37 <bertptrs>	I'm just conditioned on Opus so whenever someone writes X is X I get "Life is Life" stuck in my head
Feb 20 20:52:48 <consus>	xD
Feb 20 20:53:26 <consus>	I was actually thinking about the song about that blue dudes on an spaceship
Feb 20 20:53:37 <consus>	Can't remember the band name
Feb 20 20:53:42 <bertptrs>	ah no. Eiffel 65
Feb 20 20:53:47 <bertptrs>	Different genre
Feb 20 20:53:48 <consus>	yeah, right
Feb 20 20:53:59 <cehteh>	bertptrs: https://www.youtube.com/watch?v=Zt2_11e6QPA ;)
Feb 20 20:55:41 <cehteh>	https://www.youtube.com/watch?v=y_cbTcaoErI  better version
Feb 20 20:57:07 <consus>	what is the explicit of '?'?
Feb 20 20:57:52 <consus>	I remember writing ResultExt with into_res() but I think stdlib should have something standard for that
Feb 20 20:58:15 <cehteh>	explicit? desugaring?
Feb 20 20:58:34 <consus>	Ok(foo().await?) => foo().await.into_res()
Feb 20 20:59:01 <cehteh>	its not that trivial
Feb 20 20:59:33 <bertptrs>	it cannot be desugared like that, since it's equivalent to match foo().await { Ok(val) => val, Err(e) => return Err(e.into()) }
Feb 20 20:59:43 <bertptrs>	there used to be the try! macro which did almost this
Feb 20 21:00:28 <cehteh>	https://rust-lang.github.io/rfcs/3058-try-trait-v2.html
Feb 20 21:00:58 <bertptrs>	https://doc.rust-lang.org/std/ops/trait.Try.html also this
Feb 20 21:01:05 <consus>	damn, I had it somewhere
Feb 20 21:01:12 <cehteh>	yeet
Feb 20 21:01:32 <consus>	probably the old laptop
Feb 20 21:01:38 <consus>	well, nevermind :(
Feb 20 21:01:45 <bertptrs>	I hate that yeet exists
Feb 20 21:01:55 <consus>	yeet?
Feb 20 21:02:02 <bertptrs>	https://doc.rust-lang.org/std/ops/struct.Yeet.html
Feb 20 21:03:06 <bertptrs>	it exists to avoid a bikeshed about what it should be called from slowing down the RFC; they chose a name that definitely nobody likes so it was sure to be changed later
Feb 20 21:03:22 <bertptrs>	as opposed to a "not quite great but acceptable" name sticking around after development
Feb 20 21:03:34 <darkling>	... and that was 10 years ago? :)
Feb 20 21:03:38 <consus>	:D
Feb 20 21:03:54 <consus>	I miss pure
Feb 20 21:03:55 <bertptrs>	it hasn't been stabilized yet, that's something
Feb 20 21:05:09 <consus>	.map_err(|e| e.into())
Feb 20 21:05:09 <polychromata{J}>	bertptrs: baba is baba
Feb 20 21:05:10 <consus>	yeah
Feb 20 21:05:11 <consus>	this
Feb 20 21:05:27 <consus>	I was looking for this
Feb 20 21:05:37 <bertptrs>	that's only half of what ? does, but sure
Feb 20 21:06:01 <consus>	it helps me not to wrap everything in Ok()
Feb 20 21:06:12 <consus>	Which look really ugly
Feb 20 21:06:13 <bertptrs>	Fair enough, it makes sense for your final return statement
Feb 20 21:06:18 <consus>	yeah
Feb 20 21:06:18 <bertptrs>	or just returns in geenral
Feb 20 21:06:36 <consus>	it's a pity that ? without ; is not a thing
Feb 20 21:07:06 <consus>	feels wront to explicitly mark return values as "good"
Feb 20 21:07:28 <j`ey>	feels right to me
Feb 20 21:09:12 <consus>	it was unambigous in the beginning, before ?
Feb 20 21:09:25 <consus>	but now the language itself has an operator for returning errors
Feb 20 21:09:38 <consus>	And now it feels weird
Feb 20 21:11:15 <bertptrs>	most languages have a keyword instead
Feb 20 21:11:18 <bertptrs>	either way works
Feb 20 21:11:46 <bertptrs>	C hasâ€¦ error codes and out parameters, I guess
Feb 20 21:13:25 <consus>	? is cool! but it would be even cooler to go one step further and allow `foo().await?` instead of `Ok(foo().await?)`
Feb 20 21:14:09 <j`ey>	I mean with ? that would make it context sensitive I guess
Feb 20 21:15:19 <consus>	more than it now?
Feb 20 21:15:28 <j`ey>	yes?
Feb 20 21:15:46 <j`ey>	I assumed you were saying if it was the return value, the Ok would be implicit
Feb 20 21:15:53 <consus>	yeah
Feb 20 21:23:35 <bertptrs>	the annoucement blog for anyhow did something like that, with a proc macro, but honestly it just muddies the water and makes types harder to explain
Feb 20 22:00:53 <dav1d>	Isn't  `Ok(foo().await?)` just a `foo().await.map_err(Into::into)` if you prefer not to use the `?` here
Feb 20 22:01:13 <consus>	yeah
Feb 20 22:01:14 <bertptrs>	It is
Feb 20 22:01:28 <consus>	but since we already have ?
Feb 20 22:01:46 <consus>	kinda makes sense to use it here too
Feb 20 22:01:59 <consus>	let foo = may_fail()?;
Feb 20 22:02:15 <consus>	but  may_fail()? does not do the same
Feb 20 22:03:32 <bertptrs>	does it not?
Feb 20 22:04:13 <consus>	nope
Feb 20 22:04:30 <dav1d>	but it does
Feb 20 22:04:33 <consus>	nope
Feb 20 22:04:42 <dav1d>	okay nvm
Feb 20 22:04:45 <consus>	Ok(foo()?) works
Feb 20 22:04:50 <consus>	foo()? -- does not
Feb 20 22:05:06 <bertptrs>	because the return type of foo()? is T, not Result<T, E>
Feb 20 22:05:09 <consus>	what I  mean is  that foo()? cannot be on the last line
Feb 20 22:05:22 <bertptrs>	that's actually caused by it doing the same
Feb 20 22:05:35 <consus>	but it behaves differently
Feb 20 22:05:37 <dav1d>	exactly because it does the same it does not work
Feb 20 22:05:44 <consus>	and that's weird
Feb 20 22:05:53 <consus>	no?
Feb 20 22:05:53 <bertptrs>	no it behaves the same. It turns a Result<T, E> into a T (or returns early)
Feb 20 22:06:06 <consus>	well, perhaps
Feb 20 22:06:14 <bertptrs>	And if your function returns a Result<T, E> you cannot return a T from it
Feb 20 22:06:23 <consus>	yeah, makes sense
Feb 20 22:06:24 <dav1d>	`let foo = may_fail().unwrap();` `works but `may_fail().unwrap()` we should make unwrap behave special
Feb 20 22:06:34 <consus>	nah
Feb 20 22:06:38 <j`ey>	that's what I meant about context
Feb 20 22:06:53 <dav1d>	although we could also tell the compiler to implicitly wrap items in Ok if there is a result expected
Feb 20 22:07:02 <consus>	let foo = foo().await?.some()?.other()?.chains()?;
Feb 20 22:07:26 <consus>	it will return Result<T> if some() fails, for example
Feb 20 22:07:34 <consus>	it will even converse it for you
Feb 20 22:07:46 <consus>	which is good, right?
Feb 20 22:07:50 <bertptrs>	dav1d: that stops working when you introduce nested Results, which is not uncommon in generic code
Feb 20 22:07:57 <dav1d>	bertptrs, it is a terrible idea
Feb 20 22:08:04 <dav1d>	it would also fuck with infering types
Feb 20 22:08:17 <dav1d>	e.g. collecting into anything that is a result
Feb 20 22:08:53 <bertptrs>	yea
Feb 20 22:08:55 <bertptrs>	better not
Feb 20 22:25:02 <cappy>	Is there a way to get cargo(1) to clean --release just the object files (ELF) from a project directory?
Feb 20 22:40:23 <cappy>	I've been using: find . -exec file {} \; | grep -i elf | awk '{print $1}' to locate the files for rm(1) but there might be a better way.
Feb 20 22:46:33 <polychromata{J}>	why just the object files?
Feb 20 22:49:23 <cappy>	polychromata{J}: They can be rebuilt. The source and other files will be picked up by my backup program. No sense in backing up ELFs.
Feb 20 22:50:01 <j`ey>	but cargo clean wont delete the source files
Feb 20 22:50:18 <j`ey>	everything that cargo clean deletes can be rebuilt
Feb 20 22:50:33 <polychromata{J}>	why not just exclude the entire target directory from backups?
Feb 20 22:50:45 <polychromata{J}>	that might happen by default, even; cargo tags it as a cache
Feb 20 22:51:00 <nullie>	tags?
Feb 20 22:51:06 <cappy>	j`ey: All true. I just started using Rust/Cargo today.
Feb 20 22:51:11 <polychromata{J}>	yeah, look inside.
Feb 20 22:51:12 <j`ey>	puts a special file in the foldre
Feb 20 22:51:35 <nullie>	oh, TIL
Feb 20 22:51:56 <j`ey>	cappy: see if your backup program knows about https://bford.info/cachedir/
Feb 20 22:52:24 <cappy>	polychromata{J}: Of course.
Feb 20 22:53:17 <cappy>	j`ey: cachedir... I'll look at that. No my backup program does not see such. Might look at an alternative for backups.
Feb 20 23:09:57 <cappy>	borgbackup will exclude CACHEDIR.TAG directories. It's in my repo. Thanks for the help guys.
Feb 21 00:07:47 <turlando>	If I know that due to some incompatibility my program will only run on 64 bit architectures, is it possible to restrict the target platforms in Cargo.toml and at the same time get access to, e.g., From<usize> for u64?
Feb 21 00:08:25 <j`ey>	nope
Feb 21 00:08:56 <turlando>	Would it be something sane to implement myself?
Feb 21 00:09:10 <j`ey>	You couldn't implement the From<usize>
Feb 21 00:09:24 <j`ey>	you can error on the pointer size though, but I think only from code
Feb 21 00:09:36 <jbg>	but you can always just write `as usize` since you know it's fine
Feb 21 00:10:27 <jbg>	(in the process creating that incompatibility if it didn't already exist!)
Feb 21 00:11:27 <turlando>	Having it handled at type level would make me feel better
Feb 21 00:11:42 <turlando>	And sleep better at night maybe
Feb 21 00:13:46 <jbg>	should be possible to refuse to compile on non-64-bit arch. use something like #[cfg(not(target_pointer_width = 64))] compile_error!("only 64-bit architectures are supported");
Feb 21 00:14:05 <jbg>	then you can use `42u64 as usize` and still sleep at night
Feb 21 00:15:01 <turlando>	That is true untile somebody decides that 32 bits are fine and the compiler will gladly allow that :
Feb 21 00:15:03 <Arnavion>	Or `#[cfg(target_pointer_width = 64)] fn convert(a: usize) -> u64 { a as _ }` and use `convert()` everywhere
Feb 21 00:15:20 <Arnavion>	so the fn won't be defined if it can't be used safely
Feb 21 00:15:35 <turlando>	Arnavion: that looks much better as long as it's a non-op
Feb 21 00:16:45 <jbg>	the body is clearly a no-op, you could put #[inline(always)] on it if you are really worried
Feb 21 00:17:06 <turlando>	It still has to do runtime checks even in release mode?
Feb 21 00:17:29 <j`ey>	there's no runtime checks with as
Feb 21 00:17:33 <turlando>	Sorry, I was reading "it's not a non-op"
Feb 21 00:18:13 <jbg>	you could also do similar with a trait to make it feel a bit more like From
Feb 21 00:19:30 <turlando>	I'm not sure why I can't guard the impl From with #[cfg] (sorry for the noob question)
Feb 21 00:20:05 <jbg>	you can't impl From
Feb 21 00:20:16 <jbg>	to impl a trait either the trait or the type must be local to your crate
Feb 21 00:20:20 <jbg>	(that's the short version)
Feb 21 00:20:41 <jbg>	look up "rust orphan rule" for the long version
Feb 21 00:21:09 <jbg>	so you can write a trait FromPointerWidth {} and impl that for u64 but you can't impl From for u64
Feb 21 00:22:03 <jbg>	similarly, you could make a wrapper, struct MyU64(u64); and then impl From<usize> for that
Feb 21 00:22:05 <turlando>	Oh, right, that's similar to how typeclass instances must be implemented
**** BEGIN LOGGING AT Wed Feb 21 00:53:37 2024

Feb 21 00:53:37 *	Now talking on ##rust
Feb 21 00:53:37 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 21 00:53:37 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Feb 21 04:01:07 <Mikachu>	https://github.com/Speykious/cve-rs
Feb 21 04:14:22 <daddy>	so glad i figured out what GLWTSPL was on first guess
Feb 21 04:54:59 <Diablo-D3>	https://github.com/Speykious/cve-rs
Feb 21 04:55:03 <Diablo-D3>	but why
Feb 21 05:04:18 <Mikachu>	i guess they got tired of the bug going unfixed for 6 years so they made some proofs of concept?
Feb 21 05:28:53 <danieldg>	they could at least expand that to use any of the other unsoundness bugs
Feb 21 05:29:38 <danieldg>	there are a few more to choose from afaik - typeid hash collisions are the one I recall offhand
Feb 21 05:39:20 <phy1729>	Should have come up with a catchy name if they really wanted it fix. Unsafe at any lifetime is my terrible stab at it.
Feb 21 06:17:27 <Widdershins>	looking forward to the new trait solver tho...
Feb 21 06:17:44 <Widdershins>	i have some gripes with the way this one works
Feb 21 06:40:15 <Mutabah>	So do I... grumble grumble accepting tautalogical bounds
Feb 21 06:40:45 <Mutabah>	I've spent the two weeks thinking through/experimenting with a mrustc issue related to a crate having a tautalogical trait bound.
Feb 21 06:41:32 <Mutabah>	`S: SomeTrait, &S: SomeTrait<Assoc=S::Assoc>`, but there's a blanket `impl<S: SomeTrait> SomeTrait for &S { type Assoc = S::Assoc; }`
Feb 21 07:16:43 <dav1d>	turlando, or instead of converting u64 to usize, you convert usize to u64 which even works on 32bit platforms
Feb 21 07:55:39 <davros1>	Any interesting features on the horizon in Rust .. have been obsessed with AI for a while and not keeping track of the language changes
Feb 21 07:56:00 <davros1>	I remember a problem stopping nested 'From' impl
Feb 21 07:56:13 <davros1>	Which might have needed a workaround like negative impl's or something
Feb 21 07:56:21 <davros1>	Negative trait bounds (I forget)
Feb 21 08:51:29 <bertptrs>	negative trait bounds aren't on the way AFAIK, and the last release was a bit quiet, but before that we got async in traits and RPITIT which I find a hilarious acronym but also very useful
Feb 21 09:11:05 <Bish>	if a method returns a reference and i want to match it, why do i have to match with a reference? isnt this especially confusing with @str?
Feb 21 09:11:11 <Bish>	&str*
Feb 21 09:11:20 <Bish>	i am guessing it's a special case there?
Feb 21 09:11:57 <Bish>	https://github.com/hyperium/hyper/blob/00a703a9ef268266f8a8f78540253cbb2dcc6a55/examples/echo.rs#L24 for example this
Feb 21 09:13:28 <Mutabah>	You match a reference with a reference, that's how matching works
Feb 21 09:13:37 <Mutabah>	although, "match ergonomics" sometimes hides it
Feb 21 09:13:53 <Mutabah>	string literals are of type `&str`, so they match against a `&str`
Feb 21 09:15:21 <Bish>	what if i have 2 equal objects but they're duplicates
Feb 21 09:15:28 <Bish>	what happens if i match their references?
Feb 21 09:16:03 <Bish>	i guess the (Partial)Eq trait's == will get called and it can be whatever?
Feb 21 09:16:17 <Mutabah>	No, matching destructures to compare
Feb 21 09:16:30 <Mutabah>	and you can't match against a variable
Feb 21 09:18:28 <Bish>	hm confusing
Feb 21 09:19:12 <jbg>	how so?
Feb 21 09:19:37 <Bish>	i don't understand if that's a pointer comparison now
Feb 21 09:19:49 <jbg>	there is no comparison as such
Feb 21 09:19:50 <Bish>	or thje contents of the referenced object will be compared
Feb 21 09:19:54 <jbg>	not in the sense you are thinking
Feb 21 09:19:55 <jbg>	the left hand side of a match is a pattern, ideally one of the first concepts you learn in rust
Feb 21 09:20:16 <jbg>	names in there are new bindings, not the names of existing variables to compare to
Feb 21 09:20:25 <jbg>	you have other tools for that, like `if a == b`
Feb 21 09:20:32 <Bish>	so the compiler just compares the names, a constant struct in this case
Feb 21 09:20:55 <jbg>	you're matching structure -- types -- not content
Feb 21 09:21:05 <Bish>	ah okay
Feb 21 09:21:17 <jbg>	the book chapter on patterns is instructive here
Feb 21 09:21:24 <Bish>	but for &str that's special
Feb 21 09:21:26 <jbg>	https://doc.rust-lang.org/book/ch18-00-patterns.html
Feb 21 09:21:28 <Mutabah>	`match foo { bar => ... }` just defines `bar` as a variable with the same value as `foo`
Feb 21 09:21:53 <Mutabah>	`match foo { path::to::BAR => ... }` only works if `BAR` is a `const`, and it compares the contents (not using `==`)
Feb 21 09:22:01 <jbg>	Bish: any literals can be used in match
Feb 21 09:22:09 <jbg>	(as well as constants)
Feb 21 09:23:02 <jbg>	it's not that it's special for &str as such, but special for string literals. `match foo { bar => ... }` in Mutabah's example is still the same if foo is a &str
Feb 21 09:23:46 <jbg>	but `match foo { "bar" => ... }` will only compile if foo is a &str and will execute that arm only if it is "bar"
Feb 21 09:24:21 <bertptrs>	Bish: refererences compare by contents, pointers compare by address. This is also documented as such https://doc.rust-lang.org/std/primitive.reference.html
Feb 21 09:29:41 <Bish>	> Reference equality by address, instead of comparing the values pointed to
Feb 21 09:30:15 <Bish>	isn't that the opposite of "refererences compare by contents"
Feb 21 09:30:46 <Mutabah>	Did you read the rest of that sentence?
Feb 21 09:31:01 <Mutabah>	> is accomplished via implicit reference-pointer coercion and raw pointer equality via ptr::eq, while PartialEq compares values.
Feb 21 09:31:19 <Bish>	yeah i don't see where that dereferences
Feb 21 09:31:25 <Bish>	it sounds like pointer get compared
Feb 21 09:31:34 <Bish>	to me that is
Feb 21 09:31:47 <Mutabah>	It's saying that to compare two references by address you use `std::ptr::eq(ref1, ref2)`
Feb 21 09:32:05 <Mutabah>	(which will coerce `&T` to `*const T` then compare the two `*const T`s - comparing the addresses)
Feb 21 09:32:44 <Bish>	oh yeah i misread that sentence
Feb 21 09:36:07 <Bish>	so matching with (&Method::GET, "/test") will call .eq of both of them, right?
Feb 21 09:36:23 <Bish>	there i no pattern matching happening except for the tuple maybe
Feb 21 09:37:33 <erk>	Mutabah: To compare by address you actually don't want std::ptr::eq, you instead want the newly added std::ptr::addr_eq
Feb 21 09:37:55 <erk>	Otherwise it will use some fat pointer information that can give strange results.
Feb 21 09:38:13 <Mutabah>	erk: I was quoting docs
Feb 21 09:40:38 <Bish>	so match will pattern match and call .eq() for concrete types?
Feb 21 09:40:56 <Bish>	conrecte values*
Feb 21 09:41:56 <Mutabah>	It doesn't use `.eq`... it just uses primitive comparisons
Feb 21 09:43:25 <Bish>	so it uses.. == ?
Feb 21 09:43:39 <Bish>	what would i use to emulate match
Feb 21 09:44:53 <Mutabah>	it uses `==` and `memcmp` - match is a low-level language construct, so expands to some very low level things
Feb 21 09:46:55 <Bish>	when is == equal to .eq() if there is no primitive comparision?
Feb 21 09:47:25 <Bish>	Mutabah: wouldn't that mean i coulnd't compare something that is not copy?
Feb 21 09:47:55 <Mutabah>	if you write `foo == bar` then the `PartialEq::eq` trait method is invoked... unless it's a primitive integer/bool/float type, which the compiler already inherently knows how to equate
Feb 21 09:48:17 <Mutabah>	Maybe you should play around with `match` and read the book/reference on how it works
Feb 21 09:49:06 <Bish>	well, i don't feel like it helps me understanding how it operates, but i will try
Feb 21 09:49:31 <Mutabah>	Or, if you're brave - you could attempt to understand the mrustc `match` lowering code :)
Feb 21 09:51:36 <Bish>	i was hoping there is a simple explanation for example it just being .eq()
Feb 21 09:52:21 <Mutabah>	pattern matching is destructuring until it finds a pattern that doesn't destructure (i.e. a literal)
Feb 21 09:52:22 <Bish>	i compiled & looking at the assembler of something already and it seems to call into partialeq for &str
Feb 21 09:53:43 <Bish>	but for u32 it creates code on the spot
Feb 21 09:54:05 <Bish>	but i feel like that would happen if i did it without match as well
Feb 21 09:55:56 <Bish>	so match does many things. not a single thing.. okay
Feb 21 09:59:19 <Mutabah>	It does a LOT of things
Feb 21 09:59:34 <Mutabah>	for context - mrustc's match lowering code is larger than the rest of MIR lowering
Feb 21 10:01:12 <Bish>	why does that exist.. :o
Feb 21 10:01:22 <Bish>	is it the first rust compiler? because it says reimplementation
Feb 21 10:02:19 <Mutabah>	It's not the first, it's my project (hence why I know it's internals) to create a bootstrapping rust compiler
Feb 21 10:02:37 <Mutabah>	`match` is complex and powerful
Feb 21 10:02:58 <Bish>	why did you do this project?
Feb 21 10:04:16 <Mutabah>	fun?
Feb 21 10:04:28 <Bish>	i can get behind that
Feb 21 10:05:03 <Widdershins>	i am currently also doing a fun project (writing like 11 thousand words of documentation for a personal project for some reason)
Feb 21 10:05:50 <Bish>	i bet most people would disagree with your definitions of fun
**** BEGIN LOGGING AT Wed Feb 21 10:31:33 2024

Feb 21 10:31:33 *	Now talking on ##rust
Feb 21 10:31:33 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 21 10:31:33 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** BEGIN LOGGING AT Wed Feb 21 10:38:42 2024

Feb 21 10:38:40 *	Now talking on ##rust
Feb 21 10:38:40 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 21 10:38:40 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Feb 21 10:59:18 <Bish>	Mutabah: why wouldn't i read up rustcs code
Feb 21 10:59:18 *	Mutabah is away (not here ...)
Feb 21 10:59:27 <Bish>	would you say that's even more daunting?
Feb 21 11:09:40 <bertptrs>	Widdershins: can I dm you about something?
Feb 21 11:26:18 <Mutabah>	Bish: You could, I just don't know exactly where it is or how it looks (the `match` impl)
Feb 21 11:31:45 <j`ey>	Mutabah: so you didnt start mrustc by running rust2c on rustc?
Feb 21 11:31:47 <j`ey>	:p
Feb 21 11:38:25 <Mutabah>	j`ey: Well... strictly speaking that was what mrustc started out as - convert AST to C
Feb 21 11:38:52 <Mutabah>	but by the time I got anywhere near close to codegen, that was gone and C was backend
Feb 21 11:45:53 <Widdershins>	bertptrs: what's up
Feb 21 12:41:26 <Bish>	im still on my http2 streaming bodies adventure
Feb 21 12:41:54 <Bish>	https://bpa.st/5QQA but im stuck on e=hyper::Error(User(ManualUpgrade))
Feb 21 12:42:11 <Bish>	if someone knows whats going on it'd be cool
Feb 21 12:43:03 <Bish>	(specificially the websocket route, the rest works)
Feb 21 12:46:25 <Bish>	https://github.com/hyperium/hyper/blob/00a703a9ef268266f8a8f78540253cbb2dcc6a55/src/upgrade.rs#L264 https://github.com/hyperium/hyper/blob/00a703a9ef268266f8a8f78540253cbb2dcc6a55/src/server/conn/http1.rs#L220 this seems to be the "callstack" on that error
Feb 21 12:48:47 <Bish>	fuck me, im so stupid
Feb 21 12:48:53 <Bish>	rubber ducky best method
**** BEGIN LOGGING AT Wed Feb 21 16:46:59 2024

Feb 21 16:46:59 *	Now talking on ##rust
Feb 21 16:46:59 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 21 16:46:59 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Feb 21 17:12:09 <bombastick>	Hi
Feb 21 17:23:17 <Aorimn>	hi, what would be the most idiomatic way of converting a [u8; 6] to a [u8; 8] by adding zeroes to the end of it (so that I can u64::from_le_bytes() it afterward)?
Feb 21 17:23:43 <Aorimn>	the only solution I can think of is copying the bytes in a loop, but that doesn't sound nice
Feb 21 17:23:55 <bombastick>	what % of you use Rust for work as your primary language, as opposed to hobbyist?
Feb 21 17:24:22 <Aorimn>	I have this 6 size because I'm reading (impl Read) those 6 bytes
Feb 21 17:24:52 <bertptrs>	let mut dest = [0u8; 8]; reader.read(&mut dest[..6])?
Feb 21 17:27:07 <Aorimn>	ah... that's even better indeed ^^'   thanks bertptrs!
Feb 21 17:27:31 <bertptrs>	err, read_exact of course
Feb 21 17:27:37 <bertptrs>	close enough
Feb 21 17:28:14 <Aorimn>	yeah, I managed to make the translation :)
Feb 21 17:28:15 <bertptrs>	ideally the compiler realizes that it doesn't have to zero initialize the first 6 bytes but if not it's just six bytes, how hard can it be
Feb 21 17:29:21 <Aorimn>	in this case I'm not too strict on performances, I'll code the feature before looking at such issues (not even sure it'll be in a hot path at this point)
Feb 21 17:30:58 <bertptrs>	good decision
Feb 21 19:53:42 <flipchan>	im trying to print some ascii art, does anyone know any crates that lets you autoscale a string based on terminal size?
Feb 21 19:54:06 <flipchan>	I'm trying to scale the ascii art based on terminal size so it will work on all terminal sizes
Feb 21 19:54:42 <danieldg>	look for wrappers around ncurses or just access to termios in general to get the size
Feb 21 19:54:45 <bertptrs>	terminal_size and then wrap it yourself?
Feb 21 19:54:48 <bertptrs>	that's what clap does
Feb 21 19:54:52 <alip>	BufRead::lines() will OOM when you hand it /dev/zero, bug or feature?
Feb 21 19:55:08 <danieldg>	alip: working as intended
Feb 21 19:55:18 <alip>	nice
Feb 21 19:55:25 <bertptrs>	alip: you made it read until the end of the line, when there was no end of the line
Feb 21 19:55:28 <bertptrs>	what did you expect?
Feb 21 19:55:34 <danieldg>	alip: just like loop { vec.push(0) } OOMs
Feb 21 19:55:40 <alip>	i expected no newline found in LINE_MAX bytes with ENAMETOOLONG
Feb 21 19:55:48 <alip>	and hence i implemented it myself
Feb 21 19:55:53 <alip>	never trust rust stdlib lol
Feb 21 19:56:20 <danieldg>	LINE_MAX? is that the thing that gets() uses, but only if on a TTY?
Feb 21 19:56:38 <alip>	no line_max is just a random big number doesn't matter what
Feb 21 19:56:46 <alip>	friends don't oom on each other
Feb 21 19:56:55 <danieldg>	it'll never be big enough
Feb 21 19:57:05 <alip>	the alternative is far worse
Feb 21 19:57:21 <bertptrs>	going OOM on infinite input isn't that bad
Feb 21 19:57:27 <danieldg>	I want to read json-lines files with .lines() and have json blobs not be limited to a few MB
Feb 21 19:57:44 <alip>	i can see why the never big enough argument is logical
Feb 21 19:57:46 <bertptrs>	arbitrarily splitting lines after so many characters is bound to lead to weird surprises
Feb 21 19:57:54 <alip>	but then i'd at least expect a warning in lines() docs about this
Feb 21 19:58:14 <danieldg>	alip: the lack of a LINES_MAX reference *is* the warning
Feb 21 19:58:25 <alip>	nice
Feb 21 19:58:32 <alip>	never trust the stdlib docs
Feb 21 19:58:51 <danieldg>	if that's how you define trust...
Feb 21 19:59:13 <alip>	you say the lack of stating a limit is good enough for the code ooming on you
Feb 21 19:59:18 <alip>	and yes, that's how i define trust
Feb 21 19:59:24 <bertptrs>	code OOM'ing is safe behaviour
Feb 21 19:59:30 <alip>	mmph ofc it is
Feb 21 19:59:32 <alip>	ok nvm
Feb 21 19:59:39 <bertptrs>	as opposed to the alternatives it is
Feb 21 19:59:45 <danieldg>	you could just as easily call it an OS bug
Feb 21 19:59:57 <bertptrs>	BufRead::lines() has issues but this is not (imo) one of them
Feb 21 20:00:21 <danieldg>	/dev/zero should stop after you've read too much data
Feb 21 20:00:35 <danieldg>	maybe prompt you to be sure you want to read that much
Feb 21 20:00:35 <bertptrs>	I'd much prefer an API where you can hand out your own buffer
Feb 21 20:00:39 <bertptrs>	alas
Feb 21 20:00:49 <bertptrs>	(yes there's read_line but that's not an iterator)
Feb 21 20:00:50 <alip>	ye that'd solve it too bertptrs
Feb 21 20:01:09 <alip>	danieldg: c'mon now you're just being ridicilous
Feb 21 20:01:32 <alip>	it just means calling lines() in the wrong context may mean DOS
Feb 21 20:01:43 <alip>	and documenting that is nice and kind
Feb 21 20:01:45 <alip>	ofc it's safe
Feb 21 20:02:29 <danieldg>	calling any read function can mean dos if you don't put limiters on it
Feb 21 20:02:42 <danieldg>	lines() doesn't work well with nonblocking after all
Feb 21 20:03:02 <int-e>	danieldg: so my takeaway from that talk is that I'm not the first one to be surprised by Linux's madvise semantics ;-)
**** BEGIN LOGGING AT Wed Feb 21 20:38:01 2024

Feb 21 20:38:01 *	Now talking on ##rust
Feb 21 20:38:01 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 21 20:38:01 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Feb 21 20:54:20 <capitol>	I have this idea of a new clippy lint, maybe of the pedantic type. One way to make your code be non-portable to 32-bit arches is to write something like: let foo : usize = 4294967295;
Feb 21 20:54:46 <capitol>	and this feels like it would be nice to have a warning about
Feb 21 20:56:56 <j`ey>	you can just try compile for 32 bits :P
Feb 21 20:57:04 <danieldg>	how pedantic should it be?  Rust tries to be able to run with 16-bit usize too
Feb 21 20:57:29 <danieldg>	but there's a lot of code that wants more than 64K for things
Feb 21 20:58:08 <danieldg>	it's not too uncommon to want a vec![0;1<<20] as a buffer (1MB)
Feb 21 21:00:42 <capitol>	yeah, the 16 bit one should maybe be it's own lint, so that it would be able to enable just the ones that you support
Feb 21 21:01:12 <danieldg>	also, anything over 1<<31 in a usize will start to cause problems on 32-bit
Feb 21 21:01:19 <danieldg>	over or equal to
Feb 21 21:01:32 <capitol>	j`ey: true, this is more so that I hopefully don't have to send to many patches to other projects when I package for debian :)
Feb 21 21:01:56 <capitol>	yes
Feb 21 21:17:24 <Vorpal>	Hm I have a crate that can have multiple backends (for talking to distro package managers, different ones for different Linux distros). You can build with support for multiple. But if I disable all features it doesn't work, due to empty enums and the like. Which is a problem for publishing the crate. What is the recommended approach for this. I don't think it makes sense to set any specific distro backend as a default feature either.
Feb 21 21:17:33 <Vorpal>	The issue is enums like this one: https://0x0.st/H5bj.txt
Feb 21 21:18:00 <j`ey>	whats the issue with an empty enum?
Feb 21 21:18:22 <Vorpal>	j`ey: well match statements on those (with similar cfg directives) doesn't work when the body of the match statement becomes empty
Feb 21 21:18:23 <j`ey>	empty enums are fine in general
Feb 21 21:18:28 <Vorpal>	error[E0004]: non-exhaustive patterns: type `&config::Backend` is non-empty
Feb 21 21:18:47 <j`ey>	can you paste the code that fails
Feb 21 21:18:52 <j`ey>	 / full error
Feb 21 21:19:00 <Vorpal>	one second
Feb 21 21:19:22 <j`ey>	https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=6ed4245c28a8728d6edc7c355c313087
Feb 21 21:20:48 <danieldg>	depending on what you actually need, you could just add a 'not implemented' backend that is always available.  But yes, this should work already.
Feb 21 21:20:49 <Vorpal>	https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=3bd573a790b0fcaad5bff662d8b9e77d
Feb 21 21:20:52 <Arnavion>	Publishing shouldn't be a problem. You can do `--features` with `cargo publish`
Feb 21 21:21:10 <Vorpal>	ah, the issue seems to be the reference
Feb 21 21:21:10 <Arnavion>	so you can pick one or all of them just to satisfy `cargo publish`
Feb 21 21:21:17 <j`ey>	ah right
Feb 21 21:21:37 <danieldg>	wait, references are always inhabited now?  When did this happen?
Feb 21 21:21:47 <Vorpal>	hm for this enum it works, I have another one (different file checksums) where it will be trickier since it isn't copy
Feb 21 21:22:11 <j`ey>	danieldg: wasnt that always the case??
Feb 21 21:22:33 <danieldg>	j`ey: pretty sure you used to be able to match reference {}
Feb 21 21:22:34 <j`ey>	Vorpal: I think danieldg's suggestion of a NullBackend is probably the easiest.. maybe
Feb 21 21:23:09 <danieldg>	I think I used it in some Infallible impls
Feb 21 21:23:28 <Vorpal>	j`ey: for backend I don't need the reference (payload-less enum, Copy). For https://0x0.st/H5b2.txt I have a very similar situation, there I don't want to copy, so that will be trickier
Feb 21 21:23:41 <j`ey>	danieldg: same error on 1.18
Feb 21 21:23:54 <danieldg>	j`ey: ahh, "match *self" works
Feb 21 21:24:00 <danieldg>	Vorpal: you could use that
Feb 21 21:24:24 <Vorpal>	danieldg: won't that result in a copy though? For the second case.
Feb 21 21:24:33 <Vorpal>	(that is https://0x0.st/H5b2.txt )
Feb 21 21:24:48 <Arnavion>	Just do `--features` instead of adding a fake backend or changing your code...
Feb 21 21:24:50 <danieldg>	you can start throwing in ref in your match arms
Feb 21 21:25:01 <Vorpal>	Arnavion: yeah probably the right choice
Feb 21 21:25:06 <danieldg>	it will not force a copy
Feb 21 21:25:26 <Vorpal>	or that, that works too
Feb 21 21:26:24 <danieldg>	I suppose I wrote the Infallible matches prior to match ergonomics and didn't notice they used *
Feb 21 21:27:41 <Vorpal>	Arnavion: actually, right now --features work, but I plan to add other packages and data source types (flatpak, snap, rpm, tmpfiles.d) not all of them have all info on installed files, not all of them have info on installed packages, Some have both, some have either or. So I believe I could end up in a similar situation if I only build support for snap and flatpak say (no need to depend on any checksum library for those)
Feb 21 21:28:09 <Vorpal>	So I'm going with ref
Feb 21 21:29:31 <Vorpal>	still end up with a bunch of warnings though for --no-default-features (variable don't need to be mutable, unused variants, etc). Oh well. I think I'll live with that.
Feb 21 21:30:46 <j`ey>	you could also just explicitly fail to compile with no backend selected
Feb 21 21:32:08 <Vorpal>	I could yes, might make sense to tell any users other than me how to use it properly.
Feb 21 21:47:39 <Arnavion>	Vorpal:   https://github.com/Arnavion/k8s-openapi/blob/master/build.rs#L9-L60   If you need inspiration
Feb 21 21:48:44 <Vorpal>	#[cfg(not(any(feature = "arch_linux", feature = "debian")))] compile_error!("At least one backend must be enabled");
Feb 21 21:48:54 <Vorpal>	seems simpler
Feb 21 21:50:03 <Vorpal>	no need to add a build script if I don't need to
Feb 21 21:50:19 <Arnavion>	Yes, if it's just `any(feature, feature)` you can do it inline
Feb 21 21:55:28 <Vorpal>	well, I assume any takes any number of arguments, so I should be able to continue once I add more backends too
Feb 21 21:57:20 <Arnavion>	Yes
**** BEGIN LOGGING AT Wed Feb 21 23:19:27 2024

Feb 21 23:19:26 *	Now talking on ##rust
Feb 21 23:19:26 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 21 23:19:26 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** ENDING LOGGING AT Wed Feb 21 23:20:04 2024

**** BEGIN LOGGING AT Wed Feb 21 23:21:17 2024

Feb 21 23:21:17 *	Now talking on ##rust
Feb 21 23:21:17 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 21 23:21:17 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** ENDING LOGGING AT Wed Feb 21 23:50:23 2024

**** BEGIN LOGGING AT Wed Feb 21 23:50:23 2024

**** ENDING LOGGING AT Wed Feb 21 23:52:21 2024

**** BEGIN LOGGING AT Wed Feb 21 23:52:21 2024

**** ENDING LOGGING AT Wed Feb 21 23:53:41 2024

**** BEGIN LOGGING AT Wed Feb 21 23:53:41 2024

**** ENDING LOGGING AT Wed Feb 21 23:57:59 2024

**** BEGIN LOGGING AT Wed Feb 21 23:57:59 2024

Feb 22 00:18:13 <bwidawsk>	I want to keep a hashmap where the values in the map are a hashable object. I don't care what the key will be, as it's an opaque handle that is used by the caller in the API. What is the best way to create unique keys to associate with the object? (I was thinking `hashmap.insert(object.hash(), object)`)
Feb 22 00:18:34 <bwidawsk>	(Could also use an atomic as an index ofc)
Feb 22 00:19:36 <Arnavion>	object.hash() is fine. To avoid double-hashing you can use something like   https://docs.rs/hash_hasher
Feb 22 00:19:51 <Arnavion>	or BTreeMap
Feb 22 00:20:42 <bwidawsk>	Arnavion: thank you
Feb 22 02:15:58 <segfaultfizzbuzz>	are there any good recommendations for how to store a secret string/token in a rust binary?
Feb 22 02:16:47 <danieldg>	either anywhere or nowhere
Feb 22 02:16:55 <danieldg>	anywhere if the binary can be a secret, nowhere if not
Feb 22 02:19:48 <segfaultfizzbuzz>	so a const String is about as good as it gets i guess?
Feb 22 02:20:05 <segfaultfizzbuzz>	i am aware of SGX but i can't do that unfortunately...
Feb 22 02:20:35 <danieldg>	yes, if you're not able to store it anywhere else secure either
Feb 22 02:20:58 <danieldg>	HSM, TPM, etc
Feb 22 02:21:21 <segfaultfizzbuzz>	so this isn't worthwhile for instance: https://crates.io/crates/secstr
Feb 22 02:22:10 <Mutabah>	that would help prevent runtime leaks
Feb 22 02:22:56 <Mutabah>	but the original secret will still be in the binary somewhere - you can obsfucate it, but that only adds a thin layer of protection
Feb 22 02:23:27 <segfaultfizzbuzz>	runtime leaks? on a related note, can unsafe code read/modify the program itself (which i suppose is in memory..?)  ?
Feb 22 02:24:23 <segfaultfizzbuzz>	secstr isn't stored on github, which is odd
Feb 22 02:27:28 <danieldg>	segfaultfizzbuzz: read, usually; modify, no, not unless it takes action to call mprotect
Feb 22 02:28:10 <segfaultfizzbuzz>	why wouldn't the operating system wall the program code off from the data ?
Feb 22 02:28:28 <danieldg>	most architectures don't support that
Feb 22 02:28:46 <segfaultfizzbuzz>	yipes
Feb 22 02:29:07 <cehteh>	moderm ones do, but ther are a zillion ways to circumvent it
Feb 22 02:29:39 <danieldg>	ASLR helps too
Feb 22 02:29:56 <danieldg>	but yeah, 'bypassing ASLR' is like 'hacking 102' these days
Feb 22 02:30:25 <cehteh>	x86-64 has write protection on executable pages
Feb 22 02:30:40 <segfaultfizzbuzz>	you would think that there would be read protection for those as well...
Feb 22 02:30:46 <danieldg>	yes - executable plages are *normally* write protected
Feb 22 02:30:59 <danieldg>	there's not normally a need or desire to read protect
Feb 22 02:31:03 <cehteh>	but a program could do all kinds of fancy stuff like creating a dynlib and loading that
Feb 22 02:31:11 <segfaultfizzbuzz>	...but why would you want to read at all?
Feb 22 02:31:30 <danieldg>	segfaultfizzbuzz: code and read-only data can share pages
Feb 22 02:31:39 <cehteh>	on linux you can do a lot protection with seccomp, but its not trivial
Feb 22 02:31:44 <segfaultfizzbuzz>	memory locality/speed then?
Feb 22 02:31:58 <danieldg>	seccomp doesn't help with read the executable
Feb 22 02:32:14 <danieldg>	you need less common things like memory protection keys
Feb 22 02:32:27 <cehteh>	yes but seccomp makes sure that a program cant m(un)protect pages it shouldn
Feb 22 02:32:54 <cehteh>	or load dynlibs and so on
Feb 22 02:32:56 <danieldg>	the memseal system calls are useful here too
Feb 22 02:34:11 <segfaultfizzbuzz>	darpa Measures for Establishment of Memory Signatures in Early Activated Lymphocytes
Feb 22 02:35:09 <danieldg>	no
Feb 22 02:35:56 <danieldg>	https://lwn.net/Articles/958438/
Feb 22 02:44:32 <danieldg>	basically a well-written program won't read from arbitrary memory addresses and so won't be a problem
Feb 22 02:45:18 <danieldg>	so just rely on that - rust doesn't let you bypass it without unsafe
Feb 22 02:45:38 <segfaultfizzbuzz>	right ok thanks
Feb 22 03:22:41 <dkg>	i'm struggling with Rust's C FFI: i'm building a shared object in Rust that exposes a function to the C ABI.  I want the external C code to be able to call the function with an argument that is a pointer to a fixed-length buffer of chars.  this argument, if non-null, will be used to return a limited-length, null-terminated error string if the function fails.
Feb 22 03:23:35 <dkg>	i'm having trouble with the typing for this buffer and how to get a Rust string error message to be written to it properly.
Feb 22 03:23:43 <danieldg>	*mut u8
Feb 22 03:23:57 <Mutabah>	By fixed-length, do you mean ABI/API specified, or is the length in another argument?
Feb 22 03:24:09 <Mutabah>	If it's the former - then `*mut [u8; 123]`
Feb 22 03:24:20 <dkg>	what i've got so far is:     #[repr(C)] pub struct foo_err_msg { message: [c_char; 128], }
Feb 22 03:24:38 <dkg>	the API specifies that the error buffer is always  a simple struct with 128 chars in it.
Feb 22 03:25:00 <dkg>	then the argument to the function is Option<&mut foo_err_msg>
Feb 22 03:25:16 <Mutabah>	that all seems reasonable
Feb 22 03:25:26 <dkg>	and i'll only write to it if let Some(err_out) = err_out
Feb 22 03:25:39 <dkg>	so the problem i'm having in the function is figuring out how to write to the buffer
Feb 22 03:25:47 <danieldg>	I'd use u8 and not c_char
Feb 22 03:26:00 <danieldg>	because rust prefers writing to u8
Feb 22 03:26:18 <danieldg>	and it's not like C actually cares if char is signed or not 99.9% of the time
Feb 22 03:26:26 <dkg>	hm, but in the C interface i'd prefer it is a char, because that's a clean hint to the C user that this will be a null-terminated string.
Feb 22 03:26:43 <dkg>	and if we're gonna get typing right, i kind of want to get it right :P
Feb 22 03:26:57 <danieldg>	here's a secret: char* and unsigned char* have the same ABI :)
Feb 22 03:27:02 <dkg>	but yeah, i'm seeing messgaes like: expected `[i8; 128]`, found `&[u8]`
Feb 22 03:27:33 <dkg>	i'm aware that they have the same ABI, i'm just trying to do this cleanly by respecting the type system and not tricking it :)
Feb 22 03:27:34 <danieldg>	yes, because rust wants to write to u8
Feb 22 03:28:00 <danieldg>	you can just impl std::io::Write for your struct foo_err_msg
Feb 22 03:28:06 <danieldg>	or fmt::Write, if you like
Feb 22 03:28:25 <danieldg>	copy the bytes one by one and cast them from u8 to i8
Feb 22 03:29:06 <dkg>	well, from u8 to std::ffi::c_char, since presumably different platforms have different c_chars -- they aren't all i8 :/
Feb 22 03:29:18 <danieldg>	yes
Feb 22 03:29:21 <dkg>	it happens to be i8 on my platform
Feb 22 03:29:32 <danieldg>	it's i8 or u8 basically everywhere
Feb 22 03:30:03 <dkg>	agreed
Feb 22 03:30:05 <danieldg>	only systems that aren't byte-addressible can get away with char not being a byte
Feb 22 03:30:51 <dkg>	but again, i'm trying to do clean typing without assumptions; that's one of the things i find compelling about Rust.  maybe i'm being too much of a purist
Feb 22 03:31:35 <danieldg>	your cast can be char, yes
Feb 22 03:31:40 <dkg>	so even if i switch to u8 instead of std::ffi::c_char, i get: expected `[u8; 128]`, found `&[u8]`
Feb 22 03:31:53 <dkg>	how do i deal with the length limit safely?
Feb 22 03:32:03 <danieldg>	you use a ref?
Feb 22 03:32:04 <dkg>	sorry if this is a n00b question, i'm a n00b ðŸ˜›
Feb 22 03:32:21 <Mutabah>	you want .copy_from_slice
Feb 22 03:32:31 <Mutabah>	which might also require slicing the destination to the right length
Feb 22 03:32:35 <dkg>	yes, i'm using Option<&mut foo_err_msg>  and i'm in the case where "if let Some(err_msg) = err_msg {"
Feb 22 03:32:50 <Mutabah>	Or, a custom loop that writes into the destination and ensures that it's NUL terminated
Feb 22 03:33:10 <dkg>	i was hoping to use something like CString.as_bytes_with_nul()
Feb 22 03:33:19 <dkg>	so that i don't have to write any custom byte-level loops
Feb 22 03:33:41 <danieldg>	you'll still have to copy the memory from the CString to the output
Feb 22 03:33:46 <dkg>	agreed.
Feb 22 03:33:51 <dkg>	(fwiw, i'm jumping through these hoops to try to avoid any memory allocations across the FFI)
Feb 22 03:33:52 <danieldg>	but that could be with copy_from_slice
Feb 22 03:34:18 <danieldg>	writing to the destination buffer in-place is "nicer"
Feb 22 03:34:35 <danieldg>	vs writing to a String, converting to CString, then copying
Feb 22 03:34:45 <dkg>	i agree, it does seem cleaner to write to the destination buffer in place
Feb 22 03:35:22 <dkg>	but i don't know how to do that :/  and, in some cases, i'll have an Err that i want to extract a (potentially truncated) message from and copy it in
Feb 22 03:36:43 <danieldg>	dkg: struct Writer { buf: &mut [c_char] }  impl Writer { fn new(buf:&mut [c_char;128]) -> Self { Self { buf }}} impl std::fmt::Write for Writer { ...
Feb 22 03:37:33 <danieldg>	you can maintain the null-termination invariant as you write, or do it in Drop
Feb 22 03:38:41 <danieldg>	write_str is where you put either your u8->c_char loop, or a copy_from_slice if you decide to use u8 not c_char
Feb 22 03:38:58 <danieldg>	then you can call write!() on your Writer
Feb 22 03:39:50 <danieldg>	write_str should advance self.buf - that's why it uses a slice, not an array
Feb 22 03:40:08 <dkg>	thanks!  still trying to wrap my head around thisâ€¦  i need a new struct to do this?  or i put this impl on my foo_err_msg ?
Feb 22 03:40:16 <danieldg>	new struct
Feb 22 03:40:45 <danieldg>	it has to track the 'cursor'
Feb 22 03:41:40 <dkg>	i see, the Writer struct is just the cursor tracker
Feb 22 03:42:43 <dkg>	ok, you've given me enough to chew on, i'll try to sort it out further.  thanks!  i thought this would be a bit simpler than it is turning out to be :/
Feb 22 03:48:18 <danieldg>	the simple way is to use the existing io::Write impl for &mut [u8]
Feb 22 03:49:09 <danieldg>	you can cast a &mut [u8;128] to a &mut [u8] and then write to it
Feb 22 03:50:11 <danieldg>	or even the one for Cursor<[u8;N]>
Feb 22 03:50:40 <danieldg>	I just noticed that one, it's nicer for this case
Feb 22 09:33:00 <SiegeLord>	Lets say I have a trait: `trait Foo { fn call(&self, ctx: impl Context) -> (); }`, is there a way to automatically implement it for functions with the same signature as the `call` associated function?
Feb 22 09:33:23 <SiegeLord>	Like a `fn foo(ctx: impl Context) -> () {}`
Feb 22 09:33:51 <bertptrs>	Sort of
Feb 22 09:37:09 <SiegeLord>	The final goal is to somehow write: `fn bar(call: impl Fn(impl Context) -> ()`
Feb 22 09:37:28 <SiegeLord>	Which isn't possible, so I'm attempting to write `fn bar(call: impl Foo)`
Feb 22 09:37:42 <SiegeLord>	But I want to do something approximating `bar(foo)`
Feb 22 09:39:03 <SiegeLord>	It's clear that I can, for every `foo`, write a manual implementation for some dummy type `F`, but I wonder if there's something with less boilerplate
Feb 22 09:39:18 <SiegeLord>	manual implementation of `Foo`
Feb 22 09:40:11 <bertptrs>	Ah I see, the problem is that you cannot have "impl Trait" in a trait bound
Feb 22 09:40:23 <bertptrs>	so my idea doesn't work https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=77a5b8655b47befd6cae887993bf6250
Feb 22 09:41:12 <bertptrs>	The double generics make it hard
Feb 22 09:41:43 <SiegeLord>	I think this is a type of HKT, so perhaps something using GATs could be a solution, but that's as far as that line of thought goes
Feb 22 09:42:11 <bertptrs>	I don't think you can express this particular thing yet. Which is sad, it's not an unreasonable question
Feb 22 09:42:40 <bertptrs>	If you can tweak the Foo trait a little it might work
Feb 22 09:43:15 <SiegeLord>	I can, it's something I fully control.
Feb 22 09:43:29 <bertptrs>	https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=27e2d1dc09c79939e69c9a917784863f
Feb 22 09:54:56 <SiegeLord>	Ah, that won't work. Here's the version with the dummy type, perhaps clarifying the design goals: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=3d7636e6c165af5ad4b5d0e12dad864d
Feb 22 11:23:12 <sword_smith>	Is a (u64,u64)->u128 multiplication as fast on my x86-64 machine as a (u32,u32)->u64 multiplication?
Feb 22 11:25:37 <Mutabah>	probably pretty close on its own...
Feb 22 11:25:46 <Mutabah>	but more data takes longer to load/manipulate
Feb 22 11:27:12 <Norkle>	hi
Feb 22 11:28:07 <Mutabah>	Hello.
Feb 22 11:28:16 <Mutabah>	Interesting hostname you have there
Feb 22 11:43:25 <saati>	sword_smith: on most cpus multiplication takes variable time determined by it's inputs
Feb 22 11:43:51 <saati>	bigger numbers can take a couple more cycles
Feb 22 11:44:57 <saati>	iirc zen4 has const time multiplication
Feb 22 11:45:48 <Mutabah>	saati: eeeh... multiplication units can be done in constant time based on the bit size
Feb 22 11:46:18 <Mutabah>	shift+add for each bit in the other number
Feb 22 11:50:06 <saati>	let's benchmark
Feb 22 11:54:21 <sword_smith>	saati: Thanks. I have a benchmark here, but it does some annoying addition, that I would like to remove: use std::ptr;
Feb 22 11:54:24 <sword_smith>	use criterion::measurement::WallTime;
Feb 22 11:54:26 <sword_smith>	use criterion::{
Feb 22 11:54:29 <sword_smith>	    criterion_group, criterion_main, BenchmarkGroup, BenchmarkId, Criterion, Throughput,
Feb 22 11:54:32 <sword_smith>	};
Feb 22 11:54:34 <sword_smith>	use twenty_first::shared_math::other::random_elements;
Feb 22 11:54:37 <sword_smith>	fn mul(c: &mut Criterion) {
Feb 22 11:54:39 <sword_smith>	    let mut group = c.benchmark_group("mul");
Feb 22 11:54:42 <sword_smith>	    let log2_of_sizes: Vec<usize> = vec![3, 7, 12, 18, 23];
Feb 22 11:54:44 <sword_smith>	    // Benchmarking forward ntt on BFieldElements
Feb 22 11:54:47 <sword_smith>	    for log2_of_size in log2_of_sizes.iter() {
Feb 22 11:54:49 <sword_smith>	        u32_mul(
Feb 22 11:54:52 <sword_smith>	            &mut group,
Feb 22 11:54:54 <sword_smith>	            BenchmarkId::new("(u32,u32)->u64", log2_of_size),
Feb 22 11:54:57 <sword_smith>	            *log2_of_size,
Feb 22 11:54:59 <sword_smith>	        );
Feb 22 11:55:02 <sword_smith>	    }
Feb 22 11:55:04 <sword_smith>	    for log2_of_size in log2_of_sizes.iter() {
Feb 22 11:55:07 <sword_smith>	        u64_mul(
Feb 22 11:55:09 <sword_smith>	            &mut group,
Feb 22 11:55:12 <sword_smith>	            BenchmarkId::new("(u64,u64)->u128", log2_of_size),
Feb 22 11:55:13 <j`ey>	um
Feb 22 11:55:15 <sword_smith>	            *log2_of_size,
Feb 22 11:55:17 <sword_smith>	        );
Feb 22 11:55:20 <sword_smith>	    }
Feb 22 11:55:22 <sword_smith>	    group.finish();
Feb 22 11:55:25 <sword_smith>	}
Feb 22 11:55:27 <sword_smith>	fn u32_mul(group: &mut BenchmarkGroup<WallTime>, bench_id: BenchmarkId, log2_of_size: usize) {
Feb 22 11:55:30 <sword_smith>	    let size: usize = 1 << log2_of_size;
Feb 22 11:55:33 <sword_smith>	    let xs: Vec<u32> = random_elements(size);
Feb 22 11:55:35 <sword_smith>	    group.throughput(Throughput::Elements(size as u64));
Feb 22 11:55:38 <sword_smith>	    group.bench_with_input(bench_id, &size, |b, _| {
Feb 22 11:55:40 <sword_smith>	        b.iter(|| {
Feb 22 11:55:43 <sword_smith>	            let mut acc = 0u64;
Feb 22 11:55:45 <sword_smith>	            for i in 0..(size - 1) {
Feb 22 11:55:48 <sword_smith>	                acc = acc.wrapping_add(xs[i] as u64 * xs[i + 1] as u64);
Feb 22 11:55:50 <sword_smith>	            }
Feb 22 11:55:53 <sword_smith>	            // Prevent the compiler from optimizing the loop away
Feb 22 11:55:55 <sword_smith>	            unsafe {
Feb 22 11:55:58 <sword_smith>	                ptr::write_volatile(&mut acc as *mut u64, acc);
Feb 22 11:56:00 <sword_smith>	            }
Feb 22 11:56:03 <sword_smith>	        })
Feb 22 11:56:05 <sword_smith>	    });
Feb 22 11:56:08 <sword_smith>	    group.sample_size(10);
Feb 22 11:56:10 <sword_smith>	}
Feb 22 11:56:13 <sword_smith>	fn u64_mul(group: &mut BenchmarkGroup<WallTime>, bench_id: BenchmarkId, log2_of_size: usize) {
Feb 22 11:56:16 <sword_smith>	    let size: usize = 1 << log2_of_size;
Feb 22 11:56:18 <sword_smith>	    let xs: Vec<u64> = random_elements(size);
Feb 22 11:56:21 <sword_smith>	    group.throughput(Throughput::Elements(size as u64));
Feb 22 11:56:23 <sword_smith>	    group.bench_with_input(bench_id, &size, |b, _| {
Feb 22 11:56:26 <sword_smith>	        b.iter(|| {
Feb 22 11:56:28 <sword_smith>	            let mut acc = 0u128;
Feb 22 11:56:31 <sword_smith>	            for i in 0..(size - 1) {
Feb 22 11:56:33 <sword_smith>	                acc = acc.wrapping_add(xs[i] as u128 * xs[i + 1] as u128);
Feb 22 11:56:36 <sword_smith>	            }
Feb 22 11:56:38 <sword_smith>	            // Prevent the compiler from optimizing the loop away
Feb 22 11:56:40 <j`ey>	bertptrs:
Feb 22 11:56:41 <sword_smith>	            unsafe {
Feb 22 11:56:43 <sword_smith>	                ptr::write_volatile(&mut acc as *mut u128, acc);
Feb 22 11:56:46 <sword_smith>	            }
Feb 22 11:56:48 <sword_smith>	        })
Feb 22 11:56:51 <sword_smith>	    });
Feb 22 11:56:53 <sword_smith>	    group.sample_size(10);
Feb 22 11:56:56 <sword_smith>	}
Feb 22 11:56:58 <sword_smith>	criterion_group!(benches, mul);
Feb 22 11:57:01 <sword_smith>	criterion_main!(benches);
Feb 22 11:57:03 <sword_smith>	fucking hell
Feb 22 11:57:06 <sword_smith>	sorry
Feb 22 11:57:08 <sword_smith>	I meant to copy-paste this: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021
Feb 22 11:57:09 <Affliction>	https://play.rust-lang.org/?version=stable&mode=debug&edition=2021 for code pastes; doing it that way results in you sending 1 message per second. And that is generally annoying.
Feb 22 11:57:11 <sword_smith>	yeah .. sorry guys. Didn't mean to spam. `irssi` warned me about 75 lines, but the command to go ahead is the command I use to delete my input (ctrl+a, ctrl+k).
Feb 22 11:57:23 <j`ey>	sword_smith: imagine if you accidentally pasted the same thing again lol
Feb 22 11:58:03 <Affliction>	nice how my message lined up with the very end, heh.
Feb 22 11:58:03 <bertptrs>	sword_smith: can you not do that again
Feb 22 11:58:05 <sword_smith>	My IRC client *should* make it harder to SPAM, imo.
Feb 22 11:58:16 <sword_smith>	Yes, I'm blaming my software, partially.
Feb 22 11:58:19 <j`ey>	bertptrs: ban him!!!
Feb 22 11:58:34 <bertptrs>	I think the youth of today would call it a skill issue
Feb 22 11:58:44 <bertptrs>	j`ey: accidents happen, let it slide
Feb 22 11:58:48 <sword_smith>	j`ey: Watch out with irony on text :)
Feb 22 11:58:52 <Affliction>	Anyway, you pasted a link to the empty playground; hit share and "permalink"
Feb 22 11:59:03 <j`ey>	sword_smith: I was hoping the multiple !! was enough :P
Feb 22 11:59:21 <sword_smith>	saati: Here's the benchmark I've written: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=d52ce86b44e054533e003e8440ed8ec0
Feb 22 12:00:31 <Widdershins>	sword_smith: what did you want to remove
Feb 22 12:00:44 <bertptrs>	j`ey: the double ping cancels out the exclamation marks
Feb 22 12:01:08 <Widdershins>	the exclamation marks cast your sarcasm to boolean
Feb 22 12:01:13 <j`ey>	bertptrs: oh true, my bad
Feb 22 12:01:43 <sword_smith>	saati: But my benchmark includes some summation, that I would like to avoid. The compiler is quick optimize away unused results though.
Feb 22 12:02:18 <Bish>	how many people here are fulltime rusters (getting paid for it)
Feb 22 12:02:26 <Widdershins>	you mean your volatile thing you're doing to force the loop not to optimize?
Feb 22 12:02:28 <sword_smith>	The benchmark I've written *almost* achieves what I want. And does run faster for (u32,u32)->u64 mul than for u64->u128 mul.
Feb 22 12:02:57 <Widdershins>	https://doc.rust-lang.org/std/hint/fn.black_box.html
Feb 22 12:03:06 <sword_smith>	Widdershins: The volatile thing *and* the entire accumulation. I don't actually want to add anything.
Feb 22 12:03:10 <sword_smith>	Just multiply.
Feb 22 12:03:34 <Widdershins>	see that link, that's the dedicated tool for this
Feb 22 12:08:24 <sword_smith>	Widdershins: Do you have something I can use on `stable`?
Feb 22 12:14:54 <saati>	yeah i was wrong, i can't demonstrate t
Feb 22 12:15:24 <saati>	it, but on skylake u64*u64 -> u128 is half as fast as u32*u32->u64, on zen3 they take the same time
Feb 22 12:16:44 <sword_smith>	Criterion has its own `black_box` thing that I think I can use. Not too well documented though.
Feb 22 12:27:58 <sword_smith>	saati: Managed to get a benchmark that I *think* does want I want it to. On my Intel Core i9-11950H multiplying two u64s takes the same time as multiplying two u32s.
Feb 22 12:29:12 <sword_smith>	Here's my benchmark: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=51d1ec615fb88dfeca508d58213efcbf
Feb 22 12:30:37 <Widdershins>	saati: black box is on stable, it's just not *const*
Feb 22 12:30:41 <Widdershins>	unless you're on unstable
Feb 22 12:30:48 <Widdershins>	sorry, sword_smith
Feb 22 12:31:02 <Widdershins>	using criterion's black box is also good
Feb 22 12:32:10 <Widdershins>	but std::hint::black_box has been stable since 1.66
Feb 22 12:36:31 <sword_smith>	Widdershins: I see. My IDE wanted to import `std::intrinsics::black_box` instead for some reason. And that thing gave me the `unstable` error.
Feb 22 12:36:55 <Widdershins>	the hint one just calls that, but yeah. which ide
Feb 22 12:37:36 <sword_smith>	VS Code. With `rust-analyzer`.
Feb 22 12:45:43 *	ChanServ gives channel operator status to Widdershins
Feb 22 12:49:02 *	Widdershins removes channel operator status from Widdershins
**** ENDING LOGGING AT Thu Feb 22 13:52:24 2024

**** BEGIN LOGGING AT Thu Feb 22 13:55:48 2024

Feb 22 13:55:47 *	Now talking on ##rust
Feb 22 13:55:47 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 22 13:55:47 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** BEGIN LOGGING AT Thu Feb 22 13:57:12 2024

Feb 22 13:57:11 *	Now talking on ##rust
Feb 22 13:57:11 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 22 13:57:11 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Feb 22 15:10:59 <sword_smith>	How can all these benchmarks take the same about of time? They really shouldn't, I think: https://github.com/Neptune-Crypto/twenty-first/blob/9f86d4a1341ef72bd2e6ae87e9fe0e4fb75ac170/twenty-first/benches/various_muls.rs
Feb 22 15:11:19 <sword_smith>	I'm I making an error in the benchmarking code?
Feb 22 15:13:20 <bertptrs>	what do you mean same amount of time?
Feb 22 15:13:47 <bertptrs>	criterion by default takes 100 samples over the course of 5 seconds, or longer if it's impossible to do within 5 seconds
Feb 22 15:15:47 <bertptrs>	oh the unsigned_mul test looks weird, that's ont how that works
Feb 22 15:16:11 <sword_smith>	bertptrs: Certain times are reported when a benchmark is run. That's the time I'm referring to.
Feb 22 15:16:33 <sword_smith>	`unsigned_mul/(u32,u32)->u64/1000000 time:   [306.18 Âµs 306.86 Âµs 307.70 Âµs]` etc.
Feb 22 15:22:34 <sword_smith>	bertptrs: If you think you can fix my tests, I would love to get your input :)
Feb 22 15:22:40 <sword_smith>	s/tests/benchmarks/
Feb 22 15:25:46 <bertptrs>	It goes against my religion to spell it out, but I do something fairly similar here: https://github.com/bertptrs/tracing-mutex/blob/master/benches/mutex.rs
Feb 22 15:26:45 <bertptrs>	but crucially you are misusing black_box
Feb 22 15:26:52 <bertptrs>	you don't pass it a closure, you pass it an expression
Feb 22 15:27:21 <bertptrs>	So I'm guessing all you're measuring is how quickly you can loop (size - 1) times
Feb 22 15:31:19 <bertptrs>	also for good measure, I recommend you use the same random data for all tests (to avoid random skew in how CPUs special-case certain multiplications) and use the windows() function instead of xs[i] xs[i + 1]
Feb 22 15:34:39 <sword_smith>	bertptrs: Now I'm getting some more sensible results.
Feb 22 15:47:32 <cehteh>	for some benchmarks i lock them on a specific core and set that core to a fixed frequency like 80% of its max. that makes the benchmarks slower but more reliable because overboost and thermal throttling wont happen
Feb 22 15:49:17 <sword_smith>	Pushed a commit. Now the results are sensible: https://github.com/Neptune-Crypto/twenty-first/blob/57699bb41100f60f7be11816587706acff49453f/twenty-first/benches/various_muls.rs
Feb 22 15:49:51 <cehteh>	on modern CPU's not all cores are equal, and i dont mean the efficiency/performance core thing, even having heterogenous cores some may run cooler and reach higher frequencies than their buddies on the same silicon
Feb 22 15:49:51 <phy1729>	iirc the rust project uses callgrind to record the number of instructions (in addition to other things)
Feb 22 15:50:41 <cehteh>	yes using callgrind helps too, but its more atifical since it emulates a cpu/caches its not the real numbers you get
Feb 22 15:51:09 <dminuoso>	I have dovecot and want it to talk to a server-local HTTP server. What kind of simple but performant server library choices might I have? Security concerns are practically non-existent since the service is not exposed outside the server.
Feb 22 15:52:11 <dminuoso>	(Ultimately I just want something small with a small dependency closure)
Feb 22 16:03:03 <alip>	is there a way to split the parent and file name of a Path in one go rather than calling parent() and file_name() in sequence?
Feb 22 16:05:05 <danieldg>	alip: no, not unless you want to look at components instead of the parent
Feb 22 16:05:48 <alip>	thx
Feb 22 16:07:19 <pflanze>	Are there any philosophies around using borrowing rules for I/O? Like, File implements Read and gets operations that all take &mut self, of course that's needed as some implementations need to maintain state; but maybe it would be there anyway to make sure a file handle is only used from one place to avoid the possibility for interference statically? Or is that outside of Rust's concerns?
Feb 22 16:08:09 <danieldg>	pflanze: if you want to do that, you should wrap the File in something that only allows read/etc on a &mut
Feb 22 16:08:25 <danieldg>	pflanze: &File implements Read explicitly so this isn't needed
Feb 22 16:09:21 <pflanze>	So I get that the answer is that Rust does *not* use borrow checking rules for I/O.
Feb 22 16:09:26 <danieldg>	correct
Feb 22 16:09:31 <pflanze>	OK, thanks!
Feb 22 16:09:46 <danieldg>	look at read_at/write_at if you want to avoid interference
Feb 22 16:11:19 <nullie>	read and gets modify state on any file implementation
Feb 22 16:12:16 <danieldg>	that depends on what you count as state
Feb 22 16:13:08 <danieldg>	the file's cursor will get modified, but that is actually a kernel state thing that rust doesn't control
Feb 22 16:16:01 <pflanze>	Yep, IIRC on POSIX the cursor is even shared across processes.
Feb 22 16:16:28 <danieldg>	yes, it is
Feb 22 16:17:42 <nullie>	let's implement IO monad
Feb 22 16:18:05 <danieldg>	you can do that if you like
Feb 22 16:19:31 <pflanze>	(Last I know HKT are not ready hence no generic monad infrastructure.)
Feb 22 16:19:59 <pflanze>	(Not that I necessarily wanted to see monads, anyway.)
**** ENDING LOGGING AT Thu Feb 22 17:51:49 2024

**** BEGIN LOGGING AT Thu Feb 22 18:35:18 2024

Feb 22 18:35:17 *	Now talking on ##rust
Feb 22 18:35:17 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 22 18:35:17 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Feb 22 20:09:02 <monr0e>	Moved from Windows to Linux, and am rebuilding a .net web application in Rust with Rocket. Tryign otu CLion, should I look elsewhere for an IDE? Been kinda spoiled by visual studio
Feb 22 20:12:42 <cappy>	monr0e: I'm looking for an IDE for Rust as well. Just went to https://www.jetbrains.com/clion/ and there is no mention of Rust; only C/C++. Is there a Rust plug-in?
Feb 22 20:13:47 <monr0e>	Yes, but I don't know how extensive it is. I ran into some sort of issue settin gup a new project too
Feb 22 20:14:32 <monr0e>	but that may also be because I have no idea how to use rust yet. In fact, I know next to nothing abotu it
Feb 22 20:15:56 <monr0e-pooping>	Oh I should change this nick
Feb 22 20:16:29 <cappy>	monr0e: I just started with Rust a day or two ago. But I found an alternate: VSCodium or Visual Studio Code can be set up for Rust:
Feb 22 20:16:50 <cappy>	monr0e: https://github.com/larina3315/personal-stuff/blob/main/coding/vsc-flatpak-rust.md
Feb 22 20:17:11 <monr0e-phone>	I really want to avoid a vscode solution tbh
Feb 22 20:18:55 <monr0e-phone>	I'm looking for something as close to equivalency as possible to visual studio
Feb 22 20:18:55 <cappy>	Believe that's why the open source VSCodium exists, apart from Microsoft's telemetry et al. Just mentioning it.
Feb 22 20:19:54 <monr0e-phone>	Honestly the telemetry is easy to fix, but I really have been spoiled by visual studio. That sort of featureset is second nature to me now
Feb 22 20:20:26 <monr0e-phone>	VSCode is something I use more for super basic website building
Feb 22 20:20:46 <cappy>	Understand your point. IDK of anything else. Perhaps someone else here can add?
Feb 22 20:20:50 <LawnGnome>	JetBrains has RustRover as their (fairly new) Rust specific product.
Feb 22 20:21:04 <LawnGnome>	I haven't used it, but if you're used to the JetBrains way of doing things, I assume it would work for you.
Feb 22 20:21:42 <monr0e-phone>	I have zero experience with jetbrains either tbh. I'm willing to try anything that has a decent enough featureset
Feb 22 20:22:20 <monr0e-phone>	RustRover is a plugin? Or an entire IDE in its own right?
Feb 22 20:22:38 <Alexendoo>	somewhere inbetween
Feb 22 20:22:55 <monr0e-phone>	Oh interesting
Feb 22 20:23:00 <cappy>	Is there pricing on RustRover? I'm at the site; don't see it.
Feb 22 20:24:20 <bertptrs>	I've previously used either CLion or IntelliJ Ultimate with the official rust plugin, but then I stopped having a rust job and moved to vscode + rust-analyzer
Feb 22 20:24:22 <cappy>	Or is it considered part of their "Products Pack"?
Feb 22 20:24:29 <Diablo-D3>	I dont think they sell rustrover yet
Feb 22 20:25:08 <cappy>	So is their d/l a trial? (for now)
Feb 22 20:25:15 <monr0e-phone>	From what I can see RustRover is in beta
Feb 22 20:25:29 <Diablo-D3>	cappy: "trial"
Feb 22 20:26:01 <Diablo-D3>	its the same as intellij community edition, but with the rust plugin set instead of the java one
Feb 22 20:26:16 <cappy>	Diablo-D3: meaning, use it for a time until it's out of beta and then pay.
Feb 22 20:26:21 <monr0e-phone>	There's an entirely separate, though deprecated, plugin for intellij cappy
Feb 22 20:26:39 <Diablo-D3>	cappy: basically.
Feb 22 20:26:56 <Diablo-D3>	I'd probably take IDEA more seriously if they'd quit trying to split it up per language
Feb 22 20:27:06 <monr0e-phone>	I might try this preview. Looks interesting
Feb 22 20:27:08 <Diablo-D3>	if I buy intellij ultimate, all of them are in the same IDE
Feb 22 20:27:47 <Diablo-D3>	they jumped the shark, though
Feb 22 20:27:58 <Diablo-D3>	they're all in on AI, which means they're basically dead.
Feb 22 20:28:22 <nCrazed>	last I tried RustRover on my current $job project, it choked on what I am guessing was the workspace set up that I had for that project
Feb 22 20:28:29 <monr0e-phone>	Ugh I noticed the ai thing
Feb 22 20:28:30 <nCrazed>	so still CLion + the plugin for me
Feb 22 20:29:03 <bertptrs>	Diablo-D3: if anyone who went all in on AI was dead, I'd be much happier about the future of the tech industry
Feb 22 20:29:46 <Alexendoo>	monr0e-phone: well you wanted it to be like VS :P
Feb 22 20:30:13 <monr0e-phone>	Alexendoo: No ai in VS 2017!
Feb 22 20:30:31 <monr0e-phone>	Lol "ai"
Feb 22 20:32:03 <nCrazed>	there's no AI in Intellij's 2017 offerings either :|
**** BEGIN LOGGING AT Thu Feb 22 20:35:46 2024

Feb 22 20:35:46 *	Now talking on ##rust
Feb 22 20:35:46 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 22 20:35:46 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** BEGIN LOGGING AT Thu Feb 22 20:47:45 2024

Feb 22 20:47:43 *	Now talking on ##rust
Feb 22 20:47:43 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 22 20:47:43 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Feb 22 20:53:57 <bwidawsk>	istr there was work to allow `..Default::default()` for a struct that doesn't impl Default, but where the remaining members do. Did I make that up? If not, could someone please help me find it?
Feb 22 20:54:35 <bertptrs>	you might've, because that fundamentally cannot work
Feb 22 20:55:02 <bertptrs>	..Default::default() is less magic than you think; it's the struct update syntax
Feb 22 20:55:20 <bertptrs>	What it does, is "these are new fields, then take whatever else from this other struct"
Feb 22 20:55:38 <bertptrs>	Where all Default::default() does is call the default function and take the default values from there
**** BEGIN LOGGING AT Thu Feb 22 20:58:52 2024

Feb 22 20:58:50 *	Now talking on ##rust
Feb 22 20:58:50 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 22 20:58:50 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Feb 22 20:58:56 <bwidawsk>	but looks like it's not longer alive
**** BEGIN LOGGING AT Thu Feb 22 21:13:03 2024

Feb 22 21:13:03 *	Now talking on ##rust
Feb 22 21:13:03 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 22 21:13:03 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** BEGIN LOGGING AT Thu Feb 22 21:16:07 2024

Feb 22 21:16:06 *	Now talking on ##rust
Feb 22 21:16:06 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 22 21:16:06 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Feb 22 21:35:00 <maxsimo>	list
Feb 22 21:56:07 <swansone>	Hey, I'm writting a unit test for a function that returns a Result. Is there a convenient shorthant to assert that it returns Ok, or prints Err if not?
Feb 22 21:57:06 <bertptrs>	just unwrap it?
Feb 22 21:57:31 <swansone>	Oh, that might work
Feb 22 21:58:16 <bertptrs>	Has the benefit of automatically failing the test too
Feb 22 22:00:44 <swansone>	Do I need to change the type signature of the test to do that?
Feb 22 22:01:00 <swansone>	Trying this gives me "^ cannot use the `?` operator in a function that returns `()`"
Feb 22 22:05:23 <swansone>	Trying to update the test function signature to return a result gives me an error that I need to implement the `Termination` trait
Feb 22 22:10:59 <swansone>	I think this is probably the best I can do then: `assert!(config.is_ok(), "{:?}", config)`
Feb 22 22:18:38 <Alexendoo>	swansone: unwrap as in .unwrap()
Feb 23 00:29:17 <Widdershins>	sigh, nightly clippy recently started complaining about redundant prelude imports. even when they are for no_std
Feb 23 00:34:14 <Widdershins>	nightly-2024-02-16 is fine, 2024-02-19 isn't
Feb 23 00:39:12 <Widdershins>	happened between the -18 and -19 toolchains
Feb 23 01:04:56 <Widdershins>	really struggling making a minimal reproducer for this!
Feb 23 01:05:10 <Widdershins>	i don't know why it dislikes my crate specifically
Feb 23 02:09:39 <Widdershins>	ok i figured it out bug submitted ðŸ˜Œ
Feb 23 03:38:29 <Widdershins>	ok i sent the bug to the wrong place and failed to find the real issue, but i got an interesting idea from the real one
Feb 23 04:21:46 <Widdershins>	Is there a way to make cargo compile with the no_std prelude, even in std?
Feb 23 04:23:11 <Mutabah>	Why not just have `#![no_std]`
Feb 23 04:23:22 <Mutabah>	(and import std manually)
Feb 23 04:23:31 <Widdershins>	does that have other effects when the library is included in the whole program?
Feb 23 04:23:42 <Widdershins>	if the rest of the program is normal std?
Feb 23 04:23:50 <danieldg>	no
Feb 23 04:23:53 <Widdershins>	i am looking at https://github.com/rust-lang/rust/issues/121362#issuecomment-1955202508 here
Feb 23 04:24:13 <Widdershins>	though, as i'm currently looking to find out, that may only affect the *whole binary* when it applies to the program, not to each library individually
Feb 23 04:24:17 <danieldg>	you can use no-std crates normally from std ones
Feb 23 04:24:18 <Mutabah>	`no_std` libraries can be included in std-including binaries
Feb 23 04:24:44 <Widdershins>	do they produce the same code as if they were not no_std, as long as they use the same types etc.?
Feb 23 04:24:49 <Mutabah>	In fact it's very common for `no_std` libraries to have feature flags to turn on use of std/alloc
Feb 23 04:24:55 <Mutabah>	yes.
Feb 23 04:25:11 <Mutabah>	The stuff you use in `no_std` is the same in std (just re-exports)
Feb 23 04:25:33 <Widdershins>	yes, that's what i have. i have a library that has a std feature flag. currently this feature disables the no_std config, rather than causing std to be imported
Feb 23 04:26:41 <Widdershins>	as long as no_std code benefits from "stack overflow protection" and "runs init code before main" when included in a std program then that answers my question
Feb 23 04:26:59 <Widdershins>	seems likely that that would be the case
Feb 23 04:27:17 <danieldg>	if main is std, then it would
Feb 23 04:27:29 <danieldg>	stack overflow is also set up prior to main
Feb 23 04:28:03 <Widdershins>	context for the problem is also in that issue; rust nightly started throwing lint complaints for redundant imports when a maybe-no_std crate imports items that are also in the std prelude when it's std
Feb 23 04:28:29 <Mutabah>	The solution is to always be `no_std` but manually import std if needed
Feb 23 04:28:34 <Mutabah>	example: https://github.com/thepowersgang/stack_dst-rs/blob/master/src/lib.rs
Feb 23 04:28:38 <Widdershins>	not clear if they'll roll it back but if it's unambiguously a good idea to extern std instead of disable no_std i'll just do that, it does sound better
Feb 23 04:28:44 <Widdershins>	yea
Feb 23 04:28:46 <Mutabah>	It conditionally imports alloc (and std - for miri tricks)
Feb 23 04:28:55 <Widdershins>	mhm
Feb 23 04:44:54 <Widdershins>	alright sweet
Feb 23 04:45:01 <Widdershins>	thanks danieldg Mutabah
Feb 23 08:48:09 <enoq>	is there something that allows you to serialize JSON in a streaming fashion? like serializer.startArray(); serializer.writeStruct(struct); serializer.stopArray()
Feb 23 09:43:47 <enoq>	can anyone explain this? https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=52322953af6b6452bdc73953cbcd6845
Feb 23 09:43:54 <enoq>	error[E0369]: cannot add `&{integer}` to `&mut {integer}`
Feb 23 09:44:38 <enoq>	these don't look like really distinct types to me
Feb 23 09:51:00 <dminuoso>	Hi, is there a way to get a delimited use of ? when ultimately I dont return a io::Result<T> at the end, but I do make a bunch of successive calls to functions that do in the beginning?
Feb 23 09:51:10 <dminuoso>	Or is the idiomatic approach to just split this into two functions?
Feb 23 09:51:34 <j`ey>	try blocks, but not stable afaik
Feb 23 09:52:42 <j`ey>	enoq: I think you want reduce, not scan?
Feb 23 09:53:08 <enoq>	I want to turn [1, 2, 3] into [0, 1, 3, 6]
Feb 23 09:53:26 <dav1d>	enoq, they are distinct types, compiler tells you how you can fix it
Feb 23 09:53:33 <enoq>	dav1d, right, but why
Feb 23 09:53:33 <j`ey>	oh
Feb 23 09:53:57 <dav1d>	enoq, one is mutable the other isn't. You can impl traits for &Foo and &mut Foo separately
Feb 23 09:54:17 <dav1d>	enoq, &Foo and Foo are also not the same type
Feb 23 09:54:33 <enoq>	is there no trait impl for left hand &mut and right hand &
Feb 23 09:55:15 <dav1d>	enoq, yeah that's what is missing
Feb 23 09:55:44 <dav1d>	enoq, but it's the same for `&u32 + u32`
Feb 23 09:56:06 <enoq>	you mean you also can't add those?
Feb 23 09:56:54 <enoq>	the scan type signature is also kinda complicated btw
Feb 23 09:57:35 <dminuoso>	j`ey: Alright thanks.
Feb 23 10:01:59 <enoq>	looks like this is sort of what I want
Feb 23 10:02:00 <enoq>	https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=1e1dc6b62e21fb45d5a9a216e3844952
Feb 23 10:02:07 <enoq>	I've never used * before in rust
Feb 23 10:29:17 <mkoncek>	does rustc / cargo offer more granular optimize / debug flags? like -O<N> in gcc
Feb 23 10:29:46 <j`ey>	opt-level
Feb 23 10:34:24 <mkoncek>	also, i have two processes, one is sending UDP to a local address in a while loop and the other one is receiving them, after roughly 300 datagrams some of them get lost, is it possible i overflowed the kernel buffers?
Feb 23 10:39:38 <dav1d>	enoq, https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=e7ca6a2c5abc4babd48ce6ce27918140
Feb 23 10:39:59 <dav1d>	oh nvm I think I broke it
Feb 23 10:40:20 <enoq>	you forgot to sum it up
Feb 23 10:40:34 <enoq>	I know, the API does not work like in other languages
Feb 23 10:40:40 <dav1d>	yeah, I think yours is as good as it gets
Feb 23 10:40:54 <enoq>	thanks, was worried about the type soup
Feb 23 10:41:05 <dav1d>	enoq, eh `*state = *state + curr;`
Feb 23 10:41:30 <dav1d>	that should work, but it's just a minor thing which clippy probably also notices
Feb 23 10:41:50 <enoq>	what's the solution?
Feb 23 10:42:19 <dav1d>	oh clippy wants ` *state += curr;`
Feb 23 10:42:22 <dav1d>	that's nice
Feb 23 10:42:35 <enoq>	ah, yeah, less characters for the same thing then :)
Feb 23 10:42:51 <dav1d>	enoq, https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=ae625557c0702aa6b79b5a5b3c6c8797
Feb 23 10:42:53 <dav1d>	full thing
Feb 23 10:43:04 <enoq>	thanks
Feb 23 10:43:13 <enoq>	so let's say I want to execute this function at compile time
Feb 23 10:43:24 <enoq>	I think there's some form of constexpr
Feb 23 10:44:16 <dav1d>	enoq, you can't create a vector with items at compiletime, if you have an array you'd need to manually do it with a while loop I believe (not sure if for works alread)
Feb 23 10:44:36 <enoq>	because vec is heap allocated?
Feb 23 10:45:49 <bertptrs>	yea
Feb 23 10:46:07 <bertptrs>	also many of the functions you are using cannot be used in a const context yet
Feb 23 10:56:30 <enoq>	I suppose simple ::new methods are fine to make const?
Feb 23 10:56:40 <enoq>	when you just want to fill in default values for a struct
Feb 23 10:59:24 <j`ey>	yep
Feb 23 11:00:45 <enoq>	thanks
Feb 23 11:01:26 <enoq>	I don't really fully understand the limitation of no vectors inside const fns; it should be possible to just allocate that vector at compile time, right?
Feb 23 11:02:28 <enoq>	or does Rust have more guarantees  in that regard?
Feb 23 11:03:40 <enoq>	like: will not check how big the actual thing is after running it during compile but instead needs to know all sizes statically in advance?
Feb 23 11:09:12 <enoq>	oh :( https://github.com/rust-lang/rfcs/pull/2237
Feb 23 11:14:42 <synapse>	enoq, they're heap allocated
Feb 23 11:15:33 <synapse>	enoq, if you made a StaticVec<T> you could statically allocate it. some people call that an array. :-D
Feb 23 11:16:12 <synapse>	enoq, .push() and such don't make much sense if the allocation is fixed.
Feb 23 11:16:57 <enoq>	right, you should be able to iter over arrays though, right?
Feb 23 11:17:05 <synapse>	yes
Feb 23 11:17:06 <dav1d>	need someone to just reply with yes as a sanity check, if I destructure a struct its Drop impl wont run?
Feb 23 11:17:42 <enoq>	doesn't drop always run at the end of the lifetime?
Feb 23 11:18:02 <bertptrs>	You cannot destructure things that have Drop
Feb 23 11:20:25 <bertptrs>	Oh it seems you can, provided the things you destructure are Copy
Feb 23 11:20:28 <dav1d>	bertptrs, https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=ac877edafd206dbdb899fcd3be13ddbf ?
Feb 23 11:20:53 <dav1d>	okay seems like I need to properly figure out semantics
Feb 23 11:20:55 <dav1d>	thanks
Feb 23 11:21:45 <bertptrs>	dav1d: it's just moving out of the thing, not actually destroying it
Feb 23 11:23:28 <dav1d>	bertptrs, yeah I see, it only allows you to get a ref when destructuring. I have a Token which logs something on drop and I want to be able to transform that token to another token which logs more information, that transformation shouldn't trigger the initial drop though :(
Feb 23 11:23:39 <dav1d>	Guess I'll have to wrap everything in an option
Feb 23 11:23:55 <bertptrs>	ManuallyDrop might help?
Feb 23 11:25:34 <davros1>	Haven't been following the rust world so much lately (AI hype got me) .. is there movement in the realm of this existing problem:
Feb 23 11:26:02 <davros1>	Can't impl From for collections when the inner type has a From
Feb 23 11:26:07 <dav1d>	bertptrs, thanks, I though that wouldnt work but it looks like it should!
Feb 23 11:26:25 <davros1>	I think it needed negative bounds or something (there might have been some other proposals)
Feb 23 11:27:58 <dav1d>	Actually I can just std::mem::forget
Feb 23 11:28:16 <davros1>	In my own vecmath libs I ran into this .. 'struct Vec3<T>{x:T, y:T, z:T} .. can't impl From<[B;3]> for Vec3<A> where A:From<B> {} because it'll freak out at the possibility of infinite nesting or something
Feb 23 11:33:52 <bertptrs>	negative bounds aren't anywhere coming as far as I know, the new trait solver has been in limbo for a bit
Feb 23 11:42:00 <enoq>	is there no built in way to handle dates & ISO8601 formatting?
Feb 23 11:50:39 <bertptrs>	no, the standard library is intentionally somewhat limited since it's intended to be stable forever
Feb 23 11:50:46 <bertptrs>	you can look at either the chrono or time crates
Feb 23 11:56:23 <dav1d>	I thought Rust would catch this out of bounds on static arrays :( https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=f9bdc0f3c23bfde2073c9d7676c39c4b
Feb 23 11:56:36 <dav1d>	Is there a way to have the array access validated on compiletime?
Feb 23 12:09:05 <turlando>	dav1d: ironically the release llvm ir code is just a call to core::panicking::panic_bounds_check when i try to run weight
Feb 23 12:09:31 <turlando>	So it's actually doing some kind of const propagation
Feb 23 12:47:28 <dav1d>	turlando, nice! optimized panics
**** BEGIN LOGGING AT Fri Feb 23 14:47:00 2024

Feb 23 14:47:00 *	Now talking on ##rust
Feb 23 14:47:00 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 23 14:47:00 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Feb 23 14:47:16 <enoq>	I'm using the File buf reader lines() method I think
Feb 23 14:47:49 <enoq>	yep, that one handles \r\n
**** BEGIN LOGGING AT Fri Feb 23 14:52:02 2024

Feb 23 14:52:01 *	Now talking on ##rust
Feb 23 14:52:01 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 23 14:52:01 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Feb 23 14:52:44 <cehteh>	you can use that when you use std String -- but creating a string from untrusted io is fallible, by panic or you handling the Result
Feb 23 14:54:07 <cehteh>	and read_lines etc have no safeguard against malicious files that use extremely long lines. often thats ok, but sometimes thats a big problem
Feb 23 14:54:56 <enoq>	that's a problem in other languages as well
Feb 23 14:54:59 <cehteh>	and its all-or-nothing in case of invalid utf8
Feb 23 14:55:04 <cehteh>	yeah sure
Feb 23 14:55:21 <cehteh>	just telling you to consider it, if it doesnt matter ignore it
Feb 23 14:55:32 <enoq>	yeah, thank you for the tp
Feb 23 14:55:34 <enoq>	tip*
Feb 23 14:56:10 <enoq>	usually you've got an enforced size limit for uploaded files
Feb 23 14:56:11 <cehteh>	esp invalid utf8 isnt really unexpected
Feb 23 14:56:33 <cehteh>	you may at least handle that instead panicking
Feb 23 14:56:39 <enoq>	right
Feb 23 14:59:15 <cehteh>	gtg
Feb 23 15:12:49 <sword_smith>	I've seen the recommendation that a `Debug` implementation should be added as a rule of thumb.
Feb 23 15:13:00 <sword_smith>	Why?
Feb 23 15:14:34 <bertptrs>	https://rust-lang.github.io/api-guidelines/interoperability.html
Feb 23 15:15:06 <bertptrs>	private types not necessarily, but for public types it's very helpful for API consumers to debug their own codew
Feb 23 15:16:47 <tstonge>	it's nice to be able to format!("{:?}", my_obj), and all it takes is `Debug`
Feb 23 15:21:36 <bertptrs>	or if you're hip, to use the dbg! macro
Feb 23 15:42:58 <enoq>	how can you hold onto a value outside of a loop, that goes out of scope in a loop
Feb 23 15:43:30 <nullie>	enoq: set_fact?
Feb 23 15:43:39 <enoq>	what do you mean?
Feb 23 15:43:49 <nullie>	I don't quite understand what do you want to do
Feb 23 15:43:53 <enoq>	I need to keep track of a previous value
Feb 23 15:44:07 <enoq>	compare the current value to the previous value
Feb 23 15:44:21 <nullie>	well you could use set_fact to store it
Feb 23 15:44:59 <enoq>	I can only find Ansible stuff when I google that
Feb 23 15:45:18 <nullie>	oh, shit, sorry, I though it was #ansible :D
Feb 23 15:45:39 <nullie>	you can declare a variable outside of a loop
Feb 23 15:46:30 <enoq>	right, I can, but if I assign to it, I either need to move? it since the value goes out of scope
Feb 23 15:46:35 <enoq>	or copy it somehow
Feb 23 15:47:09 <nullie>	it will be moved by default
Feb 23 15:47:23 <nullie>	can you show the code for your current attempt?
Feb 23 15:48:10 <enoq>	nullie, https://dpaste.com/6WP8SDQYQ#line-150
Feb 23 15:48:29 <enoq>	error is ^^^^^^^^ borrowed value does not live long enough
Feb 23 15:48:38 <enoq>	line 172
Feb 23 15:49:08 <nullie>	remove the reference
Feb 23 15:49:20 <enoq>	you mean move it?
Feb 23 15:49:37 <nullie>	Option<ArticleLine> instead of Option<&ArticleLine>
Feb 23 15:50:30 <nullie>	and then Some(article_line) instead of Some(&article_line)
Feb 23 15:50:49 <nullie>	s/article_line/article/g
Feb 23 15:51:43 <enoq>	use of moved value now
Feb 23 15:51:54 <enoq>	https://dpaste.com/F2XWBCSTG
Feb 23 15:52:06 <enoq>	157 |             Some(cheapest) => {
Feb 23 15:52:09 <enoq>	value moved here
Feb 23 15:52:29 <nullie>	match lowest_price.as_ref()
Feb 23 15:53:41 <enoq>	https://dpaste.com/H2WCW7KRT
Feb 23 15:53:50 <enoq>	    |                     ^^^^^^^^^^^^ `lowest_price` is assigned to here but it was already borrowed
Feb 23 15:53:55 <enoq>	line 160
Feb 23 15:54:24 <enoq>	(my gutt feeling is that I need a copy)
Feb 23 15:54:42 <nullie>	lowest_price = match { }, and then at finish each branch with Some()
Feb 23 15:55:32 <nullie>	well, maybe it's not the right way
Feb 23 15:57:14 <danieldg>	you might be able to avoid a copy, but it depends on what exactly you are iterating and storing
Feb 23 15:57:57 <phy1729>	It feels .fold(ish maybe with group_by
Feb 23 15:58:35 <enoq>	yes, it feels like group_by, but doesn't group by evaluated everything?
Feb 23 15:59:13 <enoq>	if I evaluate it, I'm loading 120 gigs of strings into memory
Feb 23 15:59:59 <nullie>	group_by should evaluate lazily
Feb 23 16:01:40 <enoq>	so it accumulates values until the grouping criterium does not match anymore?
Feb 23 16:01:45 <enoq>	then starts a new group?
Feb 23 16:02:20 <nullie>	it doesn't even accumulate group values
Feb 23 16:02:29 <nullie>	I think
Feb 23 16:02:41 <nullie>	"If the groups are consumed in order, or if each groupâ€™s iterator is dropped without keeping it around, then GroupBy uses no allocations. It needs allocations only if several group iterators are alive at the same time."
Feb 23 16:02:51 <enoq>	sounds like magic, will take a look thank you!
Feb 23 18:05:14 <Vorpal>	Does anyone know any tool to generate an install script similar to the one you curl for rustup. Lots of pieces of software have these, but most seem to be hand written for each project. Or depend on Go. Looking for something with multi-architecture support for my own usage. I'm absolutely proficient enough in shell script that I could hack something together. But then there is MacOS/Windows support (which I have no clue about). So I was hoping for some ready
Feb 23 18:05:16 <Vorpal>	made tool.
Feb 23 18:05:39 <Vorpal>	Preferably something that integrates easily with a rust build system too
Feb 23 18:05:53 <bertptrs>	as far as I know these tend to be hand-written
Feb 23 18:06:38 <bertptrs>	which is not great, people make the same mistakes over and over
Feb 23 18:06:52 <Vorpal>	That would be a good project then, for someone who has time for that (which I don't). So I too will hand-write one for my project, that will be Linux only.
Feb 23 18:06:53 <bertptrs>	but I don't think anyone's set up a standardized method yet
Feb 23 18:07:34 <bertptrs>	composer for example is a PHP tool so they decided to write it in PHP rather than bash. Makes sense but doesn't help standardization
Feb 23 18:07:35 <Vorpal>	really for my purpose it is a single binary, so all I need is to figure out which is the latest github release, and what architecture I'm running on. Then download and unpack the relevant binary into the current directory
Feb 23 18:08:10 <Vorpal>	heh, never heard of composer. I thought PHP was dead these days except for existing software (mediawiki, wordpress, probably a few more)
Feb 23 18:09:08 <bertptrs>	PHP is very much alive, and composer was its revival. it made libraries a lot more accessible and from that the ecosystem got a big boost
Feb 23 18:09:13 <enoq>	struggling with lifetimes here https://dpaste.com/GJASURSDQ error https://dpaste.com/65WKULUVC
Feb 23 18:09:17 <phy1729>	it doesn't help that POSIX sh is a maze of twisty edge cases all of them sharp
Feb 23 18:09:26 <enoq>	I don't understand why I'm getting 2 different lifetimes here
Feb 23 18:09:46 <Vorpal>	phy1729: true. You can't assume bash. Mac OS uses zsh (which I happen to know since I use it myself). Then there is also dash.
Feb 23 18:10:04 <LawnGnome>	And, in fairness to Composer, anyone who wants to use it already has PHP installed, so making the installer a PHP script makes total sense from that perspective. Plus, yeah, cross platform shell scripting no es bueno.
Feb 23 18:10:09 <phy1729>	and ksh on the BSDs, so you can only really assume POSIX sh
Feb 23 18:10:43 <bertptrs>	LawnGnome: I'm not dissing composer's choice, it makes perfect sense and lets them avoid POSIX shell
Feb 23 18:10:49 <LawnGnome>	I had to help maintain a cross platform (maximally, Linux, FreeBSD, macOS, Solaris) "install from tarball" type shell script for several years. I do not recommend the experience.
Feb 23 18:10:50 <Vorpal>	phy1729: oh right, well I don't build for BSDs (since cross-rs can't cross-test for them). So that I don't won't have to worry about
Feb 23 18:10:55 <LawnGnome>	bertptrs: I didn't think you were. :)
Feb 23 18:11:13 <phy1729>	Vorpal: I'm on one, so I tend to care about them
Feb 23 18:11:51 <Vorpal>	phy1729: I wouldn't mind supporting them with pre-built binaries. But I refuse to support anything I can't actually run integration tests on in CI. That way lies madness.
Feb 23 18:12:25 <Vorpal>	I expect my program to work fine there (there is no reason it wouldn't it works on Windows even after all)
Feb 23 18:12:48 <Vorpal>	but BSDs and Mac OS ARM I can't cross test in CI, so they get no support.
Feb 23 18:12:58 <enoq>	is there a way to link the lambda parameter lifetime to the return value?
Feb 23 18:13:01 <Vorpal>	(I only use Linux myself, not even windows)
Feb 23 18:21:47 <enoq>	how does one group by two values
Feb 23 18:34:21 <enoq>	ok https://docs.rs/itertools/latest/src/itertools/groupbylazy.rs.html#299-307
Feb 23 18:34:29 <enoq>	looking at that signature, there are no lifetimes
Feb 23 18:34:37 <enoq>	    F: FnMut(&J::Item) -> K,
Feb 23 18:34:43 <enoq>	so &J and K are not related
Feb 23 18:34:58 <enoq>	I suppose that's why you can't use any K that refers to &J
Feb 23 18:35:04 <enoq>	so you have to copy?
Feb 23 18:36:41 <enoq>	so .group_by(|article| (article.code.clone(), article.pos))
Feb 23 18:36:49 <enoq>	code is a string, pos a usize
Feb 23 19:04:35 <alip>	using bitflags how do i check any one of a set of flags is set in a bitflags var? do i have a better way than calling contains() for each flag?
Feb 23 19:04:48 <alip>	i tried intersects() but it does not seem to do the right thing
Feb 23 19:10:38 <dav1d>	alip, does that work `FOO & (A |  B | C) > 0`?
Feb 23 19:13:31 <alip>	dav1d: no
Feb 23 19:14:38 <Mikachu>	what is a "bitflags var"
Feb 23 19:15:09 <alip>	a struct defined with bitflags::bitflags!
Feb 23 19:15:18 <alip>	i mean the crate
Feb 23 19:20:33 <spb>	the documentation for intersects seems to match what you described - what's different about it from what you want?
Feb 23 19:23:11 <a51>	I installed erdtree and erdtree says command not found
Feb 23 19:25:41 <alip>	spb: indeed, but it does not do what i want appearently, i use it with nix's type OFlag and e.g. (OFlag.O_RDONLY|OFlag.O_CLOEXEC|O_DIRECTORY).intersects(O_CREAT|O_TMPFILE) returns true for some reason. o.O
Feb 23 19:27:55 <a51>	bat and exa work but not erdtree
Feb 23 19:28:41 <j`ey>	a51: erd
Feb 23 19:31:08 <enoq>	how does one get an owned value out of a vec
Feb 23 19:31:17 <j`ey>	remove()
Feb 23 19:31:26 <spb>	depends what you want to happen to the thing in the vec
Feb 23 19:31:35 <dav1d>	enoq, remove, std::mem::take/replace
Feb 23 19:31:44 <enoq>	I want to move it into something else
Feb 23 19:31:48 <dav1d>	remove is quite expensive
Feb 23 19:32:08 <enoq>	the vec is only used to calculate something temporarlily
Feb 23 19:32:13 <spb>	and do you want to remove it from the vec, or leave something else in its place?
Feb 23 19:32:26 <dav1d>	enoq, if you want to get rid of the entire vector, into_iter()
Feb 23 19:32:41 <enoq>	I need to know the size of the vec as well
Feb 23 19:33:04 <enoq>	basically the length and the struct with the lowest value
Feb 23 19:33:35 <enoq>	basically this https://dpaste.com/866BQBL59
Feb 23 19:34:02 <enoq>	so I guess remove it is?
Feb 23 19:35:17 <phy1729>	You're throwing away the Vec once you have the min?
Feb 23 19:35:22 <enoq>	yees
Feb 23 19:35:26 <spb>	so you're extracting the first item and then throwing away the vec
Feb 23 19:35:37 <enoq>	first item + vec length, then throwing it away
Feb 23 19:36:23 <phy1729>	.into_iter().reduce and skip the sorting step
Feb 23 19:36:43 <spb>	and calculate the length before you do it
Feb 23 19:36:47 <phy1729>	er Iterator has a .min
Feb 23 19:37:13 <spb>	using min means you don't have to actually sort the list which will be considerably faster
Feb 23 20:03:00 <enoq>	what does this mean: error[E0515]: cannot return value referencing temporary value https://dpaste.com/C7YCXKBJV
Feb 23 20:03:17 <enoq>	https://dpaste.com/2ZP7SP48S
Feb 23 20:03:39 <enoq>	I don't really understand what creates the temporary value
Feb 23 20:05:13 <Vorpal>	enoq: using rust playground would help rather than a pastebin so we can see which line and part the error applies to
Feb 23 20:05:22 <enoq>	yes, one sec
Feb 23 20:05:28 <Vorpal>	(see the /topic for a link to the playground)
Feb 23 20:06:08 <enoq>	https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=6ac152cbe4c36b75e0227875da658f17
Feb 23 20:07:24 <Vorpal>	hm, used to seeing type inlay hints from vscode, much harder without that :D. But I would expect you take article by value and return a reference to it in group_by()
Feb 23 20:08:09 <enoq>	at least intellij says &ArticleLine in line 168 but it's pretty buggy as well :/
Feb 23 20:08:12 <Vorpal>	some things that could help are to collect into a Vec and returning that vec.into_iter() since the computation won't depend on something after the function returns the iterator then
Feb 23 20:08:54 <enoq>	Vorpal, it's a 120gb string line iterator
Feb 23 20:09:01 <Vorpal>	but I understand you don't want that, since you try to keep everything as iterators very much so
Feb 23 20:09:04 <enoq>	I doubt I want to collec tthat
Feb 23 20:09:10 <Vorpal>	fair point!
Feb 23 20:09:30 <Vorpal>	what type is pos?
Feb 23 20:09:34 <Vorpal>	article.pos I mean
Feb 23 20:09:37 <enoq>	it's a usize
Feb 23 20:09:49 <Vorpal>	which is Copy. Huh
Feb 23 20:10:38 <Vorpal>	aha! article.code is a &str. You want to_owned() not clone()
Feb 23 20:10:42 <Vorpal>	I think that is it
Feb 23 20:10:56 <Vorpal>	pretty sure you are just cloning the reference into a new reference right now
Feb 23 20:11:13 <enoq>	same error
Feb 23 20:11:34 <enoq>	(article.code.to_owned(), article.pos) right?
Feb 23 20:11:36 <Vorpal>	hm you are right
Feb 23 20:11:42 <Vorpal>	yeah okay I'm confused too
Feb 23 20:11:52 <enoq>	the group_by is from itertools btw
Feb 23 20:12:28 <enoq>	what exactly is the temporary value btw?
Feb 23 20:12:38 <Vorpal>	I'm wondering that too now
Feb 23 20:12:41 <enoq>	is it the iterator? or is it the stuff inside the group_by
Feb 23 20:13:40 <Vorpal>	This type implements IntoIterator (it is not an iterator itself), because the group iterators need to borrow from this value. It should be stored in a local variable or temporary and iterated.
Feb 23 20:13:48 <Vorpal>	ah, that is probably the issue
Feb 23 20:14:07 <Vorpal>	you are borrowing from GroupBy itself
Feb 23 20:15:20 <Vorpal>	I don't have a good answer for how to solve that. I expect if you put it inside the next function it would work, but that is several layers deep in returning files, so that is no good for code organisation.
Feb 23 20:15:45 <Vorpal>	enoq: hopefully that has given you some idea about the cause though, even though I don't have a suggestion for the fix
Feb 23 20:17:47 <enoq>	Vorpal, basically, I can't into_iter() after the group by?
Feb 23 20:18:21 <Vorpal>	well, I haven't looked into the details, but I quoted a line from the documentation of group_by
Feb 23 20:18:53 <Vorpal>	it seems plausible that the moment you need to iterate over it you need to finish doing so in the same scope
Feb 23 20:18:58 <enoq>	right, I didn't understand that one tbh
Feb 23 20:20:11 <Vorpal>	I don't have a suggested fix, perhaps someone else can chime in. You could could try on https://users.rust-lang.org/ maybe?
Feb 23 20:21:29 <enoq>	there's https://stackoverflow.com/questions/47885478/how-to-use-itertools-group-by-iterator-method-without-a-for-loop
Feb 23 20:21:37 <enoq>	the suggestion is to clone everything :/
Feb 23 20:23:19 <Vorpal>	hm... maybe a different design then?
Feb 23 20:25:02 <enoq>	the one I tried before is passing in a lambda that is executed after each iteration, but closures sure are terrible in Rust, couldn't get it to work
Feb 23 20:37:24 <Vorpal>	could you pass in a separate function rather than lambda instead?
Feb 23 20:41:20 <dkg>	So i've got a functioning cdylib built now (i ended up deciding not to do the string manipulation in fixed-size buffers that i'd asked about earlier at all; ended up with a much cleaner interface and implementation, but thanks danieldg and Mutabah for walking me through it anyway)
Feb 23 20:41:42 <dkg>	now i'm struggling because the library object generated by the cdylib crate exposes a *ton* of symbols that i don't want it to expose.
Feb 23 20:44:05 <dkg>	i've done searches for "cdylib symbol visibility" and found nothing that works for me :(  i've tried passing a "version script" to the linker, but it ends up in conflict with the version script passed automatically by cargo
Feb 23 20:44:36 <dkg>	what i want is for the cdylib to only expose those symbols that are marked as C symbols
Feb 23 20:44:53 <dkg>	so, the things that cbindgen would pick up on, for example.
Feb 23 20:45:49 <dkg>	the desired C API is simple enough that i don't need to actually use cbindgen to produce it, and i'd prefer to avoid depending on that crate anyway during build.  Any pointers on what i can do to minimize the exported symbols in a cdylib?
Feb 23 20:49:46 <enoq>	Vorpal, tried this approach instead https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=22cc396e399dd04c469f98eb94d67d3b
Feb 23 20:50:01 <enoq>	getting "borrowed data escapes outside of closure"
Feb 23 20:50:06 <enoq>	I suppose it's the same issue
Feb 23 20:51:54 <j`ey>	dkg: so youre getting rust mangled symbols?
Feb 23 20:52:44 <j`ey>	(oops go to go)
Feb 23 21:00:04 <dkg>	j`ey: yes, i'm seeing rust mangled symbols in addition to the ones that i want to export
Feb 23 21:03:43 <dkg>	hm, actually, as i look at it further, maybe not!  i think i was just seeing mangled symbols in the non-stripped shared object.  when i run "strip" on it, the only symbols that remain are the deliberately exported ones.
**** BEGIN LOGGING AT Fri Feb 23 21:29:52 2024

Feb 23 21:29:49 *	Now talking on ##rust
Feb 23 21:29:49 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 23 21:29:49 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Feb 23 23:14:47 <ljhklhjl>	hi
Feb 23 23:15:57 <ljhklhjl>	https://tr.cpabestoffer.click/redirect?aff_id=1153&offer_id=121
Feb 23 23:16:07 <ljhklhjl>	https://tr.cpabestoffer.click/redirect?aff_id=1153&offer_id=121
Feb 23 23:58:17 <lolita>	Ok, el trato... dame una membresÃ­a gratis y te enviarÃ© 5 videos de coÃ±os calientes despuÃ©s de un chat de sexo en vivo gratis, Â¿es bueno el trato? https://tr.cpabestoffer.click/redirect?aff_id=1153&offer_id=121
Feb 23 23:58:43 <lolita>	Ok, el trato... dame una membresÃ­a gratis y te enviarÃ© 5 videos de coÃ±os calientes despuÃ©s de un chat de sexo en vivo gratis, Â¿es bueno el trato? https://tr.cpabestoffer.click/redirect?aff_id=1153&offer_id=121
Feb 23 23:59:15 <lolita>	Soy una chica soltera. Busco diversion con gente real.. Si realement quieres conocerme, sigue mi perfil personal
Feb 23 23:59:16 <lolita>	Si este enlace no funciona, cÃ³pielo y pÃ©guelo manual en su navegador: https://tr.cpabestoffer.click/redirect?aff_id=1153&offer_id=121
**** BEGIN LOGGING AT Sat Feb 24 12:02:42 2024

Feb 24 12:02:41 *	Now talking on ##rust
Feb 24 12:02:41 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 24 12:02:41 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Feb 24 12:02:47 <osse>	Of course, need to wait for a new release of cargo-lockdiff since the current one segfaults
Feb 24 12:04:57 <osse>	With that said, if there is a newer/better/shinier way to get a easily digestible "diff" of Cargo.lock then I'm all ears
Feb 24 12:49:38 *	zato slaps Jarrko Oikarinen around with a big nice tuna sandwich 
Feb 24 12:50:00 <jbg>	osse: i like `lockdiff`
Feb 24 12:50:29 <jbg>	https://lib.rs/crates/lockdiff
Feb 24 12:51:12 <jbg>	not a cargo 'plugin' but rather just a command you can point git to, so `git diff` gives nice diffs on lock files automatically
Feb 24 12:51:21 <jbg>	works for some python and JS lockfile formats too
Feb 24 12:53:27 <osse>	 Cool, I'll check it out
Feb 24 12:54:03 <osse>	At first glance this looks more like what I would have written myself. The big table you get from cargo-lockdiff sort of sticks out
Feb 24 14:27:50 <osse>	I need to act on the inner value of an enum if the enum is of a particular variant: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=20be5267fe0800bc46c21dd271668b43 - Is there a way to make maybe_reverse2() work the same as maybe_reverse() ?
Feb 24 14:29:22 <osse>	Ahh, I think macro hygiene is screwing me here. the matches!() itself compiles just fine (there's a typo in the playground)
Feb 24 14:45:41 <yuri6037>	Hello, I have a question about the &str type: is there any way to refer to the &str type other than by using a type statement? I'm attempting to write a custom deserialize function for a proprietary format of date time and in that deserialize function I'd like to call &str::deserialize however it appears that in rust it's impossible other than by creating a type statement.
Feb 24 14:46:59 <erk>	yuri6037: You could look into the built-in trait FromStr, and if you want to replicate what that does you will have to make a trait and then implement it for &str
Feb 24 14:47:20 <osse>	<&str>::deserialize()   works
Feb 24 14:48:31 <yuri6037>	osse: thank you never seen that weird type syntax before but works or is it just a variant of the <type as trait> syntax?
Feb 24 14:50:28 <osse>	yuri6037: I'm not really qualified to answer :P But I *think* it's essentially the same as <type as trait> yes.
Feb 24 14:50:40 <yuri6037>	ok
Feb 24 14:50:50 <yuri6037>	thank you anyways
Feb 24 14:59:25 <osse>	yuri6037: tested a bit on the playground and I feel I know less than I did. the < > seem to be just to scope the &.
Feb 24 14:59:51 <yuri6037>	ok I see
Feb 24 14:59:58 <osse>	&T::foo() is a reference to T::foo()  <&T>::foo() calls &T'
Feb 24 15:00:06 <osse>	ugh, whatever, you get what I mean.
Feb 24 15:00:26 <yuri6037>	Oh ok that's like the parentheses in C casts
Feb 24 15:01:12 <jbg>	it's called a "qualified path"
Feb 24 15:01:21 <jbg>	and yeah it's basically like parens but for types
Feb 24 15:01:29 <yuri6037>	Anyway that failed because the xml_serde_rs crate can't parse borrowed string it can only parse owned strings so it's gonna have to be more allocs
Feb 24 15:01:32 <jbg>	https://doc.rust-lang.org/reference/paths.html#qualified-paths
Feb 24 15:01:47 <jbg>	< Type (as TypePath)? >
Feb 24 15:01:57 <yuri6037>	jbg: thanks for the name good to know
Feb 24 15:02:52 <yuri6037>	I tried to reduce allocs but the lib I use does not appreciate
Feb 24 15:03:06 <jbg>	serde_xml_rs seems to be able to deserialize from &str
Feb 24 15:03:44 <yuri6037>	apparently not: Failed to decode TTMD monitor data object: Custom { field: "invalid type: string \"05/06/2014 09:14:56\", expected a borrowed string" }
Feb 24 15:04:12 <jbg>	that error doesn't seem to say what you are saying it says though
Feb 24 15:04:15 <jbg>	in any case you'd have to show code
Feb 24 15:10:58 <yuri6037>	Here is the code that failed with the error I gave you (note that the playground does not have serde_xml_rl): https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=581fd21d3150d2d6b7a4d87ce8c4a9f8
Feb 24 15:12:36 <jbg>	the error implies that serde_xml_rs is providing a String *that it allocated* while you are assuming it will provide a &str
Feb 24 15:12:40 <jbg>	i bet i know why as well
Feb 24 15:12:43 <jbg>	XML entities
Feb 24 15:12:59 <jbg>	it can't give a &str borrowed from the input because it has to interpret entities
Feb 24 15:13:26 <jbg>	best it could give is Cow<'a, str> -- the Borrowed variant if there are no entities and the Owned variant if there are. no idea if they implemented that or not
Feb 24 15:13:50 <jbg>	it's the same reason why serde_json can't reliably deserialize JSON strings into &str, only into String or Cow<'a, str>
Feb 24 15:13:59 <jbg>	because it needs to interpret backslash escapes
Feb 24 15:20:55 <Alexendoo>	It's based on xml-rs which doesn't borrow from the input
Feb 24 15:22:16 <Alexendoo>	You probably want quick-xml instead
Feb 24 15:27:30 <jbg>	quick-xml looks good. has the same setup as serde_json: you can deserialize strings into String, Cow<'a, str> or &str but &str will fail if the XML is non-UTF8, if there are any entities in the input, or if an element contains multiple cdatas
Feb 24 15:28:14 <yuri6037>	Thanks for the tip
Feb 24 15:35:55 <capitol>	do anyone know if it's possible to check if you are in the context of a #[cfg(...)] conditional when writing a clippy lint? There is a stripped_cfg_items() function on the context object, but that is not what I want
Feb 24 15:39:14 <Alexendoo>	capitol: You can use any_parent_has_attr
Feb 24 15:42:31 <capitol>	Alexendoo: oh, thanks :)
Feb 24 16:08:07 <yuri6037>	Does quick-xml support unordered readings?
Feb 24 16:08:51 <yuri6037>	I.e. Does it support formats where objects may appear in any order in the tree and deserialize as a single structure with fields
**** BEGIN LOGGING AT Sat Feb 24 16:29:08 2024

Feb 24 16:29:06 *	Now talking on ##rust
Feb 24 16:29:06 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 24 16:29:06 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** BEGIN LOGGING AT Sat Feb 24 16:32:03 2024

Feb 24 16:32:03 *	Now talking on ##rust
Feb 24 16:32:03 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 24 16:32:03 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Feb 24 16:33:36 <yuri6037>	well I think there's no other choice at this point my input XML is unparseable in Rust
Feb 24 16:34:29 <Alexendoo>	Since you're in boring hyperbole mode I assume you're just using the library wrong
Feb 24 16:34:55 <Alexendoo>	As has been the case every other time
Feb 24 16:35:02 <j`ey>	lmao I really hate yuri6037's way of talking
Feb 24 16:35:21 <j`ey>	glad theyve been away for ages lol
Feb 24 16:35:47 <yuri6037>	The problem is the library does not dcument anything about unordered items
Feb 24 16:36:13 <yuri6037>	it appears nobody in Rust has through of unordered XML elements when parsing XML
Feb 24 16:36:47 <j`ey>	but apparently it's super common /s
Feb 24 16:37:23 <yuri6037>	at least its common enough to be supported in C# and Jav
Feb 24 17:17:05 <nullie>	it was always a stupid idea to store structures in xml
Feb 24 17:17:40 <yuri6037>	I ended finding something the quick_xml lib can do it but using very weird struct field names
Feb 24 17:18:36 <yuri6037>	Like naming "monitor" instead of "monitors" in order to parse a Vec<Monitor> and naming "sensor" instead of "sensors" to parse a Vec<Sensor>
Feb 24 17:18:52 <yuri6037>	This behavior is obviously not documented
Feb 24 17:19:33 <yuri6037>	and error messages from the lib are misleading like saying that fields do not exist when they do on a standard text editor
Feb 24 17:20:37 <danieldg>	yes, if you want automatic things you'll need to use the right plurality; otherwise, you can generally rename them
Feb 24 17:21:13 <danieldg>	it's perfectly reasonable to have both <monitor> and <monitors> tags in XML
Feb 24 17:21:31 <ksynwa>	Is this the "correct" way to check a Path? `path == Path::new("filename.json")`
Feb 24 17:21:40 <danieldg>	ksynwa: define 'check'
Feb 24 17:22:07 <danieldg>	ksynwa: because that doesn't actually do anything but convert the type
Feb 24 17:22:28 <ksynwa>	I just wanna check if path points to filename.json
Feb 24 17:23:03 <ksynwa>	Don't care if there is a file there or not. Just what the string value is.
Feb 24 17:23:30 <danieldg>	ksynwa: ok, rephrasing: what do you want to *reject*?
**** BEGIN LOGGING AT Sat Feb 24 17:28:08 2024

Feb 24 17:28:07 *	Now talking on ##rust
Feb 24 17:28:07 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 24 17:28:07 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Feb 24 17:30:54 <nullie>	ksynwa: maybe path.to_str() == Some("filename.json")
Feb 24 17:31:08 <ksynwa>	Yeah that looks fine.
Feb 24 17:31:18 <nullie>	but why are you doing that?
Feb 24 17:32:21 <ksynwa>	nullie: I am reading the contents of a zip file. For certain filenames I want to handle the files differently.
Feb 24 17:37:07 <Alexendoo>	The == Path::new() allows skipping the UTF-8 check
Feb 24 18:11:28 <nullie>	yeah, could be faster
**** ENDING LOGGING AT Sat Feb 24 19:15:17 2024

**** BEGIN LOGGING AT Sun Feb 25 02:09:52 2024

Feb 25 02:09:50 *	Now talking on ##rust
Feb 25 02:09:50 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 25 02:09:50 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Feb 25 03:35:44 <krez>	hello :D
Feb 25 05:11:59 <thegman>	is set_read_timeout not a thing on TcpListener
Feb 25 05:12:20 <thegman>	i cant figure out how to notify a listener that the sender has finished sending stuff
Feb 25 05:13:04 <danieldg>	tcplistener is for new sockets
Feb 25 05:13:25 <danieldg>	it's normally used in an event loop, not with timeouts
Feb 25 05:15:19 <thegman>	i thought tcplistener was used to receive bytes from a tcp stream
Feb 25 05:21:29 <Affliction>	nope, it's used to listen on a port and accept connections.
Feb 25 05:21:59 <thegman>	how do i recieve data then
Feb 25 05:22:08 <thegman>	tcp listener works but it wont close afterwards
Feb 25 05:22:09 <Affliction>	It creates TcpStreams for incoming connections, which are bidirectional
Feb 25 06:05:57 <Widdershins>	listener sockets bind to a port & wait for incoming connections, they don't send or receive data themselves
Feb 25 06:53:27 <Ademan_>	since &str[i] isn't supported (I understand why), is there a way I can iterate over characters in the string and pull out regions as a slice? I started going down that path and I don't think I can do it without a useless enumerate() to keep track of character index (can't == compare Skip<Char<...>> apparently)
Feb 25 06:54:11 <Ademan_>	the approach I was going for was going to require me to collect() into a new String anyway, if I could get it working
Feb 25 06:59:39 <Widdershins>	Ademan_: pull out what regions?
Feb 25 07:00:28 <Ademan_>	oh, char_indices() looks promising, if I want to grab a slice from start = s.char_indices() to stop = s.char_indices().skip();  can I just do &s.as_bytes()[start.0..stop.0] ?
Feb 25 07:00:58 <Ademan_>	Widdershins: some region I've selected while parsing
Feb 25 07:02:14 <Ademan_>	wait I'm being dumb s.as_bytes()[...] is going to be a &[u8] and I can't just get the current index with .0 heh
Feb 25 07:04:17 <Ademan_>	oh start.offset()..stop.offset() would work if it wasn't experimental
Feb 25 07:05:17 <Ademan_>	I assume s.as_bytes()[start.offset()..stop.offset()] would result in a valid utf-8 byte slice so I ought to be able to turn that back into a string slice, but I'm hosed since offset() is experimental anyway
Feb 25 07:12:57 <Ademan_>	oh huh, since Chars is a DoubleEndedIterator maybe it does everything I need by itself...
Feb 25 07:13:26 <Ademan_>	will have to look again later though, night
Feb 25 10:22:23 <polychromata{J}>	Ademan_: you can't index a string with a single integer, but you /can/ slice it with a range
Feb 25 10:22:35 <polychromata{J}>	(put you've probably already figured that out)
Feb 25 10:29:11 <jbg>	thegman: most likely you are actually using TcpStream (returned by accept() on TcpListener) without realising it. to close the connection you can just drop the TcpStream
Feb 25 11:32:04 <synapse>	can my Cargo example have its own dependencies?
Feb 25 11:33:12 <Widdershins>	synapse: examples can use dev dependencies
**** BEGIN LOGGING AT Sun Feb 25 18:41:35 2024

Feb 25 18:41:33 *	Now talking on ##rust
Feb 25 18:41:33 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 25 18:41:33 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** ENDING LOGGING AT Sun Feb 25 18:41:51 2024

**** BEGIN LOGGING AT Tue Feb 27 23:16:00 2024

Feb 27 23:15:58 *	Now talking on ##rust
Feb 27 23:15:58 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 27 23:15:58 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** BEGIN LOGGING AT Wed Feb 28 02:09:41 2024

Feb 28 02:09:40 *	Now talking on ##rust
Feb 28 02:09:40 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 28 02:09:40 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** ENDING LOGGING AT Wed Feb 28 02:32:44 2024

**** BEGIN LOGGING AT Thu Feb 29 01:02:43 2024

Feb 29 01:02:42 *	Now talking on ##rust
Feb 29 01:02:42 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 29 01:02:42 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Feb 29 01:13:02 *	Disconnected ()
**** ENDING LOGGING AT Thu Feb 29 01:13:02 2024

**** BEGIN LOGGING AT Thu Feb 29 01:15:36 2024

Feb 29 01:15:36 *	Now talking on ##rust
Feb 29 01:15:36 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 29 01:15:36 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Feb 29 05:36:03 <polychromata{J}>	evalr: -0.0_f64
Feb 29 05:36:05 -evalr/##rust-	polychromata{J}: -0.0
Feb 29 05:37:18 <polychromata{J}>	evalr: --nightly #![feature(float_next_up_down)] (0.0_f64.is_finite(), (-0.0_f64).is_finite())
Feb 29 05:37:20 -evalr/##rust-	polychromata{J}: (true, true)
Feb 29 07:36:37 <Chagall>	Is anyone aware of a simple method for adding or parsing dakuten/handakuten in Japanese chars?
Feb 29 07:37:10 <Chagall>	(Simpler than writing lookup tables myself)
Feb 29 07:38:40 <Chagall>	IIRC it's possible by operating on the character codes depending on the encoding...
Feb 29 07:39:12 <Chagall>	But that's not very idiomatic(TM)
Feb 29 07:48:37 <Arnavion>	Parsing can be done by normalizing into whatever form separates the dakuten/handakuten (NFD?)
Feb 29 07:49:03 <Arnavion>	Adding can be done by the opposite normalization
Feb 29 07:49:47 <Chagall>	Ah, neat
Feb 29 07:50:12 <Arnavion>	evalr: use unicode_normalization::UnicodeNormalization; "ã°".nfd().collect::<Vec<_>>()
Feb 29 07:50:14 -evalr/##rust-	Arnavion: ['ã¯', '\u{3099}']
Feb 29 07:50:45 <Chagall>	perfect, thanks
Feb 29 14:15:32 *	Disconnected ()
**** ENDING LOGGING AT Thu Feb 29 14:15:32 2024

**** BEGIN LOGGING AT Thu Feb 29 14:15:51 2024

Feb 29 14:15:51 *	Now talking on ##rust
Feb 29 14:15:51 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 29 14:15:51 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** BEGIN LOGGING AT Thu Feb 29 14:39:53 2024

Feb 29 14:39:53 *	Now talking on ##rust
Feb 29 14:39:53 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 29 14:39:53 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** BEGIN LOGGING AT Thu Feb 29 15:16:04 2024

Feb 29 15:16:03 *	Now talking on ##rust
Feb 29 15:16:03 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 29 15:16:03 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Feb 29 15:58:35 <Ademan_>	Just when I thought I was starting to figure lifetimes out... https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=2d1decc35a732b73a1a04340752d94dd why does the compiler want me to add 's (the lifetime of the &str CharIndices points to) to the result iterator? On the contrary the result lifetime 'r should be less than or equal to that, right?
Feb 29 15:59:25 <cehteh>	programmers rule #1 The compiler is always right :D
Feb 29 16:00:00 <Ademan_>	secondary question is: is there something that does what RefMap here does (wrap an iterator without owning it, and applying a map function to its elements results)
Feb 29 16:01:48 <Alexendoo>	.by_ref().map()?
Feb 29 16:02:07 <Alexendoo>	Or just .map if you already have a &mut Iterator
Feb 29 16:03:05 <Ademan_>	Alexendoo: thanks you're right!
Feb 29 16:04:23 <Alexendoo>	The trick being https://doc.rust-lang.org/std/iter/trait.Iterator.html#impl-Iterator-for-%26mut+I
Feb 29 16:14:51 <Ademan_>	so does ` -> impl Iterator<Item = char> + 's` express something other than "a type implementing iterator that lives *at least* as long as 's" ? If it means what I think, doesn't that mean the result could outlive the original string being referenced? (since we have CharIndices<'s>)
Feb 29 16:15:40 <bertptrs>	no, because CharIndices<'s> borrows the lifetime of the underlying string 's
Feb 29 16:16:29 <bertptrs>	I don't quite know why you're not allowed to unify the lifetimes into 'i; I would expect that to work
Feb 29 16:20:11 <Ademan_>	changing the lifetimes to simply be `'i: 'r + 's` appears to work but I still am really struggling why the lifetime of 'i should exceed 's. I feel like I missed something important not reading the rust book page by page or something.
Feb 29 16:22:33 <bertptrs>	ah now I understand, your relation was wrong
Feb 29 16:24:37 <bertptrs>	you wrote 's: 'i, but this is the wrong way around, it should be 'i: 's
Feb 29 16:25:02 *	polychromata{J} frowns and flips through the Book yet again to confirm that `'a: 'b` means 'a lives at least as long as 'b
Feb 29 16:29:53 <polychromata{J}>	i'm confused too c.c
Feb 29 16:29:54 <Ademan_>	yeah so I am still confused lol, doesn't this indicate the the reference iter will borrow for 'i, which is now longer than 's, which is the lifetime of the underlying &str of CharIndices<> ? Maybe the key is me not understanding "no, because CharIndices<'s> borrows the lifetime of the underlying string 's" ?
Feb 29 16:34:36 <bertptrs>	Hmm, yeah, that makes no sense, even if it compiles
Feb 29 16:34:50 <Ademan_>	maybe it can be distilled further: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=c8fd35a844a20ce33ee9663bc6c9aa3c
Feb 29 16:35:47 <Ademan_>	hrm no, my modified version doesn't mind if 'i and 's are totally unrelated lifetimes, I guess *that* makes sense
Feb 29 16:41:04 <Ademan_>	HRM, this might be slightly enlightening https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=fdd7f10fad30b06b654c3f2c4bec67c8 as_str() returns a string reference with lifetime 's and the exact lifetime of 'i remains irrelevant. it's like it was "cut through". obvious but possibly relevant behavior
Feb 29 16:41:12 <Ademan_>	if anyone tires of me thinking out loud please tell me to shut up
Feb 29 16:42:44 <cehteh>	yoi can just remove 'i there :D
Feb 29 16:43:36 <cehteh>	well i'd only took a glimpse
Feb 29 16:44:06 <Ademan_>	yeah I think you're right, I'm kind of just exploring right now, though
Feb 29 16:44:48 <cehteh>	aim for minimal lifetime annotations, let the compiler infer as much and if possible use generic '_
Feb 29 16:51:55 <cehteh>	CharIndices::as_str()  returns the str with the same lifetime as CharIndices, theoretically it may be a longer lasting one, but that complicates things as it would need to expose another lifetime up
Feb 29 16:52:20 <cehteh>	you have some kindof artifical limit there, which makes sense
Feb 29 16:52:42 <cehteh>	impl<'a> CharIndices<'a> { pub fn as_str(&self) -> &'a str
Feb 29 17:02:53 <Ademan_>	is it fair to say that the return value of as_str()s lifetime is "up to 'a" ? Since typically I think of lifetimes as being "at least 'x"
Feb 29 17:03:23 <Arnavion>	No, it's "at least 'a"
Feb 29 17:03:50 <Arnavion>	The 'a is the lifetime of the original &str that .char_indices() was called on
Feb 29 17:04:54 <Arnavion>	The returned &str only borrows from that original &str and nothing from the CharIndices, so there's no reason to limit its lifetime to the CharIndices itself
Feb 29 17:20:26 <Ademan_>	Arnavion: the last part makes perfect sense, but I don't understand how you could borrow "at least 'a" if the lifetime of the original str is also 'a (which afaict it is, per what cehteh shared above)
Feb 29 17:21:01 <Ademan_>	or I guess the lifetime of the original string is *also* "at least 'a"
Feb 29 17:21:30 <Ademan_>	but then how could you borrow it safely longer than 'a? I wouldn't think you could.
Feb 29 17:32:51 <cehteh>	of course you cant
Feb 29 17:38:56 <Beatussum>	Hi! I'd like to write a function returning an iterator but what should I prefer to specify as return type ? 1) An `impl Iterator<Item = Something>` ? 2) The iterator type directly which could be therefore a bit long ?
Feb 29 17:42:07 <j`ey>	Beatussum: impl Iterator is good yeah
Feb 29 17:44:13 <Beatussum>	j`ey: if the iterator returned implements other traits (for example, Clone, Debug, etc.) should I specify them too?
Feb 29 17:44:49 <j`ey>	if they make sense
Feb 29 17:47:12 <Ademan_>	cehteh: then how can we say the lifetime is "at least 'a" ? longer than 'a would be longer than the known lifetime of the underlying string
Feb 29 17:47:15 <cehteh>	just specify what you need, no more no less
Feb 29 17:48:24 <cehteh>	Ademan_?
Feb 29 17:48:34 <Beatussum>	cehteh: okay I've got it
Feb 29 17:48:39 <Beatussum>	thanks :)
Feb 29 17:52:07 <gastus>	I tried .lines to count lines of a file found out that it's much slower than C fgets() function. Found rust-mio but I have issues compiling it on some systmes eg stdlib.h is missing (nixos) or OSX other error. Is there yet another solution I missed ? I am interested in using json-yy like very fast parsers cause I have to process like 3GB of JSON files.
Feb 29 17:53:03 <cehteh>	gastus: you use that with a BufReader ?
Feb 29 17:57:21 <Beatussum>	I've another question about the error `E0700`? I'm not sure to understand why a lifetime specifier is needed in the following case https://bpa.st/PG3A
Feb 29 18:09:41 <Arnavion>	Ademan_: We're talking about "at least" / "at most" from different points of view :)
Feb 29 18:10:30 <Arnavion>	A &'static str can be converted to a &'a str. So from the POV of the producer of the &'a str, the str lives at least as long as 'a (it could be living longer). From the POV of the consumer of the &'a str, the str lives at most as long as 'a
Feb 29 18:11:26 <Arnavion>	The consumer for example cannot put it in a variable of type &'static str, because the &str is only guaranteed to live at most as long as 'a
Feb 29 18:18:51 <Arnavion>	So in this case, CharIndices::as_str() could just return `"foo"` (str literals are &'static str) and it would compile fine. But when the caller of CharIndices::as_str() lost the original &str that they had called .char_indices() on, they would also lost the &str returned by CharIndices::as_str()
Feb 29 18:24:26 <Guest13>	Hi, how do I print the current enum variant as string, assuming its debug/display traits were changed to something unrelated(like a full error message), this output is what I'm looking for: https://play.rust-lang.org/?version=nightly&mode=debug&edition=2024&gist=9e002932cba05f4c386211e2356c9df2
Feb 29 18:42:52 <gastus>	cehteh: Looks like libc might do it as well. So google fooled me into using a maybe too complex library.
Feb 29 18:43:19 <cehteh>	huh?
Feb 29 18:46:45 <cehteh>	just using a BufReader should fix this, when you didnt do so already, while rust might be a bit more pedantic since it validates that the strings/lines are utf-8, when you need it really fast then you count the \n's
Feb 29 18:46:50 <cehteh>	byte wise
Feb 29 18:47:31 <gastus>	Yes, the UTF-8 might be the reason why it's slower. Cause the JSON parsing in C showed similar difference.
Feb 29 18:47:53 <cehteh>	i suspect the most slowdown comes when you dont do buffered io
Feb 29 18:48:01 <gastus>	I will try and report.
Feb 29 18:48:38 <cehteh>	reading each byte is then a syscall turnaround
Feb 29 18:49:02 <gastus>	In fact I was using BufReader (thanks GPT :-). So that's not the difference.
Feb 29 18:49:22 <cehteh>	ah ok, hence i asked, W/O would be slower
Feb 29 18:49:33 <cehteh>	maybe you use a bigger buffer as well
Feb 29 18:50:08 <gastus>	Maybe boost of my CPU is not setup correctly. Maybe RAM actually is the bottleneck. That would explain why UTF8 makes bigger difference than it should.
Feb 29 18:50:19 <edgimar>	What is the recommended way to compute an average and standard-deviation on a [f64]?  I'm looking for traits that are already defined, since I don't want to reinvent the wheel every time I need this.
Feb 29 18:51:27 <cehteh>	gastus: the utf-8 check adds certainly some penalty
Feb 29 18:54:13 <Alexendoo>	BufRead::lines allocates a new string for each line, there's read_line if you want to re-use the same buffer
Feb 29 18:55:18 <cehteh>	the fastest would be to mmap the file, some madvise hints and then iterate by bytes counting \n's .. possibly in few parallel threads :)
Feb 29 18:55:29 <edgimar>	And yes I can just do numbers.iter().sum / (numbers.len() as f64), but I want something like numbers.mean_and_std().
Feb 29 18:55:36 <cehteh>	of course thats the most involved was as well :)
Feb 29 19:20:13 <consus>	Documentation to From suggests that implementing From<T> for U also brings me Into<T> for U
Feb 29 19:20:19 <consus>	However, that's not happening
Feb 29 19:20:30 <consus>	What am I doing wrong?
Feb 29 19:20:51 <j`ey>	Into<U> for T
Feb 29 19:20:56 <spb>	implementing From<T> for U gets you Into<U> for T
Feb 29 19:21:16 <consus>	ah dammit
Feb 29 19:21:38 <consus>	shame :(
Feb 29 19:24:44 <Guest13>	If I try to find out type of 'e' by doing "let i:i64=e;", then I get ^ expected `i64`, found `Error`, but 'Error' is not good enough type information, whilst I know now it's an enum variant "pkg_config::Error::Command" at that spot in the code (through brute force means aka match over all variants but what if there's 100s?!). Is there some way to
Feb 29 19:24:44 <Guest13>	find that "pkg_config::Error::Command" type?
Feb 29 19:29:53 <consus>	given that I've implemented both From<T> for U and Into<T> for U, should I also imlement From<Vec<T>> and Into<Vec<T>>?
Feb 29 19:30:03 <consus>	Or these come for free?
Feb 29 19:32:06 <spb>	you generally shouldn't implement Into yourself
Feb 29 19:32:23 <spb>	if the conversion goes both ways, impl From<T> for U and From<U> for T
Feb 29 19:32:36 <consus>	sadly I cannot touch U
Feb 29 19:32:39 <consus>	that's foreign type
Feb 29 19:33:45 <consus>	Or it's possible to define From<U> if U is another crate?
Feb 29 19:34:41 <spb>	you can impl From<T> on U if you own T
Feb 29 19:34:52 <consus>	oh
Feb 29 19:35:26 <spb>	owning a type that's a generic param for the trait is enough to satisfy the orphan rule
Feb 29 19:35:41 <consus>	thanks
Feb 29 19:35:45 <consus>	    Ok(Json(list.into_iter().map(Into::into).collect()))
Feb 29 19:36:00 <consus>	So then I have this
Feb 29 19:36:05 <consus>	Vec<T> -> Vec<U>
Feb 29 19:36:51 <consus>	Is it possible to make it like this: Ok(Json(list.into())? Or this is not how things work?
Feb 29 19:37:28 <Guest13>	just making sure, can people see this message?
Feb 29 19:37:29 <consus>	I was under the impression that Into should work for T<U> -> T<F> conversions
Feb 29 19:38:44 <spb>	not in the general case
Feb 29 19:38:52 <consus>	:(
Feb 29 19:39:10 <Guest13>	hello?
Feb 29 19:39:16 <consus>	Guest13: Hi :)
Feb 29 19:39:47 <Guest13>	oh ok, sorry, i thought my messages weren't getting through, I guess then no one knows about my issue, which is fair
Feb 29 19:40:20 <j`ey>	Guest13: yes the compiler wont print the exact variant basically
Feb 29 19:40:49 <nox>	How would rustc know
Feb 29 19:40:52 <Guest13>	ok, thanks
Feb 29 19:41:04 <Guest13>	I don't know, I thought maybe macros
Feb 29 19:41:13 <Guest13>	but I'm too new
Feb 29 19:41:45 <Guest13>	I guess the way is through match after all
Feb 29 19:42:01 <j`ey>	or dbg!(e) if it supports Debug
Feb 29 19:42:31 <nox>	Guest13: e is an Error, rustc knows that, but it doesn't know which variant the value is, as that's known at runtime
Feb 29 19:42:32 <Guest13>	it does but it prints an explanation message, and I was trying to see which type it was so I can match against it instead
Feb 29 19:42:46 <Guest13>	nox, understood,. thanks
Feb 29 20:02:51 <consus>	spb: thanks, this pub trait VecExtInto<T, U> {
Feb 29 20:02:51 <consus>	    fn morf(self) -> Vec<U>;
Feb 29 20:02:51 <consus>	}
Feb 29 20:02:51 <consus>	impl<T,U> VecExtInto<T, U> for Vec<T>
Feb 29 20:02:51 <consus>	where
Feb 29 20:02:52 <consus>	    U: From<T>
Feb 29 20:02:52 <consus>	{
Feb 29 20:02:53 <consus>	    fn morf(self) -> Vec<U> {
Feb 29 20:02:53 <consus>	        self.into_iter().map(Into::into).collect()
Feb 29 20:02:54 <consus>	    }
Feb 29 20:02:54 <consus>	}
Feb 29 20:02:55 <consus>	does the trick
Feb 29 20:19:30 <Ademan>	Arnavion: thanks, that makes sense, now I just need to integrate that info haha
Feb 29 20:39:16 <gastus>	libc fopen returns FILE which is enum FILE {}. So there is no real way to check the result of an fopen call (trying to be unsafe to understand the speed difference). So looks like best way to go is write actual C code.
Feb 29 20:45:51 <osse>	gastus: Can call ptr.is_null() ?
Feb 29 21:00:19 <_Vi>	Is there already a feature proposal / pre-RFC about library compilation settings that are supposed to be adjusted only by a root crate, not intermediate dependencies? For example, `tokio_unstable`. Many rhai's Cargo-level features would look better as root-crate-only features.
**** BEGIN LOGGING AT Fri Mar  1 01:59:42 2024

Mar 01 01:59:41 *	Now talking on ##rust
Mar 01 01:59:41 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 01 01:59:41 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Mar 01 03:31:39 <danieldg>	is there a nicer-looking way of getting a String out of a HashMap<&str,&str> than map.get("key").map_or("", |s| s).into()?
Mar 01 03:40:27 <She>	danieldg: Consider https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_default instead of the map_or.
Mar 01 03:41:55 <danieldg>	She: can't; it's an Option<&&str>, which has no Default
Mar 01 03:46:50 <She>	Ooop, indeed, you'd also need to throw a cloned() into there.
Mar 01 03:48:59 <polychromata{J}>	evalr: <&str as Default>::default()
Mar 01 03:49:01 -evalr/##rust-	polychromata{J}: ""
Mar 01 03:49:11 <polychromata{J}>	evalr: <&&str as Default>::default()
Mar 01 03:49:12 -evalr/##rust-	polychromata{J}: error[E0277]: the trait bound `&&str: Default` is not satisfied ...
Mar 01 03:49:13 -evalr/##rust-	polychromata{J}: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=18c5736f5e498008079eee3e407cea29
Mar 01 03:49:19 <polychromata{J}>	ah, that makes sense
Mar 01 03:51:53 <Arnavion>	Or get to Option<String> and then _or_default it, eg   .get().copied().map_or_else(Default::default, Into::into)
Mar 01 03:55:27 <danieldg>	sure.  Mine wins for code-golf, but I think I'll use .copied.unwrap_or_default.to_owned
Mar 01 03:55:33 <Arnavion>	Also   impl Default for &&T where &'static T: Default { fn default() -> Self { &Default::default() } }   would let &&str be Default, I think
Mar 01 03:56:56 <danieldg>	might fail due to str:!Sized
Mar 01 03:57:48 <danieldg>	I don't see the &&T impl in the docs
Mar 01 03:57:51 <Mutabah>	Nah, it'd fail due to `Default::default()` not being `const`
Mar 01 03:57:56 <danieldg>	ah
Mar 01 03:58:48 <Arnavion>	https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=bd3443fd171959867f0aa78d91bbb5a7   Bah
Mar 01 03:59:48 <Arnavion>	Yeah, makes sense, static promotion only works for const-evaluated exprs
Mar 01 05:49:44 <mips64el>	hi o/
Mar 01 07:12:06 <Ademan_>	are derived Clones inline? in general? with exception? always?
Mar 01 08:42:59 <bertptrs>	Ademan_: at present not defined, but you can use cargo-expand to see (it is)
Mar 01 10:32:22 <Bish>	whenever i use a stream i basicially HAVE to get the futures_util::StreamExt, why isn't that default? im guessing because stream is not a first class citizen in rust?
Mar 01 10:32:27 <Bish>	is it async streams that are not std::stream ?
Mar 01 10:48:40 <bertptrs>	std::stream does not exist yet, and currently the Stream trait is kept minimal to make future adoption easier
Mar 01 10:56:28 <Bish>	and where is "the" stream trait? is it in futures_util?
Mar 01 10:59:49 <bertptrs>	futures_core
Mar 01 11:01:33 <nullie>	is there a better way to do something n times (than for _ in 0..n)?
Mar 01 11:03:31 <j`ey>	(0..n).for_each(..) maybe
Mar 01 11:04:16 <osse>	std::iter::repeat(()).take(10).for_each(|()| do_something())  \O/
Mar 01 11:04:32 <j`ey>	heh
Mar 01 11:04:55 <j`ey>	thars more optimal since it doesnt need to count the numbers /s
Mar 01 11:06:35 <dav1d>	j`ey, https://rust-lang.github.io/rust-clippy/master/index.html#/needless_for_each
Mar 01 11:07:37 <dav1d>	Wait did they move that lint into pedantic ðŸ¤”
Mar 01 11:07:38 <osse>	Hmm, when is .for_each() more performant ?
Mar 01 11:09:58 <j`ey>	dav1d: not sure if that would apply here?
Mar 01 11:11:02 <dav1d>	can I make clippy pedantic on the playground?
Mar 01 11:12:18 <dav1d>	j`ey, yeah it doesn't
Mar 01 11:47:34 <polychromata{J}>	osse: probably never
Mar 01 11:47:43 <polychromata{J}>	all else being equal, just use for{}
Mar 01 11:48:05 <polychromata{J}>	IOW, `for _ in 0..n {}` /is/ the way to do that
Mar 01 11:48:32 <polychromata{J}>	(i'll accept for_each() if it's a lot nicer to write, e.g. at the end of a long iterator chain)
Mar 01 11:48:47 <polychromata{J}>	(at least until we get postfix control flow keywords c; )
Mar 01 12:25:03 <prmthz>	hello! does anyone know how can I set "cargo test" parameters like "--test-threads=2" in the .cargo/config.toml ?
Mar 01 12:50:49 <curious-user>	hi, is there an orm which can load nested one-to-many relations without jumping through hoops?
Mar 01 12:52:04 <curious-user>	sea orm can't do that at all, diesel can but requires a lot of grouped_by's and zip's
Mar 01 12:53:01 <curious-user>	it seems weird that such basic functionality is still missing from major orms
Mar 01 12:54:57 <curious-user>	(not bashing, just wondering maybe i've missed something)
Mar 01 13:21:47 <sword_smith>	How do I strip all special characters from a string? The concrete example I have right now is that I want to convert the string
Mar 01 13:21:55 <sword_smith>	"*a" into "a".
Mar 01 13:22:27 <sword_smith>	Or `&str`, I guess. I don't think that matters. But what I have now i of type `String`.
Mar 01 13:24:18 <j`ey>	hm, maybe .replace(&['a', 'b'....'z'], "")
Mar 01 13:24:23 <j`ey>	that seems a little annoying
Mar 01 13:24:35 <j`ey>	ah no, you can put a function there
Mar 01 13:25:22 <j`ey>	evalr: let a = String::from("a-z"); a.replace(|c|!c.is_alphabetic(), "")
Mar 01 13:25:24 -evalr/##rust-	j`ey: error[E0282]: type annotations needed ...
Mar 01 13:25:24 -evalr/##rust-	j`ey: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=8faea1028e4dbb8e42af3cf0ddd9caea
Mar 01 13:25:53 <j`ey>	evalr: et a = String::from("a-z"); a.replace(|c: char|!c.is_alphabetic(), "")
Mar 01 13:25:55 -evalr/##rust-	j`ey: error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an ...
Mar 01 13:25:55 -evalr/##rust-	j`ey: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=805e1fdc104003e093c03c105bf383df
Mar 01 13:25:59 <j`ey>	ffs lol
Mar 01 13:26:23 <Lumpio->	...et?
Mar 01 13:26:48 <j`ey>	mis copy :)
Mar 01 13:26:52 <polychromata{J}>	evalr: let a = String::from("a-z"); a.replace(|c: char| !c.is_alphabetic(), "")
Mar 01 13:26:54 -evalr/##rust-	polychromata{J}: "az"
Mar 01 13:28:55 <sword_smith>	j`ey: That seems to work :)
Mar 01 13:32:07 <sword_smith>	This is for the debugger of a VM. I'm auto-generating some type/variable name hints. The best solution would be to make the assembly-parser more permissive wrt. these names, but for now, j`ey's above snippet works.
Mar 01 13:32:59 <polychromata{J}>	eh, that's fair. :)
Mar 01 13:33:11 <polychromata{J}>	though perhapsâ€¦
Mar 01 13:33:27 <polychromata{J}>	evalr: let a = String::from("a**z%"); a.replace(|c: char| !c.is_alphabetic(), "_")
Mar 01 13:33:29 -evalr/##rust-	polychromata{J}: "a__z_"
Mar 01 13:34:01 <j`ey>	yes _ is better, maybe
Mar 01 13:34:23 <osse>	polychromata{J}: i see. Then that performance claim in that clippy is a bit weird.
Mar 01 13:35:00 <polychromata{J}>	clippy makes a performance claim?
Mar 01 13:35:34 <osse>	Bad phrasing on my part, probably.
Mar 01 13:35:46 <osse>	I meant this, quoted from the link above: "for_each may be used after applying iterator transformers like filter for better readability and performance. It may also be used to fit a simple operation on one line. But when none of these apply, a simple for loop is more idiomatic."
Mar 01 13:35:52 <sword_smith>	All tests pass :) I'm going with the replacement with `_`.
Mar 01 13:36:16 <polychromata{J}>	i'd be surprised if `for bar in foo { $body }` and `foo.for_each(|bar| { $body });` compiled to any different code.
Mar 01 13:38:51 <osse>	Same
Mar 01 13:39:04 <osse>	Interesting, from the std docs: "In some cases for_each may also be faster than a loop, because it will use internal iteration on adapters like Chain."
Mar 01 13:42:03 <osse>	Aka. it can take some shortcut that doesn't involve literally calling next() I guess
Mar 01 13:42:17 <osse>	s/Aka\./IOW./
Mar 01 13:42:54 <LDericher>	hi, currently relearning rust on my stm32 "blue pill" thingy and ran into an ownership/borrowing problem. Code: https://bpa.st/EUEA Issue: Lines 72/73 work, but doing that inside the loop at L82/87 fails as `tx` and `buf` are moved into the loop. tx and buf are both okay to be made 'static if needed. how to proceed?
Mar 01 13:46:35 <LDericher>	also, changing `buf` to `&*buf` in L82 makes one error go away as the analyzer suggests, but doesn't that only give the first value to the `write` fn?
Mar 01 13:59:38 <osse>	LDericher: what is the signature of tx.write()
**** BEGIN LOGGING AT Fri Mar  1 14:01:17 2024

Mar 01 14:01:16 *	Now talking on ##rust
Mar 01 14:01:16 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 01 14:01:16 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Mar 01 14:05:08 <LDericher>	osse, `fn write(mut self, buffer: B) -> Transfer<R, B, Self>` and `B: ReadBuffer<Word = u8>`
Mar 01 14:07:09 <spb>	https://docs.rs/stm32f1xx-hal/latest/stm32f1xx_hal/serial/type.TxDma1.html
Mar 01 14:07:19 <spb>	that's the `tx` you're working with
Mar 01 14:08:34 <spb>	write() consumes self and presumably wraps it into the returned Transfer object so you have to wait for the operation to complete before using it again for a new one
Mar 01 14:09:57 <LDericher>	spb, yes and the error is: `stm32f1xx_hal::dma::WriteDma::write` takes ownership of the receiver `self`, which moves `tx`
Mar 01 14:11:32 <spb>	yes
Mar 01 14:11:50 <spb>	once you call tx.write() you cannot use tx any more because it is consumed by the write call
Mar 01 14:12:40 <LDericher>	but the `with_dma` call to initialize `tx` takes care of the DMA initialization, so I'd like to reuse tx
Mar 01 14:13:02 <spb>	you can't reuse tx, the api doesn't allow it
Mar 01 14:13:25 <spb>	what you can do is use the returned Transfer object to get a new tx out of it, once the transfer has completed
Mar 01 14:14:14 *	polychromata{J} squints at that name.
Mar 01 14:14:18 <null_ptr>	osse: One problem with for loops is that the compiler cannot generate nested loops and needs additional state tracking. With internal iteration the iteration structure can be kept optimal.
Mar 01 14:15:38 <LDericher>	I don't see anything in the `xfer` that looks like "reinitiate this" ... on the other hand I just inspected the DMA init and it looks less complex than I assumed it to be
Mar 01 14:16:11 <spb>	LDericher: look at what's returned from wait()
Mar 01 14:21:08 <LDericher>	spb, looks fine https://bpa.st/ORDQ but only shifts the issue: `Tx::<stm32f1xx_hal::pac::USART1>::with_dma` takes ownership of the receiver `self`, which moves `serial.tx`
Mar 01 14:22:06 <spb>	that's not at all what i said to do
Mar 01 14:22:51 <LDericher>	and using wait() feels like a chicken-and-egg problem as I'd need a completed Transfer before starting one?
Mar 01 14:24:31 <spb>	once you start the transfer, you need to use wait(), get whichever type that particular variant returns in its tuple, call release() on that, and you get a new Tx
Mar 01 14:24:47 <spb>	set up dma again on that, and write it back over the top of `tx` so you can use it in the next loop
Mar 01 14:26:39 <spb>	i'm being vague here because i'm working purely from the rustdocs which are pretty hopeless
Mar 01 14:26:57 <spb>	hopefully there's some real documentation somewhere else to make actual sense of why all this dance is required
Mar 01 14:29:08 <LDericher>	well it works, idk why it is this convoluted, but the C(++) way is way more obscure btw
**** BEGIN LOGGING AT Fri Mar  1 16:01:18 2024

Mar 01 16:01:17 *	Now talking on ##rust
Mar 01 16:01:17 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 01 16:01:17 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** BEGIN LOGGING AT Fri Mar  1 18:08:59 2024

Mar 01 18:08:59 *	Now talking on ##rust
Mar 01 18:08:59 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 01 18:08:59 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** ENDING LOGGING AT Fri Mar  1 18:10:30 2024

**** BEGIN LOGGING AT Fri Mar  1 19:04:14 2024

Mar 01 19:04:13 *	Now talking on ##rust
Mar 01 19:04:13 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 01 19:04:13 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** BEGIN LOGGING AT Sat Mar  2 03:05:27 2024

Mar 02 03:05:26 *	Now talking on ##rust
Mar 02 03:05:26 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 02 03:05:26 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Mar 02 04:03:52 <Sync03>	Hi there -- I have am making a vim-like editor, and I am implementing functionality for buffers. Does an associated function exist for the iter type, that is similar to .next() but when the end of the iterator is reached, instead of returning None, it goes back to the start of the iterator. So it's effectively infinitely repeating? Is this a possibility? Cheers.
Mar 02 04:05:36 <danieldg>	sure; look at Iterator::cycle
Mar 02 04:06:21 <Sync03>	Thanks!
Mar 02 04:06:23 <danieldg>	it isn't used like you described but it does what you want
Mar 02 05:43:00 <josh19291>	Â¬Â¬LL
Mar 02 05:46:51 <josh19291>	Hi
**** BEGIN LOGGING AT Sat Mar  2 06:15:35 2024

Mar 02 06:15:35 *	Now talking on ##rust
Mar 02 06:15:35 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 02 06:15:35 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** BEGIN LOGGING AT Sat Mar  2 06:17:10 2024

Mar 02 06:17:09 *	Now talking on ##rust
Mar 02 06:17:09 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 02 06:17:09 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Mar 02 08:03:16 <Guest27>	Iti
Mar 02 08:03:45 <Guest27>	YMEJWG
Mar 02 08:04:34 <Guest27>	Bn8
Mar 02 08:27:04 <Wulf>	How do I call posix_fadvise on an std::fs::File?
Mar 02 08:35:58 <capitol>	Wulf: https://docs.rs/nix/latest/nix/fcntl/fn.posix_fadvise.html maybe
Mar 02 08:37:45 <capitol>	Wulf: or did you mean how to get a rawfd? https://doc.rust-lang.org/std/fs/struct.File.html#impl-AsRawFd-for-File
Mar 02 08:40:08 <Wulf>	capitol: both. Why won't "use nix::fcntl::posix_fadvise;" not work? "no `posix_fadvise` in `fcntl`"
Mar 02 08:40:50 <capitol>	maybe "Available on crate feature fs only" have you enabled that feature?
Mar 02 08:40:57 <Wulf>	capitol: I have no idea what that means.
Mar 02 08:42:14 <capitol>	when you import it in Cargo.toml you can specify features
Mar 02 08:43:43 <capitol>	https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#choosing-features
Mar 02 08:50:57 <Wulf>	capitol: thanks, works.
Mar 02 08:58:30 <capitol>	Wulf: nice :)
Mar 02 09:44:34 <Wulf>	How do I declare a function parameter that is either a u64 or "nothing"? And how do I check for "nothing" in the code?
Mar 02 09:45:04 <lambda>	Wulf: Option<u64>?
Mar 02 09:45:26 <lambda>	that has a value of either `Some(n)` where `n` is a u64, or `None`
Mar 02 09:46:27 <lambda>	you can check which one it is with `match`, `if let`, or maybe there's an existing method on `Option` that does what you need - you'd need to explain a bit more about the problem you're trying to solve
Mar 02 09:47:58 <Wulf>	lambda: it's my second day with rust. Guess I'll look at each of them and see what looks more useful.
Mar 02 09:49:18 <lambda>	Wulf: FYI, Option isn't magic in any way, the definition at the top of this page is all it really is: https://doc.rust-lang.org/std/option/enum.Option.html
Mar 02 09:49:48 <lambda>	I'd recommend reading the relevant chapter in the book: https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html?highlight=option#the-option-enum-and-its-advantages-over-null-values
Mar 02 09:53:01 <Chagall>	anyone else notice a large drop in throughput and less stable measurements when using criterion with batched iterations?
Mar 02 09:54:29 <dav1d>	Is it feasible to have a macro_rules macro that accepts any enum without data in the variants and then just does something with the variants? I feel like this is proc macro territory
Mar 02 09:59:14 <lambda>	dav1d: should be possible, if a bit of a pain to cover all the things that can be in an enum definition (attributes and such)
Mar 02 10:01:16 <dav1d>	lambda, I remembered pin-project-lite does something like that for structs, doesn't seem terrible, just gotta figure out how to not discard docs
Mar 02 10:42:56 <polychromata{J}>	Wulf: `match{}` is the most general thing; all of Option's other operations can be implemented in terms of it
Mar 02 10:43:05 <farnext>	 /msg NickServ REGISTER farnext far.next@gmail.com
Mar 02 10:43:55 <polychromata{J}>	Option has a /ton/ of convenience methods; don't worry about learning them all at once. You'll gradually get to know what's best|prettiest to use in each situation, over time. :)
Mar 02 10:44:09 <polychromata{J}>	farnext: protip: don't set your password equal to your nickname c.c
Mar 02 10:46:24 <polychromata{J}>	I like Diceware. Although you can also just use [a-z]+ as long as it's long enough (e.g. 26.pow(11) is roughly equal to 7776.pow(4)).
Mar 02 10:46:34 <polychromata{J}>	And then, for IRC, there's client cert auth, of course.
Mar 02 11:14:37 <Wulf>	I'm quite confused with match, functions, error handling, etc. Could someone please translate this toy example to rust for me? https://paste.debian.net/1309229/
Mar 02 11:20:25 <j`ey>	Wulf: why dont you show us what you have so far
Mar 02 11:23:11 <j`ey>	Wulf: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021 is a good site for rust snippets
Mar 02 11:33:51 <dav1d>	ah right I remember, documentation is just an attribute in macro_rules
Mar 02 11:36:28 <Wulf>	j`ey: https://gist.github.com/rust-play/ef6118a1923a74cdefd328eb7b09a410
Mar 02 11:37:12 <j`ey>	alright, looks good so far
Mar 02 11:37:21 <Wulf>	j`ey: well, the error handling is missing.
Mar 02 11:37:38 <j`ey>	Wulf: then you need to return Result<Self, Error> instead of just Self
Mar 02 11:37:54 <j`ey>	fn new(foo: Option<u64>, bar: u64) -> Result<Self, YourErrorType> {
Mar 02 11:38:09 <Wulf>	j`ey: and what error type would that be?
Mar 02 11:39:02 <j`ey>	you have to make one up or use an exisiting error type
Mar 02 11:39:10 <j`ey>	or just ().. any type basically
Mar 02 11:39:36 <polychromata{J}>	The first counterquestion isâ€¦is this for a library or an application?
Mar 02 11:40:40 <j`ey>	Wulf: this extends the example, minimally, https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=4154763522c6ad453c327d76239b3169
Mar 02 11:41:19 <polychromata{J}>	If it's an app, you can play pretty fast and loose with error types.
Mar 02 11:41:20 <Wulf>	polychromata{J}: application, but it must not crash when a bad value is passed.
Mar 02 11:41:31 <polychromata{J}>	Right, of course.
Mar 02 11:42:18 <polychromata{J}>	So having proper error types isn't quite as important. You can use `Box<dyn Error>` or `anyhow::Error` or whateverâ€”the latter is easy to get started with compared to alternatives, i believe
Mar 02 11:42:23 *	polychromata{J} doublechecks this
Mar 02 11:42:30 <Wulf>	It will accept a TLS connection and receive the parameter through it. When it's bad, the connection is closed, but the application should keep running to handle other connections.
Mar 02 11:43:09 <j`ey>	we're not talking about crashing :)
Mar 02 11:43:10 <Wulf>	j`ey: thanks
Mar 02 11:43:59 <polychromata{J}>	Oh, wow, anyhow has a good amount of support for ad-hoc errors.
Mar 02 11:44:05 <polychromata{J}>	That's pretty nice.[^1]
Mar 02 11:46:01 <polychromata{J}>	So if you pull in anyhow and change the return type to `Result<Self, anyhow::Error>`, you can do things like `if foo > 9 { bail!("tried to construct a Hello with foo={foo:?} (foo must be less than 9)") }`
Mar 02 11:46:30 <polychromata{J}>	s/bail!/anyhow::bail!/
Mar 02 11:46:48 <polychromata{J}>	This is a few new things at once; what questions do you have? :)
Mar 02 11:47:19 <j`ey>	I wwould learn more about Result itself first
Mar 02 11:47:22 <Wulf>	polychromata{J}: I think throwing more libraries at me only increases my confusion ;-)
Mar 02 11:47:58 <polychromata{J}>	Well, personally i like to do proper error types everywhere, but that's a good bit more work. :)
Mar 02 11:48:06 <polychromata{J}>	(Also i use thiserror for that, which is another library.)
Mar 02 11:48:15 <polychromata{J}>	(Because it's more tedious to not.)
Mar 02 11:48:46 <j`ey>	I mean the easiest thing to do next is: struct WulfError {} and change the Result<Self, ()> to Result<Self, WulfError>
Mar 02 11:48:47 <polychromata{J}>	Rust's std tends to err on the minimal side, so if you try hard to avoid libraries, you're probably going to have a bad time. :)
Mar 02 11:49:21 *	polychromata{J} notes that the Book introduces a library (rand) in chapter 2.
Mar 02 11:49:38 <polychromata{J}>	j`ey: The thing about that, though, is that it carries no information on what actually went wrong.
Mar 02 11:49:46 <j`ey>	sure
Mar 02 11:49:49 *	polychromata{J} gestures to her error message. It's detailed.
Mar 02 11:49:57 <j`ey>	but this is like their second day of rust :P
Mar 02 11:50:25 *	polychromata{J} tailswishes.
Mar 02 11:50:28 <polychromata{J}>	You may be right. :P
Mar 02 11:52:31 <polychromata{J}>	So yes, `struct WulfError;` is easyâ€¦
Mar 02 11:54:28 <saati>	enum WulfError{}; and the compiler proves you make no errors :)
Mar 02 11:54:52 <polychromata{J}>	Tch. Uninhabited types on day 2?
Mar 02 11:55:03 <j`ey>	hah
Mar 02 12:07:19 <dav1d>	Result::into_ok when ðŸ˜¡
Mar 02 12:07:28 <polychromata{J}>	never
Mar 02 12:07:44 <dav1d>	noooooooooooooo :(
Mar 02 12:07:53 <polychromata{J}>	i know right ;-;
Mar 02 12:08:03 <dav1d>	!
Mar 02 12:40:15 <Diablo-D3>	you know, its kinda sad that microsoft is this huge big company thats tried to fix directwrite several times (and tbf, they have, its way better than it used to be)....
Mar 02 12:40:31 <Diablo-D3>	but they cant catch up to a bunch of random dudes on the internet who made freetype.
Mar 02 15:58:06 <Beatussum>	Hi! I would like to implement a "symetric" trait e.g. if I implement MyTrait<A> is implemented for B, therefore MyTrait<B> is also implemented for A by using the previous implementation. What is the best way to achieve this?
Mar 02 16:03:48 <tokie>	Beatussum: look at From/Into. If you impl From you get the reverse Into trait from a blanket impl
Mar 02 16:05:17 <tokie>	https://doc.rust-lang.org/src/core/convert/mod.rs.html#747-749
Mar 02 16:06:39 <tokie>	oh, that's two different traits though
Mar 02 16:15:44 <Beatussum>	tokie: Yeah, I would like to have the same trait implemented `MyTrait<A>` and `MyTrait<B>` because `MyTrait` provide one method which should be used by an instance of `A` or `B`
Mar 02 16:15:58 <Beatussum>	`From` and `Into` provide two different method
Mar 02 16:28:32 <josh19291>	A
Mar 02 16:28:36 <josh19291>	/hwlp
Mar 02 16:55:40 <polychromata{J}>	evalr: trait MyTrait<T> {} impl<A, B> MyTrait<B> for A where B: MyTrait<A> {}
Mar 02 16:55:41 -evalr/##rust-	polychromata{J}: ()
Mar 02 16:56:58 <polychromata{J}>	evalr: trait MyTrait<T> { fn method(&self, other: &T); } impl<A, B> MyTrait<B> for A where B: MyTrait<A> { fn method(&self, other: &B) { other.method(self) } }
Mar 02 16:57:00 -evalr/##rust-	polychromata{J}: ()
Mar 02 16:57:46 <polychromata{J}>	Beatussum: a cursory check says that it works, but i have a sneaking feeling that there's some subtle reason why it'll break c.c
**** BEGIN LOGGING AT Sat Mar  2 19:02:29 2024

Mar 02 19:02:28 *	Now talking on ##rust
Mar 02 19:02:28 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 02 19:02:28 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** BEGIN LOGGING AT Sun Mar  3 08:36:18 2024

Mar 03 08:36:17 *	Now talking on ##rust
Mar 03 08:36:17 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 03 08:36:17 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Mar 03 08:38:03 <Widdershins>	ok the distance from where i was at to the associative key-value version that we've been talking about was pretty short
Mar 03 08:38:18 <Widdershins>	this passes MIRI https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=a70e90eabeab883b7229a9c4f062f45b
Mar 03 08:38:46 <Widdershins>	probably a good idea to make it so this panics less when you ask for keys that aren't there or whatever but the underlying mechanism is sound
Mar 03 08:41:48 <Widdershins>	the symbol repo version of this would have a slightly different api, probably like add_clown but not accepting a value
Mar 03 08:48:29 <Widdershins>	or, this could be combined with the vec-of-vecs to make a type that doesn't need to be StableDeref itself... so many possibilities
Mar 03 10:09:39 <polychromata{J}>	Widdershins: passes miri huh
Mar 03 10:09:53 <polychromata{J}>	do you have yarn tests? do those pass miri?
Mar 03 10:48:00 <Widdershins>	polychromata{J}: no idk that. yarn is a dep manager for javascript that i avoid looking at, too me. just saying that this doesn't complain when i run that program under miri, so it does seem like the unsafety is pretty much legal
Mar 03 10:48:19 <polychromata{J}>	not the JavaScript yarn!
Mar 03 10:49:23 <polychromata{J}>	oh, i misremembered. it's called loom.
Mar 03 10:49:28 <Widdershins>	i'm unable to find what you're looking for then
Mar 03 10:50:04 <polychromata{J}>	different textileish word. ^.^;
Mar 03 10:50:07 <Widdershins>	based on the readme of loom miri is WAY more comprehensive
Mar 03 10:50:51 <Widdershins>	it also runs a godzillion times slower, and is made to test more of the things i care about here (i am personally a lot more worried about memory UB than the concurrency violation. the concurrency part is simple)
Mar 03 10:52:11 <Widdershins>	miri makes it so if you so much as accidentally create an intermediate reference when you shouldn't by spelling something in a basically equivalent but different way, it will throw up
Mar 03 11:08:14 <dav1d>	How can I `cfg(test)` expose something for doctests? Having `#[cfg(any(test, doctest))] pub mod test;` doesn't seem to do it
Mar 03 11:08:40 <Widdershins>	it doesn't?
Mar 03 11:09:35 <dav1d>	nope, module not found
Mar 03 11:09:47 <dav1d>	`unresolved import `enumap::test``
Mar 03 11:10:01 <Widdershins>	:(
Mar 03 11:10:36 <dav1d>	:( https://github.com/rust-lang/rust/issues/67295#issuecomment-568287766
Mar 03 11:11:23 <dav1d>	guess I'll just copy paste into every doctest
Mar 03 11:51:01 <dav1d>	What trickery am I missing to implement an iterator which yields mutable references form an array? https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=28afe7124468d51f23c63898bfe75944
Mar 03 11:53:26 <dav1d>	Seems like I'll have to go to unsafe, but meh
Mar 03 12:00:58 <dav1d>	I finessed it, I think? https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=0cc5e250dc61ce32044e4db239e0d45b
Mar 03 12:12:02 <bertptrs>	yeah, something like that
Mar 03 12:12:29 <bertptrs>	there's a reason the default slice iterators use unsafe, to avoid your dance overhead
Mar 03 12:23:01 <gastus_>	@ polychromata{J}  Want to get the prototype done. Might want to care about arena allocation like etc later. In fact I used C and wrote my own inc based allocation which crashed rust but worked for C and the benefit was small (which was I was told upfront here). Need to proof that merging data from CSV this way actually is faster and worth the effort first compared to eg database. It should be.
Mar 03 12:23:58 <gastus_>	There is another thing I dont' get yet and that's the unwind to catch panics. Eg when searching there might be unknown symbols which means that find won't find anything (in fact its actually a speedup). So pattern is like try { ..  return true/false} catch { return false }.
Mar 03 12:24:11 <gastus_>	Maybe passing mut to lambda or such is the way to go.
Mar 03 12:24:39 <gastus_>	Just sometimes missing the convenience of other languages like ruby begin .. code rescue false end done.
Mar 03 12:25:15 <j`ey>	you would return a Result, not panic there usually
Mar 03 12:26:10 <gastus_>	But then I have to write catching the none Some cases..
Mar 03 12:26:28 <gastus_>	And that's the cool thing about exceptions you don't have to.
Mar 03 12:26:53 <j`ey>	with the ? operator it's pretty easy to add early returns on Errors
Mar 03 12:30:04 <gastus_>	So it means Result is to be used instead of Some.
Mar 03 12:30:50 <j`ey>	Result is used if there could be an error.
Mar 03 12:30:55 <j`ey>	whereas option is just some or none
Mar 03 12:32:49 <gastus_>	None in my case means error. So ok_or is the way to go.
Mar 03 12:37:58 <gastus_>	But then need to turn error case into false. Then need a block within which ? is caught. Then I can use Some and patern matching
Mar 03 12:39:50 <j`ey>	you cant currently use ? in blocks
Mar 03 12:39:52 <j`ey>	only functions
Mar 03 12:41:20 <j`ey>	I guess you could use ? in a closure
Mar 03 12:41:51 <gastus_>	But then I still need to convert and for two ? its not worth the effort.
Mar 03 12:52:14 <Widdershins>	you definitely should not be using unwinding for that
Mar 03 12:57:31 <gastus_>	Widdershins: depends on whether speed or programmers time is important :-/ And that's what annoys me you either have srcipting or compiled. But you cannot mix depending on the part of a project you're working. Not everything is most important. And sometimes its ok to be fast and done and option to optimize later.
Mar 03 12:57:50 <gastus_>	But let's say you rewriting Dart/js/wahtever to Rust later is huge effort.
Mar 03 12:57:56 <Widdershins>	dav1d: i'd probably just delegate to core::slice::IterMut
Mar 03 12:58:40 <Widdershins>	gastus_: i'm saying you're going to waste time and cause lots of problems down the line if you try to it this way instead of learning more ergonomic spellings for these things that already exist
Mar 03 12:59:07 <Widdershins>	you aren't the only person in the world who needs the kind of control flow you're trying to write. the tools already exist, you just haven't actually asked questions about it yet
Mar 03 12:59:44 <gastus_>	https://dpaste.com/AU66MTVRY line 72 is one of the stuff I wrote for JS. It basically can create it's own bash completion. It allows to have multiple lazy nested commands done fast.  async ()  or () => or just {} -> it eats everything.
Mar 03 13:00:17 <gastus_>	Widdershins: which keywords do you suggest me looking up ?
Mar 03 13:00:42 <Widdershins>	i don't know because i don't know what you're trying to do. you're talking about how results aren't ergonomic to write but you haven't explained what you have
Mar 03 13:01:44 <gastus_>	I have many CSV files. which contain name/phone .. and they a date like 'company-2023-01-01'. I want to merge all data so that I can query and mix and filter them. Like a person is the same person if they have the same company numebr, the same mobile phone number or have similar name and same zip (this last thing is fuzzy).
Mar 03 13:02:31 <gastus_>	And because I mostly have like 8 different keys attached I thought that actually representing the data as numbers person is list of attributes. List of attributes is (key, value, list of sources it was found) kinda gets the job done and is memory efficient.
Mar 03 13:03:07 <gastus_>	Because there are many different ways to query (by GPS location from address, by region such as state, by company) I didn't find a way to make mysql always be fast. So I really was wonedring whether just using 8 threads and filter is easier cause not many users.
Mar 03 13:03:16 <Widdershins>	sure so what's the issue. i don't see what about this requires intentionally catching unwind
Mar 03 13:03:38 <Widdershins>	certainly the fact that you have mysql involved is part of your problem. it is a very poor database
Mar 03 13:04:28 <gastus_>	So searching a phone number which I represent as symbols cause I expect phone numbers to be presented in 20+ csvs the symbol might not exist. So the fun thing is in that case I don't have any work to do to say not found :-) And that was what the case was about mixing the symbol not found with iterating over the people and the attributes.
Mar 03 13:05:10 <gastus_>	The project is like 10y old and that time I didn't know better. And that's why I investigate bare metal approach to learn from it.
Mar 03 13:06:04 <Widdershins>	i mean you are just mostly describing indexing all these attributes in memory and skipping the rows with something not-found
Mar 03 13:06:25 <dav1d>	Widdershins, I'll have to try again, but I think I also needed the Option dance for that to work
Mar 03 13:06:59 <gastus_>	And because the fuzzy part matching by name / zip depends on task wanted the mixer to be fast and maintainable and adjustable to the task. And loading 300K lines into mysql was like 4h. Now there are 10+ such files. Now thought let me learn Rust and retry using it to learn understand whether the different solution is better and get hands dirty with Rust cause will not go away. And once I understand might
Mar 03 13:07:05 <gastus_>	get an impression whether I even want to throw away my TS code. Not there yet.
Mar 03 13:07:09 <Widdershins>	so start with a column that's always unique, iterate over it, and use .filter_map(|..| ...). it's really easy, because the closure returns Option and you can just skip all the ones with not-found using ?
Mar 03 13:07:12 <Wulf>	I'm stuck with this code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=a74eb6335c9f9de18829bbdd83368e82 . How to fix it?  If it's too large, I can create a smaller testcase for the error.
Mar 03 13:08:19 <gastus_>	Widdershins: but talking about DBs which one do you consider to be better ? I mean there are som any PG, DuckDB, to name just 2. Each ahvinvg its own sweet spot. PG has geo index mysql doesn't but mysql has cache. So for some stupid cache based workload mysql actually might be a good choice and fast choice without much work.
Mar 03 13:09:12 <gastus_>	Widdershins: And you hit the nail. I feel like TS has some nice concepts such as typing 'objects' and wonder why nobody misses is using Rust/Java cause some simple fetch as Promise<type here> use scripting like use cases might exist for such languages, too.
Mar 03 13:09:39 <gastus_>	https://github.com/automerge/automerge-repo.git solve it by having typed and untyped documents and converting between them.
Mar 03 13:09:58 <Widdershins>	Wulf: you've written code that tries to capture a unique reference to self in not just one but ten different threads
Mar 03 13:10:21 <Widdershins>	gastus_: postgres is a thousand times better than mysql
Mar 03 13:10:31 <Widdershins>	mysql does not "have cache"
Mar 03 13:10:46 <Widdershins>	mysql is almost categorically worse than postgres.
Mar 03 13:10:52 <gastus_>	https://dev.mysql.com/doc/refman/5.7/en/query-cache.html
Mar 03 13:11:03 <Wulf>	Widdershins: and I don't know what to do about it. I'm new to rust.
Mar 03 13:11:04 <Widdershins>	it is very, very hard to come up with any type of scenario where mysql performs better than postgres
Mar 03 13:12:07 <Widdershins>	gastus_: you've linked to a "feature" that was deprecated 7 years ago in an EOL release line
Mar 03 13:12:19 <darkling>	It used to be faster than Postgres IIRC, but that was something over 20 years ago. (MySQL prioritised speed; Postgres prioritised correctness).
Mar 03 13:12:56 <Widdershins>	it hasn't been truly faster than postgres in any typical database scenario any time in the last decade
Mar 03 13:13:14 <gastus_>	Gonna shut up and listen more.
Mar 03 13:13:16 <Widdershins>	it's some of the worst software i've ever had the displeasure of being required to use
Mar 03 13:13:45 <darkling>	Oh, I think there's much worse under the false bottom of that particular barrel. :)
Mar 03 13:13:50 <Widdershins>	and i've been a senior data engineer for like 7 years now working with quite a few different ones
Mar 03 13:13:59 <bertptrs>	Saw a beautiful article that tried to establish what exactly it was that the transaction isolation levels in mysql do guarantee, because it surely wasn't what the ANSI SQL spec required
Mar 03 13:14:02 <Widdershins>	darkling: maybe but you'd be surprised
Mar 03 13:14:29 <bertptrs>	Found it, this one https://jepsen.io/analyses/mysql-8.0.34
Mar 03 13:14:30 <Widdershins>	mysql doesn't even have reliable prepared statements in the latest version
Mar 03 13:14:36 <gastus_>	Widdershins: If you have use cases such as sales with different use currencies. I mean you either can have struct {EUR: currency, USD: currency} or a hash lik thing. Now you want to store and sum in database ? What's the best way to share such datatype with a database without having to implement sum multiple currencies twice ?
Mar 03 13:14:41 <Widdershins>	and they're not going to fix it
Mar 03 13:15:21 <Widdershins>	gastus_: sum numeric values grouped by currency
Mar 03 13:15:54 <Widdershins>	if you want the conversions that combine them to happen inside the database too, no you don't
Mar 03 13:21:21 <bertptrs>	I try to actively fight including currency conversions in my code. the finance guys can figure that one out
Mar 03 13:24:02 <gastus_>	I had in mind writing something like a booking platform for campers. And for tihs and others reasons I thought it would be fun to have documents with history builtin. So that wehn merges happens (offline usage) you know what changed and can guide conflict resolution. Kind of key/value store with git like history. So you find branches, you know state last synced with server and changes by user and what
Mar 03 13:24:08 <gastus_>	has'nt been synced etc. Now with TS everything is an object. You add typing. Done. With Rust ? Now how to store with PG ? Yes you can use JSON and query it. And you can reformat the docs to have final state and reversed history. But querying nested JSON keys kinda feels awkward. And then I wonder over and over again what if a database was a library and I could just share types with my app ? Why do I have
Mar 03 13:24:14 <gastus_>	to learn multiple programming languages and stored procedures ? You're right PG allows to create my own libraries. But then I am at the issue which is the most convenient way to package and distribute ? And that's a different story if you have a better tahn rust channel to discuss this I'd be interested in your opinion whether I am reinventing the wheel, too. Cause looking at the many github readmes (if
Mar 03 13:24:20 <gastus_>	youh ave hardawer, then otherwise, .. if you use conda otherwise pip otherwise ubuntu otherwise, ...) kinda sucks and feels like standardised glue code might be missing.
Mar 03 13:24:23 <gastus_>	And about summing -> you have to take care about rounding of database which could be different from your app.
Mar 03 13:24:56 <gastus_>	Liek PHP/JS didn't find a way to make both round the same way. I tried hard like 5+ different ways. Then I concluded Haskell like typeclasses might just fix it, but within DB? back at what if DB was a library ..
Mar 03 13:25:06 <j`ey>	this sounds quite off topoc tbh
Mar 03 13:31:21 <Widdershins>	you're storing well-structured data as json objects and wondering why it's harder to work with?
Mar 03 13:31:54 <Widdershins>	we have tools for that, it's called "having a relational schema"
Mar 03 13:32:30 <gastus_>	But they don't have history :-) So I could derive 'relational data' from it.
Mar 03 13:37:29 <Widdershins>	Wulf: as it is it looks like every thread is trying to share the whole `self` including the File. most of this will probably work if each worker has its own file handle
Mar 03 13:38:34 <gastus_>	@ Wulf Do you think its a wise idea to share a file handle across threads have each call read_exact and have it working ? To my knowledge which is limited a file handle gets loned. so if thread 10 seeks it'll gonna change location for running thread 1 ?
Mar 03 13:38:57 <Widdershins>	gastus_: it doesn't compile at all because the threads are capturing mutable self
Mar 03 13:39:17 <Widdershins>	that capture by the closure requires self to outlive static
Mar 03 13:39:51 <Widdershins>	and the fact it's mutable means it can't work at all with multiple threads
Mar 03 13:39:57 <Wulf>	gastus_: the threads don't seek the file, and reading is protected by the mutex. So there's only one read at a time.
Mar 03 13:40:50 <Widdershins>	why so many threads then
Mar 03 13:41:32 <Wulf>	Widdershins: for the hashing part.
Mar 03 13:42:02 <Wulf>	maybe I'll need to have one thread do the reading and pass blocks into hasher threads?
Mar 03 13:42:15 <gastus_>	Threads make sense if hashing is slower than loading data from disk which in the future might be the case cause they developed non volatile RAM like SSDs having speed of RAM. When they will be used by majority is a different question.
Mar 03 13:42:17 <Widdershins>	i guess i don't expect one thread's i/o to be that much faster than the hashing part
Mar 03 13:43:14 <Wulf>	I can read about 1.5 GiB from my disk, but a single thread can't hash that fast.
Mar 03 13:43:20 <Wulf>	(per second)
Mar 03 13:43:38 <Widdershins>	regardless the issue is that while you're getting the ids via the arc, you are using `self.file` without any kind of synchronization, and have a plain &mut ref to `self` captured, which must be unique
Mar 03 13:44:26 <Wulf>	any way to tell rust that my file is not mutable, while in fact, it is?
Mar 03 13:44:43 <Widdershins>	i recommend trying to make it so that the information needed for the work done by each thread is encapsulated entirely in a struct which you move deliberately
Mar 03 13:45:36 <gastus_>	Wulf: Why not use English to describe what you want to do using one sentence such as within a file witihn a region read blocks and hash each one within a thread summing up the results ? The question is interesting like if the disk is the bottleneck one thread is enough. Reading in a sequence is the fastest you can do on physical disks unless you have high fragmentation which might be the only case when
Mar 03 13:45:42 <gastus_>	asking OS to find the closest chunk which might not be worth it. Ok let's assume youh ave a RAM based disk so reading is fast and digesting is the bottleneck, then .. we're at what you try to do ?
Mar 03 13:46:06 <Widdershins>	gastus_: read_exact requires a mutable reference to the file
Mar 03 13:46:46 <Widdershins>	it's not about whether the contents of the file on disk are changing; it's about the fs::File object, in memory, having exclusive access by you which makes writes safe
Mar 03 13:47:17 <Widdershins>	but you aren't guaranteeing that only one of those references exists. quite the opposite
Mar 03 13:48:01 <Wulf>	gastus_: For now, I'm trying to create a multi-threaded file hasher. Reads must be sequential for best speed. Hashing must occur in multiple threads because otherwise that's the bottleneck.
Mar 03 13:48:08 <Alexendoo>	It requires &mut access to the thing that implements Read, &File does implement Read so you don't strictly need exclusive access to File since &mut &File works
Mar 03 13:48:35 <Widdershins>	Alexendoo: ah
Mar 03 13:48:39 <Alexendoo>	It may or may not be a bad idea to use
Mar 03 13:48:51 <Widdershins>	i think then that leaves just the lifetime issue then
Mar 03 13:49:18 <Widdershins>	in that this is capturing references and then starting in a thread, which isn't allowed
Mar 03 13:49:26 <Widdershins>	that might have to be an rc
Mar 03 13:50:33 <Widdershins>	https://doc.rust-lang.org/std/thread/fn.spawn.html requires that the closure be 'static
Mar 03 13:54:41 <Alexendoo>	since all the handles are being joined std::thread::scope would be a choice
Mar 03 13:56:25 <gastus_>	@ Wulf after 3 chat gpt iterations you end up with https://dpaste.com/6YTFRSV5C but I am still new to rust. But if you look at such code and move the file reading part up before caling into_par_iter would this just be clean readable code getting the job done ?
Mar 03 13:57:07 <gastus_>	The question I don't know yet wether into_par_iter will consume all items before starting or will start as fast as the items arrive.
Mar 03 13:59:12 <Alexendoo>	That wouldn't compile, but rayon is probably what I would use here. Create a synchronous iterator of chunks and then use rayon to process in parallel
Mar 03 13:59:19 <gastus_>	So typicall such eventually could be done with pipes and back pressure. Eg the thread pool saying 'all busy, don't deliver more items' But not sure what's the right Rust library for that.
Mar 03 14:00:58 <gastus_>	https://medium.com/@polyglot_factotum/rust-concurrency-a-streaming-workflow-served-with-a-side-of-back-pressure-955bdf0266b5 is from 2020 might be an alternative read to get an idea.
Mar 03 14:09:57 <gastus_>	@ Wulf tokio might lead to code looking something like this :  https://dpaste.com/GCPTUAYHD   And now you have abstracted away the multi threading part, you have eventually (unchecked) back pressuring and this all is done by tokio / async code which handles the waiting nicefully for you. Not saying its the perfect solution yet. But gives you some ideas. Now the feeding and receiving results is still
Mar 03 14:10:03 <gastus_>	lacking some abstraction. There might be some .async_map_paralell_iter() whatever ? But you might have the properties you want the main thread reading the bytes, handing the mover to the pool doing teh work and getting back the results.
Mar 03 14:11:01 <dav1d>	can you stop with this chat gpt garbage?
Mar 03 14:12:00 <gastus_>	dav1d: Can yout tell me what's garbage about the idea of using iterator, having bytes, backpressure and using async ? Sry truly believed it would be a nice way to turn the task into readable code.
Mar 03 14:12:49 <dav1d>	gastus_, the code is garbage, just look at `receive_chunk`. If you want to help someone but not write the code, then describe the algorithm or behaviour, don't add garbage code to it that will confuse and mislead readers.
Mar 03 14:14:05 <Alexendoo>	also tokio to read one file is kinda pointless
Mar 03 14:15:13 <Wulf>	gastus_: there are lots of subtle bugs. Usually the last block is smaller than the block size. My code handled this, the GPT one doesn't. And I need to use the block hashes as they are computed (and in order). The GPT code collects them all, which means e.g. unbounded memory usage.
Mar 03 14:16:02 *	dav1d thinks copy pasting from chat gpt should be a bannable offense 
Mar 03 14:16:03 <Wulf>	Alexendoo: I will probably use tokio. The finished program will be a client/server model where one server can handle multiple clients and files.
Mar 03 14:17:01 <dav1d>	Wulf, you might still want to consider a separate thread (pool) for CPU bound work. Also file io just uses a blocking thread behind the scenes anyways
Mar 03 14:17:41 <gastus_>	Let me try showing pseudo code :-) which I think is very readable cause it talks about what it does: https://dpaste.com/6DFNHMB97 Whether it can be done with what version of Tokio or similar I lack experience yet.
Mar 03 14:18:48 <gastus_>	https://dpaste.com/5473YVRCA (indentation fixed sry)
Mar 03 14:19:58 <gastus_>	line 14 should be using do_work
Mar 03 14:24:21 <gastus_>	Wulf: That's why I said there is some abstraction missing on top. Like passing the idx for ordering or such. And the last pseudo code would allow to put a buffering stream component in between in case IO turns busy you have like 10 blocks in memory to continue processing cause CPU /calculation might be the bottlenick. Could all be overkill though.
Mar 03 14:26:06 <Wulf>	Learning rust is hard. I'll go for a walk.  Thanks so far!
Mar 03 14:53:50 <gastus_>	@Wulf https://users.rust-lang.org/t/does-async-have-a-notion-of-priority/81199 mind the link to "Reducing tail latencies with automatic cooperative task yielding". Wanting to say if you run multiple 'hashing' reqeusts the rest might suffer (?). I've been wondering about prioritizing about JS Promises / networking / Quic etc, too. According to changelog (nov 27 2023) nothing has been added (?).
**** BEGIN LOGGING AT Mon Mar  4 04:37:44 2024

Mar 04 04:37:43 *	Now talking on ##rust
Mar 04 04:37:43 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 04 04:37:43 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** BEGIN LOGGING AT Mon Mar  4 04:39:41 2024

Mar 04 04:39:41 *	Now talking on ##rust
Mar 04 04:39:41 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 04 04:39:41 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Mar 04 08:35:03 <gastus>	Wulf:     let (tx, mut rx) = mpsc::channel::<u8>(10);
Mar 04 08:35:27 <gastus>	Is all you need you can send async/sync to it and it keeps eg 10 items thus once you filled those 10 will apply backpressure.
Mar 04 11:02:18 <neiluj>	Hiu! Getting the following error for a call to a derive macro: https://bpa.st/AFFA. I'm hesitating between implementing the CanonicalSer/Deser trait for the entire struct or only the E::G1Prepared types, though they would then have to be wrapped in a new struct
Mar 04 11:02:59 <neiluj>	which option (or other option) you think is best in terms of easy to write?
Mar 04 11:20:04 <neiluj>	went with a new struct with serializable types only and a function to map the previous struct to the serializable one
Mar 04 11:20:13 <neiluj>	let's keep it simple
Mar 04 11:48:24 <elichai2>	Is it possible to tell `#[tracing::instrument]` to use the Display impl for the arguments?
Mar 04 11:52:23 <dav1d>	elichai2, yes, by using %field
Mar 04 11:52:34 <dav1d>	elichai2, https://docs.rs/tracing/latest/tracing/#recording-fields
Mar 04 11:53:05 <jbg>	yes, verbosely
Mar 04 11:53:15 <jbg>	skip_all and then %field for each field
Mar 04 11:53:19 <elichai2>	got it, i'll skip all and manually add back
Mar 04 14:08:14 <nlaerema>	hello
Mar 04 14:09:55 <bertptrs>	o/
Mar 04 15:13:52 <alip>	> warning: dropping unsupported crate type `cdylib` for target `x86_64-unknown-linux-musl`
Mar 04 15:14:07 <alip>	can i somehow force it to build a dylib or is there just no way?
Mar 04 15:14:21 <alip>	i mean without installing a glibc toolchain
Mar 04 15:15:30 <alip>	and/or is there a way to detect this so i can skip tests that dep on the cdylib?
Mar 04 15:22:40 <alip>	ah nvm figured it out, building with distro rustc works
Mar 04 15:41:10 <jbg>	alpine has a patch that changes the musl target
Mar 04 15:41:21 <jbg>	so if your distro is alpine or alpine based, that's why it works
Mar 04 15:42:11 <jbg>	rust made the questionable early decision to make -unknown-linux-musl targets default to enabling the crt-static target feature, i think because they were focused on the use-case of making 0-dependency binaries
Mar 04 15:42:30 <jbg>	you can probably build with standard rustc if you disable the crt-static target feature
Mar 04 16:06:26 <alip>	thanks for the explanation
Mar 04 16:37:57 <dav1d>	Can I have iter.any or iter.all which separately tells me wether the iterator was empty?
Mar 04 16:38:10 <dav1d>	Cause I need the exact opposite behaviour of any/all
Mar 04 16:38:20 <dav1d>	all but if it's empty return false
Mar 04 16:40:57 <phy1729>	Just curious why do you need that? all of nothing being true preserves monoidish properties
Mar 04 16:43:40 <dav1d>	phy1729, I have an iterator of matching limits, I want to drop a certain item if all of the limits are "passive" (just a bool), but I need to keep it if there is no matching limit
Mar 04 16:44:59 <dav1d>	I could do peekable and then check for empty I guess
Mar 04 16:45:03 <dav1d>	but not sure if that's better
Mar 04 17:03:52 <bertptrs>	any does return false if the iterator is empty
Mar 04 17:04:35 <bertptrs>	since existance on the empty set is always false, and universality on the empty set is always true
Mar 04 17:31:34 <Ademan>	is there a good way to make an iterator own some data? I produce some owned data down in a flat_map(), something like `flat_map(|x| { let y = calculate(x); z.thing_that_produces_another_iterator(&y) }` and it needs to live as long as the iterator itself (or at least, the relevant parts of the flat mat?)
Mar 04 17:33:34 <phy1729>	Maybe turn it into an Iterator of Iterators and then flatten?
Mar 04 17:38:26 <bertptrs>	Ademan: add a move to that closure?
Mar 04 17:45:11 <Ademan>	isn't y already owned by that closure since it's scoped to it? hrm, this is pretty difficult I think, I couldn't even make like a `struct OwningIterator<T, U, I: Iterator<Item=U> { owned: T, iter: I }` to bundle them together since it would be self referential
Mar 04 18:22:49 <bertptrs>	ah I misread something, you construct y and then borrow it for your inner iterator
Mar 04 18:25:01 <polychromata{J}>	dav1d: you can fold() it
Mar 04 18:39:57 <dav1d>	bertptrs, any is the same as all, if I use any I need to invert the condition, which means I need to invert the result, same problem
Mar 04 18:40:03 <dav1d>	polychromata{J}, try_fold right?
Mar 04 18:40:13 <dav1d>	I want to short circuit
Mar 04 18:40:29 <polychromata{J}>	ah, yeah, you're right.
Mar 04 18:41:19 <dav1d>	My "solution" https://p.dav1d.de/8Yl.rs
Mar 04 18:41:27 <dav1d>	I have yet to test it (keep getting side tracked)
Mar 04 18:42:37 <bertptrs>	Oh I have an even worse idea, thanks for reminding me of filter()
Mar 04 18:43:19 <dav1d>	lol
Mar 04 18:43:31 *	dav1d waits in anticipation
Mar 04 18:47:04 <bertptrs>	https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=057e53c5c9ba1e698b21b0b94bd47ec5
Mar 04 18:47:27 <bertptrs>	using find_map instead of find so the closure can take by value
Mar 04 18:48:05 <dav1d>	lol
Mar 04 18:48:24 <dav1d>	I might just use that and confuse everyone, love it
Mar 04 18:49:40 <bertptrs>	It works and it short circuits, those were my requirements
Mar 04 18:53:55 <dav1d>	yeah, it's a pretty smart solution, I did think of using find() but discarded it because I never thought about inverting the condition and then checking for none
Mar 04 18:54:34 <polychromata{J}>	evalr: use std::ops::ControlFlow::{self, *}; fn check<I: Iterator<Item = u128>>(iter: I) -> Option<ControlFlow<bool>> { iter.try_fold(None, |o, n| if n < 159936340279099635845489784282289365899 { Some(Continue(true)) } else { Some(Break(false)) }) }
Mar 04 18:54:35 -evalr/##rust-	polychromata{J}: error[E0271]: type mismatch resolving `<Option<ControlFlow<bool, ...
Mar 04 18:54:36 -evalr/##rust-	polychromata{J}: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=6d4fe0ec41b0c4d5313de7b59fd7ef57
Mar 04 18:58:38 <dav1d>	`159936340279099635845489784282289365899` that's a big number :D
Mar 04 18:59:57 <int-e>	close to 2^127 hmm and not prime.
Mar 04 19:12:09 <polychromata{J}>	evalr: use std::ops::ControlFlow::{self, *}; fn check<I: Iterator<Item = u128>>(iter: I) -> Option<bool> { iter.try_fold(None, |o, n| if n < 159936340279099635845489784282289365899 { Continue(Some(true)) } else { Break(Some(false)) }) } check([].into_iter())
Mar 04 19:12:11 -evalr/##rust-	polychromata{J}: error[E0308]: mismatched types ...
Mar 04 19:12:12 -evalr/##rust-	polychromata{J}: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=cbf42709499938b8cd2878de88126743
Mar 04 19:13:15 <polychromata{J}>	ah, yeah, and then you have to flatten the `ControlFlow<T, T>`
Mar 04 19:14:24 <dav1d>	int-e, do you have all primes up to 2^127 in your head? :p
Mar 04 19:14:44 <polychromata{J}>	evalr: use std::ops::ControlFlow::*; fn check<I: Iterator<Item = u128>>(iter: I) -> Option<bool> { let short_circuit = iter.try_fold(None, |o, n| if n < 159936340279099635845489784282289365899 { Continue(Some(true)) } else { Break(Some(false)) }); match short_circuit { Continue(value) | Break(value) => value } } check([].into_iter())
Mar 04 19:14:46 -evalr/##rust-	polychromata{J}: error[E0596]: cannot borrow `iter` as mutable, as it is not decl ...
Mar 04 19:14:47 -evalr/##rust-	polychromata{J}: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=a4520d439000162fedf13b8f27c3bcc9
Mar 04 19:14:53 <polychromata{J}>	for Celestia's sake
Mar 04 19:14:59 <bertptrs>	I don't know about them but factor is in coreutils
Mar 04 19:15:33 <polychromata{J}>	evalr: use std::ops::ControlFlow::*; fn check<I: Iterator<Item = u128>>(mut iter: I) -> Option<bool> { let short_circuit = iter.try_fold(None, |_, n| if n < 159936340279099635845489784282289365899 { Continue(Some(true)) } else { Break(Some(false)) }); match short_circuit { Continue(value) | Break(value) => value } } check([].into_iter())
Mar 04 19:15:35 -evalr/##rust-	polychromata{J}: None
Mar 04 19:15:37 <polychromata{J}>	there
Mar 04 19:15:46 <dav1d>	bertptrs, :o that's neat!
Mar 04 19:16:38 <int-e>	Hmm `factor` used to be limited to 64 bits or so, so I trained myself to use pari/gp instead.
Mar 04 19:17:16 <int-e>	(which has a factor() function)
Mar 04 19:17:26 <dav1d>	polychromata{J}, I appreciate the solution but if that's not hidden away in a dusty module it's quite ugly :p
Mar 04 19:17:46 <bertptrs>	I used to use it for programming contests and those rarely need primes larger than that
Mar 04 19:18:27 <polychromata{J}>	dav1d: it would be a lot nicer if there was a ControlFlow::merge(), yeah c.c
Mar 04 19:18:41 <polychromata{J}>	huh, Result doesn't have such a method either
Mar 04 19:18:53 <polychromata{J}>	though you can at least do `.unwrap_or_else(identity)`
Mar 04 19:19:23 *	polychromata{J} would probably just write an extension providing merge()
Mar 04 19:19:27 <polychromata{J}>	(bikeshed the name)
Mar 04 19:20:07 <polychromata{J}>	â€¦or you could package the whole thing up into an extension on Iterator providing maybe_any() and maybe_all() :P
Mar 04 19:20:18 <polychromata{J}>	since that's what you really want, after all
Mar 04 19:22:39 <dav1d>	actually surprised there isnt anything in Itertools ðŸ¤”
Mar 04 19:23:16 <dav1d>	I guess find_or_first would simplify bertptr_s' solution a bit
Mar 04 19:25:21 <polychromata{J}>	find_or_first() wouldn't distinguish the empty case though
Mar 04 19:26:34 <dav1d>	polychromata{J}, on empty it would return None right?
Mar 04 19:26:46 <dav1d>	otherwise it always returns an element
Mar 04 19:26:56 <dav1d>	actually maybe doesn't even make it easier
Mar 04 19:26:57 <polychromata{J}>	oh right
Mar 04 19:27:05 <polychromata{J}>	it doesn't distinguish the /other two/ cases from each other.
Mar 04 19:28:26 <polychromata{J}>	wow itertools sure has a lot of methods
Mar 04 19:28:31 <polychromata{J}>	this is more than i remember, too
Mar 04 19:34:12 <dav1d>	yeah, e.g. I dont remember ever seeing the position_min/max/... ones
Mar 04 19:34:38 <dav1d>	nvm they exist since at least 0.9
Mar 04 20:24:25 <edgimar>	What is the best practice related to specifying a consistent version of a crate for use across a cargo workspace.  I have a workspace where one of the crates has a cdylib target that is a facade for functions in several of the other crates.  Is there a good way to ensure that when there is more than one crate that shares the same dependency, the dependencies use the same version?
Mar 04 20:26:20 <polychromata{J}>	cargo tries to do that automatically. but sometimes crates in the dependency tree depend on incompatible versions of the same crate, and those of course can't be unified
Mar 04 20:26:39 <bertptrs>	there are workspace dependencies too, where every crate in the workspace gets a certain dependency
Mar 04 20:26:45 <dav1d>	edgimar, if the versions are semver compatible then they will use the same version, if they aren't then I can't think of anything better than checking the Cargo.lock for duplicates or using cargo tree
Mar 04 20:27:20 <bertptrs>	https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#inheriting-a-dependency-from-a-workspace
Mar 04 20:31:59 <edgimar>	bertptrs: thanks, that looks promising.  Maybe unrelated, but I'm trying to diagnose a strange error that just started happening when trying to build, but I can't determine what change would be repsonsible for it:  there are several error messages "cannot find macro println in this scope" for a crate I'm depending on (rstar) - I'm not getting any traceback, besides the line in the rstar code with
Mar 04 20:32:01 <edgimar>	the println! - wasn't seeing these before, so I'm confused about what I might have changed in my code that would cause that error to occur.
Mar 04 20:32:56 <bertptrs>	edgimar: are you by chance doing a no_std build on a crate that doesn't support it
Mar 04 20:36:09 <edgimar>	That would have required changing something in a Cargo.toml file I assume?  I am not building any differently than before.  I did add an nalgebra = "*" dependency in one of my crates where rstar was already a dependency - hm. maybe a clue?
**** BEGIN LOGGING AT Tue Mar  5 07:39:52 2024

Mar 05 07:39:50 *	Now talking on ##rust
Mar 05 07:39:50 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 05 07:39:50 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Mar 05 08:15:13 <daddy>	Oh, bindgen enables runtime as a default feature, and *insert every sys crate in my stack* uses bindgen with default features
Mar 05 08:40:25 <daddy>	Is there a way I can build `build.rs` files with a set of RUSTFLAGS that are separate from RUSTFLAGS used on non-build.rs ?
Mar 05 09:26:06 <Arnavion>	Yes, by not using RUSTFLAGS. Use target.rustflags in .cargo/config.toml instead
Mar 05 09:35:35 <daddy>	target.<cfg>.rustflags ? what would I use for `cfg()` ?
Mar 05 09:36:22 <daddy>	I don't think <triple> gives me any way to specify build.
Mar 05 09:41:09 <daddy>	I'm building on the same system I'll be running it on so I can't specify different triples.
Mar 05 12:27:33 <elichai2>	is there a way with tracing::instrument to bypass rust's fmt machinery and use something faster?
Mar 05 12:32:49 <osse>	elichai2: to log the files, e.g. args to functions you meaÇ¹?
Mar 05 12:33:36 <elichai2>	osse: yes, ideally with things like `#[instrument(field(...))]` and `tracing::debug!(...)`
Mar 05 12:33:47 <elichai2>	but the debug/info etc macros I can replace with my own
Mar 05 12:34:04 <osse>	elichai2: if it's your own type i suppose you can implement the Value trait yourself
Mar 05 12:34:47 <elichai2>	osse it is Sealed though: https://docs.rs/tracing/latest/tracing/trait.Value.html
Mar 05 12:35:41 <osse>	huh
Mar 05 12:35:46 <osse>	I don't know, then
Mar 05 12:35:55 <osse>	the Visit trait isn't, but I don't know if that helps
Mar 05 12:37:00 <elichai2>	but the visitor will still call `record_debug`
Mar 05 12:37:14 <elichai2>	maybe if I directly use the `valuable` crate I could do it
Mar 05 12:40:17 <osse>	yeah but it's up to use to implement it
Mar 05 12:40:34 <osse>	I figured you could avoid the implementation of Debug inside it somehow
Mar 05 12:52:56 <dav1d>	Ignoring endianness issues etc. Am I even allowed to transmute &[f64] to &[u8]?
Mar 05 12:53:42 <dav1d>	I guess slice length would break, so from_raw_parts ðŸ¤”
Mar 05 12:57:21 <neiluj>	Hey! Trying to implement the Serialize/Deserialize trait for a type implementing the following trait: https://docs.rs/ark-serialize/latest/ark_serialize/trait.CanonicalSerialize.html
Mar 05 12:57:34 <elichai2>	dav1d: no, the length would not match
Mar 05 12:57:40 <neiluj>	not sure how to turn the writer into a serializer
Mar 05 12:57:50 <elichai2>	you need to deconstruct the slice, multiply the length, and construct a new slice
Mar 05 12:58:25 <dav1d>	elichai2, yeah, see my second sentence. looking at bytemuck, it should be safe https://docs.rs/bytemuck/latest/src/bytemuck/internal.rs.html#353-372
Mar 05 12:58:37 <dav1d>	but probably should just use bytemuck in the first place
Mar 05 12:58:41 <elichai2>	yep, f64 has no padding
Mar 05 12:58:49 <elichai2>	so if it's initialized it's safe to read as u8
Mar 05 12:59:05 <elichai2>	all primitives except `bool` don't have paddings
Mar 05 12:59:15 <dav1d>	and alignment is fine, since u8. The other way probably is not fine
Mar 05 12:59:23 <dav1d>	right?
Mar 05 12:59:32 <dav1d>	&[u8] -> &[f64]
Mar 05 13:00:17 <elichai2>	yep
Mar 05 13:00:26 <elichai2>	the other way you need to check and offset alignment
Mar 05 13:01:00 <dav1d>	Thanks! Always good to have a second opinion on this
Mar 05 13:02:21 <elichai2>	always run your unsafe code through miri ;)
Mar 05 16:48:56 <jess>	if i'm casting from a u64 and a u32 and would like it to overflow, is there a more correct way to do it that tells clippy that overflow is desired?
Mar 05 16:49:03 <jess>	from a u64 to a u32*
Mar 05 16:51:01 <jess>	for context this is for using a u64 siphash as an array index usize for a bloom filter, so overflow is not really a problem for me. it'll get modulo too regardless
Mar 05 16:51:35 <bertptrs>	you can #[allow(clippy::cast_possible_wrap)] but by default Clippy already allows those
Mar 05 16:51:50 <jess>	i'm on clippy pedantic
Mar 05 16:52:27 <bertptrs>	or #[allow(clippy::cast_possible_truncation)] which is more correct imo
Mar 05 16:52:35 <jess>	just thought there might be some magic function or trait that is "cast this with wrapping please" that would satisfy clippy
Mar 05 16:55:45 <danieldg>	maybe clippy could learn that (some_u64 & 0xFFFF_FFFF) as u32 can't truncate?
Mar 05 16:56:41 <jess>	^ no implementation for `u64 & u32`
Mar 05 16:56:42 <danieldg>	not sure if doing constant-propagation to make that rule nicer is beyond clippy or not
Mar 05 16:56:43 <jess>	boo sadface
Mar 05 16:57:01 <danieldg>	well yes, you have to upcast the mask
Mar 05 16:57:11 <danieldg>	or, you know, literals
Mar 05 16:57:30 <bertptrs>	you're missing the point, & could automatically downcast since the result should be equivalent
Mar 05 16:57:59 <bertptrs>	uX & u32 fits in an u32 regardless of X
Mar 05 16:58:21 <bertptrs>	but automatic conversions are badâ„¢ so I'm happy it doesn't work lioke that
Mar 05 16:58:21 <jess>	yes, indeed
Mar 05 16:58:23 <danieldg>	right.  The bitwise and/or ops could easily be implemented for arbitrary sizes
Mar 05 16:58:29 <jess>	but the compiler doesnt seem to know it
Mar 05 16:59:11 <danieldg>	I think libcore could impl it
Mar 05 16:59:25 <danieldg>	but it'd probably break things if you do it now
Mar 05 16:59:26 <jess>	i can apparently right shift a u64 to a u32
Mar 05 16:59:37 <danieldg>	I don't think you can
Mar 05 16:59:44 <bertptrs>	you can shift any int with any other int for some reason
Mar 05 17:00:01 <danieldg>	isn't it only u32 and maybe u8 on the rhs of the shift?
Mar 05 17:00:08 <danieldg>	or maybe usize?
Mar 05 17:00:25 <jess>	oh, im reading the impl wrong
Mar 05 17:00:41 <bertptrs>	danieldg: no pretty much everything https://doc.rust-lang.org/std/primitive.u128.html#impl-Shl%3C%26i128%3E-for-%26u128
Mar 05 17:00:49 <danieldg>	huh
Mar 05 17:02:00 <bertptrs>	there's no reason it works like this, but there is also no reason it shouldn't work so they just did it
Mar 05 17:02:20 <danieldg>	I guess it's not symmetric, so there's no gain from trying to propagate types through it
Mar 05 17:03:23 <danieldg>	for | you could have takes_u64(x | y) and it'd end up inferring both x and y are u64 now, but if widening or happens then y could easily get inferred to be i32
Mar 05 17:03:29 <danieldg>	or maybe u32
Mar 05 17:16:25 <gastus_>	I want to store pointers to vecs which I eventually want to remove (set to NULL). Now I could be using Option but will take more memory. Would it make sense to have special Option<> type for pointers if they are NULL meaning "no value" so not having to use an enum ?
Mar 05 17:17:04 <j`ey>	gastus_: do you mean pointers or references?
Mar 05 17:17:10 <j`ey>	*const T or &T?
Mar 05 17:17:56 <danieldg>	gastus_: std::ptr::NonNull
Mar 05 17:18:18 <danieldg>	references already do it
Mar 05 17:18:54 <danieldg>	Option<NonNull> or Option<&T> are guaranteed to fit in a usize
Mar 05 17:18:59 <bertptrs>	danieldg: Option<&T> and *const T have the same size
Mar 05 17:19:45 <rendar>	i always wondered something, if i have `fn myfn(&self) {   for i in &self.data { .. }  .. }`  <- why here we have to use &self.data, if self is already of &Self type ?
Mar 05 17:19:49 <j`ey>	but not Option<*const T>
Mar 05 17:20:06 <danieldg>	rendar: self is the object
Mar 05 17:20:08 <bertptrs>	rendar: because otherwise self.data would attempt to move out of self, which it can't
Mar 05 17:20:34 <bertptrs>	and if it can, you might not want it to
Mar 05 17:21:12 <rendar>	bertptrs, ok, right, so it's just a further notation to remark the user: look you're traversing and not moving out
Mar 05 17:21:35 <rendar>	it would be very messy code in the other way, indeed
Mar 05 17:22:05 <bertptrs>	well you could move data out of self and then traverse it, which does something different, but unless data is Copy you can't
Mar 05 17:22:46 <danieldg>	"let Self { data, .. } = self; for i in data { .. }" does the same thing as &self.data
Mar 05 17:22:58 <rendar>	oh right
**** BEGIN LOGGING AT Tue Mar  5 18:13:43 2024

Mar 05 18:13:42 *	Now talking on ##rust
Mar 05 18:13:42 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 05 18:13:42 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Mar 05 18:38:03 <n1>	 is here a way how to tell compiler that a method should be included only for "lib" use? i mean the #[cfg...
Mar 05 18:38:36 <segfaultfizzbuzz>	suggestions for a rust library for transforming markdown into an html form, or for a markdown parser which i could easily extend (as a bad programmer) to have form elements?
Mar 05 18:39:40 <j`ey>	n1: what do you mean for 'lib' use?
Mar 05 18:39:57 <j`ey>	if it's part of a non-binary crate, it's always for a library?
Mar 05 18:40:38 <n1>	j`ey: i use my rust app as a dependency in another project - i suppose it turns into a "lib" mode (dunno how to phrase it better) when tne intrypoint in lib.rs instead of main.rs
Mar 05 18:41:28 <j`ey>	n1: yes
Mar 05 18:42:12 <n1>	the thing is this... i have a method that is not used in binary mode (thus i get unused warning) but it's used in lib mode
Mar 05 18:42:17 <n1>	does if make sense j`ey ?
Mar 05 18:42:21 <n1>	it*
Mar 05 18:42:33 <j`ey>	n1: what file is that method in?
Mar 05 18:43:27 <n1>	src/config.rs
Mar 05 18:43:56 <j`ey>	n1: and you have mod config in src/lib.rs?
Mar 05 18:44:39 <n1>	yes
Mar 05 18:44:49 <n1>	pub mod config; to be exact
Mar 05 18:44:59 <n1>	re-export
Mar 05 18:45:16 <danieldg>	n1: you should *not* have 'mod config' in main.rs then
Mar 05 18:45:30 <danieldg>	you should 'use yourcrate::config' in main.rs
Mar 05 18:45:55 <JordiGH>	Hey, any of you use Prisma? What are your impressions? I'm trying to find a fun Rust project to work on that people enjoy using and care about. Prisma came to mind, but I'm not sure if it's loved or not.
Mar 05 18:46:09 <n1>	danieldg: i need that line there because i use that file in both modes - only one particular method is not used in binary mode
Mar 05 18:47:13 <j`ey>	n1: no dont have mod config in main.rs
Mar 05 18:47:22 <j`ey>	n1: you should 'use' the library crate from the binary one
Mar 05 18:49:54 <n1>	im lost ... i removed the "mod config;" line from my main.rs - now im getting tons of errors of "unresolbed import"
Mar 05 18:50:15 <danieldg>	n1: remove all 'mod' lines in main.rs
Mar 05 18:50:22 <j`ey>	'use <yourcratename>::config;'
Mar 05 18:50:23 <danieldg>	unless the module is only for the binary
Mar 05 18:52:26 <n1>	j`ey: done - but now im getting another couple of errors that weren't there before
Mar 05 18:52:55 <j`ey>	tell us, and we can help fix it
Mar 05 18:52:58 <j`ey>	otherwise, we cant :P
Mar 05 18:55:21 <n1>	sure ... but that seems like a random error of "cannot fined a method from a trait" or value of this type cannot be build from that type
Mar 05 18:55:34 <n1>	looks like someone just f'ked my code :)
Mar 05 18:56:01 <danieldg>	n1: if you are still duplicating 'mod' lines, then you'll get that
Mar 05 18:56:18 <danieldg>	because you will define two different types with the same name
Mar 05 18:56:29 <n1>	so i guess the real question is what the "substitude 'mod config' with 'use <cratename>::config;'" really does
Mar 05 18:57:05 <danieldg>	it removes the duplication
Mar 05 18:57:37 <n1>	https://dpaste.com/B6LW487LG head of my main file before the errors
Mar 05 18:57:56 <n1>	once i comment out line 3 and uncommet line 10 i get the errors
Mar 05 18:58:14 <danieldg>	... read what I said
Mar 05 18:58:19 <danieldg>	17:50:15 < danieldg> n1: remove all 'mod' lines in main.rs
Mar 05 18:58:45 <n1>	just like that? not needed anymore?
Mar 05 18:59:01 <danieldg>	you may need to replace them with 'use' lines
Mar 05 18:59:31 <n1>	okay i didnt get that
Mar 05 18:59:33 <n1>	will try
Mar 05 19:01:16 <n1>	https://imgur.com/a/1EZ6H4c
Mar 05 19:01:26 <n1>	even worse lol
Mar 05 19:02:03 <danieldg>	no, you now have a TODO list for fixing your lib
Mar 05 19:02:15 <danieldg>	make things you need public, or remove the use if you don't need it
**** BEGIN LOGGING AT Tue Mar  5 19:05:32 2024

Mar 05 19:05:30 *	Now talking on ##rust
Mar 05 19:05:30 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 05 19:05:30 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Mar 05 19:07:14 <n1>	that sounds like "to make that one particular method hidden from bin-mode you have to rewrite all the imports"
Mar 05 19:07:20 <n1>	thats nuts to me
Mar 05 19:08:06 <danieldg>	the problem is that the way you were doing it was wrong
Mar 05 19:08:32 <danieldg>	it worked, but you had two copies of your code
Mar 05 19:08:39 <n1>	what exactly was wrong? i was acting based on tutorials where every part of my app needs to be "mod"ed
Mar 05 19:09:01 <n1>	>two copies of your code - what do you mean exactly?
Mar 05 19:09:04 <danieldg>	that's true if you only have a main.rs
Mar 05 19:09:08 <danieldg>	or only a lib.rs
Mar 05 19:09:23 <danieldg>	having both means you're making two crates, one that depends on the other
Mar 05 19:10:13 <spb>	you put all of your library code into the library crate. you make your binary crate depend on the library crate. things in the library that aren't used by the binary are not dead code because they're exported from the library
Mar 05 19:10:19 <spb>	it's quite simple
Mar 05 19:12:02 <n1>	okay so instead of one monolith i need to separate (it is but probably imported wrongly) my code - right?
Mar 05 19:13:09 <spb>	the best answer depends on what you're actually doing and the specifics of your particular design
Mar 05 19:14:49 <n1>	i guess i will just go with that one warning ig
Mar 05 19:15:26 <n1>	but ... im curious whats the difference between mod and use thing that you suggested
Mar 05 19:16:03 <danieldg>	the tutorial should tell you about them
Mar 05 19:16:08 <danieldg>	or the docs do
Mar 05 19:16:09 <n1>	my guess it's that moding hard-"imports" all the stuff but on the other hand the "use" really imports what i need
Mar 05 19:16:20 <spb>	your library and your binary are different crates. the binary implicitly depends upon the library. by writing 'mod' in both, you are including the code of those files into both crates and duplicating it
Mar 05 19:16:36 <spb>	by writing 'use' in the binary, you just refer to the version that was already built as part of the library
Mar 05 19:17:53 <n1>	makes sense
Mar 05 19:18:10 <n1>	do i need to ad some stuff to cargo too? or just update my "imports"?
Mar 05 19:18:51 <spb>	first you need to stop using "import" to refer to something that is not importing
Mar 05 19:19:28 <spb>	and no, you do not need to change anything in cargo because, as i said above, the binary crates within a project implicitly depend on the library crate
Mar 05 19:20:04 <n1>	so once a lib.rs exists the binary is suddenly dependend on the lib - right?
Mar 05 19:20:33 <spb>	yes
Mar 05 19:21:32 <n1>	maybe i got enlighted - i try it once again - the thing is i need to move all my mods to lib.rs and then use what i actually need in my main.rs - right?
Mar 05 19:21:49 <n1>	so basically my lib is the library and main comes in and says what it needs
Mar 05 19:22:10 <n1>	and the libs knows all the "books" thanks to "mod"s
Mar 05 19:22:15 <n1>	am i right?
Mar 05 19:23:33 <spb>	any code that is a part of the library should be included only in the library, i.e. a 'mod' declaration for it should appear only in lib.rs or something included from lib.rs
Mar 05 19:23:46 <n1>	right
Mar 05 19:23:48 <spb>	any code that is a part of *only* the binary, you can declare the 'mod' in main.rs
Mar 05 19:24:06 <spb>	and any code which is a part of the library and is used by the binary, you 'use' in the binary code
Mar 05 19:25:11 <spb>	note that if you have multiple modules in play, then using src/main.rs and src/lib.rs will be very confusing because you can't tell from just the folder structure whether a given module is in the lib or the bin
Mar 05 19:25:46 <n1>	the code is 99% used in binary ... actually it was 100% as long as the whole app was a cli app - now i did add a few stuff so i can use the app as a dependency and use the functionality programatically instead of from CLI - so thats why i did add a few methods which are use in "dependecy" mode only
Mar 05 19:26:47 <spb>	if you want to make the code usable as a library, then you need to go all in on the idea and make your binary just be another consumer of that library
Mar 05 19:27:11 <n1>	i see
Mar 05 19:27:16 <n1>	damn it :)
Mar 05 19:27:25 <n1>	thx for your time spb
**** BEGIN LOGGING AT Tue Mar  5 20:41:19 2024

Mar 05 20:41:19 *	Now talking on ##rust
Mar 05 20:41:19 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 05 20:41:19 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** BEGIN LOGGING AT Tue Mar  5 22:33:04 2024

Mar 05 22:33:03 *	Now talking on ##rust
Mar 05 22:33:03 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 05 22:33:03 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Mar 05 22:36:51 <nullie>	What can I do here to pass store correctly: https://gist.github.com/nullie/d5f02dcd8ae84b1b94a128ee66155984
Mar 05 23:00:51 <polychromata{J}>	nullie: not familiar with wasm, but it looks like binding is keeping the borrow of store around. Since you seem to need binding throughout, you'll have to find a way to get it to not keep the borrow past the call to exports(), or else use shared ownership of store.
Mar 05 23:03:18 <chairs>	maybe you don't need to use the same `store` everywhere? (I'm also not familiar with wasm so don't know)
Mar 05 23:06:03 <nullie>	no, it panics if you pass other store
Mar 05 23:08:17 <nullie>	I don't get why does it need store for those calls
Mar 05 23:09:19 <chairs>	another guess: maybe you're supposed to save the output of `.func()` and only use it later after `binding` has gone out of scope
Mar 05 23:10:21 <nullie>	yeah, looks like .func() result is copiable
Mar 05 23:13:32 <chairs>	s/gone out of scope/can be dropped/ # I don't think you need to play explicit scoping games here, but doing so might help with understanding the issue as usual with lifetimes
Mar 05 23:14:46 <nullie>	yeah, I have to drop binding before I can use store again
**** BEGIN LOGGING AT Wed Mar  6 01:51:38 2024

Mar 06 01:51:37 *	Now talking on ##rust
Mar 06 01:51:37 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 06 01:51:37 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Mar 06 01:59:05 <Widdershins>	danieldg: I'm curious what makes Cheri pointers and size ints different widths
Mar 06 02:00:08 <danieldg>	cheri pointers are 128 bits; they store validity information in addition to the usual 64-bit start position
Mar 06 02:02:21 <danieldg>	so technically you could just declare usize to be u128, but that's really inefficient as the maximum allocation is still well below u64::MAX
Mar 06 02:05:28 <Widdershins>	oh man it's architecturally capability-based?
Mar 06 02:32:43 <polychromata{J}>	danieldg: why so? why not just `size.next_multiple_of(align) * len`?
Mar 06 02:32:54 <polychromata{J}>	(. You broke `slice::from_ref()`.)
Mar 06 02:33:02 <polychromata{J}>	â€¦ahh
Mar 06 02:34:08 <danieldg>	yep
Mar 06 02:34:13 <polychromata{J}>	and you /could/ require padding after every allocation of a T, but at that point `{ size: 5, align: 4 }` is kind op meaningless.
Mar 06 02:34:42 <danieldg>	requiring padding after every allocation is exactly today
Mar 06 02:35:06 <danieldg>	since you can't actually use the padding, if your memcpy could overwrite it
Mar 06 02:35:16 <polychromata{J}>	yep.
Mar 06 02:36:28 <polychromata{J}>	just not worth it to save a few bytes here and there when you have some `struct(u8, u32);`s.
Mar 06 02:36:55 <danieldg>	better support for repr(packed) is about the best we could do
Mar 06 02:37:11 *	polychromata{J} nods.
Mar 06 02:37:47 <polychromata{J}>	That way, the usecases that really want to squeeze bytes out, and are okay trading cycles to get them, can make that decision.
Mar 06 02:38:29 <danieldg>	and with modern cpu and memory speeds, that's true a lot more of the time than you might think
Mar 06 02:39:40 <danieldg>	if your data is >1MB you will likely get a speedup from packing it
Mar 06 02:40:04 <danieldg>	unless you're doing a lot more compute than usual on it
Mar 06 02:57:45 <polychromata{J}>	really? huh.
Mar 06 02:57:55 *	polychromata{J} imagines a PackedVecâ€¦
Mar 06 02:58:12 <polychromata{J}>	the iterators would have to be streaming though.
Mar 06 03:00:20 <danieldg>	yes, it makes all your code ugly and doesn't work well if you want atomics or anything like that
Mar 06 03:01:22 <danieldg>	often performance isn't that critical, or you aren't actually saturating the memory bus, or other reasons
Mar 06 04:38:48 <Widdershins>	you can already get the best packing possible other than alignment overhead by just reordering fields (by descending alignment requirement), but if the fields themselves have alignment overhead the waste starts to add up
Mar 06 04:39:27 <danieldg>	yes, and that's pretty common
Mar 06 04:39:40 <Widdershins>	mhm
**** BEGIN LOGGING AT Wed Mar  6 07:16:33 2024

Mar 06 07:16:31 *	Now talking on ##rust
Mar 06 07:16:31 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: Â«codeÂ» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 06 07:16:31 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Mar 06 08:56:53 <shamelessshill>	Hello, good folks. I have a rather simple but strange question.
Mar 06 08:57:19 <shamelessshill>	So in my project, I have a bunch of crates... and I have a script that bumps up versions.
Mar 06 08:57:58 <osse>	So far so good
Mar 06 08:58:08 <shamelessshill>	So, my question is this - if my script bumps up the version in the Cargo.toml files for each of my crates, it should be fine if the same script bumps up the versions in Cargo.lock as well, yes?
Mar 06 08:58:33 <shamelessshill>	We check in Cargo.lock into version control, and the version update step is done as a separate commit (no dependencies added, etc.)
Mar 06 08:58:54 <shamelessshill>	I thought of running a build and the adding the generated Cargo.lock, but that seems like overkill?
Mar 06 08:59:47 <shamelessshill>	Otherwise right now I observe that the crate versions (my own crates) in the lockfile are falling behind the toml versions because people keep forgetting to check in the lock file (nor should they have to, imho).
Mar 06 09:00:44 <shamelessshill>	and overkill since all the changes are for my own crates (not deps) and only the version string would change to match that in the TOML file... I'm not adding any dependencies during this version bumping step.
Mar 06 09:00:48 <shamelessshill>	Thoughts?
Mar 06 09:01:18 <shamelessshill>	I thought of checksum issues, but we don't track checksums in the lock file for our own crates, do we? Only for external dependencies.
Mar 06 09:01:45 <shamelessshill>	Any other issues that come to mind?
Mar 06 09:08:54 <polychromata{J}>	shamelessshill: simplistic editing of the lockfile sounds like a good way to break things
Mar 06 09:09:33 <polychromata{J}>	do you know what happens if the lockfile specifies a crate with a version that has a dependency, but doesn't say anything about that dependency?
Mar 06 09:09:35 <polychromata{J}>	(I don't.)
Mar 06 09:09:49 <polychromata{J}>	how about `cargo generate-lockfile`?
Mar 06 09:11:03 <shamelessshill>	Hmmm
Mar 06 09:11:23 <polychromata{J}>	actuallyâ€¦isn't the overall thing you're trying to do just `cargo update`?
Mar 06 09:11:49 <shamelessshill>	It is true that right now the script is run as a separate independent "version change only" step, but that __requires__ developer discpline. You're right - I don't like the idea myself.
Mar 06 09:12:12 <shamelessshill>	polychromata{J}: Wouldn't `cargo update` update the dependencies as well?
Mar 06 09:12:21 <shamelessshill>	Even minor/patch versions, I mean.
Mar 06 09:12:29 <bertptrs>	correct, so you don't want that
Mar 06 09:12:31 <shamelessshill>	I think cago generate lockfile looks promising... polychromata{J} ... TIL
Mar 06 09:13:14 <shamelessshill>	bertptrs: Yes, indeed. Let me experiment with generate lockfile and see...
Mar 06 09:14:15 <shamelessshill>	Oops... looks like generate-lockfile also updates
Mar 06 09:14:17 <shamelessshill>	:(
Mar 06 09:18:34 <bertptrs>	so it does, that's annoying
Mar 06 09:18:49 <bertptrs>	I guess you could get awaym with `cargo check` instead of a full build?
Mar 06 09:20:07 <shamelessshill>	Actually, I found something that does appears to work: `cargo update --workspace`
Mar 06 09:20:19 <bertptrs>	that should still update deps if I read the docs?
Mar 06 09:20:24 <shamelessshill>	"--workspace Attempt to update only packages defined in the workspace. Other packages are updated only if they donâ€™t already exist in the lockfile. This option is useful for updating Cargo.lock after youâ€™ve changed version numbers in Cargo.toml.
Mar 06 09:20:28 <shamelessshill>	"
Mar 06 09:20:31 <bertptrs>	ooooh
Mar 06 09:20:32 <shamelessshill>	__Seems__ to work
Mar 06 09:20:33 <bertptrs>	that's brilliant
Mar 06 09:20:39 <shamelessshill>	Let me double-check! :)
Mar 06 09:20:45 <bertptrs>	somewhat misnamed but w/e
Mar 06 09:20:47 <shamelessshill>	bertptrs: Yeah... beautiful indeed!
Mar 06 09:20:59 <shamelessshill>	Yeah, I would never have guessed with that flag name.
Mar 06 09:21:39 <shamelessshill>	Yup... appears to work! So polychromata{J} was right after all. Hehehe.
Mar 06 09:22:13 <polychromata{J}>	â€¦that's a really bad name for that flag.
Mar 06 09:22:18 <polychromata{J}>	Good find though.
Mar 06 09:22:44 <shamelessshill>	Indeed... I only happened to even go to that doc page because the generate-lockfile docs said that `update` had more options... so pure luck!
Mar 06 09:41:33 <gastus>	I want to experiment with non utf-8 fast csv parsing and wanted to create ffi bindings to zsv now bindgen fails to find some definitions. Is it best to manually convert or is bindgen supposed to understand all header files and my configuration is incomplete ?
Mar 06 09:42:25 <bertptrs>	bindgen doesn't understand all header files, and you usually have to make it ignore things
Mar 06 09:59:53 <rendar>	in your experience, do you think exist one crate which abstracts Box<&str> and adds useful traits (e.g. From, etc) ?
Mar 06 10:00:11 <rendar>	i mean, Box<Rc<&str>>
Mar 06 10:01:04 <rendar>	i want to create |1 ptr size poiting to| --->  |ref_count|my string data|
Mar 06 10:01:50 <Mutabah>	`Rc<str>` is a fat pointer to counts and string data
Mar 06 10:01:54 <bertptrs>	That's just Rc<str>
Mar 06 10:02:00 <Mutabah>	although, maybe you'd want a string interning crate
Mar 06 10:03:06 <bertptrs>	nvm, Rc<str> is two pointer size because of the fat pointer
Mar 06 10:09:49 <rendar>	Mutabah, no, i don't want a global state to check
Mar 06 10:10:38 <rendar>	i wish to get only 1 pointer size, like a Box, but also a ref counter for cheap cloning
Mar 06 10:10:50 <rendar>	can i combine the 2 things?
Mar 06 10:11:08 <rendar>	having only 1 heap allocation that contains both ref counter and string data
Mar 06 10:12:30 <bertptrs>	Not right now, there is no nice way to create DSTs from rust
Mar 06 10:13:06 <bertptrs>	your allocation would have to store |len|rc|data|
Mar 06 10:15:29 <rendar>	bertptrs, yes sorry, i meant just that one
Mar 06 10:15:37 <rendar>	rc+len+data
Mar 06 10:15:44 <rendar>	in one unique block, isn't that possible?
Mar 06 10:16:07 <bertptrs>	Creating dsts yourself is annoying but it's not impossible I guess
Mar 06 10:16:17 <bertptrs>	You have to basically do it without language support
Mar 06 10:16:38 <rendar>	what you mean with DSTs?
Mar 06 10:16:45 <bertptrs>	dynamically sized types
Mar 06 10:16:50 <rendar>	i see
Mar 06 10:16:52 <bertptrs>	types that do not have a fixed size\
Mar 06 10:16:54 <bertptrs>	such as str
Mar 06 10:17:38 <bertptrs>	or slices
Mar 06 10:18:00 <rendar>	bertptrs, well, Box<str> is not dinamically sized type, because sizeof(Box<str>) is 8 (1 pointer size), then it allocates N bytes on heap, just like Vec<u8> which is 24 in sizeof, but then it allocates N bytes on heap, am i wrong?
Mar 06 10:18:24 <bertptrs>	wrong, sizeof Box<str> is 16
Mar 06 10:18:35 <bertptrs>	because str is a DST
Mar 06 10:18:35 <rendar>	because of the fat pointer?
Mar 06 10:18:38 <bertptrs>	Correct
Mar 06 10:18:41 <rendar>	yeah
Mar 06 10:18:46 <rendar>	what about Box<&str> ?
Mar 06 10:18:54 <bertptrs>	That one is indeed size 8
Mar 06 10:19:12 <rendar>	indeed, but Box<&str> is a pointer pointing to |len|data..| ?!
Mar 06 10:19:17 <rendar>	or just data?
Mar 06 10:19:54 <rendar>	or is a pointer pointing to |len|ptr_to_data|    which in turn points to |data..| ?
Mar 06 10:19:54 <bertptrs>	Box<&str> is pointing to an &str which is contains a length and a pointer to the data
Mar 06 10:20:12 <rendar>	so with Box<&str> i get 2 heap allocations per string?
Mar 06 10:20:30 <bertptrs>	not necessarily heap allocations (can use a static str after all) but yes two indirections
Mar 06 10:20:45 <rendar>	oh gosh :| i see
Mar 06 10:23:48 <rendar>	now i get the purpose of a crate that tried to fix this problem, and had strings of 2 pointer size
Mar 06 10:26:53 <rendar>	https://crates.io/crates/tendril
Mar 06 10:27:08 <rendar>	that's is! i found it, doesn't this crate does what i need?
Mar 06 10:28:48 <Mutabah>	Maybe it is
Mar 06 10:28:58 <Mutabah>	Depends on why you want those single-pointer strings
Mar 06 10:29:16 <Mutabah>	What you were asking for reminds me of the `RcString` type I have in mrustc (... in C++, but same idea)
Mar 06 10:29:30 <Mutabah>	A pointer to a refcount, length, and then string data
Mar 06 10:31:49 <rendar>	Mutabah, that's simple: consider a very large hasmap with strings as keys, i don't need them to be mutable, still i will spare a lot of memory not having 24 bytes for each string
Mar 06 10:32:02 <rendar>	what is mrust?
Mar 06 10:33:06 <bertptrs>	Mutabah's Rust Compiler
Mar 06 10:35:28 <rendar>	really?
Mar 06 10:40:47 <synapse>	I have a colleague who uses Result<(), ()> instead of bool. in a way, I kinda get why 'return Err(());' is more readable than 'return false;' :P
Mar 06 10:41:05 <Mutabah>	`Result` carries more semantic information than a `bool`
Mar 06 10:41:25 <Mutabah>	is `false` "operation failed" or is it "don't worry about me"?
Mar 06 10:41:36 <synapse>	yeah, it's answering a generic question
Mar 06 10:41:46 <synapse>	whereas Result<(), ()> is always whether some operation went well
Mar 06 10:56:02 <mkoncek1>	and allows ? shortcut
Mar 06 11:00:16 <Affliction>	Caller probably still needs to map_err it into something sane, but yeah, I might start using that pattern
Mar 06 11:00:37 <bertptrs>	nothing matches! can't fix
Mar 06 11:00:45 <Affliction>	true
Mar 06 11:00:45 <bertptrs>	Or just is_ok()
Mar 06 11:29:44 <kpcyrd>	I'd still use anyhow::Result<T>, then provide a simple message for bail!. the few bytes in the binary for a &'static str shouldn't hurt.
Mar 06 11:30:19 <kpcyrd>	I use anyhow::Result<()> quite often
Mar 06 12:00:02 <mkoncek1>	no method named `poll` found for mutable reference `&mut (dyn Future<Output = ()> + 'static)` in the current scope
Mar 06 12:00:29 <mkoncek1>	i have a vector of Box<dyn Future>
Mar 06 12:01:04 <mkoncek1>	also, should i be using PollFn instead?
Mar 06 12:01:14 <dav1d>	Is there a nice way to just take the first item from a &mut [T]?
Mar 06 12:01:58 <dav1d>	`take_first` is of course nightly
Mar 06 12:02:18 <bertptrs>	split_at_mut can kind of do it but it's not perfect
Mar 06 12:02:19 <dav1d>	guess I'll just have to do split_first :(
Mar 06 12:02:28 <bertptrs>	oh split_first too
Mar 06 12:03:52 <dav1d>	aight thanks
Mar 06 12:03:54 <bertptrs>	mkoncek1: is the Future trait in scope? Not sure if it's part of the prelude
Mar 06 12:07:08 <mkoncek1>	oh right, poll is not a member function
Mar 06 12:07:17 <mkoncek1>	fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;
Mar 06 12:07:25 <mkoncek1>	the first arg is not a reference to self
Mar 06 12:25:41 <bertptrs>	No it's a pin, because the requirements for Future are slightly stronger. poll is a member though
Mar 06 12:26:17 <bertptrs>	Members are allowed to take Pin, Arc, Rc, Box, or any combination of them as their self
Mar 06 12:42:01 <mkoncek1>	really? didn't know about that
Mar 06 12:42:23 <Widdershins>	and don't forget native references that counts too
Mar 06 12:42:45 <Widdershins>	altho idk how much you can layer it actually
Mar 06 12:44:19 <Widdershins>	&&self isn't allowed, but self: &Box<Self> is
Mar 06 12:44:41 <Widdershins>	i guess that's 'cause && just decays to &
Mar 06 12:44:42 <spb>	https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=90eec5e4a7a77b0663fd3db944c5a929
Mar 06 12:44:59 <spb>	`a.foo()` doesn't compile in that case
Mar 06 12:45:26 <Widdershins>	ah you can do it then it just doesn't let you implicitly type it like &self
Mar 06 12:46:24 <spb>	i'm not sure in what situation this would be useful, mind
Mar 06 12:46:40 <Widdershins>	ok yeah even deranged types like &Rc<&Box<&&Self>> are allowable for method receivers. but yeah not very useful, you won't see it much
Mar 06 12:47:10 <Widdershins>	usually it is like `self: Box<Self>` so that you can take ownership of the value via a box instead of the value itself
Mar 06 12:47:41 <Widdershins>	otherwise anything that would receive &Box<Self> you can just let it decay to &self by dereferencing
Mar 06 12:51:54 <bertptrs>	There's the Wake trait that takes Arc<Self> and &Arc<Self>
Mar 06 12:52:51 <Widdershins>	&arc so you don't have to mess with the count by cloning it
Mar 06 12:53:10 <bertptrs>	Exactly
Mar 06 12:55:14 <bertptrs>	but rather than making an arbitrary decision on what makes sense, the standard just allows all combinations
