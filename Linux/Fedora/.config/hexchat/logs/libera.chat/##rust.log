**** BEGIN LOGGING AT Mon Feb 12 13:08:45 2024

févr. 12 13:08:45 *	Now talking on ##rust
févr. 12 13:08:45 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
févr. 12 13:08:45 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** BEGIN LOGGING AT Mon Feb 12 14:01:09 2024

févr. 12 14:01:08 *	Now talking on ##rust
févr. 12 14:01:08 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
févr. 12 14:01:08 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
févr. 12 14:04:44 <bertptrs>	dav1d: Error has a couple of methods that you can only call on "dyn Error + 'static"
févr. 12 14:05:14 <bertptrs>	Which are (I think) inherited from Any requiring 'static
févr. 12 14:12:08 <Bish>	if i wanted to serialize datastructures of crates with serde im pretty much screwed, right?
févr. 12 14:12:22 <Bish>	in this case i want to use http::* things in my struct and it should be serializable
févr. 12 14:12:38 <Bish>	i could wrap it in my own type, but i can't magicially make it serializible via macro, right?
févr. 12 14:12:45 <Bish>	i could ofcourse write my own serializer, correct?
févr. 12 14:12:54 <spb>	https://serde.rs/remote-derive.html
févr. 12 14:13:29 <Bish>	cool
févr. 12 14:13:30 <Bish>	thanks
févr. 12 14:14:12 <Bish>	is this "dangerous" as in, what happens if i the 2 structs differ
févr. 12 14:14:50 <spb>	if you consider compiler errors dangerous
févr. 12 14:21:50 <Bish>	it bothers me i have to copy the definition of the thing i want to serialize
févr. 12 14:22:37 <Bish>	and what if they go deep?
févr. 12 14:23:03 <Bish>	then i'd have to provide many many of those?
févr. 12 14:26:55 <demize>	What from the http crate do you want to be able to de/serialize?  The http-serde crate might provide everything you need already.
févr. 12 14:27:34 <Bish>	guess it does, yeah
févr. 12 15:25:53 <dav1d>	bertptrs, that is unfortunate :(
févr. 12 15:31:13 <bertptrs>	I expect it to be related to Sentry's error sniffing logic. I haven't worked with them in Rust but in Python they try to downcast your uncaught exceptions to be more helpful in the reporting. I imagine that's why they want to touch the downcast methods
**** BEGIN LOGGING AT Sat Feb 17 17:08:29 2024

Feb 17 17:08:29 *	Now talking on ##rust
Feb 17 17:08:29 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 17 17:08:29 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** BEGIN LOGGING AT Tue Feb 20 15:07:42 2024

Feb 20 15:07:42 *	Now talking on ##rust
Feb 20 15:07:42 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 20 15:07:42 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** BEGIN LOGGING AT Tue Feb 20 15:32:27 2024

Feb 20 15:32:26 *	Now talking on ##rust
Feb 20 15:32:26 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 20 15:32:26 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** BEGIN LOGGING AT Tue Feb 20 15:37:56 2024

Feb 20 15:37:56 *	Now talking on ##rust
Feb 20 15:37:56 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 20 15:37:56 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Feb 20 15:59:10 <Ademan_>	presumably in some cases, Fromiterator::from_iter() might do something more efficient than a naive for loop might. would it be valid for <HashMap as FromIterator>::from_iter() to take only the first value for a given key and discard the rest? I've written my code assuming that the resulting hash map will use the *last* value for a given key (the behavior you'd get with a naive `for (k, v) in i {
Feb 20 15:59:16 <Ademan_>	map.insert(k, v); }` ).
Feb 20 16:06:59 <spb>	the trait documentation doesn't say anything about how situations like that should be handled, so you should assume that any reasonable implementation is possible
Feb 20 16:31:47 <Ademan_>	spb: makes sense, thanks!
Feb 20 16:36:17 <belst>	FH_thecat: did u build in release mode? the github releases are all less than 10mb
Feb 20 16:42:22 <FH_thecat>	belst: I build it using "cargo build --release"
Feb 20 16:49:03 <rendar>	if i'm using thiserror, and i have `enum MainError { #[error("Math Error")] MathError(#[from] MathError),  ... }`   when i print the error from MainError with "{}" i only get "Math Error" string, but since its a nested enum, shouldn't thiserror automatically prints the real MathError string instead of that one?
Feb 20 16:49:29 <spb>	only if you tell it to
Feb 20 16:49:44 <spb>	#[error("Math Error: {0}")]
Feb 20 16:49:54 <rendar>	hmm, i see
Feb 20 16:51:18 <rendar>	of course, it takes the same parameter id as other errors which has String or whatever, ok
Feb 20 16:52:45 <spb>	all the fields of that enum variant are available to use in any normal format expression
Feb 20 16:53:15 <spb>	based on whether they impl Display or Debug
Feb 20 19:41:44 <bertptrs>	FH_thecat: late reply but looking at the binary most of it appears to be tree-sitter parsers for various languages. It's a bit silly to statically link treesitter dozens of times, but it does, and depending on the language (*cough* sql) those parsers are pretty damn big
Feb 20 19:48:24 <bertptrs>	in other words, the extensive langauge highlighting that difftastic does
Feb 20 19:49:17 <FH_thecat>	bertptrs: can I disable some parsers for languages that I don't need ?
Feb 20 19:49:34 <FH_thecat>	and why does it have to be statically linked anyway?
Feb 20 19:50:42 <FH_thecat>	I basically just need shell (sh,zsh), python and c
Feb 20 19:51:02 <bertptrs>	I'd have to RTFS it, but from an initial glance, it compiles everything unconditionally
Feb 20 19:51:51 <FH_thecat>	what a monstrosity !
Feb 20 19:52:15 <bertptrs>	soft disagree, you want a swiss army knife, you get a swiss army knife
Feb 20 19:52:53 <bertptrs>	It's kinda funny, rust (rightfully) gets blamed for large binaries but most of this is C :P
Feb 20 19:53:17 <j`ey>	https://github.com/Wilfred/difftastic/tree/master/vendored_parsers oh yeah lotsa parsers
Feb 20 19:54:35 <FH_thecat>	why can't the parsers be modular
Feb 20 19:54:42 <FH_thecat>	ie, just install those that I need
Feb 20 19:54:51 <bertptrs>	because the devs didn't bother to do it, since it's a maintenance and testing hassle
Feb 20 19:54:58 <bertptrs>	or so I'd guess
Feb 20 19:55:08 <bertptrs>	modular features make exponential testing and such
Feb 20 19:55:35 <FH_thecat>	I thought modular approach is "cleaner"
Feb 20 19:55:54 <j`ey>	it is but requires more code / maintainenace
Feb 20 19:57:18 <FH_thecat>	then, at least there should be configuration for the build, which ones to include
Feb 20 19:57:43 <FH_thecat>	that would not add any extra complexity
Feb 20 19:57:59 <j`ey>	it would
Feb 20 19:58:10 <bertptrs>	I very much encourage you to raise these concerns upstream (though in a friendlier tone). None of us develop this tool, I was just curious how the binary could be so large. Now I have an answer
Feb 20 19:58:44 <FH_thecat>	thank you
Feb 20 20:10:42 <Odin-LAP>	bertptrs: C also gets an unwarranted assumption of its binaries being small, with enormous amounts of its runtime support libraries being considered "just the operating system".
Feb 20 20:11:20 <consus>	because it usually is :D
Feb 20 20:12:12 <consus>	having stdlib in each binary and still relying on libc is really stoopid
Feb 20 20:12:56 <dav1d>	😬
Feb 20 20:15:53 <Odin-LAP>	consus: But it means a comparison with a binary that _does_ contain all of that stuff isn't exactly apples to apples.
Feb 20 20:15:55 <Odin-LAP>	:)
Feb 20 20:16:55 <consus>	Odin-LAP: who cares? you have a hello world with 386k weigh that still does not qualify as a static binary because of it's reliance on libgcc and libc
Feb 20 20:17:05 <consus>	That's stoopid
Feb 20 20:17:21 <consus>	No amount of Rust copium will help you justify this
Feb 20 20:17:55 <bertptrs>	consus: you got warned yesterday, hereby your second warning, please behave a bit more professional
Feb 20 20:18:25 <consus>	bertptrs: I've missed the first one
Feb 20 20:18:39 <consus>	what exactly are you accusing me of?
Feb 20 20:18:58 <bertptrs>	<bertptrs> but that's not a reason to be this negative as it's counterproductive
Feb 20 20:19:22 <consus>	how should I phrase it then?
Feb 20 20:20:38 <bertptrs>	avoid "stoobid" and "copium" while discussing people's hard work
Feb 20 20:20:43 <consus>	why?
Feb 20 20:20:50 <consus>	copium is really a good word
Feb 20 20:20:57 <consus>	it's not offending
Feb 20 20:21:04 <consus>	I'm not calling people names
Feb 20 20:21:14 <consus>	but the end result is really suboptimal
Feb 20 20:22:13 <consus>	for example it forces projects like uutils to create a really large binary with HUGE attack surface
Feb 20 20:24:15 <nCrazed>	"inflamtory language" comes to mind
Feb 20 20:24:29 <consus>	fair enough
Feb 20 20:24:33 <bertptrs>	I was struggling to put it into words but yeah, that's what I meant
Feb 20 20:25:34 <cehteh>	uutils is stil at 0.0.x stage, i would guess that binary size optimization isnt even considered yet
Feb 20 20:26:08 <cehteh>	there are ways to reduce rust executables sizes, eventually
Feb 20 20:26:19 <consus>	They went busybox-like route
Feb 20 20:26:22 <consus>	With a single binary
Feb 20 20:26:31 <cehteh>	which is good
Feb 20 20:26:32 <j`ey>	but are you sure that's due to size?
Feb 20 20:26:40 <consus>	one of the reasons
Feb 20 20:26:57 <consus>	cehteh: which also creates a huge gadget space
Feb 20 20:27:36 <cehteh>	i would like if rust had better support for dynamic linking, but that opens other cans of worms
Feb 20 20:29:38 <cehteh>	https://github.com/johnthagen/min-sized-rust  there are these tips, bit outdated but many are ok, still applying that would be the icing on the cake when you are ready for production releases
Feb 20 20:31:54 <consus>	it does not help much
Feb 20 20:31:59 <consus>	you win like ~50k
Feb 20 20:32:17 <consus>	well, strip helps, but that's obvious
Feb 20 20:32:28 <consus>	no distro will let a binary without striping
Feb 20 20:32:43 <cehteh>	this is not a process you can blindly apply, you have to look at your project and see what benefit it most
Feb 20 20:33:07 <consus>	strip does 80% of the work :)
Feb 20 20:33:12 <cehteh>	lto for example usually reduces code size, somtimes significantly, but in some cases it bloats
Feb 20 20:33:22 <consus>	not that much in my experience
Feb 20 20:33:26 <consus>	you may win 20%
Feb 20 20:33:30 <consus>	even 30%
Feb 20 20:33:34 <consus>	but still
Feb 20 20:33:37 <cehteh>	it depends on the exact project
Feb 20 20:34:00 <consus>	the thing is... it does not help small projects because of unconditional stdlib
Feb 20 20:34:15 <cehteh>	removing all the panic stuff/info should save a bit, but only when combined with the build_std thing
Feb 20 20:34:17 <consus>	and if you're writing something like a webapp
Feb 20 20:34:22 <consus>	who cares?
Feb 20 20:34:37 <consus>	it can 500M, that won't be an issue
Feb 20 20:34:40 <cehteh>	you where talking about uulib
Feb 20 20:34:44 <consus>	yeah
Feb 20 20:35:20 <consus>	total busybox on my system is 1.3M
Feb 20 20:35:28 <consus>	lemme check the uutils
Feb 20 20:36:11 <cehteh>	i wont be surprised when its at this stage magnitudes larger
Feb 20 20:38:58 <cehteh>	oh they have a release-small target already
Feb 20 20:39:28 <consus>	8.5 with release
Feb 20 20:39:34 <consus>	actually not bad
Feb 20 20:39:41 <consus>	less than 10x
Feb 20 20:40:07 <cehteh>	5.3 with the release-small profile
Feb 20 20:40:20 <consus>	comparable then
Feb 20 20:40:25 <cehteh>	so just stop ranting :D
Feb 20 20:40:31 <consus>	why?
Feb 20 20:40:46 <j`ey>	does uutils try to do anything better?
Feb 20 20:40:48 <cehteh>	its annoying
Feb 20 20:40:49 <consus>	that's exactly why they decided to do that
Feb 20 20:40:53 <j`ey>	or is it just 1:1?
Feb 20 20:41:17 <consus>	because otherwise the size would be (clap + stdlib) * n_utils
Feb 20 20:41:26 <consus>	j`ey: more colors
Feb 20 20:41:31 <j`ey>	heh
Feb 20 20:41:33 <consus>	j`ey: some other imprrovements
Feb 20 20:41:39 <consus>	if you like colors that is
Feb 20 20:41:50 <cehteh>	there where people here with an actual problem that their binary was too big, if only code golfing, usually they got helped
Feb 20 20:42:31 <cehteh>	ranting about potential other project could be too big .. and then find out that its actually not the case, is stupid
Feb 20 20:42:43 <consus>	errr
Feb 20 20:42:50 <consus>	you misread
Feb 20 20:43:04 <consus>	I was citing uutils as an example of why projects decide to do single binary
Feb 20 20:43:13 <cehteh>	<consus> for example it forces projects like uutils to create a really large binary with HUGE attack surface
Feb 20 20:43:18 <consus>	yeap
Feb 20 20:43:55 <consus>	the C coreutils does not have a single binary
Feb 20 20:44:01 <consus>	it has a lot of small tools
Feb 20 20:44:14 <consus>	it works because of the dynamic linking
Feb 20 20:44:40 <cehteh>	thats just a implementation/deployment detail
Feb 20 20:44:44 <consus>	uutils cannot do that because then the total sum would be (stdlib + clap + other common deps) * N-Utils
Feb 20 20:45:07 <cehteh>	i think you can build it (mostly) statically linked with some efforts
Feb 20 20:45:22 <consus>	true, but then you have a problem with tools like ping
Feb 20 20:45:38 <consus>	because ping, for example, requires special flags
Feb 20 20:45:45 <consus>	and/or suid
Feb 20 20:46:30 <cehteh>	sure, so what? ..
Feb 20 20:46:53 <j`ey>	consus: do you have the uutils grep vs coreutils grep?
Feb 20 20:47:04 <consus>	j`ey: in terms of features?
Feb 20 20:47:39 <j`ey>	sizes
Feb 20 20:47:40 <consus>	I'm not sure uutils aims at full posix compatibility
Feb 20 20:48:01 <bertptrs>	it aims to pass GNU coreutils tests
Feb 20 20:48:52 <consus>	huh, strange, cannot find grep in applets
Feb 20 20:49:00 <cehteh>	which is probably more demanding :D posix requirements on some tools are surprisingly minimal
Feb 20 20:49:07 <consus>	nah
Feb 20 20:49:15 <consus>	the level of compatibility is a nigthmare
Feb 20 20:49:21 <j`ey>	consus: oh, well some other binary will do
Feb 20 20:49:23 <j`ey>	find or whatever
Feb 20 20:49:46 <consus>	it took openbsd 8 years or so to write grep that worked for them
Feb 20 20:49:56 <bertptrs>	grep is not in coreutils, is it?
Feb 20 20:50:14 <consus>	not sure actually
Feb 20 20:50:22 <spb>	not last i knew
Feb 20 20:50:24 <consus>	nope, it's a separate thing
Feb 20 20:50:26 <consus>	as is find
Feb 20 20:50:31 <cehteh>	woudnt ping be in netutils? i dunno
Feb 20 20:50:36 <consus>	ping netutils
Feb 20 20:50:36 <bertptrs>	not on my system
Feb 20 20:50:40 <consus>	find findutils
Feb 20 20:50:46 <consus>	grep is grep :D
Feb 20 20:50:54 <j`ey>	grr
Feb 20 20:51:16 <bertptrs>	la la, la la la
Feb 20 20:51:26 <consus>	yeah, busybox provides a lot more
Feb 20 20:51:26 <bertptrs>	lababadap dap dap grep
Feb 20 20:52:05 <dav1d>	I think bertptrs broke :(
Feb 20 20:52:37 <bertptrs>	I'm just conditioned on Opus so whenever someone writes X is X I get "Life is Life" stuck in my head
Feb 20 20:52:48 <consus>	xD
Feb 20 20:53:26 <consus>	I was actually thinking about the song about that blue dudes on an spaceship
Feb 20 20:53:37 <consus>	Can't remember the band name
Feb 20 20:53:42 <bertptrs>	ah no. Eiffel 65
Feb 20 20:53:47 <bertptrs>	Different genre
Feb 20 20:53:48 <consus>	yeah, right
Feb 20 20:53:59 <cehteh>	bertptrs: https://www.youtube.com/watch?v=Zt2_11e6QPA ;)
Feb 20 20:55:41 <cehteh>	https://www.youtube.com/watch?v=y_cbTcaoErI  better version
Feb 20 20:57:07 <consus>	what is the explicit of '?'?
Feb 20 20:57:52 <consus>	I remember writing ResultExt with into_res() but I think stdlib should have something standard for that
Feb 20 20:58:15 <cehteh>	explicit? desugaring?
Feb 20 20:58:34 <consus>	Ok(foo().await?) => foo().await.into_res()
Feb 20 20:59:01 <cehteh>	its not that trivial
Feb 20 20:59:33 <bertptrs>	it cannot be desugared like that, since it's equivalent to match foo().await { Ok(val) => val, Err(e) => return Err(e.into()) }
Feb 20 20:59:43 <bertptrs>	there used to be the try! macro which did almost this
Feb 20 21:00:28 <cehteh>	https://rust-lang.github.io/rfcs/3058-try-trait-v2.html
Feb 20 21:00:58 <bertptrs>	https://doc.rust-lang.org/std/ops/trait.Try.html also this
Feb 20 21:01:05 <consus>	damn, I had it somewhere
Feb 20 21:01:12 <cehteh>	yeet
Feb 20 21:01:32 <consus>	probably the old laptop
Feb 20 21:01:38 <consus>	well, nevermind :(
Feb 20 21:01:45 <bertptrs>	I hate that yeet exists
Feb 20 21:01:55 <consus>	yeet?
Feb 20 21:02:02 <bertptrs>	https://doc.rust-lang.org/std/ops/struct.Yeet.html
Feb 20 21:03:06 <bertptrs>	it exists to avoid a bikeshed about what it should be called from slowing down the RFC; they chose a name that definitely nobody likes so it was sure to be changed later
Feb 20 21:03:22 <bertptrs>	as opposed to a "not quite great but acceptable" name sticking around after development
Feb 20 21:03:34 <darkling>	... and that was 10 years ago? :)
Feb 20 21:03:38 <consus>	:D
Feb 20 21:03:54 <consus>	I miss pure
Feb 20 21:03:55 <bertptrs>	it hasn't been stabilized yet, that's something
Feb 20 21:05:09 <consus>	.map_err(|e| e.into())
Feb 20 21:05:09 <polychromata{J}>	bertptrs: baba is baba
Feb 20 21:05:10 <consus>	yeah
Feb 20 21:05:11 <consus>	this
Feb 20 21:05:27 <consus>	I was looking for this
Feb 20 21:05:37 <bertptrs>	that's only half of what ? does, but sure
Feb 20 21:06:01 <consus>	it helps me not to wrap everything in Ok()
Feb 20 21:06:12 <consus>	Which look really ugly
Feb 20 21:06:13 <bertptrs>	Fair enough, it makes sense for your final return statement
Feb 20 21:06:18 <consus>	yeah
Feb 20 21:06:18 <bertptrs>	or just returns in geenral
Feb 20 21:06:36 <consus>	it's a pity that ? without ; is not a thing
Feb 20 21:07:06 <consus>	feels wront to explicitly mark return values as "good"
Feb 20 21:07:28 <j`ey>	feels right to me
Feb 20 21:09:12 <consus>	it was unambigous in the beginning, before ?
Feb 20 21:09:25 <consus>	but now the language itself has an operator for returning errors
Feb 20 21:09:38 <consus>	And now it feels weird
Feb 20 21:11:15 <bertptrs>	most languages have a keyword instead
Feb 20 21:11:18 <bertptrs>	either way works
Feb 20 21:11:46 <bertptrs>	C has… error codes and out parameters, I guess
Feb 20 21:13:25 <consus>	? is cool! but it would be even cooler to go one step further and allow `foo().await?` instead of `Ok(foo().await?)`
Feb 20 21:14:09 <j`ey>	I mean with ? that would make it context sensitive I guess
Feb 20 21:15:19 <consus>	more than it now?
Feb 20 21:15:28 <j`ey>	yes?
Feb 20 21:15:46 <j`ey>	I assumed you were saying if it was the return value, the Ok would be implicit
Feb 20 21:15:53 <consus>	yeah
Feb 20 21:23:35 <bertptrs>	the annoucement blog for anyhow did something like that, with a proc macro, but honestly it just muddies the water and makes types harder to explain
Feb 20 22:00:53 <dav1d>	Isn't  `Ok(foo().await?)` just a `foo().await.map_err(Into::into)` if you prefer not to use the `?` here
Feb 20 22:01:13 <consus>	yeah
Feb 20 22:01:14 <bertptrs>	It is
Feb 20 22:01:28 <consus>	but since we already have ?
Feb 20 22:01:46 <consus>	kinda makes sense to use it here too
Feb 20 22:01:59 <consus>	let foo = may_fail()?;
Feb 20 22:02:15 <consus>	but  may_fail()? does not do the same
Feb 20 22:03:32 <bertptrs>	does it not?
Feb 20 22:04:13 <consus>	nope
Feb 20 22:04:30 <dav1d>	but it does
Feb 20 22:04:33 <consus>	nope
Feb 20 22:04:42 <dav1d>	okay nvm
Feb 20 22:04:45 <consus>	Ok(foo()?) works
Feb 20 22:04:50 <consus>	foo()? -- does not
Feb 20 22:05:06 <bertptrs>	because the return type of foo()? is T, not Result<T, E>
Feb 20 22:05:09 <consus>	what I  mean is  that foo()? cannot be on the last line
Feb 20 22:05:22 <bertptrs>	that's actually caused by it doing the same
Feb 20 22:05:35 <consus>	but it behaves differently
Feb 20 22:05:37 <dav1d>	exactly because it does the same it does not work
Feb 20 22:05:44 <consus>	and that's weird
Feb 20 22:05:53 <consus>	no?
Feb 20 22:05:53 <bertptrs>	no it behaves the same. It turns a Result<T, E> into a T (or returns early)
Feb 20 22:06:06 <consus>	well, perhaps
Feb 20 22:06:14 <bertptrs>	And if your function returns a Result<T, E> you cannot return a T from it
Feb 20 22:06:23 <consus>	yeah, makes sense
Feb 20 22:06:24 <dav1d>	`let foo = may_fail().unwrap();` `works but `may_fail().unwrap()` we should make unwrap behave special
Feb 20 22:06:34 <consus>	nah
Feb 20 22:06:38 <j`ey>	that's what I meant about context
Feb 20 22:06:53 <dav1d>	although we could also tell the compiler to implicitly wrap items in Ok if there is a result expected
Feb 20 22:07:02 <consus>	let foo = foo().await?.some()?.other()?.chains()?;
Feb 20 22:07:26 <consus>	it will return Result<T> if some() fails, for example
Feb 20 22:07:34 <consus>	it will even converse it for you
Feb 20 22:07:46 <consus>	which is good, right?
Feb 20 22:07:50 <bertptrs>	dav1d: that stops working when you introduce nested Results, which is not uncommon in generic code
Feb 20 22:07:57 <dav1d>	bertptrs, it is a terrible idea
Feb 20 22:08:04 <dav1d>	it would also fuck with infering types
Feb 20 22:08:17 <dav1d>	e.g. collecting into anything that is a result
Feb 20 22:08:53 <bertptrs>	yea
Feb 20 22:08:55 <bertptrs>	better not
Feb 20 22:25:02 <cappy>	Is there a way to get cargo(1) to clean --release just the object files (ELF) from a project directory?
Feb 20 22:40:23 <cappy>	I've been using: find . -exec file {} \; | grep -i elf | awk '{print $1}' to locate the files for rm(1) but there might be a better way.
Feb 20 22:46:33 <polychromata{J}>	why just the object files?
Feb 20 22:49:23 <cappy>	polychromata{J}: They can be rebuilt. The source and other files will be picked up by my backup program. No sense in backing up ELFs.
Feb 20 22:50:01 <j`ey>	but cargo clean wont delete the source files
Feb 20 22:50:18 <j`ey>	everything that cargo clean deletes can be rebuilt
Feb 20 22:50:33 <polychromata{J}>	why not just exclude the entire target directory from backups?
Feb 20 22:50:45 <polychromata{J}>	that might happen by default, even; cargo tags it as a cache
Feb 20 22:51:00 <nullie>	tags?
Feb 20 22:51:06 <cappy>	j`ey: All true. I just started using Rust/Cargo today.
Feb 20 22:51:11 <polychromata{J}>	yeah, look inside.
Feb 20 22:51:12 <j`ey>	puts a special file in the foldre
Feb 20 22:51:35 <nullie>	oh, TIL
Feb 20 22:51:56 <j`ey>	cappy: see if your backup program knows about https://bford.info/cachedir/
Feb 20 22:52:24 <cappy>	polychromata{J}: Of course.
Feb 20 22:53:17 <cappy>	j`ey: cachedir... I'll look at that. No my backup program does not see such. Might look at an alternative for backups.
Feb 20 23:09:57 <cappy>	borgbackup will exclude CACHEDIR.TAG directories. It's in my repo. Thanks for the help guys.
Feb 21 00:07:47 <turlando>	If I know that due to some incompatibility my program will only run on 64 bit architectures, is it possible to restrict the target platforms in Cargo.toml and at the same time get access to, e.g., From<usize> for u64?
Feb 21 00:08:25 <j`ey>	nope
Feb 21 00:08:56 <turlando>	Would it be something sane to implement myself?
Feb 21 00:09:10 <j`ey>	You couldn't implement the From<usize>
Feb 21 00:09:24 <j`ey>	you can error on the pointer size though, but I think only from code
Feb 21 00:09:36 <jbg>	but you can always just write `as usize` since you know it's fine
Feb 21 00:10:27 <jbg>	(in the process creating that incompatibility if it didn't already exist!)
Feb 21 00:11:27 <turlando>	Having it handled at type level would make me feel better
Feb 21 00:11:42 <turlando>	And sleep better at night maybe
Feb 21 00:13:46 <jbg>	should be possible to refuse to compile on non-64-bit arch. use something like #[cfg(not(target_pointer_width = 64))] compile_error!("only 64-bit architectures are supported");
Feb 21 00:14:05 <jbg>	then you can use `42u64 as usize` and still sleep at night
Feb 21 00:15:01 <turlando>	That is true untile somebody decides that 32 bits are fine and the compiler will gladly allow that :
Feb 21 00:15:03 <Arnavion>	Or `#[cfg(target_pointer_width = 64)] fn convert(a: usize) -> u64 { a as _ }` and use `convert()` everywhere
Feb 21 00:15:20 <Arnavion>	so the fn won't be defined if it can't be used safely
Feb 21 00:15:35 <turlando>	Arnavion: that looks much better as long as it's a non-op
Feb 21 00:16:45 <jbg>	the body is clearly a no-op, you could put #[inline(always)] on it if you are really worried
Feb 21 00:17:06 <turlando>	It still has to do runtime checks even in release mode?
Feb 21 00:17:29 <j`ey>	there's no runtime checks with as
Feb 21 00:17:33 <turlando>	Sorry, I was reading "it's not a non-op"
Feb 21 00:18:13 <jbg>	you could also do similar with a trait to make it feel a bit more like From
Feb 21 00:19:30 <turlando>	I'm not sure why I can't guard the impl From with #[cfg] (sorry for the noob question)
Feb 21 00:20:05 <jbg>	you can't impl From
Feb 21 00:20:16 <jbg>	to impl a trait either the trait or the type must be local to your crate
Feb 21 00:20:20 <jbg>	(that's the short version)
Feb 21 00:20:41 <jbg>	look up "rust orphan rule" for the long version
Feb 21 00:21:09 <jbg>	so you can write a trait FromPointerWidth {} and impl that for u64 but you can't impl From for u64
Feb 21 00:22:03 <jbg>	similarly, you could make a wrapper, struct MyU64(u64); and then impl From<usize> for that
Feb 21 00:22:05 <turlando>	Oh, right, that's similar to how typeclass instances must be implemented
**** BEGIN LOGGING AT Wed Feb 21 00:53:37 2024

Feb 21 00:53:37 *	Now talking on ##rust
Feb 21 00:53:37 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 21 00:53:37 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Feb 21 04:01:07 <Mikachu>	https://github.com/Speykious/cve-rs
Feb 21 04:14:22 <daddy>	so glad i figured out what GLWTSPL was on first guess
Feb 21 04:54:59 <Diablo-D3>	https://github.com/Speykious/cve-rs
Feb 21 04:55:03 <Diablo-D3>	but why
Feb 21 05:04:18 <Mikachu>	i guess they got tired of the bug going unfixed for 6 years so they made some proofs of concept?
Feb 21 05:28:53 <danieldg>	they could at least expand that to use any of the other unsoundness bugs
Feb 21 05:29:38 <danieldg>	there are a few more to choose from afaik - typeid hash collisions are the one I recall offhand
Feb 21 05:39:20 <phy1729>	Should have come up with a catchy name if they really wanted it fix. Unsafe at any lifetime is my terrible stab at it.
Feb 21 06:17:27 <Widdershins>	looking forward to the new trait solver tho...
Feb 21 06:17:44 <Widdershins>	i have some gripes with the way this one works
Feb 21 06:40:15 <Mutabah>	So do I... grumble grumble accepting tautalogical bounds
Feb 21 06:40:45 <Mutabah>	I've spent the two weeks thinking through/experimenting with a mrustc issue related to a crate having a tautalogical trait bound.
Feb 21 06:41:32 <Mutabah>	`S: SomeTrait, &S: SomeTrait<Assoc=S::Assoc>`, but there's a blanket `impl<S: SomeTrait> SomeTrait for &S { type Assoc = S::Assoc; }`
Feb 21 07:16:43 <dav1d>	turlando, or instead of converting u64 to usize, you convert usize to u64 which even works on 32bit platforms
Feb 21 07:55:39 <davros1>	Any interesting features on the horizon in Rust .. have been obsessed with AI for a while and not keeping track of the language changes
Feb 21 07:56:00 <davros1>	I remember a problem stopping nested 'From' impl
Feb 21 07:56:13 <davros1>	Which might have needed a workaround like negative impl's or something
Feb 21 07:56:21 <davros1>	Negative trait bounds (I forget)
Feb 21 08:51:29 <bertptrs>	negative trait bounds aren't on the way AFAIK, and the last release was a bit quiet, but before that we got async in traits and RPITIT which I find a hilarious acronym but also very useful
Feb 21 09:11:05 <Bish>	if a method returns a reference and i want to match it, why do i have to match with a reference? isnt this especially confusing with @str?
Feb 21 09:11:11 <Bish>	&str*
Feb 21 09:11:20 <Bish>	i am guessing it's a special case there?
Feb 21 09:11:57 <Bish>	https://github.com/hyperium/hyper/blob/00a703a9ef268266f8a8f78540253cbb2dcc6a55/examples/echo.rs#L24 for example this
Feb 21 09:13:28 <Mutabah>	You match a reference with a reference, that's how matching works
Feb 21 09:13:37 <Mutabah>	although, "match ergonomics" sometimes hides it
Feb 21 09:13:53 <Mutabah>	string literals are of type `&str`, so they match against a `&str`
Feb 21 09:15:21 <Bish>	what if i have 2 equal objects but they're duplicates
Feb 21 09:15:28 <Bish>	what happens if i match their references?
Feb 21 09:16:03 <Bish>	i guess the (Partial)Eq trait's == will get called and it can be whatever?
Feb 21 09:16:17 <Mutabah>	No, matching destructures to compare
Feb 21 09:16:30 <Mutabah>	and you can't match against a variable
Feb 21 09:18:28 <Bish>	hm confusing
Feb 21 09:19:12 <jbg>	how so?
Feb 21 09:19:37 <Bish>	i don't understand if that's a pointer comparison now
Feb 21 09:19:49 <jbg>	there is no comparison as such
Feb 21 09:19:50 <Bish>	or thje contents of the referenced object will be compared
Feb 21 09:19:54 <jbg>	not in the sense you are thinking
Feb 21 09:19:55 <jbg>	the left hand side of a match is a pattern, ideally one of the first concepts you learn in rust
Feb 21 09:20:16 <jbg>	names in there are new bindings, not the names of existing variables to compare to
Feb 21 09:20:25 <jbg>	you have other tools for that, like `if a == b`
Feb 21 09:20:32 <Bish>	so the compiler just compares the names, a constant struct in this case
Feb 21 09:20:55 <jbg>	you're matching structure -- types -- not content
Feb 21 09:21:05 <Bish>	ah okay
Feb 21 09:21:17 <jbg>	the book chapter on patterns is instructive here
Feb 21 09:21:24 <Bish>	but for &str that's special
Feb 21 09:21:26 <jbg>	https://doc.rust-lang.org/book/ch18-00-patterns.html
Feb 21 09:21:28 <Mutabah>	`match foo { bar => ... }` just defines `bar` as a variable with the same value as `foo`
Feb 21 09:21:53 <Mutabah>	`match foo { path::to::BAR => ... }` only works if `BAR` is a `const`, and it compares the contents (not using `==`)
Feb 21 09:22:01 <jbg>	Bish: any literals can be used in match
Feb 21 09:22:09 <jbg>	(as well as constants)
Feb 21 09:23:02 <jbg>	it's not that it's special for &str as such, but special for string literals. `match foo { bar => ... }` in Mutabah's example is still the same if foo is a &str
Feb 21 09:23:46 <jbg>	but `match foo { "bar" => ... }` will only compile if foo is a &str and will execute that arm only if it is "bar"
Feb 21 09:24:21 <bertptrs>	Bish: refererences compare by contents, pointers compare by address. This is also documented as such https://doc.rust-lang.org/std/primitive.reference.html
Feb 21 09:29:41 <Bish>	> Reference equality by address, instead of comparing the values pointed to
Feb 21 09:30:15 <Bish>	isn't that the opposite of "refererences compare by contents"
Feb 21 09:30:46 <Mutabah>	Did you read the rest of that sentence?
Feb 21 09:31:01 <Mutabah>	> is accomplished via implicit reference-pointer coercion and raw pointer equality via ptr::eq, while PartialEq compares values.
Feb 21 09:31:19 <Bish>	yeah i don't see where that dereferences
Feb 21 09:31:25 <Bish>	it sounds like pointer get compared
Feb 21 09:31:34 <Bish>	to me that is
Feb 21 09:31:47 <Mutabah>	It's saying that to compare two references by address you use `std::ptr::eq(ref1, ref2)`
Feb 21 09:32:05 <Mutabah>	(which will coerce `&T` to `*const T` then compare the two `*const T`s - comparing the addresses)
Feb 21 09:32:44 <Bish>	oh yeah i misread that sentence
Feb 21 09:36:07 <Bish>	so matching with (&Method::GET, "/test") will call .eq of both of them, right?
Feb 21 09:36:23 <Bish>	there i no pattern matching happening except for the tuple maybe
Feb 21 09:37:33 <erk>	Mutabah: To compare by address you actually don't want std::ptr::eq, you instead want the newly added std::ptr::addr_eq
Feb 21 09:37:55 <erk>	Otherwise it will use some fat pointer information that can give strange results.
Feb 21 09:38:13 <Mutabah>	erk: I was quoting docs
Feb 21 09:40:38 <Bish>	so match will pattern match and call .eq() for concrete types?
Feb 21 09:40:56 <Bish>	conrecte values*
Feb 21 09:41:56 <Mutabah>	It doesn't use `.eq`... it just uses primitive comparisons
Feb 21 09:43:25 <Bish>	so it uses.. == ?
Feb 21 09:43:39 <Bish>	what would i use to emulate match
Feb 21 09:44:53 <Mutabah>	it uses `==` and `memcmp` - match is a low-level language construct, so expands to some very low level things
Feb 21 09:46:55 <Bish>	when is == equal to .eq() if there is no primitive comparision?
Feb 21 09:47:25 <Bish>	Mutabah: wouldn't that mean i coulnd't compare something that is not copy?
Feb 21 09:47:55 <Mutabah>	if you write `foo == bar` then the `PartialEq::eq` trait method is invoked... unless it's a primitive integer/bool/float type, which the compiler already inherently knows how to equate
Feb 21 09:48:17 <Mutabah>	Maybe you should play around with `match` and read the book/reference on how it works
Feb 21 09:49:06 <Bish>	well, i don't feel like it helps me understanding how it operates, but i will try
Feb 21 09:49:31 <Mutabah>	Or, if you're brave - you could attempt to understand the mrustc `match` lowering code :)
Feb 21 09:51:36 <Bish>	i was hoping there is a simple explanation for example it just being .eq()
Feb 21 09:52:21 <Mutabah>	pattern matching is destructuring until it finds a pattern that doesn't destructure (i.e. a literal)
Feb 21 09:52:22 <Bish>	i compiled & looking at the assembler of something already and it seems to call into partialeq for &str
Feb 21 09:53:43 <Bish>	but for u32 it creates code on the spot
Feb 21 09:54:05 <Bish>	but i feel like that would happen if i did it without match as well
Feb 21 09:55:56 <Bish>	so match does many things. not a single thing.. okay
Feb 21 09:59:19 <Mutabah>	It does a LOT of things
Feb 21 09:59:34 <Mutabah>	for context - mrustc's match lowering code is larger than the rest of MIR lowering
Feb 21 10:01:12 <Bish>	why does that exist.. :o
Feb 21 10:01:22 <Bish>	is it the first rust compiler? because it says reimplementation
Feb 21 10:02:19 <Mutabah>	It's not the first, it's my project (hence why I know it's internals) to create a bootstrapping rust compiler
Feb 21 10:02:37 <Mutabah>	`match` is complex and powerful
Feb 21 10:02:58 <Bish>	why did you do this project?
Feb 21 10:04:16 <Mutabah>	fun?
Feb 21 10:04:28 <Bish>	i can get behind that
Feb 21 10:05:03 <Widdershins>	i am currently also doing a fun project (writing like 11 thousand words of documentation for a personal project for some reason)
Feb 21 10:05:50 <Bish>	i bet most people would disagree with your definitions of fun
**** BEGIN LOGGING AT Wed Feb 21 10:31:33 2024

Feb 21 10:31:33 *	Now talking on ##rust
Feb 21 10:31:33 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 21 10:31:33 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** BEGIN LOGGING AT Wed Feb 21 10:38:42 2024

Feb 21 10:38:40 *	Now talking on ##rust
Feb 21 10:38:40 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 21 10:38:40 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Feb 21 10:59:18 <Bish>	Mutabah: why wouldn't i read up rustcs code
Feb 21 10:59:18 *	Mutabah is away (not here ...)
Feb 21 10:59:27 <Bish>	would you say that's even more daunting?
Feb 21 11:09:40 <bertptrs>	Widdershins: can I dm you about something?
Feb 21 11:26:18 <Mutabah>	Bish: You could, I just don't know exactly where it is or how it looks (the `match` impl)
Feb 21 11:31:45 <j`ey>	Mutabah: so you didnt start mrustc by running rust2c on rustc?
Feb 21 11:31:47 <j`ey>	:p
Feb 21 11:38:25 <Mutabah>	j`ey: Well... strictly speaking that was what mrustc started out as - convert AST to C
Feb 21 11:38:52 <Mutabah>	but by the time I got anywhere near close to codegen, that was gone and C was backend
Feb 21 11:45:53 <Widdershins>	bertptrs: what's up
Feb 21 12:41:26 <Bish>	im still on my http2 streaming bodies adventure
Feb 21 12:41:54 <Bish>	https://bpa.st/5QQA but im stuck on e=hyper::Error(User(ManualUpgrade))
Feb 21 12:42:11 <Bish>	if someone knows whats going on it'd be cool
Feb 21 12:43:03 <Bish>	(specificially the websocket route, the rest works)
Feb 21 12:46:25 <Bish>	https://github.com/hyperium/hyper/blob/00a703a9ef268266f8a8f78540253cbb2dcc6a55/src/upgrade.rs#L264 https://github.com/hyperium/hyper/blob/00a703a9ef268266f8a8f78540253cbb2dcc6a55/src/server/conn/http1.rs#L220 this seems to be the "callstack" on that error
Feb 21 12:48:47 <Bish>	fuck me, im so stupid
Feb 21 12:48:53 <Bish>	rubber ducky best method
**** BEGIN LOGGING AT Wed Feb 21 16:46:59 2024

Feb 21 16:46:59 *	Now talking on ##rust
Feb 21 16:46:59 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 21 16:46:59 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Feb 21 17:12:09 <bombastick>	Hi
Feb 21 17:23:17 <Aorimn>	hi, what would be the most idiomatic way of converting a [u8; 6] to a [u8; 8] by adding zeroes to the end of it (so that I can u64::from_le_bytes() it afterward)?
Feb 21 17:23:43 <Aorimn>	the only solution I can think of is copying the bytes in a loop, but that doesn't sound nice
Feb 21 17:23:55 <bombastick>	what % of you use Rust for work as your primary language, as opposed to hobbyist?
Feb 21 17:24:22 <Aorimn>	I have this 6 size because I'm reading (impl Read) those 6 bytes
Feb 21 17:24:52 <bertptrs>	let mut dest = [0u8; 8]; reader.read(&mut dest[..6])?
Feb 21 17:27:07 <Aorimn>	ah... that's even better indeed ^^'   thanks bertptrs!
Feb 21 17:27:31 <bertptrs>	err, read_exact of course
Feb 21 17:27:37 <bertptrs>	close enough
Feb 21 17:28:14 <Aorimn>	yeah, I managed to make the translation :)
Feb 21 17:28:15 <bertptrs>	ideally the compiler realizes that it doesn't have to zero initialize the first 6 bytes but if not it's just six bytes, how hard can it be
Feb 21 17:29:21 <Aorimn>	in this case I'm not too strict on performances, I'll code the feature before looking at such issues (not even sure it'll be in a hot path at this point)
Feb 21 17:30:58 <bertptrs>	good decision
Feb 21 19:53:42 <flipchan>	im trying to print some ascii art, does anyone know any crates that lets you autoscale a string based on terminal size?
Feb 21 19:54:06 <flipchan>	I'm trying to scale the ascii art based on terminal size so it will work on all terminal sizes
Feb 21 19:54:42 <danieldg>	look for wrappers around ncurses or just access to termios in general to get the size
Feb 21 19:54:45 <bertptrs>	terminal_size and then wrap it yourself?
Feb 21 19:54:48 <bertptrs>	that's what clap does
Feb 21 19:54:52 <alip>	BufRead::lines() will OOM when you hand it /dev/zero, bug or feature?
Feb 21 19:55:08 <danieldg>	alip: working as intended
Feb 21 19:55:18 <alip>	nice
Feb 21 19:55:25 <bertptrs>	alip: you made it read until the end of the line, when there was no end of the line
Feb 21 19:55:28 <bertptrs>	what did you expect?
Feb 21 19:55:34 <danieldg>	alip: just like loop { vec.push(0) } OOMs
Feb 21 19:55:40 <alip>	i expected no newline found in LINE_MAX bytes with ENAMETOOLONG
Feb 21 19:55:48 <alip>	and hence i implemented it myself
Feb 21 19:55:53 <alip>	never trust rust stdlib lol
Feb 21 19:56:20 <danieldg>	LINE_MAX? is that the thing that gets() uses, but only if on a TTY?
Feb 21 19:56:38 <alip>	no line_max is just a random big number doesn't matter what
Feb 21 19:56:46 <alip>	friends don't oom on each other
Feb 21 19:56:55 <danieldg>	it'll never be big enough
Feb 21 19:57:05 <alip>	the alternative is far worse
Feb 21 19:57:21 <bertptrs>	going OOM on infinite input isn't that bad
Feb 21 19:57:27 <danieldg>	I want to read json-lines files with .lines() and have json blobs not be limited to a few MB
Feb 21 19:57:44 <alip>	i can see why the never big enough argument is logical
Feb 21 19:57:46 <bertptrs>	arbitrarily splitting lines after so many characters is bound to lead to weird surprises
Feb 21 19:57:54 <alip>	but then i'd at least expect a warning in lines() docs about this
Feb 21 19:58:14 <danieldg>	alip: the lack of a LINES_MAX reference *is* the warning
Feb 21 19:58:25 <alip>	nice
Feb 21 19:58:32 <alip>	never trust the stdlib docs
Feb 21 19:58:51 <danieldg>	if that's how you define trust...
Feb 21 19:59:13 <alip>	you say the lack of stating a limit is good enough for the code ooming on you
Feb 21 19:59:18 <alip>	and yes, that's how i define trust
Feb 21 19:59:24 <bertptrs>	code OOM'ing is safe behaviour
Feb 21 19:59:30 <alip>	mmph ofc it is
Feb 21 19:59:32 <alip>	ok nvm
Feb 21 19:59:39 <bertptrs>	as opposed to the alternatives it is
Feb 21 19:59:45 <danieldg>	you could just as easily call it an OS bug
Feb 21 19:59:57 <bertptrs>	BufRead::lines() has issues but this is not (imo) one of them
Feb 21 20:00:21 <danieldg>	/dev/zero should stop after you've read too much data
Feb 21 20:00:35 <danieldg>	maybe prompt you to be sure you want to read that much
Feb 21 20:00:35 <bertptrs>	I'd much prefer an API where you can hand out your own buffer
Feb 21 20:00:39 <bertptrs>	alas
Feb 21 20:00:49 <bertptrs>	(yes there's read_line but that's not an iterator)
Feb 21 20:00:50 <alip>	ye that'd solve it too bertptrs
Feb 21 20:01:09 <alip>	danieldg: c'mon now you're just being ridicilous
Feb 21 20:01:32 <alip>	it just means calling lines() in the wrong context may mean DOS
Feb 21 20:01:43 <alip>	and documenting that is nice and kind
Feb 21 20:01:45 <alip>	ofc it's safe
Feb 21 20:02:29 <danieldg>	calling any read function can mean dos if you don't put limiters on it
Feb 21 20:02:42 <danieldg>	lines() doesn't work well with nonblocking after all
Feb 21 20:03:02 <int-e>	danieldg: so my takeaway from that talk is that I'm not the first one to be surprised by Linux's madvise semantics ;-)
**** BEGIN LOGGING AT Wed Feb 21 20:38:01 2024

Feb 21 20:38:01 *	Now talking on ##rust
Feb 21 20:38:01 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 21 20:38:01 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Feb 21 20:54:20 <capitol>	I have this idea of a new clippy lint, maybe of the pedantic type. One way to make your code be non-portable to 32-bit arches is to write something like: let foo : usize = 4294967295;
Feb 21 20:54:46 <capitol>	and this feels like it would be nice to have a warning about
Feb 21 20:56:56 <j`ey>	you can just try compile for 32 bits :P
Feb 21 20:57:04 <danieldg>	how pedantic should it be?  Rust tries to be able to run with 16-bit usize too
Feb 21 20:57:29 <danieldg>	but there's a lot of code that wants more than 64K for things
Feb 21 20:58:08 <danieldg>	it's not too uncommon to want a vec![0;1<<20] as a buffer (1MB)
Feb 21 21:00:42 <capitol>	yeah, the 16 bit one should maybe be it's own lint, so that it would be able to enable just the ones that you support
Feb 21 21:01:12 <danieldg>	also, anything over 1<<31 in a usize will start to cause problems on 32-bit
Feb 21 21:01:19 <danieldg>	over or equal to
Feb 21 21:01:32 <capitol>	j`ey: true, this is more so that I hopefully don't have to send to many patches to other projects when I package for debian :)
Feb 21 21:01:56 <capitol>	yes
Feb 21 21:17:24 <Vorpal>	Hm I have a crate that can have multiple backends (for talking to distro package managers, different ones for different Linux distros). You can build with support for multiple. But if I disable all features it doesn't work, due to empty enums and the like. Which is a problem for publishing the crate. What is the recommended approach for this. I don't think it makes sense to set any specific distro backend as a default feature either.
Feb 21 21:17:33 <Vorpal>	The issue is enums like this one: https://0x0.st/H5bj.txt
Feb 21 21:18:00 <j`ey>	whats the issue with an empty enum?
Feb 21 21:18:22 <Vorpal>	j`ey: well match statements on those (with similar cfg directives) doesn't work when the body of the match statement becomes empty
Feb 21 21:18:23 <j`ey>	empty enums are fine in general
Feb 21 21:18:28 <Vorpal>	error[E0004]: non-exhaustive patterns: type `&config::Backend` is non-empty
Feb 21 21:18:47 <j`ey>	can you paste the code that fails
Feb 21 21:18:52 <j`ey>	 / full error
Feb 21 21:19:00 <Vorpal>	one second
Feb 21 21:19:22 <j`ey>	https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=6ed4245c28a8728d6edc7c355c313087
Feb 21 21:20:48 <danieldg>	depending on what you actually need, you could just add a 'not implemented' backend that is always available.  But yes, this should work already.
Feb 21 21:20:49 <Vorpal>	https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=3bd573a790b0fcaad5bff662d8b9e77d
Feb 21 21:20:52 <Arnavion>	Publishing shouldn't be a problem. You can do `--features` with `cargo publish`
Feb 21 21:21:10 <Vorpal>	ah, the issue seems to be the reference
Feb 21 21:21:10 <Arnavion>	so you can pick one or all of them just to satisfy `cargo publish`
Feb 21 21:21:17 <j`ey>	ah right
Feb 21 21:21:37 <danieldg>	wait, references are always inhabited now?  When did this happen?
Feb 21 21:21:47 <Vorpal>	hm for this enum it works, I have another one (different file checksums) where it will be trickier since it isn't copy
Feb 21 21:22:11 <j`ey>	danieldg: wasnt that always the case??
Feb 21 21:22:33 <danieldg>	j`ey: pretty sure you used to be able to match reference {}
Feb 21 21:22:34 <j`ey>	Vorpal: I think danieldg's suggestion of a NullBackend is probably the easiest.. maybe
Feb 21 21:23:09 <danieldg>	I think I used it in some Infallible impls
Feb 21 21:23:28 <Vorpal>	j`ey: for backend I don't need the reference (payload-less enum, Copy). For https://0x0.st/H5b2.txt I have a very similar situation, there I don't want to copy, so that will be trickier
Feb 21 21:23:41 <j`ey>	danieldg: same error on 1.18
Feb 21 21:23:54 <danieldg>	j`ey: ahh, "match *self" works
Feb 21 21:24:00 <danieldg>	Vorpal: you could use that
Feb 21 21:24:24 <Vorpal>	danieldg: won't that result in a copy though? For the second case.
Feb 21 21:24:33 <Vorpal>	(that is https://0x0.st/H5b2.txt )
Feb 21 21:24:48 <Arnavion>	Just do `--features` instead of adding a fake backend or changing your code...
Feb 21 21:24:50 <danieldg>	you can start throwing in ref in your match arms
Feb 21 21:25:01 <Vorpal>	Arnavion: yeah probably the right choice
Feb 21 21:25:06 <danieldg>	it will not force a copy
Feb 21 21:25:26 <Vorpal>	or that, that works too
Feb 21 21:26:24 <danieldg>	I suppose I wrote the Infallible matches prior to match ergonomics and didn't notice they used *
Feb 21 21:27:41 <Vorpal>	Arnavion: actually, right now --features work, but I plan to add other packages and data source types (flatpak, snap, rpm, tmpfiles.d) not all of them have all info on installed files, not all of them have info on installed packages, Some have both, some have either or. So I believe I could end up in a similar situation if I only build support for snap and flatpak say (no need to depend on any checksum library for those)
Feb 21 21:28:09 <Vorpal>	So I'm going with ref
Feb 21 21:29:31 <Vorpal>	still end up with a bunch of warnings though for --no-default-features (variable don't need to be mutable, unused variants, etc). Oh well. I think I'll live with that.
Feb 21 21:30:46 <j`ey>	you could also just explicitly fail to compile with no backend selected
Feb 21 21:32:08 <Vorpal>	I could yes, might make sense to tell any users other than me how to use it properly.
Feb 21 21:47:39 <Arnavion>	Vorpal:   https://github.com/Arnavion/k8s-openapi/blob/master/build.rs#L9-L60   If you need inspiration
Feb 21 21:48:44 <Vorpal>	#[cfg(not(any(feature = "arch_linux", feature = "debian")))] compile_error!("At least one backend must be enabled");
Feb 21 21:48:54 <Vorpal>	seems simpler
Feb 21 21:50:03 <Vorpal>	no need to add a build script if I don't need to
Feb 21 21:50:19 <Arnavion>	Yes, if it's just `any(feature, feature)` you can do it inline
Feb 21 21:55:28 <Vorpal>	well, I assume any takes any number of arguments, so I should be able to continue once I add more backends too
Feb 21 21:57:20 <Arnavion>	Yes
**** BEGIN LOGGING AT Wed Feb 21 23:19:27 2024

Feb 21 23:19:26 *	Now talking on ##rust
Feb 21 23:19:26 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 21 23:19:26 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** ENDING LOGGING AT Wed Feb 21 23:20:04 2024

**** BEGIN LOGGING AT Wed Feb 21 23:21:17 2024

Feb 21 23:21:17 *	Now talking on ##rust
Feb 21 23:21:17 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 21 23:21:17 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** ENDING LOGGING AT Wed Feb 21 23:50:23 2024

**** BEGIN LOGGING AT Wed Feb 21 23:50:23 2024

**** ENDING LOGGING AT Wed Feb 21 23:52:21 2024

**** BEGIN LOGGING AT Wed Feb 21 23:52:21 2024

**** ENDING LOGGING AT Wed Feb 21 23:53:41 2024

**** BEGIN LOGGING AT Wed Feb 21 23:53:41 2024

**** ENDING LOGGING AT Wed Feb 21 23:57:59 2024

**** BEGIN LOGGING AT Wed Feb 21 23:57:59 2024

Feb 22 00:18:13 <bwidawsk>	I want to keep a hashmap where the values in the map are a hashable object. I don't care what the key will be, as it's an opaque handle that is used by the caller in the API. What is the best way to create unique keys to associate with the object? (I was thinking `hashmap.insert(object.hash(), object)`)
Feb 22 00:18:34 <bwidawsk>	(Could also use an atomic as an index ofc)
Feb 22 00:19:36 <Arnavion>	object.hash() is fine. To avoid double-hashing you can use something like   https://docs.rs/hash_hasher
Feb 22 00:19:51 <Arnavion>	or BTreeMap
Feb 22 00:20:42 <bwidawsk>	Arnavion: thank you
Feb 22 02:15:58 <segfaultfizzbuzz>	are there any good recommendations for how to store a secret string/token in a rust binary?
Feb 22 02:16:47 <danieldg>	either anywhere or nowhere
Feb 22 02:16:55 <danieldg>	anywhere if the binary can be a secret, nowhere if not
Feb 22 02:19:48 <segfaultfizzbuzz>	so a const String is about as good as it gets i guess?
Feb 22 02:20:05 <segfaultfizzbuzz>	i am aware of SGX but i can't do that unfortunately...
Feb 22 02:20:35 <danieldg>	yes, if you're not able to store it anywhere else secure either
Feb 22 02:20:58 <danieldg>	HSM, TPM, etc
Feb 22 02:21:21 <segfaultfizzbuzz>	so this isn't worthwhile for instance: https://crates.io/crates/secstr
Feb 22 02:22:10 <Mutabah>	that would help prevent runtime leaks
Feb 22 02:22:56 <Mutabah>	but the original secret will still be in the binary somewhere - you can obsfucate it, but that only adds a thin layer of protection
Feb 22 02:23:27 <segfaultfizzbuzz>	runtime leaks? on a related note, can unsafe code read/modify the program itself (which i suppose is in memory..?)  ?
Feb 22 02:24:23 <segfaultfizzbuzz>	secstr isn't stored on github, which is odd
Feb 22 02:27:28 <danieldg>	segfaultfizzbuzz: read, usually; modify, no, not unless it takes action to call mprotect
Feb 22 02:28:10 <segfaultfizzbuzz>	why wouldn't the operating system wall the program code off from the data ?
Feb 22 02:28:28 <danieldg>	most architectures don't support that
Feb 22 02:28:46 <segfaultfizzbuzz>	yipes
Feb 22 02:29:07 <cehteh>	moderm ones do, but ther are a zillion ways to circumvent it
Feb 22 02:29:39 <danieldg>	ASLR helps too
Feb 22 02:29:56 <danieldg>	but yeah, 'bypassing ASLR' is like 'hacking 102' these days
Feb 22 02:30:25 <cehteh>	x86-64 has write protection on executable pages
Feb 22 02:30:40 <segfaultfizzbuzz>	you would think that there would be read protection for those as well...
Feb 22 02:30:46 <danieldg>	yes - executable plages are *normally* write protected
Feb 22 02:30:59 <danieldg>	there's not normally a need or desire to read protect
Feb 22 02:31:03 <cehteh>	but a program could do all kinds of fancy stuff like creating a dynlib and loading that
Feb 22 02:31:11 <segfaultfizzbuzz>	...but why would you want to read at all?
Feb 22 02:31:30 <danieldg>	segfaultfizzbuzz: code and read-only data can share pages
Feb 22 02:31:39 <cehteh>	on linux you can do a lot protection with seccomp, but its not trivial
Feb 22 02:31:44 <segfaultfizzbuzz>	memory locality/speed then?
Feb 22 02:31:58 <danieldg>	seccomp doesn't help with read the executable
Feb 22 02:32:14 <danieldg>	you need less common things like memory protection keys
Feb 22 02:32:27 <cehteh>	yes but seccomp makes sure that a program cant m(un)protect pages it shouldn
Feb 22 02:32:54 <cehteh>	or load dynlibs and so on
Feb 22 02:32:56 <danieldg>	the memseal system calls are useful here too
Feb 22 02:34:11 <segfaultfizzbuzz>	darpa Measures for Establishment of Memory Signatures in Early Activated Lymphocytes
Feb 22 02:35:09 <danieldg>	no
Feb 22 02:35:56 <danieldg>	https://lwn.net/Articles/958438/
Feb 22 02:44:32 <danieldg>	basically a well-written program won't read from arbitrary memory addresses and so won't be a problem
Feb 22 02:45:18 <danieldg>	so just rely on that - rust doesn't let you bypass it without unsafe
Feb 22 02:45:38 <segfaultfizzbuzz>	right ok thanks
Feb 22 03:22:41 <dkg>	i'm struggling with Rust's C FFI: i'm building a shared object in Rust that exposes a function to the C ABI.  I want the external C code to be able to call the function with an argument that is a pointer to a fixed-length buffer of chars.  this argument, if non-null, will be used to return a limited-length, null-terminated error string if the function fails.
Feb 22 03:23:35 <dkg>	i'm having trouble with the typing for this buffer and how to get a Rust string error message to be written to it properly.
Feb 22 03:23:43 <danieldg>	*mut u8
Feb 22 03:23:57 <Mutabah>	By fixed-length, do you mean ABI/API specified, or is the length in another argument?
Feb 22 03:24:09 <Mutabah>	If it's the former - then `*mut [u8; 123]`
Feb 22 03:24:20 <dkg>	what i've got so far is:     #[repr(C)] pub struct foo_err_msg { message: [c_char; 128], }
Feb 22 03:24:38 <dkg>	the API specifies that the error buffer is always  a simple struct with 128 chars in it.
Feb 22 03:25:00 <dkg>	then the argument to the function is Option<&mut foo_err_msg>
Feb 22 03:25:16 <Mutabah>	that all seems reasonable
Feb 22 03:25:26 <dkg>	and i'll only write to it if let Some(err_out) = err_out
Feb 22 03:25:39 <dkg>	so the problem i'm having in the function is figuring out how to write to the buffer
Feb 22 03:25:47 <danieldg>	I'd use u8 and not c_char
Feb 22 03:26:00 <danieldg>	because rust prefers writing to u8
Feb 22 03:26:18 <danieldg>	and it's not like C actually cares if char is signed or not 99.9% of the time
Feb 22 03:26:26 <dkg>	hm, but in the C interface i'd prefer it is a char, because that's a clean hint to the C user that this will be a null-terminated string.
Feb 22 03:26:43 <dkg>	and if we're gonna get typing right, i kind of want to get it right :P
Feb 22 03:26:57 <danieldg>	here's a secret: char* and unsigned char* have the same ABI :)
Feb 22 03:27:02 <dkg>	but yeah, i'm seeing messgaes like: expected `[i8; 128]`, found `&[u8]`
Feb 22 03:27:33 <dkg>	i'm aware that they have the same ABI, i'm just trying to do this cleanly by respecting the type system and not tricking it :)
Feb 22 03:27:34 <danieldg>	yes, because rust wants to write to u8
Feb 22 03:28:00 <danieldg>	you can just impl std::io::Write for your struct foo_err_msg
Feb 22 03:28:06 <danieldg>	or fmt::Write, if you like
Feb 22 03:28:25 <danieldg>	copy the bytes one by one and cast them from u8 to i8
Feb 22 03:29:06 <dkg>	well, from u8 to std::ffi::c_char, since presumably different platforms have different c_chars -- they aren't all i8 :/
Feb 22 03:29:18 <danieldg>	yes
Feb 22 03:29:21 <dkg>	it happens to be i8 on my platform
Feb 22 03:29:32 <danieldg>	it's i8 or u8 basically everywhere
Feb 22 03:30:03 <dkg>	agreed
Feb 22 03:30:05 <danieldg>	only systems that aren't byte-addressible can get away with char not being a byte
Feb 22 03:30:51 <dkg>	but again, i'm trying to do clean typing without assumptions; that's one of the things i find compelling about Rust.  maybe i'm being too much of a purist
Feb 22 03:31:35 <danieldg>	your cast can be char, yes
Feb 22 03:31:40 <dkg>	so even if i switch to u8 instead of std::ffi::c_char, i get: expected `[u8; 128]`, found `&[u8]`
Feb 22 03:31:53 <dkg>	how do i deal with the length limit safely?
Feb 22 03:32:03 <danieldg>	you use a ref?
Feb 22 03:32:04 <dkg>	sorry if this is a n00b question, i'm a n00b 😛
Feb 22 03:32:21 <Mutabah>	you want .copy_from_slice
Feb 22 03:32:31 <Mutabah>	which might also require slicing the destination to the right length
Feb 22 03:32:35 <dkg>	yes, i'm using Option<&mut foo_err_msg>  and i'm in the case where "if let Some(err_msg) = err_msg {"
Feb 22 03:32:50 <Mutabah>	Or, a custom loop that writes into the destination and ensures that it's NUL terminated
Feb 22 03:33:10 <dkg>	i was hoping to use something like CString.as_bytes_with_nul()
Feb 22 03:33:19 <dkg>	so that i don't have to write any custom byte-level loops
Feb 22 03:33:41 <danieldg>	you'll still have to copy the memory from the CString to the output
Feb 22 03:33:46 <dkg>	agreed.
Feb 22 03:33:51 <dkg>	(fwiw, i'm jumping through these hoops to try to avoid any memory allocations across the FFI)
Feb 22 03:33:52 <danieldg>	but that could be with copy_from_slice
Feb 22 03:34:18 <danieldg>	writing to the destination buffer in-place is "nicer"
Feb 22 03:34:35 <danieldg>	vs writing to a String, converting to CString, then copying
Feb 22 03:34:45 <dkg>	i agree, it does seem cleaner to write to the destination buffer in place
Feb 22 03:35:22 <dkg>	but i don't know how to do that :/  and, in some cases, i'll have an Err that i want to extract a (potentially truncated) message from and copy it in
Feb 22 03:36:43 <danieldg>	dkg: struct Writer { buf: &mut [c_char] }  impl Writer { fn new(buf:&mut [c_char;128]) -> Self { Self { buf }}} impl std::fmt::Write for Writer { ...
Feb 22 03:37:33 <danieldg>	you can maintain the null-termination invariant as you write, or do it in Drop
Feb 22 03:38:41 <danieldg>	write_str is where you put either your u8->c_char loop, or a copy_from_slice if you decide to use u8 not c_char
Feb 22 03:38:58 <danieldg>	then you can call write!() on your Writer
Feb 22 03:39:50 <danieldg>	write_str should advance self.buf - that's why it uses a slice, not an array
Feb 22 03:40:08 <dkg>	thanks!  still trying to wrap my head around this…  i need a new struct to do this?  or i put this impl on my foo_err_msg ?
Feb 22 03:40:16 <danieldg>	new struct
Feb 22 03:40:45 <danieldg>	it has to track the 'cursor'
Feb 22 03:41:40 <dkg>	i see, the Writer struct is just the cursor tracker
Feb 22 03:42:43 <dkg>	ok, you've given me enough to chew on, i'll try to sort it out further.  thanks!  i thought this would be a bit simpler than it is turning out to be :/
Feb 22 03:48:18 <danieldg>	the simple way is to use the existing io::Write impl for &mut [u8]
Feb 22 03:49:09 <danieldg>	you can cast a &mut [u8;128] to a &mut [u8] and then write to it
Feb 22 03:50:11 <danieldg>	or even the one for Cursor<[u8;N]>
Feb 22 03:50:40 <danieldg>	I just noticed that one, it's nicer for this case
Feb 22 09:33:00 <SiegeLord>	Lets say I have a trait: `trait Foo { fn call(&self, ctx: impl Context) -> (); }`, is there a way to automatically implement it for functions with the same signature as the `call` associated function?
Feb 22 09:33:23 <SiegeLord>	Like a `fn foo(ctx: impl Context) -> () {}`
Feb 22 09:33:51 <bertptrs>	Sort of
Feb 22 09:37:09 <SiegeLord>	The final goal is to somehow write: `fn bar(call: impl Fn(impl Context) -> ()`
Feb 22 09:37:28 <SiegeLord>	Which isn't possible, so I'm attempting to write `fn bar(call: impl Foo)`
Feb 22 09:37:42 <SiegeLord>	But I want to do something approximating `bar(foo)`
Feb 22 09:39:03 <SiegeLord>	It's clear that I can, for every `foo`, write a manual implementation for some dummy type `F`, but I wonder if there's something with less boilerplate
Feb 22 09:39:18 <SiegeLord>	manual implementation of `Foo`
Feb 22 09:40:11 <bertptrs>	Ah I see, the problem is that you cannot have "impl Trait" in a trait bound
Feb 22 09:40:23 <bertptrs>	so my idea doesn't work https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=77a5b8655b47befd6cae887993bf6250
Feb 22 09:41:12 <bertptrs>	The double generics make it hard
Feb 22 09:41:43 <SiegeLord>	I think this is a type of HKT, so perhaps something using GATs could be a solution, but that's as far as that line of thought goes
Feb 22 09:42:11 <bertptrs>	I don't think you can express this particular thing yet. Which is sad, it's not an unreasonable question
Feb 22 09:42:40 <bertptrs>	If you can tweak the Foo trait a little it might work
Feb 22 09:43:15 <SiegeLord>	I can, it's something I fully control.
Feb 22 09:43:29 <bertptrs>	https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=27e2d1dc09c79939e69c9a917784863f
Feb 22 09:54:56 <SiegeLord>	Ah, that won't work. Here's the version with the dummy type, perhaps clarifying the design goals: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=3d7636e6c165af5ad4b5d0e12dad864d
Feb 22 11:23:12 <sword_smith>	Is a (u64,u64)->u128 multiplication as fast on my x86-64 machine as a (u32,u32)->u64 multiplication?
Feb 22 11:25:37 <Mutabah>	probably pretty close on its own...
Feb 22 11:25:46 <Mutabah>	but more data takes longer to load/manipulate
Feb 22 11:27:12 <Norkle>	hi
Feb 22 11:28:07 <Mutabah>	Hello.
Feb 22 11:28:16 <Mutabah>	Interesting hostname you have there
Feb 22 11:43:25 <saati>	sword_smith: on most cpus multiplication takes variable time determined by it's inputs
Feb 22 11:43:51 <saati>	bigger numbers can take a couple more cycles
Feb 22 11:44:57 <saati>	iirc zen4 has const time multiplication
Feb 22 11:45:48 <Mutabah>	saati: eeeh... multiplication units can be done in constant time based on the bit size
Feb 22 11:46:18 <Mutabah>	shift+add for each bit in the other number
Feb 22 11:50:06 <saati>	let's benchmark
Feb 22 11:54:21 <sword_smith>	saati: Thanks. I have a benchmark here, but it does some annoying addition, that I would like to remove: use std::ptr;
Feb 22 11:54:24 <sword_smith>	use criterion::measurement::WallTime;
Feb 22 11:54:26 <sword_smith>	use criterion::{
Feb 22 11:54:29 <sword_smith>	    criterion_group, criterion_main, BenchmarkGroup, BenchmarkId, Criterion, Throughput,
Feb 22 11:54:32 <sword_smith>	};
Feb 22 11:54:34 <sword_smith>	use twenty_first::shared_math::other::random_elements;
Feb 22 11:54:37 <sword_smith>	fn mul(c: &mut Criterion) {
Feb 22 11:54:39 <sword_smith>	    let mut group = c.benchmark_group("mul");
Feb 22 11:54:42 <sword_smith>	    let log2_of_sizes: Vec<usize> = vec![3, 7, 12, 18, 23];
Feb 22 11:54:44 <sword_smith>	    // Benchmarking forward ntt on BFieldElements
Feb 22 11:54:47 <sword_smith>	    for log2_of_size in log2_of_sizes.iter() {
Feb 22 11:54:49 <sword_smith>	        u32_mul(
Feb 22 11:54:52 <sword_smith>	            &mut group,
Feb 22 11:54:54 <sword_smith>	            BenchmarkId::new("(u32,u32)->u64", log2_of_size),
Feb 22 11:54:57 <sword_smith>	            *log2_of_size,
Feb 22 11:54:59 <sword_smith>	        );
Feb 22 11:55:02 <sword_smith>	    }
Feb 22 11:55:04 <sword_smith>	    for log2_of_size in log2_of_sizes.iter() {
Feb 22 11:55:07 <sword_smith>	        u64_mul(
Feb 22 11:55:09 <sword_smith>	            &mut group,
Feb 22 11:55:12 <sword_smith>	            BenchmarkId::new("(u64,u64)->u128", log2_of_size),
Feb 22 11:55:13 <j`ey>	um
Feb 22 11:55:15 <sword_smith>	            *log2_of_size,
Feb 22 11:55:17 <sword_smith>	        );
Feb 22 11:55:20 <sword_smith>	    }
Feb 22 11:55:22 <sword_smith>	    group.finish();
Feb 22 11:55:25 <sword_smith>	}
Feb 22 11:55:27 <sword_smith>	fn u32_mul(group: &mut BenchmarkGroup<WallTime>, bench_id: BenchmarkId, log2_of_size: usize) {
Feb 22 11:55:30 <sword_smith>	    let size: usize = 1 << log2_of_size;
Feb 22 11:55:33 <sword_smith>	    let xs: Vec<u32> = random_elements(size);
Feb 22 11:55:35 <sword_smith>	    group.throughput(Throughput::Elements(size as u64));
Feb 22 11:55:38 <sword_smith>	    group.bench_with_input(bench_id, &size, |b, _| {
Feb 22 11:55:40 <sword_smith>	        b.iter(|| {
Feb 22 11:55:43 <sword_smith>	            let mut acc = 0u64;
Feb 22 11:55:45 <sword_smith>	            for i in 0..(size - 1) {
Feb 22 11:55:48 <sword_smith>	                acc = acc.wrapping_add(xs[i] as u64 * xs[i + 1] as u64);
Feb 22 11:55:50 <sword_smith>	            }
Feb 22 11:55:53 <sword_smith>	            // Prevent the compiler from optimizing the loop away
Feb 22 11:55:55 <sword_smith>	            unsafe {
Feb 22 11:55:58 <sword_smith>	                ptr::write_volatile(&mut acc as *mut u64, acc);
Feb 22 11:56:00 <sword_smith>	            }
Feb 22 11:56:03 <sword_smith>	        })
Feb 22 11:56:05 <sword_smith>	    });
Feb 22 11:56:08 <sword_smith>	    group.sample_size(10);
Feb 22 11:56:10 <sword_smith>	}
Feb 22 11:56:13 <sword_smith>	fn u64_mul(group: &mut BenchmarkGroup<WallTime>, bench_id: BenchmarkId, log2_of_size: usize) {
Feb 22 11:56:16 <sword_smith>	    let size: usize = 1 << log2_of_size;
Feb 22 11:56:18 <sword_smith>	    let xs: Vec<u64> = random_elements(size);
Feb 22 11:56:21 <sword_smith>	    group.throughput(Throughput::Elements(size as u64));
Feb 22 11:56:23 <sword_smith>	    group.bench_with_input(bench_id, &size, |b, _| {
Feb 22 11:56:26 <sword_smith>	        b.iter(|| {
Feb 22 11:56:28 <sword_smith>	            let mut acc = 0u128;
Feb 22 11:56:31 <sword_smith>	            for i in 0..(size - 1) {
Feb 22 11:56:33 <sword_smith>	                acc = acc.wrapping_add(xs[i] as u128 * xs[i + 1] as u128);
Feb 22 11:56:36 <sword_smith>	            }
Feb 22 11:56:38 <sword_smith>	            // Prevent the compiler from optimizing the loop away
Feb 22 11:56:40 <j`ey>	bertptrs:
Feb 22 11:56:41 <sword_smith>	            unsafe {
Feb 22 11:56:43 <sword_smith>	                ptr::write_volatile(&mut acc as *mut u128, acc);
Feb 22 11:56:46 <sword_smith>	            }
Feb 22 11:56:48 <sword_smith>	        })
Feb 22 11:56:51 <sword_smith>	    });
Feb 22 11:56:53 <sword_smith>	    group.sample_size(10);
Feb 22 11:56:56 <sword_smith>	}
Feb 22 11:56:58 <sword_smith>	criterion_group!(benches, mul);
Feb 22 11:57:01 <sword_smith>	criterion_main!(benches);
Feb 22 11:57:03 <sword_smith>	fucking hell
Feb 22 11:57:06 <sword_smith>	sorry
Feb 22 11:57:08 <sword_smith>	I meant to copy-paste this: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021
Feb 22 11:57:09 <Affliction>	https://play.rust-lang.org/?version=stable&mode=debug&edition=2021 for code pastes; doing it that way results in you sending 1 message per second. And that is generally annoying.
Feb 22 11:57:11 <sword_smith>	yeah .. sorry guys. Didn't mean to spam. `irssi` warned me about 75 lines, but the command to go ahead is the command I use to delete my input (ctrl+a, ctrl+k).
Feb 22 11:57:23 <j`ey>	sword_smith: imagine if you accidentally pasted the same thing again lol
Feb 22 11:58:03 <Affliction>	nice how my message lined up with the very end, heh.
Feb 22 11:58:03 <bertptrs>	sword_smith: can you not do that again
Feb 22 11:58:05 <sword_smith>	My IRC client *should* make it harder to SPAM, imo.
Feb 22 11:58:16 <sword_smith>	Yes, I'm blaming my software, partially.
Feb 22 11:58:19 <j`ey>	bertptrs: ban him!!!
Feb 22 11:58:34 <bertptrs>	I think the youth of today would call it a skill issue
Feb 22 11:58:44 <bertptrs>	j`ey: accidents happen, let it slide
Feb 22 11:58:48 <sword_smith>	j`ey: Watch out with irony on text :)
Feb 22 11:58:52 <Affliction>	Anyway, you pasted a link to the empty playground; hit share and "permalink"
Feb 22 11:59:03 <j`ey>	sword_smith: I was hoping the multiple !! was enough :P
Feb 22 11:59:21 <sword_smith>	saati: Here's the benchmark I've written: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=d52ce86b44e054533e003e8440ed8ec0
Feb 22 12:00:31 <Widdershins>	sword_smith: what did you want to remove
Feb 22 12:00:44 <bertptrs>	j`ey: the double ping cancels out the exclamation marks
Feb 22 12:01:08 <Widdershins>	the exclamation marks cast your sarcasm to boolean
Feb 22 12:01:13 <j`ey>	bertptrs: oh true, my bad
Feb 22 12:01:43 <sword_smith>	saati: But my benchmark includes some summation, that I would like to avoid. The compiler is quick optimize away unused results though.
Feb 22 12:02:18 <Bish>	how many people here are fulltime rusters (getting paid for it)
Feb 22 12:02:26 <Widdershins>	you mean your volatile thing you're doing to force the loop not to optimize?
Feb 22 12:02:28 <sword_smith>	The benchmark I've written *almost* achieves what I want. And does run faster for (u32,u32)->u64 mul than for u64->u128 mul.
Feb 22 12:02:57 <Widdershins>	https://doc.rust-lang.org/std/hint/fn.black_box.html
Feb 22 12:03:06 <sword_smith>	Widdershins: The volatile thing *and* the entire accumulation. I don't actually want to add anything.
Feb 22 12:03:10 <sword_smith>	Just multiply.
Feb 22 12:03:34 <Widdershins>	see that link, that's the dedicated tool for this
Feb 22 12:08:24 <sword_smith>	Widdershins: Do you have something I can use on `stable`?
Feb 22 12:14:54 <saati>	yeah i was wrong, i can't demonstrate t
Feb 22 12:15:24 <saati>	it, but on skylake u64*u64 -> u128 is half as fast as u32*u32->u64, on zen3 they take the same time
Feb 22 12:16:44 <sword_smith>	Criterion has its own `black_box` thing that I think I can use. Not too well documented though.
Feb 22 12:27:58 <sword_smith>	saati: Managed to get a benchmark that I *think* does want I want it to. On my Intel Core i9-11950H multiplying two u64s takes the same time as multiplying two u32s.
Feb 22 12:29:12 <sword_smith>	Here's my benchmark: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=51d1ec615fb88dfeca508d58213efcbf
Feb 22 12:30:37 <Widdershins>	saati: black box is on stable, it's just not *const*
Feb 22 12:30:41 <Widdershins>	unless you're on unstable
Feb 22 12:30:48 <Widdershins>	sorry, sword_smith
Feb 22 12:31:02 <Widdershins>	using criterion's black box is also good
Feb 22 12:32:10 <Widdershins>	but std::hint::black_box has been stable since 1.66
Feb 22 12:36:31 <sword_smith>	Widdershins: I see. My IDE wanted to import `std::intrinsics::black_box` instead for some reason. And that thing gave me the `unstable` error.
Feb 22 12:36:55 <Widdershins>	the hint one just calls that, but yeah. which ide
Feb 22 12:37:36 <sword_smith>	VS Code. With `rust-analyzer`.
Feb 22 12:45:43 *	ChanServ gives channel operator status to Widdershins
Feb 22 12:49:02 *	Widdershins removes channel operator status from Widdershins
**** ENDING LOGGING AT Thu Feb 22 13:52:24 2024

**** BEGIN LOGGING AT Thu Feb 22 13:55:48 2024

Feb 22 13:55:47 *	Now talking on ##rust
Feb 22 13:55:47 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 22 13:55:47 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** BEGIN LOGGING AT Thu Feb 22 13:57:12 2024

Feb 22 13:57:11 *	Now talking on ##rust
Feb 22 13:57:11 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 22 13:57:11 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Feb 22 15:10:59 <sword_smith>	How can all these benchmarks take the same about of time? They really shouldn't, I think: https://github.com/Neptune-Crypto/twenty-first/blob/9f86d4a1341ef72bd2e6ae87e9fe0e4fb75ac170/twenty-first/benches/various_muls.rs
Feb 22 15:11:19 <sword_smith>	I'm I making an error in the benchmarking code?
Feb 22 15:13:20 <bertptrs>	what do you mean same amount of time?
Feb 22 15:13:47 <bertptrs>	criterion by default takes 100 samples over the course of 5 seconds, or longer if it's impossible to do within 5 seconds
Feb 22 15:15:47 <bertptrs>	oh the unsigned_mul test looks weird, that's ont how that works
Feb 22 15:16:11 <sword_smith>	bertptrs: Certain times are reported when a benchmark is run. That's the time I'm referring to.
Feb 22 15:16:33 <sword_smith>	`unsigned_mul/(u32,u32)->u64/1000000 time:   [306.18 µs 306.86 µs 307.70 µs]` etc.
Feb 22 15:22:34 <sword_smith>	bertptrs: If you think you can fix my tests, I would love to get your input :)
Feb 22 15:22:40 <sword_smith>	s/tests/benchmarks/
Feb 22 15:25:46 <bertptrs>	It goes against my religion to spell it out, but I do something fairly similar here: https://github.com/bertptrs/tracing-mutex/blob/master/benches/mutex.rs
Feb 22 15:26:45 <bertptrs>	but crucially you are misusing black_box
Feb 22 15:26:52 <bertptrs>	you don't pass it a closure, you pass it an expression
Feb 22 15:27:21 <bertptrs>	So I'm guessing all you're measuring is how quickly you can loop (size - 1) times
Feb 22 15:31:19 <bertptrs>	also for good measure, I recommend you use the same random data for all tests (to avoid random skew in how CPUs special-case certain multiplications) and use the windows() function instead of xs[i] xs[i + 1]
Feb 22 15:34:39 <sword_smith>	bertptrs: Now I'm getting some more sensible results.
Feb 22 15:47:32 <cehteh>	for some benchmarks i lock them on a specific core and set that core to a fixed frequency like 80% of its max. that makes the benchmarks slower but more reliable because overboost and thermal throttling wont happen
Feb 22 15:49:17 <sword_smith>	Pushed a commit. Now the results are sensible: https://github.com/Neptune-Crypto/twenty-first/blob/57699bb41100f60f7be11816587706acff49453f/twenty-first/benches/various_muls.rs
Feb 22 15:49:51 <cehteh>	on modern CPU's not all cores are equal, and i dont mean the efficiency/performance core thing, even having heterogenous cores some may run cooler and reach higher frequencies than their buddies on the same silicon
Feb 22 15:49:51 <phy1729>	iirc the rust project uses callgrind to record the number of instructions (in addition to other things)
Feb 22 15:50:41 <cehteh>	yes using callgrind helps too, but its more atifical since it emulates a cpu/caches its not the real numbers you get
Feb 22 15:51:09 <dminuoso>	I have dovecot and want it to talk to a server-local HTTP server. What kind of simple but performant server library choices might I have? Security concerns are practically non-existent since the service is not exposed outside the server.
Feb 22 15:52:11 <dminuoso>	(Ultimately I just want something small with a small dependency closure)
Feb 22 16:03:03 <alip>	is there a way to split the parent and file name of a Path in one go rather than calling parent() and file_name() in sequence?
Feb 22 16:05:05 <danieldg>	alip: no, not unless you want to look at components instead of the parent
Feb 22 16:05:48 <alip>	thx
Feb 22 16:07:19 <pflanze>	Are there any philosophies around using borrowing rules for I/O? Like, File implements Read and gets operations that all take &mut self, of course that's needed as some implementations need to maintain state; but maybe it would be there anyway to make sure a file handle is only used from one place to avoid the possibility for interference statically? Or is that outside of Rust's concerns?
Feb 22 16:08:09 <danieldg>	pflanze: if you want to do that, you should wrap the File in something that only allows read/etc on a &mut
Feb 22 16:08:25 <danieldg>	pflanze: &File implements Read explicitly so this isn't needed
Feb 22 16:09:21 <pflanze>	So I get that the answer is that Rust does *not* use borrow checking rules for I/O.
Feb 22 16:09:26 <danieldg>	correct
Feb 22 16:09:31 <pflanze>	OK, thanks!
Feb 22 16:09:46 <danieldg>	look at read_at/write_at if you want to avoid interference
Feb 22 16:11:19 <nullie>	read and gets modify state on any file implementation
Feb 22 16:12:16 <danieldg>	that depends on what you count as state
Feb 22 16:13:08 <danieldg>	the file's cursor will get modified, but that is actually a kernel state thing that rust doesn't control
Feb 22 16:16:01 <pflanze>	Yep, IIRC on POSIX the cursor is even shared across processes.
Feb 22 16:16:28 <danieldg>	yes, it is
Feb 22 16:17:42 <nullie>	let's implement IO monad
Feb 22 16:18:05 <danieldg>	you can do that if you like
Feb 22 16:19:31 <pflanze>	(Last I know HKT are not ready hence no generic monad infrastructure.)
Feb 22 16:19:59 <pflanze>	(Not that I necessarily wanted to see monads, anyway.)
**** ENDING LOGGING AT Thu Feb 22 17:51:49 2024

**** BEGIN LOGGING AT Thu Feb 22 18:35:18 2024

Feb 22 18:35:17 *	Now talking on ##rust
Feb 22 18:35:17 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 22 18:35:17 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Feb 22 20:09:02 <monr0e>	Moved from Windows to Linux, and am rebuilding a .net web application in Rust with Rocket. Tryign otu CLion, should I look elsewhere for an IDE? Been kinda spoiled by visual studio
Feb 22 20:12:42 <cappy>	monr0e: I'm looking for an IDE for Rust as well. Just went to https://www.jetbrains.com/clion/ and there is no mention of Rust; only C/C++. Is there a Rust plug-in?
Feb 22 20:13:47 <monr0e>	Yes, but I don't know how extensive it is. I ran into some sort of issue settin gup a new project too
Feb 22 20:14:32 <monr0e>	but that may also be because I have no idea how to use rust yet. In fact, I know next to nothing abotu it
Feb 22 20:15:56 <monr0e-pooping>	Oh I should change this nick
Feb 22 20:16:29 <cappy>	monr0e: I just started with Rust a day or two ago. But I found an alternate: VSCodium or Visual Studio Code can be set up for Rust:
Feb 22 20:16:50 <cappy>	monr0e: https://github.com/larina3315/personal-stuff/blob/main/coding/vsc-flatpak-rust.md
Feb 22 20:17:11 <monr0e-phone>	I really want to avoid a vscode solution tbh
Feb 22 20:18:55 <monr0e-phone>	I'm looking for something as close to equivalency as possible to visual studio
Feb 22 20:18:55 <cappy>	Believe that's why the open source VSCodium exists, apart from Microsoft's telemetry et al. Just mentioning it.
Feb 22 20:19:54 <monr0e-phone>	Honestly the telemetry is easy to fix, but I really have been spoiled by visual studio. That sort of featureset is second nature to me now
Feb 22 20:20:26 <monr0e-phone>	VSCode is something I use more for super basic website building
Feb 22 20:20:46 <cappy>	Understand your point. IDK of anything else. Perhaps someone else here can add?
Feb 22 20:20:50 <LawnGnome>	JetBrains has RustRover as their (fairly new) Rust specific product.
Feb 22 20:21:04 <LawnGnome>	I haven't used it, but if you're used to the JetBrains way of doing things, I assume it would work for you.
Feb 22 20:21:42 <monr0e-phone>	I have zero experience with jetbrains either tbh. I'm willing to try anything that has a decent enough featureset
Feb 22 20:22:20 <monr0e-phone>	RustRover is a plugin? Or an entire IDE in its own right?
Feb 22 20:22:38 <Alexendoo>	somewhere inbetween
Feb 22 20:22:55 <monr0e-phone>	Oh interesting
Feb 22 20:23:00 <cappy>	Is there pricing on RustRover? I'm at the site; don't see it.
Feb 22 20:24:20 <bertptrs>	I've previously used either CLion or IntelliJ Ultimate with the official rust plugin, but then I stopped having a rust job and moved to vscode + rust-analyzer
Feb 22 20:24:22 <cappy>	Or is it considered part of their "Products Pack"?
Feb 22 20:24:29 <Diablo-D3>	I dont think they sell rustrover yet
Feb 22 20:25:08 <cappy>	So is their d/l a trial? (for now)
Feb 22 20:25:15 <monr0e-phone>	From what I can see RustRover is in beta
Feb 22 20:25:29 <Diablo-D3>	cappy: "trial"
Feb 22 20:26:01 <Diablo-D3>	its the same as intellij community edition, but with the rust plugin set instead of the java one
Feb 22 20:26:16 <cappy>	Diablo-D3: meaning, use it for a time until it's out of beta and then pay.
Feb 22 20:26:21 <monr0e-phone>	There's an entirely separate, though deprecated, plugin for intellij cappy
Feb 22 20:26:39 <Diablo-D3>	cappy: basically.
Feb 22 20:26:56 <Diablo-D3>	I'd probably take IDEA more seriously if they'd quit trying to split it up per language
Feb 22 20:27:06 <monr0e-phone>	I might try this preview. Looks interesting
Feb 22 20:27:08 <Diablo-D3>	if I buy intellij ultimate, all of them are in the same IDE
Feb 22 20:27:47 <Diablo-D3>	they jumped the shark, though
Feb 22 20:27:58 <Diablo-D3>	they're all in on AI, which means they're basically dead.
Feb 22 20:28:22 <nCrazed>	last I tried RustRover on my current $job project, it choked on what I am guessing was the workspace set up that I had for that project
Feb 22 20:28:29 <monr0e-phone>	Ugh I noticed the ai thing
Feb 22 20:28:30 <nCrazed>	so still CLion + the plugin for me
Feb 22 20:29:03 <bertptrs>	Diablo-D3: if anyone who went all in on AI was dead, I'd be much happier about the future of the tech industry
Feb 22 20:29:46 <Alexendoo>	monr0e-phone: well you wanted it to be like VS :P
Feb 22 20:30:13 <monr0e-phone>	Alexendoo: No ai in VS 2017!
Feb 22 20:30:31 <monr0e-phone>	Lol "ai"
Feb 22 20:32:03 <nCrazed>	there's no AI in Intellij's 2017 offerings either :|
**** BEGIN LOGGING AT Thu Feb 22 20:35:46 2024

Feb 22 20:35:46 *	Now talking on ##rust
Feb 22 20:35:46 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 22 20:35:46 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** BEGIN LOGGING AT Thu Feb 22 20:47:45 2024

Feb 22 20:47:43 *	Now talking on ##rust
Feb 22 20:47:43 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 22 20:47:43 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Feb 22 20:53:57 <bwidawsk>	istr there was work to allow `..Default::default()` for a struct that doesn't impl Default, but where the remaining members do. Did I make that up? If not, could someone please help me find it?
Feb 22 20:54:35 <bertptrs>	you might've, because that fundamentally cannot work
Feb 22 20:55:02 <bertptrs>	..Default::default() is less magic than you think; it's the struct update syntax
Feb 22 20:55:20 <bertptrs>	What it does, is "these are new fields, then take whatever else from this other struct"
Feb 22 20:55:38 <bertptrs>	Where all Default::default() does is call the default function and take the default values from there
**** BEGIN LOGGING AT Thu Feb 22 20:58:52 2024

Feb 22 20:58:50 *	Now talking on ##rust
Feb 22 20:58:50 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 22 20:58:50 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Feb 22 20:58:56 <bwidawsk>	but looks like it's not longer alive
**** BEGIN LOGGING AT Thu Feb 22 21:13:03 2024

Feb 22 21:13:03 *	Now talking on ##rust
Feb 22 21:13:03 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 22 21:13:03 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** BEGIN LOGGING AT Thu Feb 22 21:16:07 2024

Feb 22 21:16:06 *	Now talking on ##rust
Feb 22 21:16:06 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 22 21:16:06 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Feb 22 21:35:00 <maxsimo>	list
Feb 22 21:56:07 <swansone>	Hey, I'm writting a unit test for a function that returns a Result. Is there a convenient shorthant to assert that it returns Ok, or prints Err if not?
Feb 22 21:57:06 <bertptrs>	just unwrap it?
Feb 22 21:57:31 <swansone>	Oh, that might work
Feb 22 21:58:16 <bertptrs>	Has the benefit of automatically failing the test too
Feb 22 22:00:44 <swansone>	Do I need to change the type signature of the test to do that?
Feb 22 22:01:00 <swansone>	Trying this gives me "^ cannot use the `?` operator in a function that returns `()`"
Feb 22 22:05:23 <swansone>	Trying to update the test function signature to return a result gives me an error that I need to implement the `Termination` trait
Feb 22 22:10:59 <swansone>	I think this is probably the best I can do then: `assert!(config.is_ok(), "{:?}", config)`
Feb 22 22:18:38 <Alexendoo>	swansone: unwrap as in .unwrap()
Feb 23 00:29:17 <Widdershins>	sigh, nightly clippy recently started complaining about redundant prelude imports. even when they are for no_std
Feb 23 00:34:14 <Widdershins>	nightly-2024-02-16 is fine, 2024-02-19 isn't
Feb 23 00:39:12 <Widdershins>	happened between the -18 and -19 toolchains
Feb 23 01:04:56 <Widdershins>	really struggling making a minimal reproducer for this!
Feb 23 01:05:10 <Widdershins>	i don't know why it dislikes my crate specifically
Feb 23 02:09:39 <Widdershins>	ok i figured it out bug submitted 😌
Feb 23 03:38:29 <Widdershins>	ok i sent the bug to the wrong place and failed to find the real issue, but i got an interesting idea from the real one
Feb 23 04:21:46 <Widdershins>	Is there a way to make cargo compile with the no_std prelude, even in std?
Feb 23 04:23:11 <Mutabah>	Why not just have `#![no_std]`
Feb 23 04:23:22 <Mutabah>	(and import std manually)
Feb 23 04:23:31 <Widdershins>	does that have other effects when the library is included in the whole program?
Feb 23 04:23:42 <Widdershins>	if the rest of the program is normal std?
Feb 23 04:23:50 <danieldg>	no
Feb 23 04:23:53 <Widdershins>	i am looking at https://github.com/rust-lang/rust/issues/121362#issuecomment-1955202508 here
Feb 23 04:24:13 <Widdershins>	though, as i'm currently looking to find out, that may only affect the *whole binary* when it applies to the program, not to each library individually
Feb 23 04:24:17 <danieldg>	you can use no-std crates normally from std ones
Feb 23 04:24:18 <Mutabah>	`no_std` libraries can be included in std-including binaries
Feb 23 04:24:44 <Widdershins>	do they produce the same code as if they were not no_std, as long as they use the same types etc.?
Feb 23 04:24:49 <Mutabah>	In fact it's very common for `no_std` libraries to have feature flags to turn on use of std/alloc
Feb 23 04:24:55 <Mutabah>	yes.
Feb 23 04:25:11 <Mutabah>	The stuff you use in `no_std` is the same in std (just re-exports)
Feb 23 04:25:33 <Widdershins>	yes, that's what i have. i have a library that has a std feature flag. currently this feature disables the no_std config, rather than causing std to be imported
Feb 23 04:26:41 <Widdershins>	as long as no_std code benefits from "stack overflow protection" and "runs init code before main" when included in a std program then that answers my question
Feb 23 04:26:59 <Widdershins>	seems likely that that would be the case
Feb 23 04:27:17 <danieldg>	if main is std, then it would
Feb 23 04:27:29 <danieldg>	stack overflow is also set up prior to main
Feb 23 04:28:03 <Widdershins>	context for the problem is also in that issue; rust nightly started throwing lint complaints for redundant imports when a maybe-no_std crate imports items that are also in the std prelude when it's std
Feb 23 04:28:29 <Mutabah>	The solution is to always be `no_std` but manually import std if needed
Feb 23 04:28:34 <Mutabah>	example: https://github.com/thepowersgang/stack_dst-rs/blob/master/src/lib.rs
Feb 23 04:28:38 <Widdershins>	not clear if they'll roll it back but if it's unambiguously a good idea to extern std instead of disable no_std i'll just do that, it does sound better
Feb 23 04:28:44 <Widdershins>	yea
Feb 23 04:28:46 <Mutabah>	It conditionally imports alloc (and std - for miri tricks)
Feb 23 04:28:55 <Widdershins>	mhm
Feb 23 04:44:54 <Widdershins>	alright sweet
Feb 23 04:45:01 <Widdershins>	thanks danieldg Mutabah
Feb 23 08:48:09 <enoq>	is there something that allows you to serialize JSON in a streaming fashion? like serializer.startArray(); serializer.writeStruct(struct); serializer.stopArray()
Feb 23 09:43:47 <enoq>	can anyone explain this? https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=52322953af6b6452bdc73953cbcd6845
Feb 23 09:43:54 <enoq>	error[E0369]: cannot add `&{integer}` to `&mut {integer}`
Feb 23 09:44:38 <enoq>	these don't look like really distinct types to me
Feb 23 09:51:00 <dminuoso>	Hi, is there a way to get a delimited use of ? when ultimately I dont return a io::Result<T> at the end, but I do make a bunch of successive calls to functions that do in the beginning?
Feb 23 09:51:10 <dminuoso>	Or is the idiomatic approach to just split this into two functions?
Feb 23 09:51:34 <j`ey>	try blocks, but not stable afaik
Feb 23 09:52:42 <j`ey>	enoq: I think you want reduce, not scan?
Feb 23 09:53:08 <enoq>	I want to turn [1, 2, 3] into [0, 1, 3, 6]
Feb 23 09:53:26 <dav1d>	enoq, they are distinct types, compiler tells you how you can fix it
Feb 23 09:53:33 <enoq>	dav1d, right, but why
Feb 23 09:53:33 <j`ey>	oh
Feb 23 09:53:57 <dav1d>	enoq, one is mutable the other isn't. You can impl traits for &Foo and &mut Foo separately
Feb 23 09:54:17 <dav1d>	enoq, &Foo and Foo are also not the same type
Feb 23 09:54:33 <enoq>	is there no trait impl for left hand &mut and right hand &
Feb 23 09:55:15 <dav1d>	enoq, yeah that's what is missing
Feb 23 09:55:44 <dav1d>	enoq, but it's the same for `&u32 + u32`
Feb 23 09:56:06 <enoq>	you mean you also can't add those?
Feb 23 09:56:54 <enoq>	the scan type signature is also kinda complicated btw
Feb 23 09:57:35 <dminuoso>	j`ey: Alright thanks.
Feb 23 10:01:59 <enoq>	looks like this is sort of what I want
Feb 23 10:02:00 <enoq>	https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=1e1dc6b62e21fb45d5a9a216e3844952
Feb 23 10:02:07 <enoq>	I've never used * before in rust
Feb 23 10:29:17 <mkoncek>	does rustc / cargo offer more granular optimize / debug flags? like -O<N> in gcc
Feb 23 10:29:46 <j`ey>	opt-level
Feb 23 10:34:24 <mkoncek>	also, i have two processes, one is sending UDP to a local address in a while loop and the other one is receiving them, after roughly 300 datagrams some of them get lost, is it possible i overflowed the kernel buffers?
Feb 23 10:39:38 <dav1d>	enoq, https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=e7ca6a2c5abc4babd48ce6ce27918140
Feb 23 10:39:59 <dav1d>	oh nvm I think I broke it
Feb 23 10:40:20 <enoq>	you forgot to sum it up
Feb 23 10:40:34 <enoq>	I know, the API does not work like in other languages
Feb 23 10:40:40 <dav1d>	yeah, I think yours is as good as it gets
Feb 23 10:40:54 <enoq>	thanks, was worried about the type soup
Feb 23 10:41:05 <dav1d>	enoq, eh `*state = *state + curr;`
Feb 23 10:41:30 <dav1d>	that should work, but it's just a minor thing which clippy probably also notices
Feb 23 10:41:50 <enoq>	what's the solution?
Feb 23 10:42:19 <dav1d>	oh clippy wants ` *state += curr;`
Feb 23 10:42:22 <dav1d>	that's nice
Feb 23 10:42:35 <enoq>	ah, yeah, less characters for the same thing then :)
Feb 23 10:42:51 <dav1d>	enoq, https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=ae625557c0702aa6b79b5a5b3c6c8797
Feb 23 10:42:53 <dav1d>	full thing
Feb 23 10:43:04 <enoq>	thanks
Feb 23 10:43:13 <enoq>	so let's say I want to execute this function at compile time
Feb 23 10:43:24 <enoq>	I think there's some form of constexpr
Feb 23 10:44:16 <dav1d>	enoq, you can't create a vector with items at compiletime, if you have an array you'd need to manually do it with a while loop I believe (not sure if for works alread)
Feb 23 10:44:36 <enoq>	because vec is heap allocated?
Feb 23 10:45:49 <bertptrs>	yea
Feb 23 10:46:07 <bertptrs>	also many of the functions you are using cannot be used in a const context yet
Feb 23 10:56:30 <enoq>	I suppose simple ::new methods are fine to make const?
Feb 23 10:56:40 <enoq>	when you just want to fill in default values for a struct
Feb 23 10:59:24 <j`ey>	yep
Feb 23 11:00:45 <enoq>	thanks
Feb 23 11:01:26 <enoq>	I don't really fully understand the limitation of no vectors inside const fns; it should be possible to just allocate that vector at compile time, right?
Feb 23 11:02:28 <enoq>	or does Rust have more guarantees  in that regard?
Feb 23 11:03:40 <enoq>	like: will not check how big the actual thing is after running it during compile but instead needs to know all sizes statically in advance?
Feb 23 11:09:12 <enoq>	oh :( https://github.com/rust-lang/rfcs/pull/2237
Feb 23 11:14:42 <synapse>	enoq, they're heap allocated
Feb 23 11:15:33 <synapse>	enoq, if you made a StaticVec<T> you could statically allocate it. some people call that an array. :-D
Feb 23 11:16:12 <synapse>	enoq, .push() and such don't make much sense if the allocation is fixed.
Feb 23 11:16:57 <enoq>	right, you should be able to iter over arrays though, right?
Feb 23 11:17:05 <synapse>	yes
Feb 23 11:17:06 <dav1d>	need someone to just reply with yes as a sanity check, if I destructure a struct its Drop impl wont run?
Feb 23 11:17:42 <enoq>	doesn't drop always run at the end of the lifetime?
Feb 23 11:18:02 <bertptrs>	You cannot destructure things that have Drop
Feb 23 11:20:25 <bertptrs>	Oh it seems you can, provided the things you destructure are Copy
Feb 23 11:20:28 <dav1d>	bertptrs, https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=ac877edafd206dbdb899fcd3be13ddbf ?
Feb 23 11:20:53 <dav1d>	okay seems like I need to properly figure out semantics
Feb 23 11:20:55 <dav1d>	thanks
Feb 23 11:21:45 <bertptrs>	dav1d: it's just moving out of the thing, not actually destroying it
Feb 23 11:23:28 <dav1d>	bertptrs, yeah I see, it only allows you to get a ref when destructuring. I have a Token which logs something on drop and I want to be able to transform that token to another token which logs more information, that transformation shouldn't trigger the initial drop though :(
Feb 23 11:23:39 <dav1d>	Guess I'll have to wrap everything in an option
Feb 23 11:23:55 <bertptrs>	ManuallyDrop might help?
Feb 23 11:25:34 <davros1>	Haven't been following the rust world so much lately (AI hype got me) .. is there movement in the realm of this existing problem:
Feb 23 11:26:02 <davros1>	Can't impl From for collections when the inner type has a From
Feb 23 11:26:07 <dav1d>	bertptrs, thanks, I though that wouldnt work but it looks like it should!
Feb 23 11:26:25 <davros1>	I think it needed negative bounds or something (there might have been some other proposals)
Feb 23 11:27:58 <dav1d>	Actually I can just std::mem::forget
Feb 23 11:28:16 <davros1>	In my own vecmath libs I ran into this .. 'struct Vec3<T>{x:T, y:T, z:T} .. can't impl From<[B;3]> for Vec3<A> where A:From<B> {} because it'll freak out at the possibility of infinite nesting or something
Feb 23 11:33:52 <bertptrs>	negative bounds aren't anywhere coming as far as I know, the new trait solver has been in limbo for a bit
Feb 23 11:42:00 <enoq>	is there no built in way to handle dates & ISO8601 formatting?
Feb 23 11:50:39 <bertptrs>	no, the standard library is intentionally somewhat limited since it's intended to be stable forever
Feb 23 11:50:46 <bertptrs>	you can look at either the chrono or time crates
Feb 23 11:56:23 <dav1d>	I thought Rust would catch this out of bounds on static arrays :( https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=f9bdc0f3c23bfde2073c9d7676c39c4b
Feb 23 11:56:36 <dav1d>	Is there a way to have the array access validated on compiletime?
Feb 23 12:09:05 <turlando>	dav1d: ironically the release llvm ir code is just a call to core::panicking::panic_bounds_check when i try to run weight
Feb 23 12:09:31 <turlando>	So it's actually doing some kind of const propagation
Feb 23 12:47:28 <dav1d>	turlando, nice! optimized panics
**** BEGIN LOGGING AT Fri Feb 23 14:47:00 2024

Feb 23 14:47:00 *	Now talking on ##rust
Feb 23 14:47:00 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 23 14:47:00 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Feb 23 14:47:16 <enoq>	I'm using the File buf reader lines() method I think
Feb 23 14:47:49 <enoq>	yep, that one handles \r\n
**** BEGIN LOGGING AT Fri Feb 23 14:52:02 2024

Feb 23 14:52:01 *	Now talking on ##rust
Feb 23 14:52:01 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 23 14:52:01 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Feb 23 14:52:44 <cehteh>	you can use that when you use std String -- but creating a string from untrusted io is fallible, by panic or you handling the Result
Feb 23 14:54:07 <cehteh>	and read_lines etc have no safeguard against malicious files that use extremely long lines. often thats ok, but sometimes thats a big problem
Feb 23 14:54:56 <enoq>	that's a problem in other languages as well
Feb 23 14:54:59 <cehteh>	and its all-or-nothing in case of invalid utf8
Feb 23 14:55:04 <cehteh>	yeah sure
Feb 23 14:55:21 <cehteh>	just telling you to consider it, if it doesnt matter ignore it
Feb 23 14:55:32 <enoq>	yeah, thank you for the tp
Feb 23 14:55:34 <enoq>	tip*
Feb 23 14:56:10 <enoq>	usually you've got an enforced size limit for uploaded files
Feb 23 14:56:11 <cehteh>	esp invalid utf8 isnt really unexpected
Feb 23 14:56:33 <cehteh>	you may at least handle that instead panicking
Feb 23 14:56:39 <enoq>	right
Feb 23 14:59:15 <cehteh>	gtg
Feb 23 15:12:49 <sword_smith>	I've seen the recommendation that a `Debug` implementation should be added as a rule of thumb.
Feb 23 15:13:00 <sword_smith>	Why?
Feb 23 15:14:34 <bertptrs>	https://rust-lang.github.io/api-guidelines/interoperability.html
Feb 23 15:15:06 <bertptrs>	private types not necessarily, but for public types it's very helpful for API consumers to debug their own codew
Feb 23 15:16:47 <tstonge>	it's nice to be able to format!("{:?}", my_obj), and all it takes is `Debug`
Feb 23 15:21:36 <bertptrs>	or if you're hip, to use the dbg! macro
Feb 23 15:42:58 <enoq>	how can you hold onto a value outside of a loop, that goes out of scope in a loop
Feb 23 15:43:30 <nullie>	enoq: set_fact?
Feb 23 15:43:39 <enoq>	what do you mean?
Feb 23 15:43:49 <nullie>	I don't quite understand what do you want to do
Feb 23 15:43:53 <enoq>	I need to keep track of a previous value
Feb 23 15:44:07 <enoq>	compare the current value to the previous value
Feb 23 15:44:21 <nullie>	well you could use set_fact to store it
Feb 23 15:44:59 <enoq>	I can only find Ansible stuff when I google that
Feb 23 15:45:18 <nullie>	oh, shit, sorry, I though it was #ansible :D
Feb 23 15:45:39 <nullie>	you can declare a variable outside of a loop
Feb 23 15:46:30 <enoq>	right, I can, but if I assign to it, I either need to move? it since the value goes out of scope
Feb 23 15:46:35 <enoq>	or copy it somehow
Feb 23 15:47:09 <nullie>	it will be moved by default
Feb 23 15:47:23 <nullie>	can you show the code for your current attempt?
Feb 23 15:48:10 <enoq>	nullie, https://dpaste.com/6WP8SDQYQ#line-150
Feb 23 15:48:29 <enoq>	error is ^^^^^^^^ borrowed value does not live long enough
Feb 23 15:48:38 <enoq>	line 172
Feb 23 15:49:08 <nullie>	remove the reference
Feb 23 15:49:20 <enoq>	you mean move it?
Feb 23 15:49:37 <nullie>	Option<ArticleLine> instead of Option<&ArticleLine>
Feb 23 15:50:30 <nullie>	and then Some(article_line) instead of Some(&article_line)
Feb 23 15:50:49 <nullie>	s/article_line/article/g
Feb 23 15:51:43 <enoq>	use of moved value now
Feb 23 15:51:54 <enoq>	https://dpaste.com/F2XWBCSTG
Feb 23 15:52:06 <enoq>	157 |             Some(cheapest) => {
Feb 23 15:52:09 <enoq>	value moved here
Feb 23 15:52:29 <nullie>	match lowest_price.as_ref()
Feb 23 15:53:41 <enoq>	https://dpaste.com/H2WCW7KRT
Feb 23 15:53:50 <enoq>	    |                     ^^^^^^^^^^^^ `lowest_price` is assigned to here but it was already borrowed
Feb 23 15:53:55 <enoq>	line 160
Feb 23 15:54:24 <enoq>	(my gutt feeling is that I need a copy)
Feb 23 15:54:42 <nullie>	lowest_price = match { }, and then at finish each branch with Some()
Feb 23 15:55:32 <nullie>	well, maybe it's not the right way
Feb 23 15:57:14 <danieldg>	you might be able to avoid a copy, but it depends on what exactly you are iterating and storing
Feb 23 15:57:57 <phy1729>	It feels .fold(ish maybe with group_by
Feb 23 15:58:35 <enoq>	yes, it feels like group_by, but doesn't group by evaluated everything?
Feb 23 15:59:13 <enoq>	if I evaluate it, I'm loading 120 gigs of strings into memory
Feb 23 15:59:59 <nullie>	group_by should evaluate lazily
Feb 23 16:01:40 <enoq>	so it accumulates values until the grouping criterium does not match anymore?
Feb 23 16:01:45 <enoq>	then starts a new group?
Feb 23 16:02:20 <nullie>	it doesn't even accumulate group values
Feb 23 16:02:29 <nullie>	I think
Feb 23 16:02:41 <nullie>	"If the groups are consumed in order, or if each group’s iterator is dropped without keeping it around, then GroupBy uses no allocations. It needs allocations only if several group iterators are alive at the same time."
Feb 23 16:02:51 <enoq>	sounds like magic, will take a look thank you!
Feb 23 18:05:14 <Vorpal>	Does anyone know any tool to generate an install script similar to the one you curl for rustup. Lots of pieces of software have these, but most seem to be hand written for each project. Or depend on Go. Looking for something with multi-architecture support for my own usage. I'm absolutely proficient enough in shell script that I could hack something together. But then there is MacOS/Windows support (which I have no clue about). So I was hoping for some ready
Feb 23 18:05:16 <Vorpal>	made tool.
Feb 23 18:05:39 <Vorpal>	Preferably something that integrates easily with a rust build system too
Feb 23 18:05:53 <bertptrs>	as far as I know these tend to be hand-written
Feb 23 18:06:38 <bertptrs>	which is not great, people make the same mistakes over and over
Feb 23 18:06:52 <Vorpal>	That would be a good project then, for someone who has time for that (which I don't). So I too will hand-write one for my project, that will be Linux only.
Feb 23 18:06:53 <bertptrs>	but I don't think anyone's set up a standardized method yet
Feb 23 18:07:34 <bertptrs>	composer for example is a PHP tool so they decided to write it in PHP rather than bash. Makes sense but doesn't help standardization
Feb 23 18:07:35 <Vorpal>	really for my purpose it is a single binary, so all I need is to figure out which is the latest github release, and what architecture I'm running on. Then download and unpack the relevant binary into the current directory
Feb 23 18:08:10 <Vorpal>	heh, never heard of composer. I thought PHP was dead these days except for existing software (mediawiki, wordpress, probably a few more)
Feb 23 18:09:08 <bertptrs>	PHP is very much alive, and composer was its revival. it made libraries a lot more accessible and from that the ecosystem got a big boost
Feb 23 18:09:13 <enoq>	struggling with lifetimes here https://dpaste.com/GJASURSDQ error https://dpaste.com/65WKULUVC
Feb 23 18:09:17 <phy1729>	it doesn't help that POSIX sh is a maze of twisty edge cases all of them sharp
Feb 23 18:09:26 <enoq>	I don't understand why I'm getting 2 different lifetimes here
Feb 23 18:09:46 <Vorpal>	phy1729: true. You can't assume bash. Mac OS uses zsh (which I happen to know since I use it myself). Then there is also dash.
Feb 23 18:10:04 <LawnGnome>	And, in fairness to Composer, anyone who wants to use it already has PHP installed, so making the installer a PHP script makes total sense from that perspective. Plus, yeah, cross platform shell scripting no es bueno.
Feb 23 18:10:09 <phy1729>	and ksh on the BSDs, so you can only really assume POSIX sh
Feb 23 18:10:43 <bertptrs>	LawnGnome: I'm not dissing composer's choice, it makes perfect sense and lets them avoid POSIX shell
Feb 23 18:10:49 <LawnGnome>	I had to help maintain a cross platform (maximally, Linux, FreeBSD, macOS, Solaris) "install from tarball" type shell script for several years. I do not recommend the experience.
Feb 23 18:10:50 <Vorpal>	phy1729: oh right, well I don't build for BSDs (since cross-rs can't cross-test for them). So that I don't won't have to worry about
Feb 23 18:10:55 <LawnGnome>	bertptrs: I didn't think you were. :)
Feb 23 18:11:13 <phy1729>	Vorpal: I'm on one, so I tend to care about them
Feb 23 18:11:51 <Vorpal>	phy1729: I wouldn't mind supporting them with pre-built binaries. But I refuse to support anything I can't actually run integration tests on in CI. That way lies madness.
Feb 23 18:12:25 <Vorpal>	I expect my program to work fine there (there is no reason it wouldn't it works on Windows even after all)
Feb 23 18:12:48 <Vorpal>	but BSDs and Mac OS ARM I can't cross test in CI, so they get no support.
Feb 23 18:12:58 <enoq>	is there a way to link the lambda parameter lifetime to the return value?
Feb 23 18:13:01 <Vorpal>	(I only use Linux myself, not even windows)
Feb 23 18:21:47 <enoq>	how does one group by two values
Feb 23 18:34:21 <enoq>	ok https://docs.rs/itertools/latest/src/itertools/groupbylazy.rs.html#299-307
Feb 23 18:34:29 <enoq>	looking at that signature, there are no lifetimes
Feb 23 18:34:37 <enoq>	    F: FnMut(&J::Item) -> K,
Feb 23 18:34:43 <enoq>	so &J and K are not related
Feb 23 18:34:58 <enoq>	I suppose that's why you can't use any K that refers to &J
Feb 23 18:35:04 <enoq>	so you have to copy?
Feb 23 18:36:41 <enoq>	so .group_by(|article| (article.code.clone(), article.pos))
Feb 23 18:36:49 <enoq>	code is a string, pos a usize
Feb 23 19:04:35 <alip>	using bitflags how do i check any one of a set of flags is set in a bitflags var? do i have a better way than calling contains() for each flag?
Feb 23 19:04:48 <alip>	i tried intersects() but it does not seem to do the right thing
Feb 23 19:10:38 <dav1d>	alip, does that work `FOO & (A |  B | C) > 0`?
Feb 23 19:13:31 <alip>	dav1d: no
Feb 23 19:14:38 <Mikachu>	what is a "bitflags var"
Feb 23 19:15:09 <alip>	a struct defined with bitflags::bitflags!
Feb 23 19:15:18 <alip>	i mean the crate
Feb 23 19:20:33 <spb>	the documentation for intersects seems to match what you described - what's different about it from what you want?
Feb 23 19:23:11 <a51>	I installed erdtree and erdtree says command not found
Feb 23 19:25:41 <alip>	spb: indeed, but it does not do what i want appearently, i use it with nix's type OFlag and e.g. (OFlag.O_RDONLY|OFlag.O_CLOEXEC|O_DIRECTORY).intersects(O_CREAT|O_TMPFILE) returns true for some reason. o.O
Feb 23 19:27:55 <a51>	bat and exa work but not erdtree
Feb 23 19:28:41 <j`ey>	a51: erd
Feb 23 19:31:08 <enoq>	how does one get an owned value out of a vec
Feb 23 19:31:17 <j`ey>	remove()
Feb 23 19:31:26 <spb>	depends what you want to happen to the thing in the vec
Feb 23 19:31:35 <dav1d>	enoq, remove, std::mem::take/replace
Feb 23 19:31:44 <enoq>	I want to move it into something else
Feb 23 19:31:48 <dav1d>	remove is quite expensive
Feb 23 19:32:08 <enoq>	the vec is only used to calculate something temporarlily
Feb 23 19:32:13 <spb>	and do you want to remove it from the vec, or leave something else in its place?
Feb 23 19:32:26 <dav1d>	enoq, if you want to get rid of the entire vector, into_iter()
Feb 23 19:32:41 <enoq>	I need to know the size of the vec as well
Feb 23 19:33:04 <enoq>	basically the length and the struct with the lowest value
Feb 23 19:33:35 <enoq>	basically this https://dpaste.com/866BQBL59
Feb 23 19:34:02 <enoq>	so I guess remove it is?
Feb 23 19:35:17 <phy1729>	You're throwing away the Vec once you have the min?
Feb 23 19:35:22 <enoq>	yees
Feb 23 19:35:26 <spb>	so you're extracting the first item and then throwing away the vec
Feb 23 19:35:37 <enoq>	first item + vec length, then throwing it away
Feb 23 19:36:23 <phy1729>	.into_iter().reduce and skip the sorting step
Feb 23 19:36:43 <spb>	and calculate the length before you do it
Feb 23 19:36:47 <phy1729>	er Iterator has a .min
Feb 23 19:37:13 <spb>	using min means you don't have to actually sort the list which will be considerably faster
Feb 23 20:03:00 <enoq>	what does this mean: error[E0515]: cannot return value referencing temporary value https://dpaste.com/C7YCXKBJV
Feb 23 20:03:17 <enoq>	https://dpaste.com/2ZP7SP48S
Feb 23 20:03:39 <enoq>	I don't really understand what creates the temporary value
Feb 23 20:05:13 <Vorpal>	enoq: using rust playground would help rather than a pastebin so we can see which line and part the error applies to
Feb 23 20:05:22 <enoq>	yes, one sec
Feb 23 20:05:28 <Vorpal>	(see the /topic for a link to the playground)
Feb 23 20:06:08 <enoq>	https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=6ac152cbe4c36b75e0227875da658f17
Feb 23 20:07:24 <Vorpal>	hm, used to seeing type inlay hints from vscode, much harder without that :D. But I would expect you take article by value and return a reference to it in group_by()
Feb 23 20:08:09 <enoq>	at least intellij says &ArticleLine in line 168 but it's pretty buggy as well :/
Feb 23 20:08:12 <Vorpal>	some things that could help are to collect into a Vec and returning that vec.into_iter() since the computation won't depend on something after the function returns the iterator then
Feb 23 20:08:54 <enoq>	Vorpal, it's a 120gb string line iterator
Feb 23 20:09:01 <Vorpal>	but I understand you don't want that, since you try to keep everything as iterators very much so
Feb 23 20:09:04 <enoq>	I doubt I want to collec tthat
Feb 23 20:09:10 <Vorpal>	fair point!
Feb 23 20:09:30 <Vorpal>	what type is pos?
Feb 23 20:09:34 <Vorpal>	article.pos I mean
Feb 23 20:09:37 <enoq>	it's a usize
Feb 23 20:09:49 <Vorpal>	which is Copy. Huh
Feb 23 20:10:38 <Vorpal>	aha! article.code is a &str. You want to_owned() not clone()
Feb 23 20:10:42 <Vorpal>	I think that is it
Feb 23 20:10:56 <Vorpal>	pretty sure you are just cloning the reference into a new reference right now
Feb 23 20:11:13 <enoq>	same error
Feb 23 20:11:34 <enoq>	(article.code.to_owned(), article.pos) right?
Feb 23 20:11:36 <Vorpal>	hm you are right
Feb 23 20:11:42 <Vorpal>	yeah okay I'm confused too
Feb 23 20:11:52 <enoq>	the group_by is from itertools btw
Feb 23 20:12:28 <enoq>	what exactly is the temporary value btw?
Feb 23 20:12:38 <Vorpal>	I'm wondering that too now
Feb 23 20:12:41 <enoq>	is it the iterator? or is it the stuff inside the group_by
Feb 23 20:13:40 <Vorpal>	This type implements IntoIterator (it is not an iterator itself), because the group iterators need to borrow from this value. It should be stored in a local variable or temporary and iterated.
Feb 23 20:13:48 <Vorpal>	ah, that is probably the issue
Feb 23 20:14:07 <Vorpal>	you are borrowing from GroupBy itself
Feb 23 20:15:20 <Vorpal>	I don't have a good answer for how to solve that. I expect if you put it inside the next function it would work, but that is several layers deep in returning files, so that is no good for code organisation.
Feb 23 20:15:45 <Vorpal>	enoq: hopefully that has given you some idea about the cause though, even though I don't have a suggestion for the fix
Feb 23 20:17:47 <enoq>	Vorpal, basically, I can't into_iter() after the group by?
Feb 23 20:18:21 <Vorpal>	well, I haven't looked into the details, but I quoted a line from the documentation of group_by
Feb 23 20:18:53 <Vorpal>	it seems plausible that the moment you need to iterate over it you need to finish doing so in the same scope
Feb 23 20:18:58 <enoq>	right, I didn't understand that one tbh
Feb 23 20:20:11 <Vorpal>	I don't have a suggested fix, perhaps someone else can chime in. You could could try on https://users.rust-lang.org/ maybe?
Feb 23 20:21:29 <enoq>	there's https://stackoverflow.com/questions/47885478/how-to-use-itertools-group-by-iterator-method-without-a-for-loop
Feb 23 20:21:37 <enoq>	the suggestion is to clone everything :/
Feb 23 20:23:19 <Vorpal>	hm... maybe a different design then?
Feb 23 20:25:02 <enoq>	the one I tried before is passing in a lambda that is executed after each iteration, but closures sure are terrible in Rust, couldn't get it to work
Feb 23 20:37:24 <Vorpal>	could you pass in a separate function rather than lambda instead?
Feb 23 20:41:20 <dkg>	So i've got a functioning cdylib built now (i ended up deciding not to do the string manipulation in fixed-size buffers that i'd asked about earlier at all; ended up with a much cleaner interface and implementation, but thanks danieldg and Mutabah for walking me through it anyway)
Feb 23 20:41:42 <dkg>	now i'm struggling because the library object generated by the cdylib crate exposes a *ton* of symbols that i don't want it to expose.
Feb 23 20:44:05 <dkg>	i've done searches for "cdylib symbol visibility" and found nothing that works for me :(  i've tried passing a "version script" to the linker, but it ends up in conflict with the version script passed automatically by cargo
Feb 23 20:44:36 <dkg>	what i want is for the cdylib to only expose those symbols that are marked as C symbols
Feb 23 20:44:53 <dkg>	so, the things that cbindgen would pick up on, for example.
Feb 23 20:45:49 <dkg>	the desired C API is simple enough that i don't need to actually use cbindgen to produce it, and i'd prefer to avoid depending on that crate anyway during build.  Any pointers on what i can do to minimize the exported symbols in a cdylib?
Feb 23 20:49:46 <enoq>	Vorpal, tried this approach instead https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=22cc396e399dd04c469f98eb94d67d3b
Feb 23 20:50:01 <enoq>	getting "borrowed data escapes outside of closure"
Feb 23 20:50:06 <enoq>	I suppose it's the same issue
Feb 23 20:51:54 <j`ey>	dkg: so youre getting rust mangled symbols?
Feb 23 20:52:44 <j`ey>	(oops go to go)
Feb 23 21:00:04 <dkg>	j`ey: yes, i'm seeing rust mangled symbols in addition to the ones that i want to export
Feb 23 21:03:43 <dkg>	hm, actually, as i look at it further, maybe not!  i think i was just seeing mangled symbols in the non-stripped shared object.  when i run "strip" on it, the only symbols that remain are the deliberately exported ones.
**** BEGIN LOGGING AT Fri Feb 23 21:29:52 2024

Feb 23 21:29:49 *	Now talking on ##rust
Feb 23 21:29:49 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 23 21:29:49 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Feb 23 23:14:47 <ljhklhjl>	hi
Feb 23 23:15:57 <ljhklhjl>	https://tr.cpabestoffer.click/redirect?aff_id=1153&offer_id=121
Feb 23 23:16:07 <ljhklhjl>	https://tr.cpabestoffer.click/redirect?aff_id=1153&offer_id=121
Feb 23 23:58:17 <lolita>	Ok, el trato... dame una membresía gratis y te enviaré 5 videos de coños calientes después de un chat de sexo en vivo gratis, ¿es bueno el trato? https://tr.cpabestoffer.click/redirect?aff_id=1153&offer_id=121
Feb 23 23:58:43 <lolita>	Ok, el trato... dame una membresía gratis y te enviaré 5 videos de coños calientes después de un chat de sexo en vivo gratis, ¿es bueno el trato? https://tr.cpabestoffer.click/redirect?aff_id=1153&offer_id=121
Feb 23 23:59:15 <lolita>	Soy una chica soltera. Busco diversion con gente real.. Si realement quieres conocerme, sigue mi perfil personal
Feb 23 23:59:16 <lolita>	Si este enlace no funciona, cópielo y péguelo manual en su navegador: https://tr.cpabestoffer.click/redirect?aff_id=1153&offer_id=121
**** BEGIN LOGGING AT Sat Feb 24 12:02:42 2024

Feb 24 12:02:41 *	Now talking on ##rust
Feb 24 12:02:41 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 24 12:02:41 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Feb 24 12:02:47 <osse>	Of course, need to wait for a new release of cargo-lockdiff since the current one segfaults
Feb 24 12:04:57 <osse>	With that said, if there is a newer/better/shinier way to get a easily digestible "diff" of Cargo.lock then I'm all ears
Feb 24 12:49:38 *	zato slaps Jarrko Oikarinen around with a big nice tuna sandwich 
Feb 24 12:50:00 <jbg>	osse: i like `lockdiff`
Feb 24 12:50:29 <jbg>	https://lib.rs/crates/lockdiff
Feb 24 12:51:12 <jbg>	not a cargo 'plugin' but rather just a command you can point git to, so `git diff` gives nice diffs on lock files automatically
Feb 24 12:51:21 <jbg>	works for some python and JS lockfile formats too
Feb 24 12:53:27 <osse>	 Cool, I'll check it out
Feb 24 12:54:03 <osse>	At first glance this looks more like what I would have written myself. The big table you get from cargo-lockdiff sort of sticks out
Feb 24 14:27:50 <osse>	I need to act on the inner value of an enum if the enum is of a particular variant: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=20be5267fe0800bc46c21dd271668b43 - Is there a way to make maybe_reverse2() work the same as maybe_reverse() ?
Feb 24 14:29:22 <osse>	Ahh, I think macro hygiene is screwing me here. the matches!() itself compiles just fine (there's a typo in the playground)
Feb 24 14:45:41 <yuri6037>	Hello, I have a question about the &str type: is there any way to refer to the &str type other than by using a type statement? I'm attempting to write a custom deserialize function for a proprietary format of date time and in that deserialize function I'd like to call &str::deserialize however it appears that in rust it's impossible other than by creating a type statement.
Feb 24 14:46:59 <erk>	yuri6037: You could look into the built-in trait FromStr, and if you want to replicate what that does you will have to make a trait and then implement it for &str
Feb 24 14:47:20 <osse>	<&str>::deserialize()   works
Feb 24 14:48:31 <yuri6037>	osse: thank you never seen that weird type syntax before but works or is it just a variant of the <type as trait> syntax?
Feb 24 14:50:28 <osse>	yuri6037: I'm not really qualified to answer :P But I *think* it's essentially the same as <type as trait> yes.
Feb 24 14:50:40 <yuri6037>	ok
Feb 24 14:50:50 <yuri6037>	thank you anyways
Feb 24 14:59:25 <osse>	yuri6037: tested a bit on the playground and I feel I know less than I did. the < > seem to be just to scope the &.
Feb 24 14:59:51 <yuri6037>	ok I see
Feb 24 14:59:58 <osse>	&T::foo() is a reference to T::foo()  <&T>::foo() calls &T'
Feb 24 15:00:06 <osse>	ugh, whatever, you get what I mean.
Feb 24 15:00:26 <yuri6037>	Oh ok that's like the parentheses in C casts
Feb 24 15:01:12 <jbg>	it's called a "qualified path"
Feb 24 15:01:21 <jbg>	and yeah it's basically like parens but for types
Feb 24 15:01:29 <yuri6037>	Anyway that failed because the xml_serde_rs crate can't parse borrowed string it can only parse owned strings so it's gonna have to be more allocs
Feb 24 15:01:32 <jbg>	https://doc.rust-lang.org/reference/paths.html#qualified-paths
Feb 24 15:01:47 <jbg>	< Type (as TypePath)? >
Feb 24 15:01:57 <yuri6037>	jbg: thanks for the name good to know
Feb 24 15:02:52 <yuri6037>	I tried to reduce allocs but the lib I use does not appreciate
Feb 24 15:03:06 <jbg>	serde_xml_rs seems to be able to deserialize from &str
Feb 24 15:03:44 <yuri6037>	apparently not: Failed to decode TTMD monitor data object: Custom { field: "invalid type: string \"05/06/2014 09:14:56\", expected a borrowed string" }
Feb 24 15:04:12 <jbg>	that error doesn't seem to say what you are saying it says though
Feb 24 15:04:15 <jbg>	in any case you'd have to show code
Feb 24 15:10:58 <yuri6037>	Here is the code that failed with the error I gave you (note that the playground does not have serde_xml_rl): https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=581fd21d3150d2d6b7a4d87ce8c4a9f8
Feb 24 15:12:36 <jbg>	the error implies that serde_xml_rs is providing a String *that it allocated* while you are assuming it will provide a &str
Feb 24 15:12:40 <jbg>	i bet i know why as well
Feb 24 15:12:43 <jbg>	XML entities
Feb 24 15:12:59 <jbg>	it can't give a &str borrowed from the input because it has to interpret entities
Feb 24 15:13:26 <jbg>	best it could give is Cow<'a, str> -- the Borrowed variant if there are no entities and the Owned variant if there are. no idea if they implemented that or not
Feb 24 15:13:50 <jbg>	it's the same reason why serde_json can't reliably deserialize JSON strings into &str, only into String or Cow<'a, str>
Feb 24 15:13:59 <jbg>	because it needs to interpret backslash escapes
Feb 24 15:20:55 <Alexendoo>	It's based on xml-rs which doesn't borrow from the input
Feb 24 15:22:16 <Alexendoo>	You probably want quick-xml instead
Feb 24 15:27:30 <jbg>	quick-xml looks good. has the same setup as serde_json: you can deserialize strings into String, Cow<'a, str> or &str but &str will fail if the XML is non-UTF8, if there are any entities in the input, or if an element contains multiple cdatas
Feb 24 15:28:14 <yuri6037>	Thanks for the tip
Feb 24 15:35:55 <capitol>	do anyone know if it's possible to check if you are in the context of a #[cfg(...)] conditional when writing a clippy lint? There is a stripped_cfg_items() function on the context object, but that is not what I want
Feb 24 15:39:14 <Alexendoo>	capitol: You can use any_parent_has_attr
Feb 24 15:42:31 <capitol>	Alexendoo: oh, thanks :)
Feb 24 16:08:07 <yuri6037>	Does quick-xml support unordered readings?
Feb 24 16:08:51 <yuri6037>	I.e. Does it support formats where objects may appear in any order in the tree and deserialize as a single structure with fields
**** BEGIN LOGGING AT Sat Feb 24 16:29:08 2024

Feb 24 16:29:06 *	Now talking on ##rust
Feb 24 16:29:06 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 24 16:29:06 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** BEGIN LOGGING AT Sat Feb 24 16:32:03 2024

Feb 24 16:32:03 *	Now talking on ##rust
Feb 24 16:32:03 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 24 16:32:03 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Feb 24 16:33:36 <yuri6037>	well I think there's no other choice at this point my input XML is unparseable in Rust
Feb 24 16:34:29 <Alexendoo>	Since you're in boring hyperbole mode I assume you're just using the library wrong
Feb 24 16:34:55 <Alexendoo>	As has been the case every other time
Feb 24 16:35:02 <j`ey>	lmao I really hate yuri6037's way of talking
Feb 24 16:35:21 <j`ey>	glad theyve been away for ages lol
Feb 24 16:35:47 <yuri6037>	The problem is the library does not dcument anything about unordered items
Feb 24 16:36:13 <yuri6037>	it appears nobody in Rust has through of unordered XML elements when parsing XML
Feb 24 16:36:47 <j`ey>	but apparently it's super common /s
Feb 24 16:37:23 <yuri6037>	at least its common enough to be supported in C# and Jav
Feb 24 17:17:05 <nullie>	it was always a stupid idea to store structures in xml
Feb 24 17:17:40 <yuri6037>	I ended finding something the quick_xml lib can do it but using very weird struct field names
Feb 24 17:18:36 <yuri6037>	Like naming "monitor" instead of "monitors" in order to parse a Vec<Monitor> and naming "sensor" instead of "sensors" to parse a Vec<Sensor>
Feb 24 17:18:52 <yuri6037>	This behavior is obviously not documented
Feb 24 17:19:33 <yuri6037>	and error messages from the lib are misleading like saying that fields do not exist when they do on a standard text editor
Feb 24 17:20:37 <danieldg>	yes, if you want automatic things you'll need to use the right plurality; otherwise, you can generally rename them
Feb 24 17:21:13 <danieldg>	it's perfectly reasonable to have both <monitor> and <monitors> tags in XML
Feb 24 17:21:31 <ksynwa>	Is this the "correct" way to check a Path? `path == Path::new("filename.json")`
Feb 24 17:21:40 <danieldg>	ksynwa: define 'check'
Feb 24 17:22:07 <danieldg>	ksynwa: because that doesn't actually do anything but convert the type
Feb 24 17:22:28 <ksynwa>	I just wanna check if path points to filename.json
Feb 24 17:23:03 <ksynwa>	Don't care if there is a file there or not. Just what the string value is.
Feb 24 17:23:30 <danieldg>	ksynwa: ok, rephrasing: what do you want to *reject*?
**** BEGIN LOGGING AT Sat Feb 24 17:28:08 2024

Feb 24 17:28:07 *	Now talking on ##rust
Feb 24 17:28:07 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 24 17:28:07 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Feb 24 17:30:54 <nullie>	ksynwa: maybe path.to_str() == Some("filename.json")
Feb 24 17:31:08 <ksynwa>	Yeah that looks fine.
Feb 24 17:31:18 <nullie>	but why are you doing that?
Feb 24 17:32:21 <ksynwa>	nullie: I am reading the contents of a zip file. For certain filenames I want to handle the files differently.
Feb 24 17:37:07 <Alexendoo>	The == Path::new() allows skipping the UTF-8 check
Feb 24 18:11:28 <nullie>	yeah, could be faster
**** ENDING LOGGING AT Sat Feb 24 19:15:17 2024

**** BEGIN LOGGING AT Sun Feb 25 02:09:52 2024

Feb 25 02:09:50 *	Now talking on ##rust
Feb 25 02:09:50 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 25 02:09:50 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Feb 25 03:35:44 <krez>	hello :D
Feb 25 05:11:59 <thegman>	is set_read_timeout not a thing on TcpListener
Feb 25 05:12:20 <thegman>	i cant figure out how to notify a listener that the sender has finished sending stuff
Feb 25 05:13:04 <danieldg>	tcplistener is for new sockets
Feb 25 05:13:25 <danieldg>	it's normally used in an event loop, not with timeouts
Feb 25 05:15:19 <thegman>	i thought tcplistener was used to receive bytes from a tcp stream
Feb 25 05:21:29 <Affliction>	nope, it's used to listen on a port and accept connections.
Feb 25 05:21:59 <thegman>	how do i recieve data then
Feb 25 05:22:08 <thegman>	tcp listener works but it wont close afterwards
Feb 25 05:22:09 <Affliction>	It creates TcpStreams for incoming connections, which are bidirectional
Feb 25 06:05:57 <Widdershins>	listener sockets bind to a port & wait for incoming connections, they don't send or receive data themselves
Feb 25 06:53:27 <Ademan_>	since &str[i] isn't supported (I understand why), is there a way I can iterate over characters in the string and pull out regions as a slice? I started going down that path and I don't think I can do it without a useless enumerate() to keep track of character index (can't == compare Skip<Char<...>> apparently)
Feb 25 06:54:11 <Ademan_>	the approach I was going for was going to require me to collect() into a new String anyway, if I could get it working
Feb 25 06:59:39 <Widdershins>	Ademan_: pull out what regions?
Feb 25 07:00:28 <Ademan_>	oh, char_indices() looks promising, if I want to grab a slice from start = s.char_indices() to stop = s.char_indices().skip();  can I just do &s.as_bytes()[start.0..stop.0] ?
Feb 25 07:00:58 <Ademan_>	Widdershins: some region I've selected while parsing
Feb 25 07:02:14 <Ademan_>	wait I'm being dumb s.as_bytes()[...] is going to be a &[u8] and I can't just get the current index with .0 heh
Feb 25 07:04:17 <Ademan_>	oh start.offset()..stop.offset() would work if it wasn't experimental
Feb 25 07:05:17 <Ademan_>	I assume s.as_bytes()[start.offset()..stop.offset()] would result in a valid utf-8 byte slice so I ought to be able to turn that back into a string slice, but I'm hosed since offset() is experimental anyway
Feb 25 07:12:57 <Ademan_>	oh huh, since Chars is a DoubleEndedIterator maybe it does everything I need by itself...
Feb 25 07:13:26 <Ademan_>	will have to look again later though, night
Feb 25 10:22:23 <polychromata{J}>	Ademan_: you can't index a string with a single integer, but you /can/ slice it with a range
Feb 25 10:22:35 <polychromata{J}>	(put you've probably already figured that out)
Feb 25 10:29:11 <jbg>	thegman: most likely you are actually using TcpStream (returned by accept() on TcpListener) without realising it. to close the connection you can just drop the TcpStream
Feb 25 11:32:04 <synapse>	can my Cargo example have its own dependencies?
Feb 25 11:33:12 <Widdershins>	synapse: examples can use dev dependencies
**** BEGIN LOGGING AT Sun Feb 25 18:41:35 2024

Feb 25 18:41:33 *	Now talking on ##rust
Feb 25 18:41:33 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 25 18:41:33 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** ENDING LOGGING AT Sun Feb 25 18:41:51 2024

**** BEGIN LOGGING AT Tue Feb 27 23:16:00 2024

Feb 27 23:15:58 *	Now talking on ##rust
Feb 27 23:15:58 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 27 23:15:58 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** BEGIN LOGGING AT Wed Feb 28 02:09:41 2024

Feb 28 02:09:40 *	Now talking on ##rust
Feb 28 02:09:40 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 28 02:09:40 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** ENDING LOGGING AT Wed Feb 28 02:32:44 2024

**** BEGIN LOGGING AT Thu Feb 29 01:02:43 2024

Feb 29 01:02:42 *	Now talking on ##rust
Feb 29 01:02:42 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 29 01:02:42 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Feb 29 01:13:02 *	Disconnected ()
**** ENDING LOGGING AT Thu Feb 29 01:13:02 2024

**** BEGIN LOGGING AT Thu Feb 29 01:15:36 2024

Feb 29 01:15:36 *	Now talking on ##rust
Feb 29 01:15:36 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 29 01:15:36 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Feb 29 05:36:03 <polychromata{J}>	evalr: -0.0_f64
Feb 29 05:36:05 -evalr/##rust-	polychromata{J}: -0.0
Feb 29 05:37:18 <polychromata{J}>	evalr: --nightly #![feature(float_next_up_down)] (0.0_f64.is_finite(), (-0.0_f64).is_finite())
Feb 29 05:37:20 -evalr/##rust-	polychromata{J}: (true, true)
Feb 29 07:36:37 <Chagall>	Is anyone aware of a simple method for adding or parsing dakuten/handakuten in Japanese chars?
Feb 29 07:37:10 <Chagall>	(Simpler than writing lookup tables myself)
Feb 29 07:38:40 <Chagall>	IIRC it's possible by operating on the character codes depending on the encoding...
Feb 29 07:39:12 <Chagall>	But that's not very idiomatic(TM)
Feb 29 07:48:37 <Arnavion>	Parsing can be done by normalizing into whatever form separates the dakuten/handakuten (NFD?)
Feb 29 07:49:03 <Arnavion>	Adding can be done by the opposite normalization
Feb 29 07:49:47 <Chagall>	Ah, neat
Feb 29 07:50:12 <Arnavion>	evalr: use unicode_normalization::UnicodeNormalization; "ば".nfd().collect::<Vec<_>>()
Feb 29 07:50:14 -evalr/##rust-	Arnavion: ['は', '\u{3099}']
Feb 29 07:50:45 <Chagall>	perfect, thanks
Feb 29 14:15:32 *	Disconnected ()
**** ENDING LOGGING AT Thu Feb 29 14:15:32 2024

**** BEGIN LOGGING AT Thu Feb 29 14:15:51 2024

Feb 29 14:15:51 *	Now talking on ##rust
Feb 29 14:15:51 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 29 14:15:51 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** BEGIN LOGGING AT Thu Feb 29 14:39:53 2024

Feb 29 14:39:53 *	Now talking on ##rust
Feb 29 14:39:53 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 29 14:39:53 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** BEGIN LOGGING AT Thu Feb 29 15:16:04 2024

Feb 29 15:16:03 *	Now talking on ##rust
Feb 29 15:16:03 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Feb 29 15:16:03 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Feb 29 15:58:35 <Ademan_>	Just when I thought I was starting to figure lifetimes out... https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=2d1decc35a732b73a1a04340752d94dd why does the compiler want me to add 's (the lifetime of the &str CharIndices points to) to the result iterator? On the contrary the result lifetime 'r should be less than or equal to that, right?
Feb 29 15:59:25 <cehteh>	programmers rule #1 The compiler is always right :D
Feb 29 16:00:00 <Ademan_>	secondary question is: is there something that does what RefMap here does (wrap an iterator without owning it, and applying a map function to its elements results)
Feb 29 16:01:48 <Alexendoo>	.by_ref().map()?
Feb 29 16:02:07 <Alexendoo>	Or just .map if you already have a &mut Iterator
Feb 29 16:03:05 <Ademan_>	Alexendoo: thanks you're right!
Feb 29 16:04:23 <Alexendoo>	The trick being https://doc.rust-lang.org/std/iter/trait.Iterator.html#impl-Iterator-for-%26mut+I
Feb 29 16:14:51 <Ademan_>	so does ` -> impl Iterator<Item = char> + 's` express something other than "a type implementing iterator that lives *at least* as long as 's" ? If it means what I think, doesn't that mean the result could outlive the original string being referenced? (since we have CharIndices<'s>)
Feb 29 16:15:40 <bertptrs>	no, because CharIndices<'s> borrows the lifetime of the underlying string 's
Feb 29 16:16:29 <bertptrs>	I don't quite know why you're not allowed to unify the lifetimes into 'i; I would expect that to work
Feb 29 16:20:11 <Ademan_>	changing the lifetimes to simply be `'i: 'r + 's` appears to work but I still am really struggling why the lifetime of 'i should exceed 's. I feel like I missed something important not reading the rust book page by page or something.
Feb 29 16:22:33 <bertptrs>	ah now I understand, your relation was wrong
Feb 29 16:24:37 <bertptrs>	you wrote 's: 'i, but this is the wrong way around, it should be 'i: 's
Feb 29 16:25:02 *	polychromata{J} frowns and flips through the Book yet again to confirm that `'a: 'b` means 'a lives at least as long as 'b
Feb 29 16:29:53 <polychromata{J}>	i'm confused too c.c
Feb 29 16:29:54 <Ademan_>	yeah so I am still confused lol, doesn't this indicate the the reference iter will borrow for 'i, which is now longer than 's, which is the lifetime of the underlying &str of CharIndices<> ? Maybe the key is me not understanding "no, because CharIndices<'s> borrows the lifetime of the underlying string 's" ?
Feb 29 16:34:36 <bertptrs>	Hmm, yeah, that makes no sense, even if it compiles
Feb 29 16:34:50 <Ademan_>	maybe it can be distilled further: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=c8fd35a844a20ce33ee9663bc6c9aa3c
Feb 29 16:35:47 <Ademan_>	hrm no, my modified version doesn't mind if 'i and 's are totally unrelated lifetimes, I guess *that* makes sense
Feb 29 16:41:04 <Ademan_>	HRM, this might be slightly enlightening https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=fdd7f10fad30b06b654c3f2c4bec67c8 as_str() returns a string reference with lifetime 's and the exact lifetime of 'i remains irrelevant. it's like it was "cut through". obvious but possibly relevant behavior
Feb 29 16:41:12 <Ademan_>	if anyone tires of me thinking out loud please tell me to shut up
Feb 29 16:42:44 <cehteh>	yoi can just remove 'i there :D
Feb 29 16:43:36 <cehteh>	well i'd only took a glimpse
Feb 29 16:44:06 <Ademan_>	yeah I think you're right, I'm kind of just exploring right now, though
Feb 29 16:44:48 <cehteh>	aim for minimal lifetime annotations, let the compiler infer as much and if possible use generic '_
Feb 29 16:51:55 <cehteh>	CharIndices::as_str()  returns the str with the same lifetime as CharIndices, theoretically it may be a longer lasting one, but that complicates things as it would need to expose another lifetime up
Feb 29 16:52:20 <cehteh>	you have some kindof artifical limit there, which makes sense
Feb 29 16:52:42 <cehteh>	impl<'a> CharIndices<'a> { pub fn as_str(&self) -> &'a str
Feb 29 17:02:53 <Ademan_>	is it fair to say that the return value of as_str()s lifetime is "up to 'a" ? Since typically I think of lifetimes as being "at least 'x"
Feb 29 17:03:23 <Arnavion>	No, it's "at least 'a"
Feb 29 17:03:50 <Arnavion>	The 'a is the lifetime of the original &str that .char_indices() was called on
Feb 29 17:04:54 <Arnavion>	The returned &str only borrows from that original &str and nothing from the CharIndices, so there's no reason to limit its lifetime to the CharIndices itself
Feb 29 17:20:26 <Ademan_>	Arnavion: the last part makes perfect sense, but I don't understand how you could borrow "at least 'a" if the lifetime of the original str is also 'a (which afaict it is, per what cehteh shared above)
Feb 29 17:21:01 <Ademan_>	or I guess the lifetime of the original string is *also* "at least 'a"
Feb 29 17:21:30 <Ademan_>	but then how could you borrow it safely longer than 'a? I wouldn't think you could.
Feb 29 17:32:51 <cehteh>	of course you cant
Feb 29 17:38:56 <Beatussum>	Hi! I'd like to write a function returning an iterator but what should I prefer to specify as return type ? 1) An `impl Iterator<Item = Something>` ? 2) The iterator type directly which could be therefore a bit long ?
Feb 29 17:42:07 <j`ey>	Beatussum: impl Iterator is good yeah
Feb 29 17:44:13 <Beatussum>	j`ey: if the iterator returned implements other traits (for example, Clone, Debug, etc.) should I specify them too?
Feb 29 17:44:49 <j`ey>	if they make sense
Feb 29 17:47:12 <Ademan_>	cehteh: then how can we say the lifetime is "at least 'a" ? longer than 'a would be longer than the known lifetime of the underlying string
Feb 29 17:47:15 <cehteh>	just specify what you need, no more no less
Feb 29 17:48:24 <cehteh>	Ademan_?
Feb 29 17:48:34 <Beatussum>	cehteh: okay I've got it
Feb 29 17:48:39 <Beatussum>	thanks :)
Feb 29 17:52:07 <gastus>	I tried .lines to count lines of a file found out that it's much slower than C fgets() function. Found rust-mio but I have issues compiling it on some systmes eg stdlib.h is missing (nixos) or OSX other error. Is there yet another solution I missed ? I am interested in using json-yy like very fast parsers cause I have to process like 3GB of JSON files.
Feb 29 17:53:03 <cehteh>	gastus: you use that with a BufReader ?
Feb 29 17:57:21 <Beatussum>	I've another question about the error `E0700`? I'm not sure to understand why a lifetime specifier is needed in the following case https://bpa.st/PG3A
Feb 29 18:09:41 <Arnavion>	Ademan_: We're talking about "at least" / "at most" from different points of view :)
Feb 29 18:10:30 <Arnavion>	A &'static str can be converted to a &'a str. So from the POV of the producer of the &'a str, the str lives at least as long as 'a (it could be living longer). From the POV of the consumer of the &'a str, the str lives at most as long as 'a
Feb 29 18:11:26 <Arnavion>	The consumer for example cannot put it in a variable of type &'static str, because the &str is only guaranteed to live at most as long as 'a
Feb 29 18:18:51 <Arnavion>	So in this case, CharIndices::as_str() could just return `"foo"` (str literals are &'static str) and it would compile fine. But when the caller of CharIndices::as_str() lost the original &str that they had called .char_indices() on, they would also lost the &str returned by CharIndices::as_str()
Feb 29 18:24:26 <Guest13>	Hi, how do I print the current enum variant as string, assuming its debug/display traits were changed to something unrelated(like a full error message), this output is what I'm looking for: https://play.rust-lang.org/?version=nightly&mode=debug&edition=2024&gist=9e002932cba05f4c386211e2356c9df2
Feb 29 18:42:52 <gastus>	cehteh: Looks like libc might do it as well. So google fooled me into using a maybe too complex library.
Feb 29 18:43:19 <cehteh>	huh?
Feb 29 18:46:45 <cehteh>	just using a BufReader should fix this, when you didnt do so already, while rust might be a bit more pedantic since it validates that the strings/lines are utf-8, when you need it really fast then you count the \n's
Feb 29 18:46:50 <cehteh>	byte wise
Feb 29 18:47:31 <gastus>	Yes, the UTF-8 might be the reason why it's slower. Cause the JSON parsing in C showed similar difference.
Feb 29 18:47:53 <cehteh>	i suspect the most slowdown comes when you dont do buffered io
Feb 29 18:48:01 <gastus>	I will try and report.
Feb 29 18:48:38 <cehteh>	reading each byte is then a syscall turnaround
Feb 29 18:49:02 <gastus>	In fact I was using BufReader (thanks GPT :-). So that's not the difference.
Feb 29 18:49:22 <cehteh>	ah ok, hence i asked, W/O would be slower
Feb 29 18:49:33 <cehteh>	maybe you use a bigger buffer as well
Feb 29 18:50:08 <gastus>	Maybe boost of my CPU is not setup correctly. Maybe RAM actually is the bottleneck. That would explain why UTF8 makes bigger difference than it should.
Feb 29 18:50:19 <edgimar>	What is the recommended way to compute an average and standard-deviation on a [f64]?  I'm looking for traits that are already defined, since I don't want to reinvent the wheel every time I need this.
Feb 29 18:51:27 <cehteh>	gastus: the utf-8 check adds certainly some penalty
Feb 29 18:54:13 <Alexendoo>	BufRead::lines allocates a new string for each line, there's read_line if you want to re-use the same buffer
Feb 29 18:55:18 <cehteh>	the fastest would be to mmap the file, some madvise hints and then iterate by bytes counting \n's .. possibly in few parallel threads :)
Feb 29 18:55:29 <edgimar>	And yes I can just do numbers.iter().sum / (numbers.len() as f64), but I want something like numbers.mean_and_std().
Feb 29 18:55:36 <cehteh>	of course thats the most involved was as well :)
Feb 29 19:20:13 <consus>	Documentation to From suggests that implementing From<T> for U also brings me Into<T> for U
Feb 29 19:20:19 <consus>	However, that's not happening
Feb 29 19:20:30 <consus>	What am I doing wrong?
Feb 29 19:20:51 <j`ey>	Into<U> for T
Feb 29 19:20:56 <spb>	implementing From<T> for U gets you Into<U> for T
Feb 29 19:21:16 <consus>	ah dammit
Feb 29 19:21:38 <consus>	shame :(
Feb 29 19:24:44 <Guest13>	If I try to find out type of 'e' by doing "let i:i64=e;", then I get ^ expected `i64`, found `Error`, but 'Error' is not good enough type information, whilst I know now it's an enum variant "pkg_config::Error::Command" at that spot in the code (through brute force means aka match over all variants but what if there's 100s?!). Is there some way to
Feb 29 19:24:44 <Guest13>	find that "pkg_config::Error::Command" type?
Feb 29 19:29:53 <consus>	given that I've implemented both From<T> for U and Into<T> for U, should I also imlement From<Vec<T>> and Into<Vec<T>>?
Feb 29 19:30:03 <consus>	Or these come for free?
Feb 29 19:32:06 <spb>	you generally shouldn't implement Into yourself
Feb 29 19:32:23 <spb>	if the conversion goes both ways, impl From<T> for U and From<U> for T
Feb 29 19:32:36 <consus>	sadly I cannot touch U
Feb 29 19:32:39 <consus>	that's foreign type
Feb 29 19:33:45 <consus>	Or it's possible to define From<U> if U is another crate?
Feb 29 19:34:41 <spb>	you can impl From<T> on U if you own T
Feb 29 19:34:52 <consus>	oh
Feb 29 19:35:26 <spb>	owning a type that's a generic param for the trait is enough to satisfy the orphan rule
Feb 29 19:35:41 <consus>	thanks
Feb 29 19:35:45 <consus>	    Ok(Json(list.into_iter().map(Into::into).collect()))
Feb 29 19:36:00 <consus>	So then I have this
Feb 29 19:36:05 <consus>	Vec<T> -> Vec<U>
Feb 29 19:36:51 <consus>	Is it possible to make it like this: Ok(Json(list.into())? Or this is not how things work?
Feb 29 19:37:28 <Guest13>	just making sure, can people see this message?
Feb 29 19:37:29 <consus>	I was under the impression that Into should work for T<U> -> T<F> conversions
Feb 29 19:38:44 <spb>	not in the general case
Feb 29 19:38:52 <consus>	:(
Feb 29 19:39:10 <Guest13>	hello?
Feb 29 19:39:16 <consus>	Guest13: Hi :)
Feb 29 19:39:47 <Guest13>	oh ok, sorry, i thought my messages weren't getting through, I guess then no one knows about my issue, which is fair
Feb 29 19:40:20 <j`ey>	Guest13: yes the compiler wont print the exact variant basically
Feb 29 19:40:49 <nox>	How would rustc know
Feb 29 19:40:52 <Guest13>	ok, thanks
Feb 29 19:41:04 <Guest13>	I don't know, I thought maybe macros
Feb 29 19:41:13 <Guest13>	but I'm too new
Feb 29 19:41:45 <Guest13>	I guess the way is through match after all
Feb 29 19:42:01 <j`ey>	or dbg!(e) if it supports Debug
Feb 29 19:42:31 <nox>	Guest13: e is an Error, rustc knows that, but it doesn't know which variant the value is, as that's known at runtime
Feb 29 19:42:32 <Guest13>	it does but it prints an explanation message, and I was trying to see which type it was so I can match against it instead
Feb 29 19:42:46 <Guest13>	nox, understood,. thanks
Feb 29 20:02:51 <consus>	spb: thanks, this pub trait VecExtInto<T, U> {
Feb 29 20:02:51 <consus>	    fn morf(self) -> Vec<U>;
Feb 29 20:02:51 <consus>	}
Feb 29 20:02:51 <consus>	impl<T,U> VecExtInto<T, U> for Vec<T>
Feb 29 20:02:51 <consus>	where
Feb 29 20:02:52 <consus>	    U: From<T>
Feb 29 20:02:52 <consus>	{
Feb 29 20:02:53 <consus>	    fn morf(self) -> Vec<U> {
Feb 29 20:02:53 <consus>	        self.into_iter().map(Into::into).collect()
Feb 29 20:02:54 <consus>	    }
Feb 29 20:02:54 <consus>	}
Feb 29 20:02:55 <consus>	does the trick
Feb 29 20:19:30 <Ademan>	Arnavion: thanks, that makes sense, now I just need to integrate that info haha
Feb 29 20:39:16 <gastus>	libc fopen returns FILE which is enum FILE {}. So there is no real way to check the result of an fopen call (trying to be unsafe to understand the speed difference). So looks like best way to go is write actual C code.
Feb 29 20:45:51 <osse>	gastus: Can call ptr.is_null() ?
Feb 29 21:00:19 <_Vi>	Is there already a feature proposal / pre-RFC about library compilation settings that are supposed to be adjusted only by a root crate, not intermediate dependencies? For example, `tokio_unstable`. Many rhai's Cargo-level features would look better as root-crate-only features.
**** BEGIN LOGGING AT Fri Mar  1 01:59:42 2024

Mar 01 01:59:41 *	Now talking on ##rust
Mar 01 01:59:41 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 01 01:59:41 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Mar 01 03:31:39 <danieldg>	is there a nicer-looking way of getting a String out of a HashMap<&str,&str> than map.get("key").map_or("", |s| s).into()?
Mar 01 03:40:27 <She>	danieldg: Consider https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_default instead of the map_or.
Mar 01 03:41:55 <danieldg>	She: can't; it's an Option<&&str>, which has no Default
Mar 01 03:46:50 <She>	Ooop, indeed, you'd also need to throw a cloned() into there.
Mar 01 03:48:59 <polychromata{J}>	evalr: <&str as Default>::default()
Mar 01 03:49:01 -evalr/##rust-	polychromata{J}: ""
Mar 01 03:49:11 <polychromata{J}>	evalr: <&&str as Default>::default()
Mar 01 03:49:12 -evalr/##rust-	polychromata{J}: error[E0277]: the trait bound `&&str: Default` is not satisfied ...
Mar 01 03:49:13 -evalr/##rust-	polychromata{J}: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=18c5736f5e498008079eee3e407cea29
Mar 01 03:49:19 <polychromata{J}>	ah, that makes sense
Mar 01 03:51:53 <Arnavion>	Or get to Option<String> and then _or_default it, eg   .get().copied().map_or_else(Default::default, Into::into)
Mar 01 03:55:27 <danieldg>	sure.  Mine wins for code-golf, but I think I'll use .copied.unwrap_or_default.to_owned
Mar 01 03:55:33 <Arnavion>	Also   impl Default for &&T where &'static T: Default { fn default() -> Self { &Default::default() } }   would let &&str be Default, I think
Mar 01 03:56:56 <danieldg>	might fail due to str:!Sized
Mar 01 03:57:48 <danieldg>	I don't see the &&T impl in the docs
Mar 01 03:57:51 <Mutabah>	Nah, it'd fail due to `Default::default()` not being `const`
Mar 01 03:57:56 <danieldg>	ah
Mar 01 03:58:48 <Arnavion>	https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=bd3443fd171959867f0aa78d91bbb5a7   Bah
Mar 01 03:59:48 <Arnavion>	Yeah, makes sense, static promotion only works for const-evaluated exprs
Mar 01 05:49:44 <mips64el>	hi o/
Mar 01 07:12:06 <Ademan_>	are derived Clones inline? in general? with exception? always?
Mar 01 08:42:59 <bertptrs>	Ademan_: at present not defined, but you can use cargo-expand to see (it is)
Mar 01 10:32:22 <Bish>	whenever i use a stream i basicially HAVE to get the futures_util::StreamExt, why isn't that default? im guessing because stream is not a first class citizen in rust?
Mar 01 10:32:27 <Bish>	is it async streams that are not std::stream ?
Mar 01 10:48:40 <bertptrs>	std::stream does not exist yet, and currently the Stream trait is kept minimal to make future adoption easier
Mar 01 10:56:28 <Bish>	and where is "the" stream trait? is it in futures_util?
Mar 01 10:59:49 <bertptrs>	futures_core
Mar 01 11:01:33 <nullie>	is there a better way to do something n times (than for _ in 0..n)?
Mar 01 11:03:31 <j`ey>	(0..n).for_each(..) maybe
Mar 01 11:04:16 <osse>	std::iter::repeat(()).take(10).for_each(|()| do_something())  \O/
Mar 01 11:04:32 <j`ey>	heh
Mar 01 11:04:55 <j`ey>	thars more optimal since it doesnt need to count the numbers /s
Mar 01 11:06:35 <dav1d>	j`ey, https://rust-lang.github.io/rust-clippy/master/index.html#/needless_for_each
Mar 01 11:07:37 <dav1d>	Wait did they move that lint into pedantic 🤔
Mar 01 11:07:38 <osse>	Hmm, when is .for_each() more performant ?
Mar 01 11:09:58 <j`ey>	dav1d: not sure if that would apply here?
Mar 01 11:11:02 <dav1d>	can I make clippy pedantic on the playground?
Mar 01 11:12:18 <dav1d>	j`ey, yeah it doesn't
Mar 01 11:47:34 <polychromata{J}>	osse: probably never
Mar 01 11:47:43 <polychromata{J}>	all else being equal, just use for{}
Mar 01 11:48:05 <polychromata{J}>	IOW, `for _ in 0..n {}` /is/ the way to do that
Mar 01 11:48:32 <polychromata{J}>	(i'll accept for_each() if it's a lot nicer to write, e.g. at the end of a long iterator chain)
Mar 01 11:48:47 <polychromata{J}>	(at least until we get postfix control flow keywords c; )
Mar 01 12:25:03 <prmthz>	hello! does anyone know how can I set "cargo test" parameters like "--test-threads=2" in the .cargo/config.toml ?
Mar 01 12:50:49 <curious-user>	hi, is there an orm which can load nested one-to-many relations without jumping through hoops?
Mar 01 12:52:04 <curious-user>	sea orm can't do that at all, diesel can but requires a lot of grouped_by's and zip's
Mar 01 12:53:01 <curious-user>	it seems weird that such basic functionality is still missing from major orms
Mar 01 12:54:57 <curious-user>	(not bashing, just wondering maybe i've missed something)
Mar 01 13:21:47 <sword_smith>	How do I strip all special characters from a string? The concrete example I have right now is that I want to convert the string
Mar 01 13:21:55 <sword_smith>	"*a" into "a".
Mar 01 13:22:27 <sword_smith>	Or `&str`, I guess. I don't think that matters. But what I have now i of type `String`.
Mar 01 13:24:18 <j`ey>	hm, maybe .replace(&['a', 'b'....'z'], "")
Mar 01 13:24:23 <j`ey>	that seems a little annoying
Mar 01 13:24:35 <j`ey>	ah no, you can put a function there
Mar 01 13:25:22 <j`ey>	evalr: let a = String::from("a-z"); a.replace(|c|!c.is_alphabetic(), "")
Mar 01 13:25:24 -evalr/##rust-	j`ey: error[E0282]: type annotations needed ...
Mar 01 13:25:24 -evalr/##rust-	j`ey: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=8faea1028e4dbb8e42af3cf0ddd9caea
Mar 01 13:25:53 <j`ey>	evalr: et a = String::from("a-z"); a.replace(|c: char|!c.is_alphabetic(), "")
Mar 01 13:25:55 -evalr/##rust-	j`ey: error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an ...
Mar 01 13:25:55 -evalr/##rust-	j`ey: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=805e1fdc104003e093c03c105bf383df
Mar 01 13:25:59 <j`ey>	ffs lol
Mar 01 13:26:23 <Lumpio->	...et?
Mar 01 13:26:48 <j`ey>	mis copy :)
Mar 01 13:26:52 <polychromata{J}>	evalr: let a = String::from("a-z"); a.replace(|c: char| !c.is_alphabetic(), "")
Mar 01 13:26:54 -evalr/##rust-	polychromata{J}: "az"
Mar 01 13:28:55 <sword_smith>	j`ey: That seems to work :)
Mar 01 13:32:07 <sword_smith>	This is for the debugger of a VM. I'm auto-generating some type/variable name hints. The best solution would be to make the assembly-parser more permissive wrt. these names, but for now, j`ey's above snippet works.
Mar 01 13:32:59 <polychromata{J}>	eh, that's fair. :)
Mar 01 13:33:11 <polychromata{J}>	though perhaps…
Mar 01 13:33:27 <polychromata{J}>	evalr: let a = String::from("a**z%"); a.replace(|c: char| !c.is_alphabetic(), "_")
Mar 01 13:33:29 -evalr/##rust-	polychromata{J}: "a__z_"
Mar 01 13:34:01 <j`ey>	yes _ is better, maybe
Mar 01 13:34:23 <osse>	polychromata{J}: i see. Then that performance claim in that clippy is a bit weird.
Mar 01 13:35:00 <polychromata{J}>	clippy makes a performance claim?
Mar 01 13:35:34 <osse>	Bad phrasing on my part, probably.
Mar 01 13:35:46 <osse>	I meant this, quoted from the link above: "for_each may be used after applying iterator transformers like filter for better readability and performance. It may also be used to fit a simple operation on one line. But when none of these apply, a simple for loop is more idiomatic."
Mar 01 13:35:52 <sword_smith>	All tests pass :) I'm going with the replacement with `_`.
Mar 01 13:36:16 <polychromata{J}>	i'd be surprised if `for bar in foo { $body }` and `foo.for_each(|bar| { $body });` compiled to any different code.
Mar 01 13:38:51 <osse>	Same
Mar 01 13:39:04 <osse>	Interesting, from the std docs: "In some cases for_each may also be faster than a loop, because it will use internal iteration on adapters like Chain."
Mar 01 13:42:03 <osse>	Aka. it can take some shortcut that doesn't involve literally calling next() I guess
Mar 01 13:42:17 <osse>	s/Aka\./IOW./
Mar 01 13:42:54 <LDericher>	hi, currently relearning rust on my stm32 "blue pill" thingy and ran into an ownership/borrowing problem. Code: https://bpa.st/EUEA Issue: Lines 72/73 work, but doing that inside the loop at L82/87 fails as `tx` and `buf` are moved into the loop. tx and buf are both okay to be made 'static if needed. how to proceed?
Mar 01 13:46:35 <LDericher>	also, changing `buf` to `&*buf` in L82 makes one error go away as the analyzer suggests, but doesn't that only give the first value to the `write` fn?
Mar 01 13:59:38 <osse>	LDericher: what is the signature of tx.write()
**** BEGIN LOGGING AT Fri Mar  1 14:01:17 2024

Mar 01 14:01:16 *	Now talking on ##rust
Mar 01 14:01:16 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 01 14:01:16 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Mar 01 14:05:08 <LDericher>	osse, `fn write(mut self, buffer: B) -> Transfer<R, B, Self>` and `B: ReadBuffer<Word = u8>`
Mar 01 14:07:09 <spb>	https://docs.rs/stm32f1xx-hal/latest/stm32f1xx_hal/serial/type.TxDma1.html
Mar 01 14:07:19 <spb>	that's the `tx` you're working with
Mar 01 14:08:34 <spb>	write() consumes self and presumably wraps it into the returned Transfer object so you have to wait for the operation to complete before using it again for a new one
Mar 01 14:09:57 <LDericher>	spb, yes and the error is: `stm32f1xx_hal::dma::WriteDma::write` takes ownership of the receiver `self`, which moves `tx`
Mar 01 14:11:32 <spb>	yes
Mar 01 14:11:50 <spb>	once you call tx.write() you cannot use tx any more because it is consumed by the write call
Mar 01 14:12:40 <LDericher>	but the `with_dma` call to initialize `tx` takes care of the DMA initialization, so I'd like to reuse tx
Mar 01 14:13:02 <spb>	you can't reuse tx, the api doesn't allow it
Mar 01 14:13:25 <spb>	what you can do is use the returned Transfer object to get a new tx out of it, once the transfer has completed
Mar 01 14:14:14 *	polychromata{J} squints at that name.
Mar 01 14:14:18 <null_ptr>	osse: One problem with for loops is that the compiler cannot generate nested loops and needs additional state tracking. With internal iteration the iteration structure can be kept optimal.
Mar 01 14:15:38 <LDericher>	I don't see anything in the `xfer` that looks like "reinitiate this" ... on the other hand I just inspected the DMA init and it looks less complex than I assumed it to be
Mar 01 14:16:11 <spb>	LDericher: look at what's returned from wait()
Mar 01 14:21:08 <LDericher>	spb, looks fine https://bpa.st/ORDQ but only shifts the issue: `Tx::<stm32f1xx_hal::pac::USART1>::with_dma` takes ownership of the receiver `self`, which moves `serial.tx`
Mar 01 14:22:06 <spb>	that's not at all what i said to do
Mar 01 14:22:51 <LDericher>	and using wait() feels like a chicken-and-egg problem as I'd need a completed Transfer before starting one?
Mar 01 14:24:31 <spb>	once you start the transfer, you need to use wait(), get whichever type that particular variant returns in its tuple, call release() on that, and you get a new Tx
Mar 01 14:24:47 <spb>	set up dma again on that, and write it back over the top of `tx` so you can use it in the next loop
Mar 01 14:26:39 <spb>	i'm being vague here because i'm working purely from the rustdocs which are pretty hopeless
Mar 01 14:26:57 <spb>	hopefully there's some real documentation somewhere else to make actual sense of why all this dance is required
Mar 01 14:29:08 <LDericher>	well it works, idk why it is this convoluted, but the C(++) way is way more obscure btw
**** BEGIN LOGGING AT Fri Mar  1 16:01:18 2024

Mar 01 16:01:17 *	Now talking on ##rust
Mar 01 16:01:17 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 01 16:01:17 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** BEGIN LOGGING AT Fri Mar  1 18:08:59 2024

Mar 01 18:08:59 *	Now talking on ##rust
Mar 01 18:08:59 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 01 18:08:59 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** ENDING LOGGING AT Fri Mar  1 18:10:30 2024

**** BEGIN LOGGING AT Fri Mar  1 19:04:14 2024

Mar 01 19:04:13 *	Now talking on ##rust
Mar 01 19:04:13 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 01 19:04:13 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** BEGIN LOGGING AT Sat Mar  2 03:05:27 2024

Mar 02 03:05:26 *	Now talking on ##rust
Mar 02 03:05:26 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 02 03:05:26 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Mar 02 04:03:52 <Sync03>	Hi there -- I have am making a vim-like editor, and I am implementing functionality for buffers. Does an associated function exist for the iter type, that is similar to .next() but when the end of the iterator is reached, instead of returning None, it goes back to the start of the iterator. So it's effectively infinitely repeating? Is this a possibility? Cheers.
Mar 02 04:05:36 <danieldg>	sure; look at Iterator::cycle
Mar 02 04:06:21 <Sync03>	Thanks!
Mar 02 04:06:23 <danieldg>	it isn't used like you described but it does what you want
Mar 02 05:43:00 <josh19291>	¬¬LL
Mar 02 05:46:51 <josh19291>	Hi
**** BEGIN LOGGING AT Sat Mar  2 06:15:35 2024

Mar 02 06:15:35 *	Now talking on ##rust
Mar 02 06:15:35 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 02 06:15:35 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** BEGIN LOGGING AT Sat Mar  2 06:17:10 2024

Mar 02 06:17:09 *	Now talking on ##rust
Mar 02 06:17:09 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 02 06:17:09 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Mar 02 08:03:16 <Guest27>	Iti
Mar 02 08:03:45 <Guest27>	YMEJWG
Mar 02 08:04:34 <Guest27>	Bn8
Mar 02 08:27:04 <Wulf>	How do I call posix_fadvise on an std::fs::File?
Mar 02 08:35:58 <capitol>	Wulf: https://docs.rs/nix/latest/nix/fcntl/fn.posix_fadvise.html maybe
Mar 02 08:37:45 <capitol>	Wulf: or did you mean how to get a rawfd? https://doc.rust-lang.org/std/fs/struct.File.html#impl-AsRawFd-for-File
Mar 02 08:40:08 <Wulf>	capitol: both. Why won't "use nix::fcntl::posix_fadvise;" not work? "no `posix_fadvise` in `fcntl`"
Mar 02 08:40:50 <capitol>	maybe "Available on crate feature fs only" have you enabled that feature?
Mar 02 08:40:57 <Wulf>	capitol: I have no idea what that means.
Mar 02 08:42:14 <capitol>	when you import it in Cargo.toml you can specify features
Mar 02 08:43:43 <capitol>	https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#choosing-features
Mar 02 08:50:57 <Wulf>	capitol: thanks, works.
Mar 02 08:58:30 <capitol>	Wulf: nice :)
Mar 02 09:44:34 <Wulf>	How do I declare a function parameter that is either a u64 or "nothing"? And how do I check for "nothing" in the code?
Mar 02 09:45:04 <lambda>	Wulf: Option<u64>?
Mar 02 09:45:26 <lambda>	that has a value of either `Some(n)` where `n` is a u64, or `None`
Mar 02 09:46:27 <lambda>	you can check which one it is with `match`, `if let`, or maybe there's an existing method on `Option` that does what you need - you'd need to explain a bit more about the problem you're trying to solve
Mar 02 09:47:58 <Wulf>	lambda: it's my second day with rust. Guess I'll look at each of them and see what looks more useful.
Mar 02 09:49:18 <lambda>	Wulf: FYI, Option isn't magic in any way, the definition at the top of this page is all it really is: https://doc.rust-lang.org/std/option/enum.Option.html
Mar 02 09:49:48 <lambda>	I'd recommend reading the relevant chapter in the book: https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html?highlight=option#the-option-enum-and-its-advantages-over-null-values
Mar 02 09:53:01 <Chagall>	anyone else notice a large drop in throughput and less stable measurements when using criterion with batched iterations?
Mar 02 09:54:29 <dav1d>	Is it feasible to have a macro_rules macro that accepts any enum without data in the variants and then just does something with the variants? I feel like this is proc macro territory
Mar 02 09:59:14 <lambda>	dav1d: should be possible, if a bit of a pain to cover all the things that can be in an enum definition (attributes and such)
Mar 02 10:01:16 <dav1d>	lambda, I remembered pin-project-lite does something like that for structs, doesn't seem terrible, just gotta figure out how to not discard docs
Mar 02 10:42:56 <polychromata{J}>	Wulf: `match{}` is the most general thing; all of Option's other operations can be implemented in terms of it
Mar 02 10:43:05 <farnext>	 /msg NickServ REGISTER farnext far.next@gmail.com
Mar 02 10:43:55 <polychromata{J}>	Option has a /ton/ of convenience methods; don't worry about learning them all at once. You'll gradually get to know what's best|prettiest to use in each situation, over time. :)
Mar 02 10:44:09 <polychromata{J}>	farnext: protip: don't set your password equal to your nickname c.c
Mar 02 10:46:24 <polychromata{J}>	I like Diceware. Although you can also just use [a-z]+ as long as it's long enough (e.g. 26.pow(11) is roughly equal to 7776.pow(4)).
Mar 02 10:46:34 <polychromata{J}>	And then, for IRC, there's client cert auth, of course.
Mar 02 11:14:37 <Wulf>	I'm quite confused with match, functions, error handling, etc. Could someone please translate this toy example to rust for me? https://paste.debian.net/1309229/
Mar 02 11:20:25 <j`ey>	Wulf: why dont you show us what you have so far
Mar 02 11:23:11 <j`ey>	Wulf: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021 is a good site for rust snippets
Mar 02 11:33:51 <dav1d>	ah right I remember, documentation is just an attribute in macro_rules
Mar 02 11:36:28 <Wulf>	j`ey: https://gist.github.com/rust-play/ef6118a1923a74cdefd328eb7b09a410
Mar 02 11:37:12 <j`ey>	alright, looks good so far
Mar 02 11:37:21 <Wulf>	j`ey: well, the error handling is missing.
Mar 02 11:37:38 <j`ey>	Wulf: then you need to return Result<Self, Error> instead of just Self
Mar 02 11:37:54 <j`ey>	fn new(foo: Option<u64>, bar: u64) -> Result<Self, YourErrorType> {
Mar 02 11:38:09 <Wulf>	j`ey: and what error type would that be?
Mar 02 11:39:02 <j`ey>	you have to make one up or use an exisiting error type
Mar 02 11:39:10 <j`ey>	or just ().. any type basically
Mar 02 11:39:36 <polychromata{J}>	The first counterquestion is…is this for a library or an application?
Mar 02 11:40:40 <j`ey>	Wulf: this extends the example, minimally, https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=4154763522c6ad453c327d76239b3169
Mar 02 11:41:19 <polychromata{J}>	If it's an app, you can play pretty fast and loose with error types.
Mar 02 11:41:20 <Wulf>	polychromata{J}: application, but it must not crash when a bad value is passed.
Mar 02 11:41:31 <polychromata{J}>	Right, of course.
Mar 02 11:42:18 <polychromata{J}>	So having proper error types isn't quite as important. You can use `Box<dyn Error>` or `anyhow::Error` or whatever—the latter is easy to get started with compared to alternatives, i believe
Mar 02 11:42:23 *	polychromata{J} doublechecks this
Mar 02 11:42:30 <Wulf>	It will accept a TLS connection and receive the parameter through it. When it's bad, the connection is closed, but the application should keep running to handle other connections.
Mar 02 11:43:09 <j`ey>	we're not talking about crashing :)
Mar 02 11:43:10 <Wulf>	j`ey: thanks
Mar 02 11:43:59 <polychromata{J}>	Oh, wow, anyhow has a good amount of support for ad-hoc errors.
Mar 02 11:44:05 <polychromata{J}>	That's pretty nice.[^1]
Mar 02 11:46:01 <polychromata{J}>	So if you pull in anyhow and change the return type to `Result<Self, anyhow::Error>`, you can do things like `if foo > 9 { bail!("tried to construct a Hello with foo={foo:?} (foo must be less than 9)") }`
Mar 02 11:46:30 <polychromata{J}>	s/bail!/anyhow::bail!/
Mar 02 11:46:48 <polychromata{J}>	This is a few new things at once; what questions do you have? :)
Mar 02 11:47:19 <j`ey>	I wwould learn more about Result itself first
Mar 02 11:47:22 <Wulf>	polychromata{J}: I think throwing more libraries at me only increases my confusion ;-)
Mar 02 11:47:58 <polychromata{J}>	Well, personally i like to do proper error types everywhere, but that's a good bit more work. :)
Mar 02 11:48:06 <polychromata{J}>	(Also i use thiserror for that, which is another library.)
Mar 02 11:48:15 <polychromata{J}>	(Because it's more tedious to not.)
Mar 02 11:48:46 <j`ey>	I mean the easiest thing to do next is: struct WulfError {} and change the Result<Self, ()> to Result<Self, WulfError>
Mar 02 11:48:47 <polychromata{J}>	Rust's std tends to err on the minimal side, so if you try hard to avoid libraries, you're probably going to have a bad time. :)
Mar 02 11:49:21 *	polychromata{J} notes that the Book introduces a library (rand) in chapter 2.
Mar 02 11:49:38 <polychromata{J}>	j`ey: The thing about that, though, is that it carries no information on what actually went wrong.
Mar 02 11:49:46 <j`ey>	sure
Mar 02 11:49:49 *	polychromata{J} gestures to her error message. It's detailed.
Mar 02 11:49:57 <j`ey>	but this is like their second day of rust :P
Mar 02 11:50:25 *	polychromata{J} tailswishes.
Mar 02 11:50:28 <polychromata{J}>	You may be right. :P
Mar 02 11:52:31 <polychromata{J}>	So yes, `struct WulfError;` is easy…
Mar 02 11:54:28 <saati>	enum WulfError{}; and the compiler proves you make no errors :)
Mar 02 11:54:52 <polychromata{J}>	Tch. Uninhabited types on day 2?
Mar 02 11:55:03 <j`ey>	hah
Mar 02 12:07:19 <dav1d>	Result::into_ok when 😡
Mar 02 12:07:28 <polychromata{J}>	never
Mar 02 12:07:44 <dav1d>	noooooooooooooo :(
Mar 02 12:07:53 <polychromata{J}>	i know right ;-;
Mar 02 12:08:03 <dav1d>	!
Mar 02 12:40:15 <Diablo-D3>	you know, its kinda sad that microsoft is this huge big company thats tried to fix directwrite several times (and tbf, they have, its way better than it used to be)....
Mar 02 12:40:31 <Diablo-D3>	but they cant catch up to a bunch of random dudes on the internet who made freetype.
Mar 02 15:58:06 <Beatussum>	Hi! I would like to implement a "symetric" trait e.g. if I implement MyTrait<A> is implemented for B, therefore MyTrait<B> is also implemented for A by using the previous implementation. What is the best way to achieve this?
Mar 02 16:03:48 <tokie>	Beatussum: look at From/Into. If you impl From you get the reverse Into trait from a blanket impl
Mar 02 16:05:17 <tokie>	https://doc.rust-lang.org/src/core/convert/mod.rs.html#747-749
Mar 02 16:06:39 <tokie>	oh, that's two different traits though
Mar 02 16:15:44 <Beatussum>	tokie: Yeah, I would like to have the same trait implemented `MyTrait<A>` and `MyTrait<B>` because `MyTrait` provide one method which should be used by an instance of `A` or `B`
Mar 02 16:15:58 <Beatussum>	`From` and `Into` provide two different method
Mar 02 16:28:32 <josh19291>	A
Mar 02 16:28:36 <josh19291>	/hwlp
Mar 02 16:55:40 <polychromata{J}>	evalr: trait MyTrait<T> {} impl<A, B> MyTrait<B> for A where B: MyTrait<A> {}
Mar 02 16:55:41 -evalr/##rust-	polychromata{J}: ()
Mar 02 16:56:58 <polychromata{J}>	evalr: trait MyTrait<T> { fn method(&self, other: &T); } impl<A, B> MyTrait<B> for A where B: MyTrait<A> { fn method(&self, other: &B) { other.method(self) } }
Mar 02 16:57:00 -evalr/##rust-	polychromata{J}: ()
Mar 02 16:57:46 <polychromata{J}>	Beatussum: a cursory check says that it works, but i have a sneaking feeling that there's some subtle reason why it'll break c.c
**** BEGIN LOGGING AT Sat Mar  2 19:02:29 2024

Mar 02 19:02:28 *	Now talking on ##rust
Mar 02 19:02:28 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 02 19:02:28 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** BEGIN LOGGING AT Sun Mar  3 08:36:18 2024

Mar 03 08:36:17 *	Now talking on ##rust
Mar 03 08:36:17 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 03 08:36:17 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Mar 03 08:38:03 <Widdershins>	ok the distance from where i was at to the associative key-value version that we've been talking about was pretty short
Mar 03 08:38:18 <Widdershins>	this passes MIRI https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=a70e90eabeab883b7229a9c4f062f45b
Mar 03 08:38:46 <Widdershins>	probably a good idea to make it so this panics less when you ask for keys that aren't there or whatever but the underlying mechanism is sound
Mar 03 08:41:48 <Widdershins>	the symbol repo version of this would have a slightly different api, probably like add_clown but not accepting a value
Mar 03 08:48:29 <Widdershins>	or, this could be combined with the vec-of-vecs to make a type that doesn't need to be StableDeref itself... so many possibilities
Mar 03 10:09:39 <polychromata{J}>	Widdershins: passes miri huh
Mar 03 10:09:53 <polychromata{J}>	do you have yarn tests? do those pass miri?
Mar 03 10:48:00 <Widdershins>	polychromata{J}: no idk that. yarn is a dep manager for javascript that i avoid looking at, too me. just saying that this doesn't complain when i run that program under miri, so it does seem like the unsafety is pretty much legal
Mar 03 10:48:19 <polychromata{J}>	not the JavaScript yarn!
Mar 03 10:49:23 <polychromata{J}>	oh, i misremembered. it's called loom.
Mar 03 10:49:28 <Widdershins>	i'm unable to find what you're looking for then
Mar 03 10:50:04 <polychromata{J}>	different textileish word. ^.^;
Mar 03 10:50:07 <Widdershins>	based on the readme of loom miri is WAY more comprehensive
Mar 03 10:50:51 <Widdershins>	it also runs a godzillion times slower, and is made to test more of the things i care about here (i am personally a lot more worried about memory UB than the concurrency violation. the concurrency part is simple)
Mar 03 10:52:11 <Widdershins>	miri makes it so if you so much as accidentally create an intermediate reference when you shouldn't by spelling something in a basically equivalent but different way, it will throw up
Mar 03 11:08:14 <dav1d>	How can I `cfg(test)` expose something for doctests? Having `#[cfg(any(test, doctest))] pub mod test;` doesn't seem to do it
Mar 03 11:08:40 <Widdershins>	it doesn't?
Mar 03 11:09:35 <dav1d>	nope, module not found
Mar 03 11:09:47 <dav1d>	`unresolved import `enumap::test``
Mar 03 11:10:01 <Widdershins>	:(
Mar 03 11:10:36 <dav1d>	:( https://github.com/rust-lang/rust/issues/67295#issuecomment-568287766
Mar 03 11:11:23 <dav1d>	guess I'll just copy paste into every doctest
Mar 03 11:51:01 <dav1d>	What trickery am I missing to implement an iterator which yields mutable references form an array? https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=28afe7124468d51f23c63898bfe75944
Mar 03 11:53:26 <dav1d>	Seems like I'll have to go to unsafe, but meh
Mar 03 12:00:58 <dav1d>	I finessed it, I think? https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=0cc5e250dc61ce32044e4db239e0d45b
Mar 03 12:12:02 <bertptrs>	yeah, something like that
Mar 03 12:12:29 <bertptrs>	there's a reason the default slice iterators use unsafe, to avoid your dance overhead
Mar 03 12:23:01 <gastus_>	@ polychromata{J}  Want to get the prototype done. Might want to care about arena allocation like etc later. In fact I used C and wrote my own inc based allocation which crashed rust but worked for C and the benefit was small (which was I was told upfront here). Need to proof that merging data from CSV this way actually is faster and worth the effort first compared to eg database. It should be.
Mar 03 12:23:58 <gastus_>	There is another thing I dont' get yet and that's the unwind to catch panics. Eg when searching there might be unknown symbols which means that find won't find anything (in fact its actually a speedup). So pattern is like try { ..  return true/false} catch { return false }.
Mar 03 12:24:11 <gastus_>	Maybe passing mut to lambda or such is the way to go.
Mar 03 12:24:39 <gastus_>	Just sometimes missing the convenience of other languages like ruby begin .. code rescue false end done.
Mar 03 12:25:15 <j`ey>	you would return a Result, not panic there usually
Mar 03 12:26:10 <gastus_>	But then I have to write catching the none Some cases..
Mar 03 12:26:28 <gastus_>	And that's the cool thing about exceptions you don't have to.
Mar 03 12:26:53 <j`ey>	with the ? operator it's pretty easy to add early returns on Errors
Mar 03 12:30:04 <gastus_>	So it means Result is to be used instead of Some.
Mar 03 12:30:50 <j`ey>	Result is used if there could be an error.
Mar 03 12:30:55 <j`ey>	whereas option is just some or none
Mar 03 12:32:49 <gastus_>	None in my case means error. So ok_or is the way to go.
Mar 03 12:37:58 <gastus_>	But then need to turn error case into false. Then need a block within which ? is caught. Then I can use Some and patern matching
Mar 03 12:39:50 <j`ey>	you cant currently use ? in blocks
Mar 03 12:39:52 <j`ey>	only functions
Mar 03 12:41:20 <j`ey>	I guess you could use ? in a closure
Mar 03 12:41:51 <gastus_>	But then I still need to convert and for two ? its not worth the effort.
Mar 03 12:52:14 <Widdershins>	you definitely should not be using unwinding for that
Mar 03 12:57:31 <gastus_>	Widdershins: depends on whether speed or programmers time is important :-/ And that's what annoys me you either have srcipting or compiled. But you cannot mix depending on the part of a project you're working. Not everything is most important. And sometimes its ok to be fast and done and option to optimize later.
Mar 03 12:57:50 <gastus_>	But let's say you rewriting Dart/js/wahtever to Rust later is huge effort.
Mar 03 12:57:56 <Widdershins>	dav1d: i'd probably just delegate to core::slice::IterMut
Mar 03 12:58:40 <Widdershins>	gastus_: i'm saying you're going to waste time and cause lots of problems down the line if you try to it this way instead of learning more ergonomic spellings for these things that already exist
Mar 03 12:59:07 <Widdershins>	you aren't the only person in the world who needs the kind of control flow you're trying to write. the tools already exist, you just haven't actually asked questions about it yet
Mar 03 12:59:44 <gastus_>	https://dpaste.com/AU66MTVRY line 72 is one of the stuff I wrote for JS. It basically can create it's own bash completion. It allows to have multiple lazy nested commands done fast.  async ()  or () => or just {} -> it eats everything.
Mar 03 13:00:17 <gastus_>	Widdershins: which keywords do you suggest me looking up ?
Mar 03 13:00:42 <Widdershins>	i don't know because i don't know what you're trying to do. you're talking about how results aren't ergonomic to write but you haven't explained what you have
Mar 03 13:01:44 <gastus_>	I have many CSV files. which contain name/phone .. and they a date like 'company-2023-01-01'. I want to merge all data so that I can query and mix and filter them. Like a person is the same person if they have the same company numebr, the same mobile phone number or have similar name and same zip (this last thing is fuzzy).
Mar 03 13:02:31 <gastus_>	And because I mostly have like 8 different keys attached I thought that actually representing the data as numbers person is list of attributes. List of attributes is (key, value, list of sources it was found) kinda gets the job done and is memory efficient.
Mar 03 13:03:07 <gastus_>	Because there are many different ways to query (by GPS location from address, by region such as state, by company) I didn't find a way to make mysql always be fast. So I really was wonedring whether just using 8 threads and filter is easier cause not many users.
Mar 03 13:03:16 <Widdershins>	sure so what's the issue. i don't see what about this requires intentionally catching unwind
Mar 03 13:03:38 <Widdershins>	certainly the fact that you have mysql involved is part of your problem. it is a very poor database
Mar 03 13:04:28 <gastus_>	So searching a phone number which I represent as symbols cause I expect phone numbers to be presented in 20+ csvs the symbol might not exist. So the fun thing is in that case I don't have any work to do to say not found :-) And that was what the case was about mixing the symbol not found with iterating over the people and the attributes.
Mar 03 13:05:10 <gastus_>	The project is like 10y old and that time I didn't know better. And that's why I investigate bare metal approach to learn from it.
Mar 03 13:06:04 <Widdershins>	i mean you are just mostly describing indexing all these attributes in memory and skipping the rows with something not-found
Mar 03 13:06:25 <dav1d>	Widdershins, I'll have to try again, but I think I also needed the Option dance for that to work
Mar 03 13:06:59 <gastus_>	And because the fuzzy part matching by name / zip depends on task wanted the mixer to be fast and maintainable and adjustable to the task. And loading 300K lines into mysql was like 4h. Now there are 10+ such files. Now thought let me learn Rust and retry using it to learn understand whether the different solution is better and get hands dirty with Rust cause will not go away. And once I understand might
Mar 03 13:07:05 <gastus_>	get an impression whether I even want to throw away my TS code. Not there yet.
Mar 03 13:07:09 <Widdershins>	so start with a column that's always unique, iterate over it, and use .filter_map(|..| ...). it's really easy, because the closure returns Option and you can just skip all the ones with not-found using ?
Mar 03 13:07:12 <Wulf>	I'm stuck with this code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=a74eb6335c9f9de18829bbdd83368e82 . How to fix it?  If it's too large, I can create a smaller testcase for the error.
Mar 03 13:08:19 <gastus_>	Widdershins: but talking about DBs which one do you consider to be better ? I mean there are som any PG, DuckDB, to name just 2. Each ahvinvg its own sweet spot. PG has geo index mysql doesn't but mysql has cache. So for some stupid cache based workload mysql actually might be a good choice and fast choice without much work.
Mar 03 13:09:12 <gastus_>	Widdershins: And you hit the nail. I feel like TS has some nice concepts such as typing 'objects' and wonder why nobody misses is using Rust/Java cause some simple fetch as Promise<type here> use scripting like use cases might exist for such languages, too.
Mar 03 13:09:39 <gastus_>	https://github.com/automerge/automerge-repo.git solve it by having typed and untyped documents and converting between them.
Mar 03 13:09:58 <Widdershins>	Wulf: you've written code that tries to capture a unique reference to self in not just one but ten different threads
Mar 03 13:10:21 <Widdershins>	gastus_: postgres is a thousand times better than mysql
Mar 03 13:10:31 <Widdershins>	mysql does not "have cache"
Mar 03 13:10:46 <Widdershins>	mysql is almost categorically worse than postgres.
Mar 03 13:10:52 <gastus_>	https://dev.mysql.com/doc/refman/5.7/en/query-cache.html
Mar 03 13:11:03 <Wulf>	Widdershins: and I don't know what to do about it. I'm new to rust.
Mar 03 13:11:04 <Widdershins>	it is very, very hard to come up with any type of scenario where mysql performs better than postgres
Mar 03 13:12:07 <Widdershins>	gastus_: you've linked to a "feature" that was deprecated 7 years ago in an EOL release line
Mar 03 13:12:19 <darkling>	It used to be faster than Postgres IIRC, but that was something over 20 years ago. (MySQL prioritised speed; Postgres prioritised correctness).
Mar 03 13:12:56 <Widdershins>	it hasn't been truly faster than postgres in any typical database scenario any time in the last decade
Mar 03 13:13:14 <gastus_>	Gonna shut up and listen more.
Mar 03 13:13:16 <Widdershins>	it's some of the worst software i've ever had the displeasure of being required to use
Mar 03 13:13:45 <darkling>	Oh, I think there's much worse under the false bottom of that particular barrel. :)
Mar 03 13:13:50 <Widdershins>	and i've been a senior data engineer for like 7 years now working with quite a few different ones
Mar 03 13:13:59 <bertptrs>	Saw a beautiful article that tried to establish what exactly it was that the transaction isolation levels in mysql do guarantee, because it surely wasn't what the ANSI SQL spec required
Mar 03 13:14:02 <Widdershins>	darkling: maybe but you'd be surprised
Mar 03 13:14:29 <bertptrs>	Found it, this one https://jepsen.io/analyses/mysql-8.0.34
Mar 03 13:14:30 <Widdershins>	mysql doesn't even have reliable prepared statements in the latest version
Mar 03 13:14:36 <gastus_>	Widdershins: If you have use cases such as sales with different use currencies. I mean you either can have struct {EUR: currency, USD: currency} or a hash lik thing. Now you want to store and sum in database ? What's the best way to share such datatype with a database without having to implement sum multiple currencies twice ?
Mar 03 13:14:41 <Widdershins>	and they're not going to fix it
Mar 03 13:15:21 <Widdershins>	gastus_: sum numeric values grouped by currency
Mar 03 13:15:54 <Widdershins>	if you want the conversions that combine them to happen inside the database too, no you don't
Mar 03 13:21:21 <bertptrs>	I try to actively fight including currency conversions in my code. the finance guys can figure that one out
Mar 03 13:24:02 <gastus_>	I had in mind writing something like a booking platform for campers. And for tihs and others reasons I thought it would be fun to have documents with history builtin. So that wehn merges happens (offline usage) you know what changed and can guide conflict resolution. Kind of key/value store with git like history. So you find branches, you know state last synced with server and changes by user and what
Mar 03 13:24:08 <gastus_>	has'nt been synced etc. Now with TS everything is an object. You add typing. Done. With Rust ? Now how to store with PG ? Yes you can use JSON and query it. And you can reformat the docs to have final state and reversed history. But querying nested JSON keys kinda feels awkward. And then I wonder over and over again what if a database was a library and I could just share types with my app ? Why do I have
Mar 03 13:24:14 <gastus_>	to learn multiple programming languages and stored procedures ? You're right PG allows to create my own libraries. But then I am at the issue which is the most convenient way to package and distribute ? And that's a different story if you have a better tahn rust channel to discuss this I'd be interested in your opinion whether I am reinventing the wheel, too. Cause looking at the many github readmes (if
Mar 03 13:24:20 <gastus_>	youh ave hardawer, then otherwise, .. if you use conda otherwise pip otherwise ubuntu otherwise, ...) kinda sucks and feels like standardised glue code might be missing.
Mar 03 13:24:23 <gastus_>	And about summing -> you have to take care about rounding of database which could be different from your app.
Mar 03 13:24:56 <gastus_>	Liek PHP/JS didn't find a way to make both round the same way. I tried hard like 5+ different ways. Then I concluded Haskell like typeclasses might just fix it, but within DB? back at what if DB was a library ..
Mar 03 13:25:06 <j`ey>	this sounds quite off topoc tbh
Mar 03 13:31:21 <Widdershins>	you're storing well-structured data as json objects and wondering why it's harder to work with?
Mar 03 13:31:54 <Widdershins>	we have tools for that, it's called "having a relational schema"
Mar 03 13:32:30 <gastus_>	But they don't have history :-) So I could derive 'relational data' from it.
Mar 03 13:37:29 <Widdershins>	Wulf: as it is it looks like every thread is trying to share the whole `self` including the File. most of this will probably work if each worker has its own file handle
Mar 03 13:38:34 <gastus_>	@ Wulf Do you think its a wise idea to share a file handle across threads have each call read_exact and have it working ? To my knowledge which is limited a file handle gets loned. so if thread 10 seeks it'll gonna change location for running thread 1 ?
Mar 03 13:38:57 <Widdershins>	gastus_: it doesn't compile at all because the threads are capturing mutable self
Mar 03 13:39:17 <Widdershins>	that capture by the closure requires self to outlive static
Mar 03 13:39:51 <Widdershins>	and the fact it's mutable means it can't work at all with multiple threads
Mar 03 13:39:57 <Wulf>	gastus_: the threads don't seek the file, and reading is protected by the mutex. So there's only one read at a time.
Mar 03 13:40:50 <Widdershins>	why so many threads then
Mar 03 13:41:32 <Wulf>	Widdershins: for the hashing part.
Mar 03 13:42:02 <Wulf>	maybe I'll need to have one thread do the reading and pass blocks into hasher threads?
Mar 03 13:42:15 <gastus_>	Threads make sense if hashing is slower than loading data from disk which in the future might be the case cause they developed non volatile RAM like SSDs having speed of RAM. When they will be used by majority is a different question.
Mar 03 13:42:17 <Widdershins>	i guess i don't expect one thread's i/o to be that much faster than the hashing part
Mar 03 13:43:14 <Wulf>	I can read about 1.5 GiB from my disk, but a single thread can't hash that fast.
Mar 03 13:43:20 <Wulf>	(per second)
Mar 03 13:43:38 <Widdershins>	regardless the issue is that while you're getting the ids via the arc, you are using `self.file` without any kind of synchronization, and have a plain &mut ref to `self` captured, which must be unique
Mar 03 13:44:26 <Wulf>	any way to tell rust that my file is not mutable, while in fact, it is?
Mar 03 13:44:43 <Widdershins>	i recommend trying to make it so that the information needed for the work done by each thread is encapsulated entirely in a struct which you move deliberately
Mar 03 13:45:36 <gastus_>	Wulf: Why not use English to describe what you want to do using one sentence such as within a file witihn a region read blocks and hash each one within a thread summing up the results ? The question is interesting like if the disk is the bottleneck one thread is enough. Reading in a sequence is the fastest you can do on physical disks unless you have high fragmentation which might be the only case when
Mar 03 13:45:42 <gastus_>	asking OS to find the closest chunk which might not be worth it. Ok let's assume youh ave a RAM based disk so reading is fast and digesting is the bottleneck, then .. we're at what you try to do ?
Mar 03 13:46:06 <Widdershins>	gastus_: read_exact requires a mutable reference to the file
Mar 03 13:46:46 <Widdershins>	it's not about whether the contents of the file on disk are changing; it's about the fs::File object, in memory, having exclusive access by you which makes writes safe
Mar 03 13:47:17 <Widdershins>	but you aren't guaranteeing that only one of those references exists. quite the opposite
Mar 03 13:48:01 <Wulf>	gastus_: For now, I'm trying to create a multi-threaded file hasher. Reads must be sequential for best speed. Hashing must occur in multiple threads because otherwise that's the bottleneck.
Mar 03 13:48:08 <Alexendoo>	It requires &mut access to the thing that implements Read, &File does implement Read so you don't strictly need exclusive access to File since &mut &File works
Mar 03 13:48:35 <Widdershins>	Alexendoo: ah
Mar 03 13:48:39 <Alexendoo>	It may or may not be a bad idea to use
Mar 03 13:48:51 <Widdershins>	i think then that leaves just the lifetime issue then
Mar 03 13:49:18 <Widdershins>	in that this is capturing references and then starting in a thread, which isn't allowed
Mar 03 13:49:26 <Widdershins>	that might have to be an rc
Mar 03 13:50:33 <Widdershins>	https://doc.rust-lang.org/std/thread/fn.spawn.html requires that the closure be 'static
Mar 03 13:54:41 <Alexendoo>	since all the handles are being joined std::thread::scope would be a choice
Mar 03 13:56:25 <gastus_>	@ Wulf after 3 chat gpt iterations you end up with https://dpaste.com/6YTFRSV5C but I am still new to rust. But if you look at such code and move the file reading part up before caling into_par_iter would this just be clean readable code getting the job done ?
Mar 03 13:57:07 <gastus_>	The question I don't know yet wether into_par_iter will consume all items before starting or will start as fast as the items arrive.
Mar 03 13:59:12 <Alexendoo>	That wouldn't compile, but rayon is probably what I would use here. Create a synchronous iterator of chunks and then use rayon to process in parallel
Mar 03 13:59:19 <gastus_>	So typicall such eventually could be done with pipes and back pressure. Eg the thread pool saying 'all busy, don't deliver more items' But not sure what's the right Rust library for that.
Mar 03 14:00:58 <gastus_>	https://medium.com/@polyglot_factotum/rust-concurrency-a-streaming-workflow-served-with-a-side-of-back-pressure-955bdf0266b5 is from 2020 might be an alternative read to get an idea.
Mar 03 14:09:57 <gastus_>	@ Wulf tokio might lead to code looking something like this :  https://dpaste.com/GCPTUAYHD   And now you have abstracted away the multi threading part, you have eventually (unchecked) back pressuring and this all is done by tokio / async code which handles the waiting nicefully for you. Not saying its the perfect solution yet. But gives you some ideas. Now the feeding and receiving results is still
Mar 03 14:10:03 <gastus_>	lacking some abstraction. There might be some .async_map_paralell_iter() whatever ? But you might have the properties you want the main thread reading the bytes, handing the mover to the pool doing teh work and getting back the results.
Mar 03 14:11:01 <dav1d>	can you stop with this chat gpt garbage?
Mar 03 14:12:00 <gastus_>	dav1d: Can yout tell me what's garbage about the idea of using iterator, having bytes, backpressure and using async ? Sry truly believed it would be a nice way to turn the task into readable code.
Mar 03 14:12:49 <dav1d>	gastus_, the code is garbage, just look at `receive_chunk`. If you want to help someone but not write the code, then describe the algorithm or behaviour, don't add garbage code to it that will confuse and mislead readers.
Mar 03 14:14:05 <Alexendoo>	also tokio to read one file is kinda pointless
Mar 03 14:15:13 <Wulf>	gastus_: there are lots of subtle bugs. Usually the last block is smaller than the block size. My code handled this, the GPT one doesn't. And I need to use the block hashes as they are computed (and in order). The GPT code collects them all, which means e.g. unbounded memory usage.
Mar 03 14:16:02 *	dav1d thinks copy pasting from chat gpt should be a bannable offense 
Mar 03 14:16:03 <Wulf>	Alexendoo: I will probably use tokio. The finished program will be a client/server model where one server can handle multiple clients and files.
Mar 03 14:17:01 <dav1d>	Wulf, you might still want to consider a separate thread (pool) for CPU bound work. Also file io just uses a blocking thread behind the scenes anyways
Mar 03 14:17:41 <gastus_>	Let me try showing pseudo code :-) which I think is very readable cause it talks about what it does: https://dpaste.com/6DFNHMB97 Whether it can be done with what version of Tokio or similar I lack experience yet.
Mar 03 14:18:48 <gastus_>	https://dpaste.com/5473YVRCA (indentation fixed sry)
Mar 03 14:19:58 <gastus_>	line 14 should be using do_work
Mar 03 14:24:21 <gastus_>	Wulf: That's why I said there is some abstraction missing on top. Like passing the idx for ordering or such. And the last pseudo code would allow to put a buffering stream component in between in case IO turns busy you have like 10 blocks in memory to continue processing cause CPU /calculation might be the bottlenick. Could all be overkill though.
Mar 03 14:26:06 <Wulf>	Learning rust is hard. I'll go for a walk.  Thanks so far!
Mar 03 14:53:50 <gastus_>	@Wulf https://users.rust-lang.org/t/does-async-have-a-notion-of-priority/81199 mind the link to "Reducing tail latencies with automatic cooperative task yielding". Wanting to say if you run multiple 'hashing' reqeusts the rest might suffer (?). I've been wondering about prioritizing about JS Promises / networking / Quic etc, too. According to changelog (nov 27 2023) nothing has been added (?).
**** BEGIN LOGGING AT Mon Mar  4 04:37:44 2024

Mar 04 04:37:43 *	Now talking on ##rust
Mar 04 04:37:43 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 04 04:37:43 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** BEGIN LOGGING AT Mon Mar  4 04:39:41 2024

Mar 04 04:39:41 *	Now talking on ##rust
Mar 04 04:39:41 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 04 04:39:41 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Mar 04 08:35:03 <gastus>	Wulf:     let (tx, mut rx) = mpsc::channel::<u8>(10);
Mar 04 08:35:27 <gastus>	Is all you need you can send async/sync to it and it keeps eg 10 items thus once you filled those 10 will apply backpressure.
Mar 04 11:02:18 <neiluj>	Hiu! Getting the following error for a call to a derive macro: https://bpa.st/AFFA. I'm hesitating between implementing the CanonicalSer/Deser trait for the entire struct or only the E::G1Prepared types, though they would then have to be wrapped in a new struct
Mar 04 11:02:59 <neiluj>	which option (or other option) you think is best in terms of easy to write?
Mar 04 11:20:04 <neiluj>	went with a new struct with serializable types only and a function to map the previous struct to the serializable one
Mar 04 11:20:13 <neiluj>	let's keep it simple
Mar 04 11:48:24 <elichai2>	Is it possible to tell `#[tracing::instrument]` to use the Display impl for the arguments?
Mar 04 11:52:23 <dav1d>	elichai2, yes, by using %field
Mar 04 11:52:34 <dav1d>	elichai2, https://docs.rs/tracing/latest/tracing/#recording-fields
Mar 04 11:53:05 <jbg>	yes, verbosely
Mar 04 11:53:15 <jbg>	skip_all and then %field for each field
Mar 04 11:53:19 <elichai2>	got it, i'll skip all and manually add back
Mar 04 14:08:14 <nlaerema>	hello
Mar 04 14:09:55 <bertptrs>	o/
Mar 04 15:13:52 <alip>	> warning: dropping unsupported crate type `cdylib` for target `x86_64-unknown-linux-musl`
Mar 04 15:14:07 <alip>	can i somehow force it to build a dylib or is there just no way?
Mar 04 15:14:21 <alip>	i mean without installing a glibc toolchain
Mar 04 15:15:30 <alip>	and/or is there a way to detect this so i can skip tests that dep on the cdylib?
Mar 04 15:22:40 <alip>	ah nvm figured it out, building with distro rustc works
Mar 04 15:41:10 <jbg>	alpine has a patch that changes the musl target
Mar 04 15:41:21 <jbg>	so if your distro is alpine or alpine based, that's why it works
Mar 04 15:42:11 <jbg>	rust made the questionable early decision to make -unknown-linux-musl targets default to enabling the crt-static target feature, i think because they were focused on the use-case of making 0-dependency binaries
Mar 04 15:42:30 <jbg>	you can probably build with standard rustc if you disable the crt-static target feature
Mar 04 16:06:26 <alip>	thanks for the explanation
Mar 04 16:37:57 <dav1d>	Can I have iter.any or iter.all which separately tells me wether the iterator was empty?
Mar 04 16:38:10 <dav1d>	Cause I need the exact opposite behaviour of any/all
Mar 04 16:38:20 <dav1d>	all but if it's empty return false
Mar 04 16:40:57 <phy1729>	Just curious why do you need that? all of nothing being true preserves monoidish properties
Mar 04 16:43:40 <dav1d>	phy1729, I have an iterator of matching limits, I want to drop a certain item if all of the limits are "passive" (just a bool), but I need to keep it if there is no matching limit
Mar 04 16:44:59 <dav1d>	I could do peekable and then check for empty I guess
Mar 04 16:45:03 <dav1d>	but not sure if that's better
Mar 04 17:03:52 <bertptrs>	any does return false if the iterator is empty
Mar 04 17:04:35 <bertptrs>	since existance on the empty set is always false, and universality on the empty set is always true
Mar 04 17:31:34 <Ademan>	is there a good way to make an iterator own some data? I produce some owned data down in a flat_map(), something like `flat_map(|x| { let y = calculate(x); z.thing_that_produces_another_iterator(&y) }` and it needs to live as long as the iterator itself (or at least, the relevant parts of the flat mat?)
Mar 04 17:33:34 <phy1729>	Maybe turn it into an Iterator of Iterators and then flatten?
Mar 04 17:38:26 <bertptrs>	Ademan: add a move to that closure?
Mar 04 17:45:11 <Ademan>	isn't y already owned by that closure since it's scoped to it? hrm, this is pretty difficult I think, I couldn't even make like a `struct OwningIterator<T, U, I: Iterator<Item=U> { owned: T, iter: I }` to bundle them together since it would be self referential
Mar 04 18:22:49 <bertptrs>	ah I misread something, you construct y and then borrow it for your inner iterator
Mar 04 18:25:01 <polychromata{J}>	dav1d: you can fold() it
Mar 04 18:39:57 <dav1d>	bertptrs, any is the same as all, if I use any I need to invert the condition, which means I need to invert the result, same problem
Mar 04 18:40:03 <dav1d>	polychromata{J}, try_fold right?
Mar 04 18:40:13 <dav1d>	I want to short circuit
Mar 04 18:40:29 <polychromata{J}>	ah, yeah, you're right.
Mar 04 18:41:19 <dav1d>	My "solution" https://p.dav1d.de/8Yl.rs
Mar 04 18:41:27 <dav1d>	I have yet to test it (keep getting side tracked)
Mar 04 18:42:37 <bertptrs>	Oh I have an even worse idea, thanks for reminding me of filter()
Mar 04 18:43:19 <dav1d>	lol
Mar 04 18:43:31 *	dav1d waits in anticipation
Mar 04 18:47:04 <bertptrs>	https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=057e53c5c9ba1e698b21b0b94bd47ec5
Mar 04 18:47:27 <bertptrs>	using find_map instead of find so the closure can take by value
Mar 04 18:48:05 <dav1d>	lol
Mar 04 18:48:24 <dav1d>	I might just use that and confuse everyone, love it
Mar 04 18:49:40 <bertptrs>	It works and it short circuits, those were my requirements
Mar 04 18:53:55 <dav1d>	yeah, it's a pretty smart solution, I did think of using find() but discarded it because I never thought about inverting the condition and then checking for none
Mar 04 18:54:34 <polychromata{J}>	evalr: use std::ops::ControlFlow::{self, *}; fn check<I: Iterator<Item = u128>>(iter: I) -> Option<ControlFlow<bool>> { iter.try_fold(None, |o, n| if n < 159936340279099635845489784282289365899 { Some(Continue(true)) } else { Some(Break(false)) }) }
Mar 04 18:54:35 -evalr/##rust-	polychromata{J}: error[E0271]: type mismatch resolving `<Option<ControlFlow<bool, ...
Mar 04 18:54:36 -evalr/##rust-	polychromata{J}: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=6d4fe0ec41b0c4d5313de7b59fd7ef57
Mar 04 18:58:38 <dav1d>	`159936340279099635845489784282289365899` that's a big number :D
Mar 04 18:59:57 <int-e>	close to 2^127 hmm and not prime.
Mar 04 19:12:09 <polychromata{J}>	evalr: use std::ops::ControlFlow::{self, *}; fn check<I: Iterator<Item = u128>>(iter: I) -> Option<bool> { iter.try_fold(None, |o, n| if n < 159936340279099635845489784282289365899 { Continue(Some(true)) } else { Break(Some(false)) }) } check([].into_iter())
Mar 04 19:12:11 -evalr/##rust-	polychromata{J}: error[E0308]: mismatched types ...
Mar 04 19:12:12 -evalr/##rust-	polychromata{J}: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=cbf42709499938b8cd2878de88126743
Mar 04 19:13:15 <polychromata{J}>	ah, yeah, and then you have to flatten the `ControlFlow<T, T>`
Mar 04 19:14:24 <dav1d>	int-e, do you have all primes up to 2^127 in your head? :p
Mar 04 19:14:44 <polychromata{J}>	evalr: use std::ops::ControlFlow::*; fn check<I: Iterator<Item = u128>>(iter: I) -> Option<bool> { let short_circuit = iter.try_fold(None, |o, n| if n < 159936340279099635845489784282289365899 { Continue(Some(true)) } else { Break(Some(false)) }); match short_circuit { Continue(value) | Break(value) => value } } check([].into_iter())
Mar 04 19:14:46 -evalr/##rust-	polychromata{J}: error[E0596]: cannot borrow `iter` as mutable, as it is not decl ...
Mar 04 19:14:47 -evalr/##rust-	polychromata{J}: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=a4520d439000162fedf13b8f27c3bcc9
Mar 04 19:14:53 <polychromata{J}>	for Celestia's sake
Mar 04 19:14:59 <bertptrs>	I don't know about them but factor is in coreutils
Mar 04 19:15:33 <polychromata{J}>	evalr: use std::ops::ControlFlow::*; fn check<I: Iterator<Item = u128>>(mut iter: I) -> Option<bool> { let short_circuit = iter.try_fold(None, |_, n| if n < 159936340279099635845489784282289365899 { Continue(Some(true)) } else { Break(Some(false)) }); match short_circuit { Continue(value) | Break(value) => value } } check([].into_iter())
Mar 04 19:15:35 -evalr/##rust-	polychromata{J}: None
Mar 04 19:15:37 <polychromata{J}>	there
Mar 04 19:15:46 <dav1d>	bertptrs, :o that's neat!
Mar 04 19:16:38 <int-e>	Hmm `factor` used to be limited to 64 bits or so, so I trained myself to use pari/gp instead.
Mar 04 19:17:16 <int-e>	(which has a factor() function)
Mar 04 19:17:26 <dav1d>	polychromata{J}, I appreciate the solution but if that's not hidden away in a dusty module it's quite ugly :p
Mar 04 19:17:46 <bertptrs>	I used to use it for programming contests and those rarely need primes larger than that
Mar 04 19:18:27 <polychromata{J}>	dav1d: it would be a lot nicer if there was a ControlFlow::merge(), yeah c.c
Mar 04 19:18:41 <polychromata{J}>	huh, Result doesn't have such a method either
Mar 04 19:18:53 <polychromata{J}>	though you can at least do `.unwrap_or_else(identity)`
Mar 04 19:19:23 *	polychromata{J} would probably just write an extension providing merge()
Mar 04 19:19:27 <polychromata{J}>	(bikeshed the name)
Mar 04 19:20:07 <polychromata{J}>	…or you could package the whole thing up into an extension on Iterator providing maybe_any() and maybe_all() :P
Mar 04 19:20:18 <polychromata{J}>	since that's what you really want, after all
Mar 04 19:22:39 <dav1d>	actually surprised there isnt anything in Itertools 🤔
Mar 04 19:23:16 <dav1d>	I guess find_or_first would simplify bertptr_s' solution a bit
Mar 04 19:25:21 <polychromata{J}>	find_or_first() wouldn't distinguish the empty case though
Mar 04 19:26:34 <dav1d>	polychromata{J}, on empty it would return None right?
Mar 04 19:26:46 <dav1d>	otherwise it always returns an element
Mar 04 19:26:56 <dav1d>	actually maybe doesn't even make it easier
Mar 04 19:26:57 <polychromata{J}>	oh right
Mar 04 19:27:05 <polychromata{J}>	it doesn't distinguish the /other two/ cases from each other.
Mar 04 19:28:26 <polychromata{J}>	wow itertools sure has a lot of methods
Mar 04 19:28:31 <polychromata{J}>	this is more than i remember, too
Mar 04 19:34:12 <dav1d>	yeah, e.g. I dont remember ever seeing the position_min/max/... ones
Mar 04 19:34:38 <dav1d>	nvm they exist since at least 0.9
Mar 04 20:24:25 <edgimar>	What is the best practice related to specifying a consistent version of a crate for use across a cargo workspace.  I have a workspace where one of the crates has a cdylib target that is a facade for functions in several of the other crates.  Is there a good way to ensure that when there is more than one crate that shares the same dependency, the dependencies use the same version?
Mar 04 20:26:20 <polychromata{J}>	cargo tries to do that automatically. but sometimes crates in the dependency tree depend on incompatible versions of the same crate, and those of course can't be unified
Mar 04 20:26:39 <bertptrs>	there are workspace dependencies too, where every crate in the workspace gets a certain dependency
Mar 04 20:26:45 <dav1d>	edgimar, if the versions are semver compatible then they will use the same version, if they aren't then I can't think of anything better than checking the Cargo.lock for duplicates or using cargo tree
Mar 04 20:27:20 <bertptrs>	https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#inheriting-a-dependency-from-a-workspace
Mar 04 20:31:59 <edgimar>	bertptrs: thanks, that looks promising.  Maybe unrelated, but I'm trying to diagnose a strange error that just started happening when trying to build, but I can't determine what change would be repsonsible for it:  there are several error messages "cannot find macro println in this scope" for a crate I'm depending on (rstar) - I'm not getting any traceback, besides the line in the rstar code with
Mar 04 20:32:01 <edgimar>	the println! - wasn't seeing these before, so I'm confused about what I might have changed in my code that would cause that error to occur.
Mar 04 20:32:56 <bertptrs>	edgimar: are you by chance doing a no_std build on a crate that doesn't support it
Mar 04 20:36:09 <edgimar>	That would have required changing something in a Cargo.toml file I assume?  I am not building any differently than before.  I did add an nalgebra = "*" dependency in one of my crates where rstar was already a dependency - hm. maybe a clue?
**** BEGIN LOGGING AT Tue Mar  5 07:39:52 2024

Mar 05 07:39:50 *	Now talking on ##rust
Mar 05 07:39:50 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 05 07:39:50 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Mar 05 08:15:13 <daddy>	Oh, bindgen enables runtime as a default feature, and *insert every sys crate in my stack* uses bindgen with default features
Mar 05 08:40:25 <daddy>	Is there a way I can build `build.rs` files with a set of RUSTFLAGS that are separate from RUSTFLAGS used on non-build.rs ?
Mar 05 09:26:06 <Arnavion>	Yes, by not using RUSTFLAGS. Use target.rustflags in .cargo/config.toml instead
Mar 05 09:35:35 <daddy>	target.<cfg>.rustflags ? what would I use for `cfg()` ?
Mar 05 09:36:22 <daddy>	I don't think <triple> gives me any way to specify build.
Mar 05 09:41:09 <daddy>	I'm building on the same system I'll be running it on so I can't specify different triples.
Mar 05 12:27:33 <elichai2>	is there a way with tracing::instrument to bypass rust's fmt machinery and use something faster?
Mar 05 12:32:49 <osse>	elichai2: to log the files, e.g. args to functions you meaǹ?
Mar 05 12:33:36 <elichai2>	osse: yes, ideally with things like `#[instrument(field(...))]` and `tracing::debug!(...)`
Mar 05 12:33:47 <elichai2>	but the debug/info etc macros I can replace with my own
Mar 05 12:34:04 <osse>	elichai2: if it's your own type i suppose you can implement the Value trait yourself
Mar 05 12:34:47 <elichai2>	osse it is Sealed though: https://docs.rs/tracing/latest/tracing/trait.Value.html
Mar 05 12:35:41 <osse>	huh
Mar 05 12:35:46 <osse>	I don't know, then
Mar 05 12:35:55 <osse>	the Visit trait isn't, but I don't know if that helps
Mar 05 12:37:00 <elichai2>	but the visitor will still call `record_debug`
Mar 05 12:37:14 <elichai2>	maybe if I directly use the `valuable` crate I could do it
Mar 05 12:40:17 <osse>	yeah but it's up to use to implement it
Mar 05 12:40:34 <osse>	I figured you could avoid the implementation of Debug inside it somehow
Mar 05 12:52:56 <dav1d>	Ignoring endianness issues etc. Am I even allowed to transmute &[f64] to &[u8]?
Mar 05 12:53:42 <dav1d>	I guess slice length would break, so from_raw_parts 🤔
Mar 05 12:57:21 <neiluj>	Hey! Trying to implement the Serialize/Deserialize trait for a type implementing the following trait: https://docs.rs/ark-serialize/latest/ark_serialize/trait.CanonicalSerialize.html
Mar 05 12:57:34 <elichai2>	dav1d: no, the length would not match
Mar 05 12:57:40 <neiluj>	not sure how to turn the writer into a serializer
Mar 05 12:57:50 <elichai2>	you need to deconstruct the slice, multiply the length, and construct a new slice
Mar 05 12:58:25 <dav1d>	elichai2, yeah, see my second sentence. looking at bytemuck, it should be safe https://docs.rs/bytemuck/latest/src/bytemuck/internal.rs.html#353-372
Mar 05 12:58:37 <dav1d>	but probably should just use bytemuck in the first place
Mar 05 12:58:41 <elichai2>	yep, f64 has no padding
Mar 05 12:58:49 <elichai2>	so if it's initialized it's safe to read as u8
Mar 05 12:59:05 <elichai2>	all primitives except `bool` don't have paddings
Mar 05 12:59:15 <dav1d>	and alignment is fine, since u8. The other way probably is not fine
Mar 05 12:59:23 <dav1d>	right?
Mar 05 12:59:32 <dav1d>	&[u8] -> &[f64]
Mar 05 13:00:17 <elichai2>	yep
Mar 05 13:00:26 <elichai2>	the other way you need to check and offset alignment
Mar 05 13:01:00 <dav1d>	Thanks! Always good to have a second opinion on this
Mar 05 13:02:21 <elichai2>	always run your unsafe code through miri ;)
Mar 05 16:48:56 <jess>	if i'm casting from a u64 and a u32 and would like it to overflow, is there a more correct way to do it that tells clippy that overflow is desired?
Mar 05 16:49:03 <jess>	from a u64 to a u32*
Mar 05 16:51:01 <jess>	for context this is for using a u64 siphash as an array index usize for a bloom filter, so overflow is not really a problem for me. it'll get modulo too regardless
Mar 05 16:51:35 <bertptrs>	you can #[allow(clippy::cast_possible_wrap)] but by default Clippy already allows those
Mar 05 16:51:50 <jess>	i'm on clippy pedantic
Mar 05 16:52:27 <bertptrs>	or #[allow(clippy::cast_possible_truncation)] which is more correct imo
Mar 05 16:52:35 <jess>	just thought there might be some magic function or trait that is "cast this with wrapping please" that would satisfy clippy
Mar 05 16:55:45 <danieldg>	maybe clippy could learn that (some_u64 & 0xFFFF_FFFF) as u32 can't truncate?
Mar 05 16:56:41 <jess>	^ no implementation for `u64 & u32`
Mar 05 16:56:42 <danieldg>	not sure if doing constant-propagation to make that rule nicer is beyond clippy or not
Mar 05 16:56:43 <jess>	boo sadface
Mar 05 16:57:01 <danieldg>	well yes, you have to upcast the mask
Mar 05 16:57:11 <danieldg>	or, you know, literals
Mar 05 16:57:30 <bertptrs>	you're missing the point, & could automatically downcast since the result should be equivalent
Mar 05 16:57:59 <bertptrs>	uX & u32 fits in an u32 regardless of X
Mar 05 16:58:21 <bertptrs>	but automatic conversions are bad™ so I'm happy it doesn't work lioke that
Mar 05 16:58:21 <jess>	yes, indeed
Mar 05 16:58:23 <danieldg>	right.  The bitwise and/or ops could easily be implemented for arbitrary sizes
Mar 05 16:58:29 <jess>	but the compiler doesnt seem to know it
Mar 05 16:59:11 <danieldg>	I think libcore could impl it
Mar 05 16:59:25 <danieldg>	but it'd probably break things if you do it now
Mar 05 16:59:26 <jess>	i can apparently right shift a u64 to a u32
Mar 05 16:59:37 <danieldg>	I don't think you can
Mar 05 16:59:44 <bertptrs>	you can shift any int with any other int for some reason
Mar 05 17:00:01 <danieldg>	isn't it only u32 and maybe u8 on the rhs of the shift?
Mar 05 17:00:08 <danieldg>	or maybe usize?
Mar 05 17:00:25 <jess>	oh, im reading the impl wrong
Mar 05 17:00:41 <bertptrs>	danieldg: no pretty much everything https://doc.rust-lang.org/std/primitive.u128.html#impl-Shl%3C%26i128%3E-for-%26u128
Mar 05 17:00:49 <danieldg>	huh
Mar 05 17:02:00 <bertptrs>	there's no reason it works like this, but there is also no reason it shouldn't work so they just did it
Mar 05 17:02:20 <danieldg>	I guess it's not symmetric, so there's no gain from trying to propagate types through it
Mar 05 17:03:23 <danieldg>	for | you could have takes_u64(x | y) and it'd end up inferring both x and y are u64 now, but if widening or happens then y could easily get inferred to be i32
Mar 05 17:03:29 <danieldg>	or maybe u32
Mar 05 17:16:25 <gastus_>	I want to store pointers to vecs which I eventually want to remove (set to NULL). Now I could be using Option but will take more memory. Would it make sense to have special Option<> type for pointers if they are NULL meaning "no value" so not having to use an enum ?
Mar 05 17:17:04 <j`ey>	gastus_: do you mean pointers or references?
Mar 05 17:17:10 <j`ey>	*const T or &T?
Mar 05 17:17:56 <danieldg>	gastus_: std::ptr::NonNull
Mar 05 17:18:18 <danieldg>	references already do it
Mar 05 17:18:54 <danieldg>	Option<NonNull> or Option<&T> are guaranteed to fit in a usize
Mar 05 17:18:59 <bertptrs>	danieldg: Option<&T> and *const T have the same size
Mar 05 17:19:45 <rendar>	i always wondered something, if i have `fn myfn(&self) {   for i in &self.data { .. }  .. }`  <- why here we have to use &self.data, if self is already of &Self type ?
Mar 05 17:19:49 <j`ey>	but not Option<*const T>
Mar 05 17:20:06 <danieldg>	rendar: self is the object
Mar 05 17:20:08 <bertptrs>	rendar: because otherwise self.data would attempt to move out of self, which it can't
Mar 05 17:20:34 <bertptrs>	and if it can, you might not want it to
Mar 05 17:21:12 <rendar>	bertptrs, ok, right, so it's just a further notation to remark the user: look you're traversing and not moving out
Mar 05 17:21:35 <rendar>	it would be very messy code in the other way, indeed
Mar 05 17:22:05 <bertptrs>	well you could move data out of self and then traverse it, which does something different, but unless data is Copy you can't
Mar 05 17:22:46 <danieldg>	"let Self { data, .. } = self; for i in data { .. }" does the same thing as &self.data
Mar 05 17:22:58 <rendar>	oh right
**** BEGIN LOGGING AT Tue Mar  5 18:13:43 2024

Mar 05 18:13:42 *	Now talking on ##rust
Mar 05 18:13:42 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 05 18:13:42 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Mar 05 18:38:03 <n1>	 is here a way how to tell compiler that a method should be included only for "lib" use? i mean the #[cfg...
Mar 05 18:38:36 <segfaultfizzbuzz>	suggestions for a rust library for transforming markdown into an html form, or for a markdown parser which i could easily extend (as a bad programmer) to have form elements?
Mar 05 18:39:40 <j`ey>	n1: what do you mean for 'lib' use?
Mar 05 18:39:57 <j`ey>	if it's part of a non-binary crate, it's always for a library?
Mar 05 18:40:38 <n1>	j`ey: i use my rust app as a dependency in another project - i suppose it turns into a "lib" mode (dunno how to phrase it better) when tne intrypoint in lib.rs instead of main.rs
Mar 05 18:41:28 <j`ey>	n1: yes
Mar 05 18:42:12 <n1>	the thing is this... i have a method that is not used in binary mode (thus i get unused warning) but it's used in lib mode
Mar 05 18:42:17 <n1>	does if make sense j`ey ?
Mar 05 18:42:21 <n1>	it*
Mar 05 18:42:33 <j`ey>	n1: what file is that method in?
Mar 05 18:43:27 <n1>	src/config.rs
Mar 05 18:43:56 <j`ey>	n1: and you have mod config in src/lib.rs?
Mar 05 18:44:39 <n1>	yes
Mar 05 18:44:49 <n1>	pub mod config; to be exact
Mar 05 18:44:59 <n1>	re-export
Mar 05 18:45:16 <danieldg>	n1: you should *not* have 'mod config' in main.rs then
Mar 05 18:45:30 <danieldg>	you should 'use yourcrate::config' in main.rs
Mar 05 18:45:55 <JordiGH>	Hey, any of you use Prisma? What are your impressions? I'm trying to find a fun Rust project to work on that people enjoy using and care about. Prisma came to mind, but I'm not sure if it's loved or not.
Mar 05 18:46:09 <n1>	danieldg: i need that line there because i use that file in both modes - only one particular method is not used in binary mode
Mar 05 18:47:13 <j`ey>	n1: no dont have mod config in main.rs
Mar 05 18:47:22 <j`ey>	n1: you should 'use' the library crate from the binary one
Mar 05 18:49:54 <n1>	im lost ... i removed the "mod config;" line from my main.rs - now im getting tons of errors of "unresolbed import"
Mar 05 18:50:15 <danieldg>	n1: remove all 'mod' lines in main.rs
Mar 05 18:50:22 <j`ey>	'use <yourcratename>::config;'
Mar 05 18:50:23 <danieldg>	unless the module is only for the binary
Mar 05 18:52:26 <n1>	j`ey: done - but now im getting another couple of errors that weren't there before
Mar 05 18:52:55 <j`ey>	tell us, and we can help fix it
Mar 05 18:52:58 <j`ey>	otherwise, we cant :P
Mar 05 18:55:21 <n1>	sure ... but that seems like a random error of "cannot fined a method from a trait" or value of this type cannot be build from that type
Mar 05 18:55:34 <n1>	looks like someone just f'ked my code :)
Mar 05 18:56:01 <danieldg>	n1: if you are still duplicating 'mod' lines, then you'll get that
Mar 05 18:56:18 <danieldg>	because you will define two different types with the same name
Mar 05 18:56:29 <n1>	so i guess the real question is what the "substitude 'mod config' with 'use <cratename>::config;'" really does
Mar 05 18:57:05 <danieldg>	it removes the duplication
Mar 05 18:57:37 <n1>	https://dpaste.com/B6LW487LG head of my main file before the errors
Mar 05 18:57:56 <n1>	once i comment out line 3 and uncommet line 10 i get the errors
Mar 05 18:58:14 <danieldg>	... read what I said
Mar 05 18:58:19 <danieldg>	17:50:15 < danieldg> n1: remove all 'mod' lines in main.rs
Mar 05 18:58:45 <n1>	just like that? not needed anymore?
Mar 05 18:59:01 <danieldg>	you may need to replace them with 'use' lines
Mar 05 18:59:31 <n1>	okay i didnt get that
Mar 05 18:59:33 <n1>	will try
Mar 05 19:01:16 <n1>	https://imgur.com/a/1EZ6H4c
Mar 05 19:01:26 <n1>	even worse lol
Mar 05 19:02:03 <danieldg>	no, you now have a TODO list for fixing your lib
Mar 05 19:02:15 <danieldg>	make things you need public, or remove the use if you don't need it
**** BEGIN LOGGING AT Tue Mar  5 19:05:32 2024

Mar 05 19:05:30 *	Now talking on ##rust
Mar 05 19:05:30 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 05 19:05:30 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Mar 05 19:07:14 <n1>	that sounds like "to make that one particular method hidden from bin-mode you have to rewrite all the imports"
Mar 05 19:07:20 <n1>	thats nuts to me
Mar 05 19:08:06 <danieldg>	the problem is that the way you were doing it was wrong
Mar 05 19:08:32 <danieldg>	it worked, but you had two copies of your code
Mar 05 19:08:39 <n1>	what exactly was wrong? i was acting based on tutorials where every part of my app needs to be "mod"ed
Mar 05 19:09:01 <n1>	>two copies of your code - what do you mean exactly?
Mar 05 19:09:04 <danieldg>	that's true if you only have a main.rs
Mar 05 19:09:08 <danieldg>	or only a lib.rs
Mar 05 19:09:23 <danieldg>	having both means you're making two crates, one that depends on the other
Mar 05 19:10:13 <spb>	you put all of your library code into the library crate. you make your binary crate depend on the library crate. things in the library that aren't used by the binary are not dead code because they're exported from the library
Mar 05 19:10:19 <spb>	it's quite simple
Mar 05 19:12:02 <n1>	okay so instead of one monolith i need to separate (it is but probably imported wrongly) my code - right?
Mar 05 19:13:09 <spb>	the best answer depends on what you're actually doing and the specifics of your particular design
Mar 05 19:14:49 <n1>	i guess i will just go with that one warning ig
Mar 05 19:15:26 <n1>	but ... im curious whats the difference between mod and use thing that you suggested
Mar 05 19:16:03 <danieldg>	the tutorial should tell you about them
Mar 05 19:16:08 <danieldg>	or the docs do
Mar 05 19:16:09 <n1>	my guess it's that moding hard-"imports" all the stuff but on the other hand the "use" really imports what i need
Mar 05 19:16:20 <spb>	your library and your binary are different crates. the binary implicitly depends upon the library. by writing 'mod' in both, you are including the code of those files into both crates and duplicating it
Mar 05 19:16:36 <spb>	by writing 'use' in the binary, you just refer to the version that was already built as part of the library
Mar 05 19:17:53 <n1>	makes sense
Mar 05 19:18:10 <n1>	do i need to ad some stuff to cargo too? or just update my "imports"?
Mar 05 19:18:51 <spb>	first you need to stop using "import" to refer to something that is not importing
Mar 05 19:19:28 <spb>	and no, you do not need to change anything in cargo because, as i said above, the binary crates within a project implicitly depend on the library crate
Mar 05 19:20:04 <n1>	so once a lib.rs exists the binary is suddenly dependend on the lib - right?
Mar 05 19:20:33 <spb>	yes
Mar 05 19:21:32 <n1>	maybe i got enlighted - i try it once again - the thing is i need to move all my mods to lib.rs and then use what i actually need in my main.rs - right?
Mar 05 19:21:49 <n1>	so basically my lib is the library and main comes in and says what it needs
Mar 05 19:22:10 <n1>	and the libs knows all the "books" thanks to "mod"s
Mar 05 19:22:15 <n1>	am i right?
Mar 05 19:23:33 <spb>	any code that is a part of the library should be included only in the library, i.e. a 'mod' declaration for it should appear only in lib.rs or something included from lib.rs
Mar 05 19:23:46 <n1>	right
Mar 05 19:23:48 <spb>	any code that is a part of *only* the binary, you can declare the 'mod' in main.rs
Mar 05 19:24:06 <spb>	and any code which is a part of the library and is used by the binary, you 'use' in the binary code
Mar 05 19:25:11 <spb>	note that if you have multiple modules in play, then using src/main.rs and src/lib.rs will be very confusing because you can't tell from just the folder structure whether a given module is in the lib or the bin
Mar 05 19:25:46 <n1>	the code is 99% used in binary ... actually it was 100% as long as the whole app was a cli app - now i did add a few stuff so i can use the app as a dependency and use the functionality programatically instead of from CLI - so thats why i did add a few methods which are use in "dependecy" mode only
Mar 05 19:26:47 <spb>	if you want to make the code usable as a library, then you need to go all in on the idea and make your binary just be another consumer of that library
Mar 05 19:27:11 <n1>	i see
Mar 05 19:27:16 <n1>	damn it :)
Mar 05 19:27:25 <n1>	thx for your time spb
**** BEGIN LOGGING AT Tue Mar  5 20:41:19 2024

Mar 05 20:41:19 *	Now talking on ##rust
Mar 05 20:41:19 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 05 20:41:19 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** BEGIN LOGGING AT Tue Mar  5 22:33:04 2024

Mar 05 22:33:03 *	Now talking on ##rust
Mar 05 22:33:03 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 05 22:33:03 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Mar 05 22:36:51 <nullie>	What can I do here to pass store correctly: https://gist.github.com/nullie/d5f02dcd8ae84b1b94a128ee66155984
Mar 05 23:00:51 <polychromata{J}>	nullie: not familiar with wasm, but it looks like binding is keeping the borrow of store around. Since you seem to need binding throughout, you'll have to find a way to get it to not keep the borrow past the call to exports(), or else use shared ownership of store.
Mar 05 23:03:18 <chairs>	maybe you don't need to use the same `store` everywhere? (I'm also not familiar with wasm so don't know)
Mar 05 23:06:03 <nullie>	no, it panics if you pass other store
Mar 05 23:08:17 <nullie>	I don't get why does it need store for those calls
Mar 05 23:09:19 <chairs>	another guess: maybe you're supposed to save the output of `.func()` and only use it later after `binding` has gone out of scope
Mar 05 23:10:21 <nullie>	yeah, looks like .func() result is copiable
Mar 05 23:13:32 <chairs>	s/gone out of scope/can be dropped/ # I don't think you need to play explicit scoping games here, but doing so might help with understanding the issue as usual with lifetimes
Mar 05 23:14:46 <nullie>	yeah, I have to drop binding before I can use store again
**** BEGIN LOGGING AT Wed Mar  6 01:51:38 2024

Mar 06 01:51:37 *	Now talking on ##rust
Mar 06 01:51:37 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 06 01:51:37 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Mar 06 01:59:05 <Widdershins>	danieldg: I'm curious what makes Cheri pointers and size ints different widths
Mar 06 02:00:08 <danieldg>	cheri pointers are 128 bits; they store validity information in addition to the usual 64-bit start position
Mar 06 02:02:21 <danieldg>	so technically you could just declare usize to be u128, but that's really inefficient as the maximum allocation is still well below u64::MAX
Mar 06 02:05:28 <Widdershins>	oh man it's architecturally capability-based?
Mar 06 02:32:43 <polychromata{J}>	danieldg: why so? why not just `size.next_multiple_of(align) * len`?
Mar 06 02:32:54 <polychromata{J}>	(. You broke `slice::from_ref()`.)
Mar 06 02:33:02 <polychromata{J}>	…ahh
Mar 06 02:34:08 <danieldg>	yep
Mar 06 02:34:13 <polychromata{J}>	and you /could/ require padding after every allocation of a T, but at that point `{ size: 5, align: 4 }` is kind op meaningless.
Mar 06 02:34:42 <danieldg>	requiring padding after every allocation is exactly today
Mar 06 02:35:06 <danieldg>	since you can't actually use the padding, if your memcpy could overwrite it
Mar 06 02:35:16 <polychromata{J}>	yep.
Mar 06 02:36:28 <polychromata{J}>	just not worth it to save a few bytes here and there when you have some `struct(u8, u32);`s.
Mar 06 02:36:55 <danieldg>	better support for repr(packed) is about the best we could do
Mar 06 02:37:11 *	polychromata{J} nods.
Mar 06 02:37:47 <polychromata{J}>	That way, the usecases that really want to squeeze bytes out, and are okay trading cycles to get them, can make that decision.
Mar 06 02:38:29 <danieldg>	and with modern cpu and memory speeds, that's true a lot more of the time than you might think
Mar 06 02:39:40 <danieldg>	if your data is >1MB you will likely get a speedup from packing it
Mar 06 02:40:04 <danieldg>	unless you're doing a lot more compute than usual on it
Mar 06 02:57:45 <polychromata{J}>	really? huh.
Mar 06 02:57:55 *	polychromata{J} imagines a PackedVec…
Mar 06 02:58:12 <polychromata{J}>	the iterators would have to be streaming though.
Mar 06 03:00:20 <danieldg>	yes, it makes all your code ugly and doesn't work well if you want atomics or anything like that
Mar 06 03:01:22 <danieldg>	often performance isn't that critical, or you aren't actually saturating the memory bus, or other reasons
Mar 06 04:38:48 <Widdershins>	you can already get the best packing possible other than alignment overhead by just reordering fields (by descending alignment requirement), but if the fields themselves have alignment overhead the waste starts to add up
Mar 06 04:39:27 <danieldg>	yes, and that's pretty common
Mar 06 04:39:40 <Widdershins>	mhm
**** BEGIN LOGGING AT Wed Mar  6 07:16:33 2024

Mar 06 07:16:31 *	Now talking on ##rust
Mar 06 07:16:31 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 06 07:16:31 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Mar 06 08:56:53 <shamelessshill>	Hello, good folks. I have a rather simple but strange question.
Mar 06 08:57:19 <shamelessshill>	So in my project, I have a bunch of crates... and I have a script that bumps up versions.
Mar 06 08:57:58 <osse>	So far so good
Mar 06 08:58:08 <shamelessshill>	So, my question is this - if my script bumps up the version in the Cargo.toml files for each of my crates, it should be fine if the same script bumps up the versions in Cargo.lock as well, yes?
Mar 06 08:58:33 <shamelessshill>	We check in Cargo.lock into version control, and the version update step is done as a separate commit (no dependencies added, etc.)
Mar 06 08:58:54 <shamelessshill>	I thought of running a build and the adding the generated Cargo.lock, but that seems like overkill?
Mar 06 08:59:47 <shamelessshill>	Otherwise right now I observe that the crate versions (my own crates) in the lockfile are falling behind the toml versions because people keep forgetting to check in the lock file (nor should they have to, imho).
Mar 06 09:00:44 <shamelessshill>	and overkill since all the changes are for my own crates (not deps) and only the version string would change to match that in the TOML file... I'm not adding any dependencies during this version bumping step.
Mar 06 09:00:48 <shamelessshill>	Thoughts?
Mar 06 09:01:18 <shamelessshill>	I thought of checksum issues, but we don't track checksums in the lock file for our own crates, do we? Only for external dependencies.
Mar 06 09:01:45 <shamelessshill>	Any other issues that come to mind?
Mar 06 09:08:54 <polychromata{J}>	shamelessshill: simplistic editing of the lockfile sounds like a good way to break things
Mar 06 09:09:33 <polychromata{J}>	do you know what happens if the lockfile specifies a crate with a version that has a dependency, but doesn't say anything about that dependency?
Mar 06 09:09:35 <polychromata{J}>	(I don't.)
Mar 06 09:09:49 <polychromata{J}>	how about `cargo generate-lockfile`?
Mar 06 09:11:03 <shamelessshill>	Hmmm
Mar 06 09:11:23 <polychromata{J}>	actually…isn't the overall thing you're trying to do just `cargo update`?
Mar 06 09:11:49 <shamelessshill>	It is true that right now the script is run as a separate independent "version change only" step, but that __requires__ developer discpline. You're right - I don't like the idea myself.
Mar 06 09:12:12 <shamelessshill>	polychromata{J}: Wouldn't `cargo update` update the dependencies as well?
Mar 06 09:12:21 <shamelessshill>	Even minor/patch versions, I mean.
Mar 06 09:12:29 <bertptrs>	correct, so you don't want that
Mar 06 09:12:31 <shamelessshill>	I think cago generate lockfile looks promising... polychromata{J} ... TIL
Mar 06 09:13:14 <shamelessshill>	bertptrs: Yes, indeed. Let me experiment with generate lockfile and see...
Mar 06 09:14:15 <shamelessshill>	Oops... looks like generate-lockfile also updates
Mar 06 09:14:17 <shamelessshill>	:(
Mar 06 09:18:34 <bertptrs>	so it does, that's annoying
Mar 06 09:18:49 <bertptrs>	I guess you could get awaym with `cargo check` instead of a full build?
Mar 06 09:20:07 <shamelessshill>	Actually, I found something that does appears to work: `cargo update --workspace`
Mar 06 09:20:19 <bertptrs>	that should still update deps if I read the docs?
Mar 06 09:20:24 <shamelessshill>	"--workspace Attempt to update only packages defined in the workspace. Other packages are updated only if they don’t already exist in the lockfile. This option is useful for updating Cargo.lock after you’ve changed version numbers in Cargo.toml.
Mar 06 09:20:28 <shamelessshill>	"
Mar 06 09:20:31 <bertptrs>	ooooh
Mar 06 09:20:32 <shamelessshill>	__Seems__ to work
Mar 06 09:20:33 <bertptrs>	that's brilliant
Mar 06 09:20:39 <shamelessshill>	Let me double-check! :)
Mar 06 09:20:45 <bertptrs>	somewhat misnamed but w/e
Mar 06 09:20:47 <shamelessshill>	bertptrs: Yeah... beautiful indeed!
Mar 06 09:20:59 <shamelessshill>	Yeah, I would never have guessed with that flag name.
Mar 06 09:21:39 <shamelessshill>	Yup... appears to work! So polychromata{J} was right after all. Hehehe.
Mar 06 09:22:13 <polychromata{J}>	…that's a really bad name for that flag.
Mar 06 09:22:18 <polychromata{J}>	Good find though.
Mar 06 09:22:44 <shamelessshill>	Indeed... I only happened to even go to that doc page because the generate-lockfile docs said that `update` had more options... so pure luck!
Mar 06 09:41:33 <gastus>	I want to experiment with non utf-8 fast csv parsing and wanted to create ffi bindings to zsv now bindgen fails to find some definitions. Is it best to manually convert or is bindgen supposed to understand all header files and my configuration is incomplete ?
Mar 06 09:42:25 <bertptrs>	bindgen doesn't understand all header files, and you usually have to make it ignore things
Mar 06 09:59:53 <rendar>	in your experience, do you think exist one crate which abstracts Box<&str> and adds useful traits (e.g. From, etc) ?
Mar 06 10:00:11 <rendar>	i mean, Box<Rc<&str>>
Mar 06 10:01:04 <rendar>	i want to create |1 ptr size poiting to| --->  |ref_count|my string data|
Mar 06 10:01:50 <Mutabah>	`Rc<str>` is a fat pointer to counts and string data
Mar 06 10:01:54 <bertptrs>	That's just Rc<str>
Mar 06 10:02:00 <Mutabah>	although, maybe you'd want a string interning crate
Mar 06 10:03:06 <bertptrs>	nvm, Rc<str> is two pointer size because of the fat pointer
Mar 06 10:09:49 <rendar>	Mutabah, no, i don't want a global state to check
Mar 06 10:10:38 <rendar>	i wish to get only 1 pointer size, like a Box, but also a ref counter for cheap cloning
Mar 06 10:10:50 <rendar>	can i combine the 2 things?
Mar 06 10:11:08 <rendar>	having only 1 heap allocation that contains both ref counter and string data
Mar 06 10:12:30 <bertptrs>	Not right now, there is no nice way to create DSTs from rust
Mar 06 10:13:06 <bertptrs>	your allocation would have to store |len|rc|data|
Mar 06 10:15:29 <rendar>	bertptrs, yes sorry, i meant just that one
Mar 06 10:15:37 <rendar>	rc+len+data
Mar 06 10:15:44 <rendar>	in one unique block, isn't that possible?
Mar 06 10:16:07 <bertptrs>	Creating dsts yourself is annoying but it's not impossible I guess
Mar 06 10:16:17 <bertptrs>	You have to basically do it without language support
Mar 06 10:16:38 <rendar>	what you mean with DSTs?
Mar 06 10:16:45 <bertptrs>	dynamically sized types
Mar 06 10:16:50 <rendar>	i see
Mar 06 10:16:52 <bertptrs>	types that do not have a fixed size\
Mar 06 10:16:54 <bertptrs>	such as str
Mar 06 10:17:38 <bertptrs>	or slices
Mar 06 10:18:00 <rendar>	bertptrs, well, Box<str> is not dinamically sized type, because sizeof(Box<str>) is 8 (1 pointer size), then it allocates N bytes on heap, just like Vec<u8> which is 24 in sizeof, but then it allocates N bytes on heap, am i wrong?
Mar 06 10:18:24 <bertptrs>	wrong, sizeof Box<str> is 16
Mar 06 10:18:35 <bertptrs>	because str is a DST
Mar 06 10:18:35 <rendar>	because of the fat pointer?
Mar 06 10:18:38 <bertptrs>	Correct
Mar 06 10:18:41 <rendar>	yeah
Mar 06 10:18:46 <rendar>	what about Box<&str> ?
Mar 06 10:18:54 <bertptrs>	That one is indeed size 8
Mar 06 10:19:12 <rendar>	indeed, but Box<&str> is a pointer pointing to |len|data..| ?!
Mar 06 10:19:17 <rendar>	or just data?
Mar 06 10:19:54 <rendar>	or is a pointer pointing to |len|ptr_to_data|    which in turn points to |data..| ?
Mar 06 10:19:54 <bertptrs>	Box<&str> is pointing to an &str which is contains a length and a pointer to the data
Mar 06 10:20:12 <rendar>	so with Box<&str> i get 2 heap allocations per string?
Mar 06 10:20:30 <bertptrs>	not necessarily heap allocations (can use a static str after all) but yes two indirections
Mar 06 10:20:45 <rendar>	oh gosh :| i see
Mar 06 10:23:48 <rendar>	now i get the purpose of a crate that tried to fix this problem, and had strings of 2 pointer size
Mar 06 10:26:53 <rendar>	https://crates.io/crates/tendril
Mar 06 10:27:08 <rendar>	that's is! i found it, doesn't this crate does what i need?
Mar 06 10:28:48 <Mutabah>	Maybe it is
Mar 06 10:28:58 <Mutabah>	Depends on why you want those single-pointer strings
Mar 06 10:29:16 <Mutabah>	What you were asking for reminds me of the `RcString` type I have in mrustc (... in C++, but same idea)
Mar 06 10:29:30 <Mutabah>	A pointer to a refcount, length, and then string data
Mar 06 10:31:49 <rendar>	Mutabah, that's simple: consider a very large hasmap with strings as keys, i don't need them to be mutable, still i will spare a lot of memory not having 24 bytes for each string
Mar 06 10:32:02 <rendar>	what is mrust?
Mar 06 10:33:06 <bertptrs>	Mutabah's Rust Compiler
Mar 06 10:35:28 <rendar>	really?
Mar 06 10:40:47 <synapse>	I have a colleague who uses Result<(), ()> instead of bool. in a way, I kinda get why 'return Err(());' is more readable than 'return false;' :P
Mar 06 10:41:05 <Mutabah>	`Result` carries more semantic information than a `bool`
Mar 06 10:41:25 <Mutabah>	is `false` "operation failed" or is it "don't worry about me"?
Mar 06 10:41:36 <synapse>	yeah, it's answering a generic question
Mar 06 10:41:46 <synapse>	whereas Result<(), ()> is always whether some operation went well
Mar 06 10:56:02 <mkoncek1>	and allows ? shortcut
Mar 06 11:00:16 <Affliction>	Caller probably still needs to map_err it into something sane, but yeah, I might start using that pattern
Mar 06 11:00:37 <bertptrs>	nothing matches! can't fix
Mar 06 11:00:45 <Affliction>	true
Mar 06 11:00:45 <bertptrs>	Or just is_ok()
Mar 06 11:29:44 <kpcyrd>	I'd still use anyhow::Result<T>, then provide a simple message for bail!. the few bytes in the binary for a &'static str shouldn't hurt.
Mar 06 11:30:19 <kpcyrd>	I use anyhow::Result<()> quite often
Mar 06 12:00:02 <mkoncek1>	no method named `poll` found for mutable reference `&mut (dyn Future<Output = ()> + 'static)` in the current scope
Mar 06 12:00:29 <mkoncek1>	i have a vector of Box<dyn Future>
Mar 06 12:01:04 <mkoncek1>	also, should i be using PollFn instead?
Mar 06 12:01:14 <dav1d>	Is there a nice way to just take the first item from a &mut [T]?
Mar 06 12:01:58 <dav1d>	`take_first` is of course nightly
Mar 06 12:02:18 <bertptrs>	split_at_mut can kind of do it but it's not perfect
Mar 06 12:02:19 <dav1d>	guess I'll just have to do split_first :(
Mar 06 12:02:28 <bertptrs>	oh split_first too
Mar 06 12:03:52 <dav1d>	aight thanks
Mar 06 12:03:54 <bertptrs>	mkoncek1: is the Future trait in scope? Not sure if it's part of the prelude
Mar 06 12:07:08 <mkoncek1>	oh right, poll is not a member function
Mar 06 12:07:17 <mkoncek1>	fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;
Mar 06 12:07:25 <mkoncek1>	the first arg is not a reference to self
Mar 06 12:25:41 <bertptrs>	No it's a pin, because the requirements for Future are slightly stronger. poll is a member though
Mar 06 12:26:17 <bertptrs>	Members are allowed to take Pin, Arc, Rc, Box, or any combination of them as their self
Mar 06 12:42:01 <mkoncek1>	really? didn't know about that
Mar 06 12:42:23 <Widdershins>	and don't forget native references that counts too
Mar 06 12:42:45 <Widdershins>	altho idk how much you can layer it actually
Mar 06 12:44:19 <Widdershins>	&&self isn't allowed, but self: &Box<Self> is
Mar 06 12:44:41 <Widdershins>	i guess that's 'cause && just decays to &
Mar 06 12:44:42 <spb>	https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=90eec5e4a7a77b0663fd3db944c5a929
Mar 06 12:44:59 <spb>	`a.foo()` doesn't compile in that case
Mar 06 12:45:26 <Widdershins>	ah you can do it then it just doesn't let you implicitly type it like &self
Mar 06 12:46:24 <spb>	i'm not sure in what situation this would be useful, mind
Mar 06 12:46:40 <Widdershins>	ok yeah even deranged types like &Rc<&Box<&&Self>> are allowable for method receivers. but yeah not very useful, you won't see it much
Mar 06 12:47:10 <Widdershins>	usually it is like `self: Box<Self>` so that you can take ownership of the value via a box instead of the value itself
Mar 06 12:47:41 <Widdershins>	otherwise anything that would receive &Box<Self> you can just let it decay to &self by dereferencing
Mar 06 12:51:54 <bertptrs>	There's the Wake trait that takes Arc<Self> and &Arc<Self>
Mar 06 12:52:51 <Widdershins>	&arc so you don't have to mess with the count by cloning it
Mar 06 12:53:10 <bertptrs>	Exactly
Mar 06 12:55:14 <bertptrs>	but rather than making an arbitrary decision on what makes sense, the standard just allows all combinations
**** BEGIN LOGGING AT Wed Mar  6 13:29:44 2024

Mar 06 13:29:41 *	Now talking on ##rust
Mar 06 13:29:41 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 06 13:29:41 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Mar 06 14:21:09 <mkoncek1>	*const () is a synonym for *const std::ffi::c_void?
Mar 06 14:22:32 <Mutabah>	no, although they are sometimes used interchangably
Mar 06 14:22:47 <Mutabah>	`()` is an empty tuple, a zero-sized type`
Mar 06 14:23:08 <Mutabah>	`c_void` is the de-facto representation of C's `void` type, and is iirc an enum
Mar 06 14:33:31 <bertptrs>	that's a strange representation of void https://doc.rust-lang.org/src/core/ffi/mod.rs.html#209-224
Mar 06 14:35:28 <j`ey>	one variant I can maybe understand... but 2??
Mar 06 14:35:32 <Mutabah>	See the comment above
Mar 06 14:35:56 <j`ey>	ah
Mar 06 14:37:11 <bertptrs>	I read the comment but I don't know enough LLVM internals to make sense of it
Mar 06 14:48:15 <mkoncek1>	do i need the futures create to await a future? is there nothing like block_on in the vanilla Rust?
Mar 06 14:52:14 <bertptrs>	there isn't
Mar 06 14:52:40 <mkoncek1>	well, async_std has one
Mar 06 14:52:41 <bertptrs>	you can try my minimal executor, beul, which is 84 lines and does the absolute minimum
Mar 06 14:52:49 <bertptrs>	async std isn't std
Mar 06 14:52:59 <mkoncek1>	i know but i am already using it
Mar 06 14:53:29 <bertptrs>	you asked about vanilla ¯\_(ツ)_/¯
Mar 06 14:55:57 <bertptrs>	std doesn't offer one because it is unclear what a general purpose executor should do
Mar 06 14:56:20 <bertptrs>	tokio and async_std both offer much more than just futures execution, and most of the things they offer only work on their own runtimes
Mar 06 15:04:13 <mkoncek1>	well... execute an asynchronous function as a synchronous one in the current thread is not an unreasonable request is it?
Mar 06 15:04:29 <bertptrs>	it doesn't sound unreasonable
Mar 06 15:04:46 <bertptrs>	but tokio::time::sleep() cannot be executed by any runtime other than tokio
Mar 06 15:05:36 <bertptrs>	and it's not the only one, many futures require some specialized plumbing from their runtime to do anything useful
Mar 06 15:05:55 <danieldg>	mkoncek1: by the time you have a non-trivial future, you already need some kind of reactor running to cause the wakeups
Mar 06 15:06:11 <mkoncek1>	i am starting to wonder if i should try to use async at all
Mar 06 15:06:28 <danieldg>	so delegating the wait to that just makes sense.  Tokio, for example, supports a single-thread model which would deadlock forever if you had and used that method.
Mar 06 15:07:16 <bertptrs>	std needs to be very conservative in what it adds, because everything included stays forever. it's not impossible that one day std does have an executor, but until people agree what it should do, it won't be added any time soon
Mar 06 15:07:48 <danieldg>	it's very likely it would end up pluggable like the allocator in std anyway
Mar 06 15:08:38 <bertptrs>	I have my doubts, since the allocator story isn't moving either
Mar 06 15:08:43 <danieldg>	there are more reasons to want to change how task scheduling works than changing how allocation works after all
Mar 06 15:08:58 <danieldg>	I'm talking about GlobalAlloc which has been stable for quite a while
Mar 06 15:09:16 <danieldg>	and has already switched between jemalloc and system malloc
Mar 06 15:09:20 <bertptrs>	Ah yeah that works, mostly
Mar 06 15:10:24 <danieldg>	similar to having one allocator for the process, having one executor for the process is normal
Mar 06 15:10:49 <danieldg>	yes it's possible to have more than one of each, but that's pretty niche
Mar 06 15:10:49 <mkoncek1>	we had a task at uni comparing 4 allocators: GNU, jemalloc, Intel something and one more, i don't exactly remember but i think jemalloc was the best whereas GNU was consistent
Mar 06 15:11:34 <mkoncek1>	what is the price jemalloc pays for its speed tho?
Mar 06 15:12:06 <bertptrs>	jemalloc is huge, which is why rust switched back to system malloc
Mar 06 15:13:25 <erk>	rust the compiler still uses jemalloc as well.
Mar 06 15:13:57 <erk>	bertptrs: jemalloc is already system malloc (if you use FreeBSD which I think is rather unlikely)
Mar 06 15:17:42 <bertptrs>	I think also on macOS making it a bit more common
Mar 06 15:20:00 <bertptrs>	On the other hand, if you're building for Alpine it's a good idea to use jemalloc because musl's allocator isn't built for performance
Mar 06 15:23:44 <Guest11>	Hola
Mar 06 15:30:52 <mkoncek1>	is std::ops::Fn treated specifically by the compiler syntax-wise?
Mar 06 15:31:13 <mkoncek1>	help: use parenthetical notation instead: `FnMut() -> ()`
Mar 06 15:52:02 <bertptrs>	Fn/FnOnce/FnMut have special syntax to write out the function signature, yesa
Mar 06 15:58:37 <n1>	spb: hey ... to our yesterday conversation about "imports" bin vs lib .... i looked into the problem again with fresh mind and it's indeed pretty much straighforward and works nice ... i was probably tired more than i thought that i couldn't get it .... so once again thanks for your help
Mar 06 16:43:32 <rendar>	Rust uses jemalloc by default?
Mar 06 16:43:45 <bertptrs>	it doesn't AFAIK
Mar 06 16:44:56 <dav1d>	no it does not
Mar 06 16:45:24 <dav1d>	most (all?) our systems at $job have it explicitly configured though
Mar 06 16:45:26 <j`ey>	(it did in the past)
Mar 06 16:45:46 <bertptrs>	(until people complained loudly that the 2MB binary wasn't worth it)
Mar 06 16:50:35 <saati>	didn't it perform pretty suboptimal on some workloads?
Mar 06 16:53:32 <bertptrs>	AFAIK the size was the main argument, and it has a slightly larger memory footprint than libc while not performing better in single-threaded context
Mar 06 17:43:43 <rendar>	mimalloc is pretty neat
Mar 06 18:48:32 <Mikachu>	i thought that shadowing a variable in the same scope it was declared would drop it, turns out i was wrong
Mar 06 18:49:44 <tokie>	Mikachu: thankfully no. it is VERY useful in rust :)
Mar 06 18:49:59 <polychromata{J}>	try `let mut foo = a(); foo = b();` :)
Mar 06 18:51:38 <Mikachu>	in my case i had a refcell foo, let foo_inner = foo.borrow_mut(); let foo_inner = foo_inner.clone(); or so (i also wanted to assign it so i did need to use borrow_mut), and was surprised to get a panic later, explicit drop fixed it
Mar 06 18:53:24 <tokie>	usually i wouldn't do something like let foo_inner ..., since shadowing lets you let foo = foo.borrow_mut();
Mar 06 18:53:38 <tokie>	like, unlike C++ you don't have to keep coming up with names for inner parts of things
Mar 06 19:01:37 <danieldg>	it's always a good idea to explicitly drop locks if you care about when they unlock
Mar 06 19:11:43 <dav1d>	rendar, thanks that's interesting
Mar 06 19:11:54 <dav1d>	I have an urge to try it out
Mar 06 19:12:32 <rendar>	dav1d, good! let me know
Mar 06 19:13:22 <dav1d>	gonna pitch to to some colleagues cause I am pretty swamped with other stuff atm :(
Mar 06 19:17:59 <rendar>	no probl
Mar 06 19:18:15 <rendar>	dav1d, what kind of software is that, if i may ask?
Mar 06 19:19:16 <dav1d>	rendar, processing pipeline and first API layer from Sentry
Mar 06 19:19:35 <dav1d>	e.g. symbolication of stacktraces is one big part, the other is just the API which accepts all traffic
Mar 06 19:19:44 <rendar>	i see
Mar 06 19:20:10 <rendar>	so do you work for sentry.io?
Mar 06 19:20:44 <dav1d>	rendar, yep
Mar 06 19:20:55 <rendar>	great, where are you based?
Mar 06 19:23:39 <dav1d>	rendar, Vienna
Mar 06 19:23:51 <rendar>	very cool
Mar 06 19:24:05 <dav1d>	if you mean me, Sentry also has an office in canada and sf
Mar 06 19:24:23 <rendar>	yeah i saw it in their website
Mar 06 19:25:27 <dav1d>	unfortunately we dont seem to have any results of jemalloc vs system alloc but overall it fixed a memory fragementation issue we were seeing while also improving performance
Mar 06 19:25:58 <rendar>	yeah, i think mimalloc will further improve perf
Mar 06 19:26:46 <tokie>	dav1d: you work for sentry/
Mar 06 19:26:48 <tokie>	?
Mar 06 19:27:16 <dav1d>	tokie, yes
Mar 06 19:27:20 <tokie>	cool !:D
Mar 06 19:27:23 <dav1d>	:D
Mar 06 19:27:30 <tokie>	i know sentry!:D
Mar 06 19:27:41 <dav1d>	I hope only good memories
Mar 06 19:27:51 <tokie>	it catches my panics
Mar 06 19:28:05 <dav1d>	it also catches our own panics lol
Mar 06 19:33:30 <tokie>	well, it's cool to know sentry is a rust shop!
Mar 06 19:41:38 <dav1d>	tokie, and we're moving a lot more to Rust!
Mar 06 19:42:09 <tokie>	oh cool!
Mar 06 19:42:21 <dav1d>	recently replaced a bunch of kafka consumers already
Mar 06 19:42:25 <tokie>	so are we!:D
Mar 06 19:42:26 <dav1d>	more to come
Mar 06 19:42:57 <tokie>	i'm at CF and lots of rust going on
Mar 06 19:43:38 <dav1d>	CF as in cloudflare? Another one :D
Mar 06 19:44:06 <tokie>	yeah
Mar 06 19:44:22 <dav1d>	cool
Mar 06 19:46:03 <erk>	It is getting out of hand, now there are two of them
Mar 06 19:46:50 <Mikachu>	let state = &mut *state.borrow_mut(); why on earth does this work?
Mar 06 19:46:55 <tokie>	erk: two of who?
Mar 06 19:47:22 <erk>	Cloudflare people on irc
Mar 06 19:47:27 <tokie>	oh there's more than that
Mar 06 19:49:02 <bwidawsk>	I'm having some trouble deciding between anyhow (eyre), thiserror crates. I'm writing a test harness (ie. library like). Generally speaking, most test clients will not care about the specific type of error, and mostly just report out what the error was as part of the test suite. I started off with anyhow, then switched to thiserror, but now feel like thiserror might not actually be necessary here. Any thoughts?
Mar 06 19:50:08 <erk>	Mikachu: You are doing a reborrow of it, which is something that can give a bit of a headache sometime
Mar 06 19:50:30 <Mikachu>	get_mut() refused to give me a &mut T because i only have a & on the refcell, but somehow i can get one anyway?
Mar 06 19:50:53 <spb>	bwidawsk: those two crates solve quite different problems, and anyhow's doc suggests using thiserror alongside it
Mar 06 19:50:55 <erk>	What you are doing is essentially &mut *(&mut bla)
Mar 06 19:51:49 <erk>	ahh Mikachu it is the borrow_mut on refcell and not in the trait.
Mar 06 19:51:53 <bertptrs>	Mikachu: RefCell allows you to get an &mut from an &, and it will enforce at runtime that only one of those is ever live
Mar 06 19:51:56 <bwidawsk>	spb: sure, though I feel like the more anyhow integration I get, the less thiserror actually does anything for me
Mar 06 19:52:02 <dav1d>	Mikachu, borrow_mut doesn't give you a mut pointer directly, it gives you a type which implements DerefMut
Mar 06 19:52:08 <erk>	that borrow_mut will panic if you are not allowed to do that https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.borrow_mut
Mar 06 19:52:23 <bwidawsk>	spb: aiui, you really want thiserror if you want to be able to disambiguate errors
Mar 06 19:52:34 <bwidawsk>	and anyhow if you don't really care
Mar 06 19:52:49 <bertptrs>	well, you can care with anyhow
Mar 06 19:53:03 <bertptrs>	but in general: anyhow (eyre) for binaries, thiserror for libraries
Mar 06 19:53:15 <bwidawsk>	yeah, I'm just sort of a hybrid
Mar 06 19:53:37 <bwidawsk>	I suppose it might make sense to keep using both for me
Mar 06 19:54:05 <Mikachu>	erk: but when i do this, the RefMut immediately goes out of scope (it was never even given a binding), so how do i still have a &mut to the data?
Mar 06 19:54:09 <bwidawsk>	internal APIs - thiserror. public APIs that are used directly by tests, anyhow
Mar 06 19:54:57 <spb>	anyhow and relatives are for when you just want to propagate "an error occurred" upwards and maybe print it for human consumption, but don't care about calling code being able to programmatically handle different error types
Mar 06 19:55:03 <Mikachu>	i'll just accept it as magic for now
Mar 06 19:55:15 <spb>	this usually happens in application code, and usually shouldn't be in a library's public api
Mar 06 19:56:31 <erk>	Mikachu: That is the part that is the reborrow, you can find some blogs and similar about it, but it is one of the features of the borrow system that is harder to wrap your head around
Mar 06 19:59:49 <spb>	Mikachu: i think the magic phrase you're looking for is 'temporary lifetime extension' - see e.g. https://blog.m-ou.se/super-let/
Mar 06 20:01:12 <spb>	tl;dr: sometimes, if a relatively simplistic set of rules are met, the lifetime of a temporary created inside a 'let' statement will be extended to match the binding created by the let
Mar 06 20:01:35 <Mikachu>	i see
Mar 06 20:19:17 <Guest0>	Come have sex with me on my profile phone
Mar 06 20:20:31 <Guest0>	Primero haga clic en este enlace > https://ln.run/3zIyD
Mar 06 20:20:32 <Guest0>	Y completa todas las opciones y luego muestra tu tarjeta, pero no te preocupes, es totalmente gratis.
Mar 06 20:21:12 <Guest0>	hello darling
Mar 06 21:28:08 <daddy>	i'm getting "undefined symbol" a bunch of times for a specific library, when linking statically to a library even though I have `cargo:rustc-link-lib=static=gmp`. What can I use to see where that linking is happening/failing ?
**** BEGIN LOGGING AT Wed Mar  6 21:44:04 2024

Mar 06 21:44:02 *	Now talking on ##rust
Mar 06 21:44:02 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 06 21:44:02 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Mar 06 22:04:17 <bertptrs>	weird bug, after upgrading axum to 0.7 (and fixing all the breaking changes) my laptop no longer has enough RAM to compile my project
Mar 06 22:06:35 <bertptrs>	Memory usage jumped from a peak of 500MB to a over 6GB, that ain't right
Mar 06 22:07:49 <bertptrs>	how do you even debug this
Mar 06 22:08:22 <bertptrs>	eh, I'll update everything but axum for now, then
Mar 06 22:09:59 <alip>	can someone please tell me why .map(drop) is used here: https://docs.rs/nix/latest/src/nix/unistd.rs.html#3095-3110 i don't get why it's needed
Mar 06 22:11:30 <bertptrs>	alip: from looking at some other stuff, it's their preferred way to go from Result<T, E> to result<(), E>
Mar 06 22:11:37 <tokie>	bertptrs: yikes
Mar 06 22:11:44 <tokie>	i run out of memory if i try to do a coverage build
Mar 06 22:11:48 <tokie>	with 16GB dedicated ...
Mar 06 22:12:04 <bertptrs>	tokie: also axum? ouch, that's one heck of a regression
Mar 06 22:12:09 <alip>	bertptrs: ah makes sense, thank you
Mar 06 22:12:16 <tokie>	bertptrs: not axum, but a big tokio project
Mar 06 22:12:36 <bertptrs>	tokio is not being bumped in my case
Mar 06 22:12:40 <bertptrs>	hyper is tho
Mar 06 22:12:44 <tokie>	hrm
Mar 06 22:14:31 <bertptrs>	If I had time I'd go to their discord and figure it out, but I have a deadline to meet
Mar 06 22:14:46 <bertptrs>	and a bedtime I guess but the deadline wins
Mar 06 22:52:21 <Widdershins>	thus far i've successfully avoided going to anyone's discord to try to get anything fixed. miserable platform, the howling void at the end of knowledge, the enclosure in which history dies
Mar 06 22:52:47 <Widdershins>	discord is for shitposting with my weird friends, not for collecting knowledge
Mar 06 23:10:42 <mefistofeles>	whereas IRC is for shitposting with randoms
Mar 06 23:10:50 <mefistofeles>	:P
Mar 06 23:12:49 <daddy>	IRC is for solving the toughest problems known to man via shitposting with randoms.
**** ENDING LOGGING AT Wed Mar  6 23:44:24 2024

**** BEGIN LOGGING AT Thu Mar  7 02:18:47 2024

Mar 07 02:18:44 *	Now talking on ##rust
Mar 07 02:18:44 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 07 02:18:44 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Mar 07 03:10:24 <swansone>	simple question I'm having a surprisingly hard time googling: In the scope of a function, is there a way to do something like `use MyLongNamedEnum::{*}` so I don't have to keep typing MyLongNamedEnum::SomeVariant?
Mar 07 03:11:22 <danieldg>	yes
Mar 07 03:11:37 <swansone>	Oh wait, that just literally works, doesn't it
Mar 07 03:11:44 <danieldg>	:)
Mar 07 03:11:48 <swansone>	That's what I get for not trying it
Mar 07 03:14:31 <Mutabah>	:D
Mar 07 03:15:02 <Mutabah>	IMO, better would be to `use MyLongNamedEnum as En;`
Mar 07 03:15:19 <Mutabah>	just becuase then it's clearer what each name refers to, and you avoid accidentally making a bind pattern.
Mar 07 03:15:35 <Mutabah>	... One day, I'll write up a RFC for inferred enum names
Mar 07 03:15:44 <Mutabah>	`match foo { _::BarVariant => ... }`
Mar 07 03:16:41 <phy1729>	That'd be handy because it should be obvious
Mar 07 03:17:22 <Mutabah>	I think last time I tried I also got nerd-sniped into `_::new(...)` too
Mar 07 03:19:28 <swansone>	An alias is a great suggestion Mutabah, thanks! I'll do that.
**** BEGIN LOGGING AT Thu Mar  7 05:39:14 2024

Mar 07 05:39:13 *	Now talking on ##rust
Mar 07 05:39:13 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 07 05:39:13 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** BEGIN LOGGING AT Thu Mar  7 05:53:09 2024

Mar 07 05:53:08 *	Now talking on ##rust
Mar 07 05:53:08 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 07 05:53:08 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** BEGIN LOGGING AT Thu Mar  7 06:46:02 2024

Mar 07 06:46:01 *	Now talking on ##rust
Mar 07 06:46:01 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 07 06:46:01 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** BEGIN LOGGING AT Thu Mar  7 11:45:32 2024

Mar 07 11:45:29 *	Now talking on ##rust
Mar 07 11:45:29 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 07 11:45:29 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** BEGIN LOGGING AT Thu Mar  7 12:26:52 2024

Mar 07 12:26:50 *	Now talking on ##rust
Mar 07 12:26:50 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 07 12:26:50 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Mar 07 12:28:25 <lmat>	Affliction: Thank you, very helpful!
**** BEGIN LOGGING AT Thu Mar  7 12:39:51 2024

Mar 07 12:39:50 *	Now talking on ##rust
Mar 07 12:39:50 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 07 12:39:50 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Mar 07 12:51:33 <nox>	I don't remember what Servo uses
Mar 07 13:44:34 <erk>	nox: Now it uses tungstenite through the async_tungstenite crate.
Mar 07 14:03:40 <Guest67>	hey
Mar 07 14:04:57 <osse>	teacher
Mar 07 14:05:02 <osse>	leave those kids alone
**** BEGIN LOGGING AT Thu Mar  7 14:15:49 2024

Mar 07 14:15:48 *	Now talking on ##rust
Mar 07 14:15:48 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 07 14:15:48 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Mar 07 15:21:57 <Luisa14>	hey
Mar 07 16:06:26 <bertptrs>	not going to do it again
Mar 07 16:09:55 <dav1d>	lol
Mar 07 16:21:04 <n1>	i would like to cross compile for my Samsung Exynos5422 ARM - how do i exactly detect the architecture "name" for cargo target?
Mar 07 16:21:38 <j`ey>	aarch64-unknown-linux-gnu
Mar 07 16:22:18 <n1>	how did u figure?
Mar 07 16:23:05 <j`ey>	because I do arm stuff :P
Mar 07 16:23:36 <j`ey>	but tbh, Im not sure it's that easy, if youre running android. maybe termux will allow you to run stuff
Mar 07 16:24:07 <n1>	it's my odroidhc2
Mar 07 16:24:18 <n1>	from what i know it's 32bit
Mar 07 16:24:21 <n1>	thats why i asked
Mar 07 16:24:50 <j`ey>	oh I googled and thought it was 64-bit
Mar 07 16:25:52 <n1>	i know it's armv7
Mar 07 16:25:57 <n1>	LE
Mar 07 16:26:02 <j`ey>	then I dont know, probably: arm-unknown-linux-gnueabhf or something
Mar 07 16:26:02 <n1>	thats all i know
Mar 07 16:26:34 <n1>	um...how do i decide between gnuabi and musleabi?
Mar 07 16:27:36 <bertptrs>	generally if you're on musl, you know
Mar 07 16:28:08 <n1>	i was thinking exactly the same :)
Mar 07 16:28:22 <tokie>	bertptrs: lol
Mar 07 16:28:26 <tokie>	"you know. ugh."
Mar 07 16:29:26 <n1>	so last question - if i choose wrong target for compilation do i get the error right away on app startup or it can run and fail later because of wrong architecture (mainly gnu vs musle)?
Mar 07 16:30:00 <bertptrs>	yeah, it will fail to load shared libs and crash
Mar 07 16:30:24 <n1>	cool
Mar 07 16:30:57 <bertptrs>	if it doesn't crash at that stage (or before that, if you got the ABI very wrong and the thing isn't even recognized as an executable)  it should work
Mar 07 16:31:06 <n1>	looks like i narrowed down the list to 2 candidates: armv7-unknown-linux-gnueabi and armv7-unknown-linux-gnueabihfOD
Mar 07 16:31:17 <n1>	(without the OD)
Mar 07 16:31:26 <bertptrs>	hf stands for hardware float
Mar 07 16:31:46 <bertptrs>	some arm chips don't have hardware support for floating point numbers and must emulate it in software
Mar 07 16:32:07 <n1>	since dpkg says the architecture is armhf should i go for the later one?
Mar 07 16:32:47 <bertptrs>	yes. and if not, I still would've guessed hf since I can't imagine a vendor selling an android phone that doesn't need to deal with floats
Mar 07 16:33:46 <n1>	so hf is almost always the case?
Mar 07 16:34:12 <bertptrs>	basically, I think the original pi didn't have hardware float but that's about it
Mar 07 16:34:19 <bertptrs>	it's rare
Mar 07 16:34:29 <bertptrs>	armv8 stopped making the distinction
Mar 07 16:34:50 <n1>	cool thanks
Mar 07 17:32:59 <gastus_>	https://dpaste.com/78F84NYEJ Line 19 / 29  already borrowed. The borrow is no longer needed there ? Is there a simple fix?
Mar 07 17:47:07 <Mikachu>	gastus_: if let Some(ref h) = *(*my....borrow() { ... } else { // borrow_mut should be fine in here }
Mar 07 17:48:25 <gastus_>	That's nice ! :-)
Mar 07 17:49:49 <sword_smith>	Damn! Compilation takes forever now :( https://github.com/TritonVM/triton-vm
Mar 07 17:50:02 <sword_smith>	When faster rustc?
Mar 07 17:50:36 <j`ey>	sword_smith: rustc is gettng faster!
Mar 07 17:51:03 <sword_smith>	j`ey: I just saw a YouTube video about that, that it was faster on nightly :)
Mar 07 17:52:17 <sword_smith>	CI takes 46 minutes on ubuntu, 87 on macos.
Mar 07 17:53:46 <gastus_>	But also failed :-(
Mar 07 17:54:00 <sword_smith>	gastus_: yikes!
Mar 07 17:54:05 <sword_smith>	I don't think so...
Mar 07 17:59:58 <jbowen>	I have a program where I'd like to have a small list of primes defined as a constant, but it feels gross sticking it at the top of my src/main.rs. In C I'd have some file that I'd #include at the top of my main.c
Mar 07 18:00:38 <jbowen>	What's the idiomatic way to do that within a Rust simple source tree?
Mar 07 18:00:40 <j`ey>	jbowen: make a module
Mar 07 18:00:55 <j`ey>	src/primes.rs, 'mod primes' at the top of main.rs
Mar 07 18:03:14 <jbowen>	Cool, thank you, j`ey!
Mar 07 18:03:46 <jbowen>	I think I was initially put off by the word "module" feeling like a much heavier weight solution
Mar 07 18:04:50 <j`ey>	nope :)
Mar 07 19:42:36 <dav1d>	sword_smith, https://github.com/Swatinem/rust-cache 👀
Mar 07 19:43:10 <psyprus>	Q
Mar 07 19:43:23 <psyprus>	sorry ignore
Mar 07 22:24:12 <sword_smith>	dav1d: thanks. But it's not dependencies that are slow to build, but the repo itself.
Mar 07 22:24:31 <sword_smith>	however, other repos depend on it. So there might be something there.
**** BEGIN LOGGING AT Fri Mar  8 22:52:07 2024

Mar 08 22:52:06 *	Now talking on ##rust
Mar 08 22:52:06 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 08 22:52:06 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Mar 08 22:54:39 <Diablo-D3>	https://rolldown.rs/
Mar 08 22:54:45 <Diablo-D3>	remember when I said dont use rust for evil?
Mar 08 22:54:56 <Diablo-D3>	this is somewhere on the evil continuum
Mar 08 22:54:58 <polychromata{J}>	ugh
Mar 08 22:55:16 <Diablo-D3>	people, please, dont feed the javascript trolls
**** BEGIN LOGGING AT Fri Mar  8 23:04:26 2024

Mar 08 23:04:24 *	Now talking on ##rust
Mar 08 23:04:24 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 08 23:04:24 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** BEGIN LOGGING AT Fri Mar  8 23:07:15 2024

Mar 08 23:07:14 *	Now talking on ##rust
Mar 08 23:07:14 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 08 23:07:14 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** BEGIN LOGGING AT Fri Mar  8 23:14:17 2024

Mar 08 23:14:14 *	Now talking on ##rust
Mar 08 23:14:14 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 08 23:14:14 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** BEGIN LOGGING AT Sat Mar  9 07:43:52 2024

Mar 09 07:43:50 *	Now talking on ##rust
Mar 09 07:43:50 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 09 07:43:50 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** BEGIN LOGGING AT Sat Mar  9 08:24:02 2024

Mar 09 08:24:00 *	Now talking on ##rust
Mar 09 08:24:00 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 09 08:24:00 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** BEGIN LOGGING AT Sat Mar  9 10:08:22 2024

Mar 09 10:08:21 *	Now talking on ##rust
Mar 09 10:08:21 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 09 10:08:21 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Mar 09 10:08:46 <polychromata{J}>	Ah, never mind. Looks like i just had to change the /sort metric/ dropdown.
Mar 09 10:09:15 FiSHLiM plugin unloaded
**** ENDING LOGGING AT Sat Mar  9 10:09:15 2024

**** BEGIN LOGGING AT Sat Mar  9 10:12:44 2024

Mar 09 10:12:41 *	Now talking on ##rust
Mar 09 10:12:41 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 09 10:12:41 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Mar 09 10:15:17 <nox>	danieldg, daddy: Re: TLS overhead: just do RPK
Mar 09 10:16:01 <nox>	https://datatracker.ietf.org/doc/html/rfc7250#section-1
**** BEGIN LOGGING AT Sat Mar  9 11:09:20 2024

Mar 09 11:09:16 *	Now talking on ##rust
Mar 09 11:09:16 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 09 11:09:16 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Mar 09 11:11:09 <Widdershins>	nox: oh man is there a rust TLS library that has mutual RPK support
Mar 09 11:11:56 <Widdershins>	i want it so bad. x509 is suffering
Mar 09 11:12:08 <nox>	Widdershins: boring ha a rpk feature
Mar 09 11:13:22 <Widdershins>	i suppose that would work. i had a lot of trouble a year (or two?) ago when i was trying to figure out how to do this in boringssl directly
Mar 09 11:16:38 <lmat>	I am computing an average of one property of a vec of structs:   data.iter().map(|e| e.val).sum() / data.len()   The error I get is, "
Mar 09 11:17:10 <lmat>	"cannot infer type of the type parameter `S` declared on the method `sum`". I tried    sum<f64>  (f64 being the type of e.val), but that appears to be bad syntax.
**** BEGIN LOGGING AT Sat Mar  9 11:33:17 2024

Mar 09 11:33:15 *	Now talking on ##rust
Mar 09 11:33:15 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 09 11:33:15 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Mar 09 11:36:47 <lmat>	How do I print a tab character? I tried  print!("{}  ", val);  and print!("{}{}", val, "  "); but both are getting the tab expanded.
Mar 09 11:36:56 <lmat>	This is in the context of a unit test
Mar 09 11:37:11 <lmat>	(I'm printing a table that I would like to paste into libre-office --calc.
Mar 09 11:39:47 <dav1d>	evalr, println!("\tfoo\tbar\t123")
Mar 09 11:39:49 -evalr/##rust-	dav1d: 	foo	bar	123
Mar 09 11:40:04 <lmat>	dav1d: Thank you!
Mar 09 11:52:16 <nox>	Widdershins: Btw https://github.com/rustls/rustls/issues/423
Mar 09 11:52:44 <Widdershins>	nox: eyes emoji
Mar 09 11:54:46 <Widdershins>	> I don't know if it's theoretically possible to send a valid 1GB certificate during the handshake phase, and I don't want to have to know this, I'd rather just avoid X509. We don't need a self-driving car to crack a nut.
Mar 09 11:54:49 <Widdershins>	lol same brother
Mar 09 11:56:33 <polychromata{J}>	lmat: I don't see any reason why tabs in the source file should get transformed. Are you sure it's not your editor doing that? :)
Mar 09 11:57:21 <lmat>	polychromata{J}: I'm pretty sure it's not my editor (vim with :set noexpandtab), but I would guess it's happening at another layer.
Mar 09 11:58:01 <dav1d>	Widdershins, you can borrow these 👀
Mar 09 11:58:05 <polychromata{J}>	evalr: let tab = '	'; (tab, u32::from(tab))
Mar 09 11:58:07 -evalr/##rust-	polychromata{J}: error: character constant must be escaped: `\t` ...
Mar 09 11:58:08 -evalr/##rust-	polychromata{J}: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=71740193290e88d342282b37fa9d0840
Mar 09 11:58:43 <polychromata{J}>	evalr: let tab = "	"; tab.chars().next()
Mar 09 11:58:45 -evalr/##rust-	polychromata{J}: Some('\t')
Mar 09 12:55:57 <Wulf>	Is that the right syntax to move a value out of an inner block?   { let x: u32; { x = something(); }  workon(x); }
Mar 09 13:01:18 <polychromata{J}>	Yeah, that works.
Mar 09 13:02:26 <polychromata{J}>	Sometimes `let x = { other_things(); x }; work_on(x);` is nicer.
Mar 09 13:04:17 <Wulf>	indeed, that's nicer. And I didn't know I could do this. Thanks!
Mar 09 13:07:07 <polychromata{J}>	something something most things are expressions :)
Mar 09 13:11:15 <Widdershins>	blocks? expressions. if conditionals? expressions. for loops? return statements? expression. module? ok actually that's an item
Mar 09 13:12:38 <Wulf>	There is no ++ operator like in C, right?  let foo = { *bar++ }; won't work?  let foo = { *bar += 1; *bar - 1 }; works, but I don't like it.
Mar 09 13:12:54 <Widdershins>	`let` declarations aren't expressions but assignments to those variables are
Mar 09 13:14:00 <Widdershins>	Wulf: postfix incr/decr is deeply discouraged in c++ these days for a reason :) *especially* if you care to use it as a value expression
Mar 09 13:14:36 <Wulf>	Widdershins: suggestions how I can rewrite above code?
Mar 09 13:15:13 <Widdershins>	i don't know, what type is bar
Mar 09 13:15:19 <Wulf>	Widdershins: u32
Mar 09 13:17:14 <Widdershins>	Wulf: why not `let foo = *bar; *bar += 1;
Mar 09 13:17:30 <Widdershins>	don't get fancy
Mar 09 13:17:39 <Wulf>	Widdershins: I need to acquire a mutex in the inner scope.
Mar 09 13:18:08 <Widdershins>	well, have you shown me that? was i supposed to guess?
Mar 09 13:19:47 <Wulf>	Widdershins: I was hoping that you'd guess that I somehow need that inner scope.
Mar 09 13:20:08 <Widdershins>	you're hoping that i'll answer a question you haven't asked
Mar 09 13:20:16 <Widdershins>	you should ask it, and present the problem
Mar 09 13:22:47 <Widdershins>	inner scopes like that are rarely truly needed due to how the borrow checker works, they are just nicer to spell
**** ENDING LOGGING AT Sat Mar  9 13:31:10 2024

**** BEGIN LOGGING AT Sat Mar  9 13:40:25 2024

Mar 09 13:40:23 *	Now talking on ##rust
Mar 09 13:40:23 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 09 13:40:23 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Mar 09 14:10:39 <yziquel>	Really weird issue. appears only with rust code (other languages seem to be fine) when dealing with virtiosfd filesystems on guest machines with --cache=never on host.
Mar 09 14:11:21 <yziquel>	https://github.com/cross-rs/cross/issues/1313#issuecomment-1986847352
Mar 09 14:20:00 <saati>	do the other programs try to mmap it?
Mar 09 14:20:15 <saati>	ENODEV on mmap means the fs does not support memory mapping
**** BEGIN LOGGING AT Sat Mar  9 14:33:36 2024

Mar 09 14:33:35 *	Now talking on ##rust
Mar 09 14:33:35 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 09 14:33:35 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Mar 09 16:17:45 <yziquel>	seems rust tend to use MAP_SHARED in mmap more than MAP_PRIVATE. I see that by comparing git and gix.
Mar 09 16:18:28 <danieldg>	this really depends on what you're mapping more than just counting things
Mar 09 16:19:22 <danieldg>	also, the two are basically identical unless you (the mapper) are writing to the file
Mar 09 16:20:20 <danieldg>	if someone else is writing, MAP_PRIVATE has some nasty undefined behavior corner cases
Mar 09 16:28:22 <yziquel>	danieldg your assumption (almost identical) is violated in my setup: I running rust code in a VM on a filesystem using virtiofs with a zfs backend on the host.
Mar 09 16:29:16 <yziquel>	and disabling caching in virtiofsd. (with caching, seems like coherency is not enforced enough for the "No such device" error to pop up in the guest)
Mar 09 16:30:26 <yziquel>	MAP_SHARED seems to ask for more than MAP_PRIVATE than qemu is prepared to hand over in terms of memory mapping of files.
Mar 09 16:31:20 <danieldg>	yes, MAP_SHARED wants better guarantees with regards to modifications
Mar 09 16:32:24 <yziquel>	danieldg this make rust code more difficult in a VM with virtiofs and no caching.
Mar 09 16:33:03 <yziquel>	more difficult to run
Mar 09 16:33:22 <danieldg>	I have no idea why you would want to do that, but ok
Mar 09 16:33:43 <danieldg>	mostly it's the linker that does this, for shared objects
Mar 09 16:33:52 <yziquel>	danieldg disaster recovery ? my last CPU died in a bang. I'm mounting my former computer as a VM.
Mar 09 16:33:55 <danieldg>	so not rust's problem at all
Mar 09 16:34:15 <danieldg>	virtiofs is *not* the preferred way to do that
Mar 09 16:34:32 <yziquel>	danieldg and what is the prefered way ?
Mar 09 16:34:44 <danieldg>	hand the VM the actual block devices
Mar 09 16:34:51 <danieldg>	or images thereof
Mar 09 16:35:11 <yziquel>	danieldg I've been bugging the incus / lxd chat room to pass the block device. They basically told me to shut up.
Mar 09 16:35:32 <danieldg>	virtiofs is for sharing files you want to access on both systems
Mar 09 16:36:25 <danieldg>	I have no idea what incus is
Mar 09 16:36:36 <yziquel>	incus = fork of lxd.
Mar 09 16:36:40 <danieldg>	and isn't lxd a container thing?
Mar 09 16:36:53 <yziquel>	danieldg yes. a container, with some support for vm.
Mar 09 16:37:08 <danieldg>	so your problem is that you aren't using a real VM
Mar 09 16:37:21 <danieldg>	yes, a container should be using a shared FS like this
Mar 09 16:37:34 <danieldg>	but a container is not the solution to "run my old system in a VM"
Mar 09 16:37:40 <yziquel>	danieldg perhaps. my problem is that no one gives advice.
Mar 09 16:37:53 <danieldg>	have some advice: use a VM
Mar 09 16:37:57 <yziquel>	no. I'm using a QEMU vm managed by incus.
Mar 09 16:38:02 <yziquel>	not a container.
Mar 09 16:38:17 <danieldg>	it's pretty easy to pass block devices to a VM
Mar 09 16:38:37 <danieldg>	you can't have them mounted in the host if you do that, though
Mar 09 16:38:53 <spb>	in every setup i've used it's pretty difficult *not* to pass block devices to a VM
Mar 09 16:38:57 <yziquel>	danieldg I haven't had any clue as to how mount the block device with incus,
Mar 09 16:39:05 <danieldg>	this feels like an incus bug
Mar 09 16:39:15 <yziquel>	Spawns_spb try it with incus. good luck.
Mar 09 16:39:18 <yziquel>	spb
Mar 09 16:39:18 <danieldg>	use libvirt or one of the nice gui frontends to it
Mar 09 16:39:41 <yziquel>	danieldg ok. one more month toying with ANOTHER vm framework. cool,
Mar 09 16:39:45 <danieldg>	if incus is meant to be a container thing, their VM support is probably half-baked
Mar 09 16:39:56 <spb>	i'd really rather not, if it's all the same to you
Mar 09 16:40:03 <spb>	if you want a VM, use a VM solution
Mar 09 16:40:04 <yziquel>	danieldg i kind of figured that out indeed.
Mar 09 16:40:45 <yziquel>	spb well, I want a container feel to it. will look at kata containers at one point.
Mar 09 16:41:20 <danieldg>	then this is a limitation of virtiofsd
Mar 09 16:41:32 <danieldg>	or a bug there
Mar 09 16:41:34 <yziquel>	still, the MAP_SHARED issue remains an issue with rust + no caching virtiofs. This isn't going away just because I use something else.
Mar 09 16:41:50 <danieldg>	it will go away if you don't use virtiofs with no caching
Mar 09 16:41:55 <danieldg>	(why no caching?)
Mar 09 16:41:57 <yziquel>	danieldg seems that it is a virtiofs bug.
Mar 09 16:42:16 <danieldg>	rust is by far not the only thing using MAP_SHARED
Mar 09 16:42:31 <danieldg>	if virtiofs can't do it, virtiofs is not ready for use
Mar 09 16:42:36 <yziquel>	danieldg no caching matters because I can't index the VM with things like sudo updatedb is caching is allowed. it blows up the number of file descriptors on the host.
Mar 09 16:43:07 <danieldg>	... so I'm reading virtiofs is buggy again
Mar 09 16:43:14 <yziquel>	danieldg i'll try to bother a virtiofs chatroom then.
Mar 09 16:43:21 <danieldg>	it's not hard to not blow up fd counts
Mar 09 16:43:31 <danieldg>	samba servers, NFS servers, etc all do it
Mar 09 16:43:45 <danieldg>	you could also just raise that limit
Mar 09 16:44:04 <yziquel>	danieldg I've been unable to find the correct limit to raise and where to raise it.
Mar 09 16:44:14 <yziquel>	danieldg spent a month on it.
Mar 09 16:44:28 <danieldg>	/etc/security/limits.conf, ulimit, or the /proc/sys setting
Mar 09 16:44:38 <spb>	that's still not a rust problem, and therefore quite off-topic for here
Mar 09 16:44:51 <danieldg>	the virtiofs people should know what to do about *their* bug
Mar 09 16:45:10 <yziquel>	danieldg I did try all that. something is not clear. and I won't ask people to help me again on that since they obviously think I bother them.
Mar 09 16:45:22 <danieldg>	ok
Mar 09 16:46:08 <yziquel>	spb it's a problem that occurs specifically for rust code. and that does impact people doing things in vms. on apple mostly, it seems, from what I gathered.
Mar 09 16:47:04 <danieldg>	you'll hit it in C code too
Mar 09 16:47:15 <yziquel>	danieldg haven't yet.
Mar 09 16:48:11 <danieldg>	ok
Mar 09 16:59:37 <spb>	yziquel: no, it's nothing specific to rust code. it just happens that the first time you encountered it was in rust code, which is not the same thing at all
Mar 09 17:18:26 <yziquel>	spb I'm not sure. I'm wondering if the rust stdlib is not overly restrictive.
Mar 09 17:18:32 <yziquel>	spb we'll see
Mar 09 17:23:41 <dav1d>	yziquel, what dose that have to do with the std lib
Mar 09 17:24:43 <danieldg>	rust std doesn't mmap at all
Mar 09 17:25:16 <yziquel>	dav1d as many many many rust code fails, I suspect it should be somewhere down the stack. possibly in stdlib.
Mar 09 17:25:36 <dav1d>	yziquel, it's not, there is no mmap in the std lib
Mar 09 17:25:37 <yziquel>	danieldg then it should be somewhere down the stack not in stdlib
Mar 09 17:27:17 <danieldg>	you also never said how it fails
Mar 09 17:27:27 <danieldg>	but whatever, I already pointed you to how to solve it
Mar 09 17:32:15 <capitol>	is there a way to differentiate in build.rs if your crate is being built as a dependency or as the "final target"? When the crate is a library
Mar 09 17:32:53 <danieldg>	print out the various environment variables, I suspect there's a CARGO_* one that might be relevant
Mar 09 17:33:50 <capitol>	i have been trying to investigate CARGO_PKG_NAME and CARGO_CRATE_NAME, but without success
Mar 09 17:34:00 <capitol>	but good idea to print all of them
Mar 09 17:38:59 <yziquel>	danieldg I did say how it fails.
Mar 09 17:39:18 <yziquel>	danieldg https://github.com/cross-rs/cross/issues/1313#issuecomment-1986847352
Mar 09 17:39:29 <yziquel>	danieldg up in the chat log.
Mar 09 17:40:33 <danieldg>	oh, so it's not a rust bug, it's a gix bug
Mar 09 17:40:58 <yziquel>	daniel it also occurs in cargo build
Mar 09 17:41:00 <yziquel>	danieldg
Mar 09 17:41:25 <yziquel>	danieldg and people running rust in a VM report that kind of bug in bug reports.
Mar 09 17:41:43 <danieldg>	right; the bug is "various things assume that mmap works and don't have a fallback"
Mar 09 17:41:59 <yziquel>	danieldg yes.
Mar 09 17:42:17 <yziquel>	a "somewhere in rust ecosystem" + virtiosf bug.
Mar 09 17:42:20 <danieldg>	no
Mar 09 17:42:37 <danieldg>	it's just people using mmap that don't want to handle the failure
Mar 09 17:42:49 <danieldg>	mostly because it doesn't happen on normal filesystems
Mar 09 17:43:02 <danieldg>	it happens in C code too
Mar 09 17:43:10 <yziquel>	danieldg I'll have to hunt down things to the source code before pointing fingers about people not handling the failure.
Mar 09 17:43:31 <danieldg>	yziquel: you've done so already
Mar 09 17:43:50 <yziquel>	danieldg no. I've used strace. I haven't seen the corresponding source code.
Mar 09 17:44:13 <danieldg>	ok
Mar 09 17:44:46 <danieldg>	but yes, rust has an mmap wrapper that lets you specify shared or private mapping
Mar 09 17:45:23 <danieldg>	and I suppose the default is probably shared
Mar 09 17:46:59 <danieldg>	yeah, memmap2 supports both private and shared - it calls it map_copy and map, respectively
Mar 09 17:47:14 <yziquel>	danieldg well, I guess I won't understand the issue till 1. i see where the mmap wrapper is and 2. understand how madness like the DAX window in virtiofs works. Until then, I'm in the dark.
Mar 09 17:47:17 <nox>	The mmap crate is unsound, the memmap crate properly marks the function that allows you to build one from a file as unsafe
Mar 09 17:47:35 <dav1d>	danieldg, good guess https://docs.rs/memmap2/latest/src/memmap2/unix.rs.html#232-241
Mar 09 17:48:31 <nox>	Ah there is a memmap2 crate now, ugh
Mar 09 17:48:56 <danieldg>	nox: if you want to call that unsound you need to also call File::open unsound.  There's a limit to soundness when you iteract with the OS.
Mar 09 17:49:16 <nox>	danieldg: If you mean /proc, that's on Linux, not on Rust
Mar 09 17:49:33 <danieldg>	nox: no, I mean opening any of your dependencies
Mar 09 17:49:41 <nox>	That doesn't cause memory unsafety
Mar 09 17:49:46 <danieldg>	yes it can
Mar 09 17:49:49 <nox>	How?
Mar 09 17:50:00 <danieldg>	if you write to the executable file
Mar 09 17:50:14 <nox>	I have no idea what you mean
Mar 09 17:50:30 <danieldg>	you can open a shared library, for write, and overwrite the executable code
Mar 09 17:50:43 <danieldg>	that's about as unsafe as it gets
Mar 09 17:50:47 <nox>	What shared libraries
Mar 09 17:51:04 <danieldg>	any one you use
Mar 09 17:51:46 <nox>	That you dynamically loaded with unsafe code?
Mar 09 17:52:00 <danieldg>	well, std depends on libc
Mar 09 17:52:05 <nox>	But anyway that's very different from a process truncating a file that you mmapp'd
Mar 09 17:52:22 <danieldg>	getting a SIGBUS is safe
Mar 09 17:52:37 <danieldg>	it's generally not something you want, just like a deadlock or whatever, but it's safe
Mar 09 17:52:41 <nox>	https://docs.rs/memmap2/latest/memmap2/struct.Mmap.html#method.map
Mar 09 17:53:15 <danieldg>	yes, I'm aware that people mark it as unsafe
Mar 09 17:54:16 <nox>	Because it is, "those other things can lead to unsoundness in Rust" isn't a counterargument to it being an unsafe operation
Mar 09 17:56:07 <danieldg>	I'm not arguing it's unsafe
Mar 09 17:56:24 <danieldg>	I'm saying that maybe it shouldn't be called unsound for no reason
Mar 09 17:57:13 <nox>	I called it unsound because it's not marked as unsafe
Mar 09 17:57:27 <Ademan_>	so I have a `struct Foo<'a> { bar: &'a bar, } ` and everything is fine, except I hit a point where I want to mutate bar when I have a mutable Foo. Is there a way to do this without making a duplicate MutableFoo, or making Foo *always* require an &'a mut Bar ?
Mar 09 17:57:38 <Ademan_>	&'a Bar *
Mar 09 17:58:19 <danieldg>	Ademan_: no, not really.  You can do other things like have an enum between the two ref types, or make Foo generic defaulting to &'a Bar
Mar 09 17:59:04 <nox>	Ademan_: There may be a better way to design your stuff altogether but we can't see that from a Foo/Bar example
Mar 09 18:00:23 <Ademan_>	danieldg: hrm thanks, making Foo generic might work out ok
Mar 09 18:00:59 <danieldg>	warning: that can easily make your code pretty ugly
Mar 09 18:01:31 <Ademan_>	nox: probably. Basically I'm "extending" Bar with some extra data in Foo. As I wrote that I realized, maybe I should just make Foo own a Bar, and worry less about potential duplication
Mar 09 18:01:51 <Ademan_>	although Bar *is* potentially pretty big
Mar 09 18:03:07 <danieldg>	owning an Arc might work
Mar 09 18:03:15 <Ademan_>	I've never used Cow before, maybe that's actually viable?
Mar 09 18:03:31 <danieldg>	Cow is basically the enum solution, but with owned instead of &mut
Mar 09 18:03:44 <danieldg>	Arc::get_mut can be useful
Mar 09 18:04:32 <danieldg>	(or even make_mut)
Mar 09 18:06:17 <Ademan_>	hrm, maybe I'll just KISS (I'm stupid) and own the Bar, and revisit if I get reports of memory usage issues
Mar 09 18:09:16 <Ademan_>	thanks for talking me through it
Mar 09 18:09:27 <nox>	Yeah I would just own Bar probably
Mar 09 18:12:05 <tokie>	poor Foo always gets left out for Bar
Mar 09 19:01:00 <Diablo-D3>	man, I wish more apps were written the rusty way
Mar 09 19:01:17 <Diablo-D3>	just one binary and thats all you need
Mar 09 19:03:03 <danieldg>	hmm, not sure that's the rusty way; it happens plenty with other languages and also not with rust plenty of the time too
Mar 09 19:03:07 <danieldg>	but I agree it's nice
Mar 09 19:05:10 <Diablo-D3>	well, ever try to do that on c/c++? some libraries are outright hostile to static linking
Mar 09 19:05:26 <Diablo-D3>	or you got ones that do really weird hacks due to OS fuckery
Mar 09 19:05:47 <danieldg>	true; glibc is a major culprit there
Mar 09 19:06:22 <Diablo-D3>	like, SDL used to, and I think still does, have SDLmain.a and SDL.dll on windows, it hijacks main() and ld loads sdl.dll
Mar 09 19:06:37 <Diablo-D3>	glibc is a culprit on rhel, not so much other distros
Mar 09 19:07:13 <danieldg>	is that just because other distros decide they don't care about making getpwnam() work with LDAP-ish systems?
Mar 09 19:07:13 <Diablo-D3>	sadly, a lot of people build binaries on there =/
Mar 09 19:07:40 <danieldg>	because iirc that's the main reason you have trouble static linking glibc
Mar 09 19:08:12 <Diablo-D3>	I dont know; on debian, symbol poisoning only happens if you call a function that depends on newer glibcs (so, header defines your libc call, but its a macro that calls the actual symbol)
Mar 09 19:08:32 <Diablo-D3>	so if you never call one of those, your binary may very well work on every libc6 system ever
Mar 09 19:09:13 <Diablo-D3>	rust culture seems to like building binaries on alpine just to stop contamination entirely
Mar 09 19:09:28 <Diablo-D3>	or at least, Ive seen a lot of rust programs distro binaries like that
Mar 09 19:11:12 <Diablo-D3>	but no, what started my rant is actually the overhead of electron
Mar 09 19:11:43 <Diablo-D3>	I am 100% anti-weirdo packaging formats
Mar 09 19:11:49 <danieldg>	... you know, people could just ship a .html file too
Mar 09 19:11:52 <Diablo-D3>	like, flatpak can go fuck itself, appimage aint really any better
Mar 09 19:11:58 <danieldg>	if you're talking about electron
Mar 09 19:12:06 <Diablo-D3>	hahah I wish they would
Mar 09 19:12:55 <Diablo-D3>	like, fun fact: we all hate discord, right? if you're not using desktop/window capture for streaming in calls, its a shitload smoother in firefox
Mar 09 19:13:23 <Diablo-D3>	its not an electron issue (such as discord using a out of date electron due to private vendored fork bullshit), because its equally as jank in chrome
Mar 09 19:13:33 <Diablo-D3>	in firefox, its great
Mar 09 19:14:01 <Diablo-D3>	imagine, a world where single file PWAs were how shit-apps were distributed
Mar 09 19:14:51 <Diablo-D3>	no, instead, I have like 50 copies of chrome running, all different
Mar 09 19:26:23 <Diablo-D3>	obsidian is actually pretty good as a note taking app. it actually leverages electron in its favor due to using normal conventional js in plugins to extend itself.
Mar 09 19:26:55 <Diablo-D3>	a lot of markdown shit is in js, so a lot of plugins just drop the existing in-browser markdown transnformers into obsidian, and it just magically works
Mar 09 19:27:11 <FireFly>	using JS in plugins to extend things is something we had 10 years ago too :p
Mar 09 19:27:48 <FireFly>	but ye obsidian seems fine-ish
Mar 09 20:40:39 <_Vi>	Is there some drawing abstraction crate where I can draw lines, rectangles, polygons, texts and so on and render them into HTML canvas from wasm, rasterize and save to png, or save as svg (e.g. using different downstream crates)?
Mar 09 20:56:54 <danieldg>	_Vi: tiny-skia
Mar 09 20:58:05 <danieldg>	it doesn't do text (directly) though; you could use resvg to do that I think
Mar 09 20:58:26 <danieldg>	resvg will do svg stuff
Mar 09 21:01:34 <_Vi>	Will it allow placing text as a text (not a path or rasterized bitmap) into svg while still allowing to render it for immediate displaying?
Mar 09 21:02:24 <danieldg>	I think usvg (the resvg backend) might support that.  Not tried the svg output part though.
Mar 09 21:04:11 <danieldg>	if your goal is to export to svg, you'd want to do all your drawing by modifying the svg tree
Mar 09 21:04:11 <_Vi>	Will it skip those XML things in case where svg is not involved (e.g. just directly paint things on a HTML canvas)?
Mar 09 21:04:33 <danieldg>	no
Mar 09 21:06:48 <_Vi>	Or maybe closer to "yes"? "... strongly-typed tree structure", "... layer between an XML library and a potential SVG rendering library". If something renders to usvg tree (without actually being a real svg file), then rendering can be simpler and involve less overhead?
Mar 09 21:07:54 <danieldg>	maybe
Mar 09 21:08:31 <danieldg>	if you're in a browser, having the browser do the rendering is likely to do better (it can use the gpu, for one)
Mar 09 21:09:36 <danieldg>	and it'll also do things like support links in your svg documents, which usvg calls out as not supported
Mar 09 21:10:28 <capitol>	and javascript :P
Mar 09 21:11:02 <danieldg>	right, you'd have to have a wasm engine in your wasm engine to do that
Mar 09 21:11:11 <_Vi>	Can resvg or usvg or tiny-skia provide something that looks like a canvas API, but that will actually produce a SVG file at the end?
Mar 09 21:11:17 <danieldg>	no
Mar 09 21:11:55 <danieldg>	maybe usvg could do that, but I don't think it has editing support
Mar 09 21:13:00 <danieldg>	for that you'd want an svg creation or editing crate
Mar 09 21:13:26 <_Vi>	Or is there some other "easy mode" API to create new SVG files without dealing with tricky SVG details? Is svg file -> usvg tree a one-way conversion or compatible svg files can be round-tripped though usvg tree?
Mar 09 21:14:28 <danieldg>	'svg' crate might do it.  I've not used it.
Mar 09 21:15:44 <_Vi>	OK. Thanks for the advices.
Mar 09 21:16:49 <danieldg>	yeah, 'svg' looks pretty simple but exactly what you'd want
Mar 09 21:42:18 <TimMc>	Oh man, coding stuff up in Rust is so slow... and yet it feels really rewarding.
Mar 09 21:42:42 <TimMc>	I think it's taking me back to when I was first learning to program (in anything).
Mar 09 21:46:46 <lambda>	in my experience, the extra time I spend writing Rust as opposed to e.g. C or python, I get back severalfold by not having to debug it - it just works
Mar 09 21:50:42 <TimMc>	Oh, no doubt.
Mar 09 21:54:45 <pflanze>	Is there a way to specify for a type that it shall never implement Clone (nor Copy, of course) in the future? I.e. a way to make compilation fail if someone does.
Mar 09 21:55:36 <danieldg>	no, negative trait bounds aren't stable
Mar 09 21:55:50 <pflanze>	Ah, so something's in the making, amazing.
Mar 09 21:56:06 <danieldg>	not sure if that one will ever be stable
Mar 09 21:56:18 <danieldg>	specialization could do it too (another unstable feature)
Mar 09 21:56:24 <pflanze>	OK.
Mar 09 21:56:48 <danieldg>	for !Copy, you could require that it impl Drop
Mar 09 21:57:20 <danieldg>	!Clone doesn't really restrict anything; you can always write a "fn clone(&self)" after all
Mar 09 21:57:54 <danieldg>	what are you actually trying to do?
Mar 09 21:58:50 <pflanze>	I've just been pondering how to make sure nobody breaks something by haphazardly adding #[derive(Clone)] to some type I know can't be cloned.
Mar 09 21:59:04 <danieldg>	pflanze: you could always write a must-compile-fail test that tries to pass your thing to an f<T:Clone>()
Mar 09 21:59:15 <pflanze>	Ah, good idea.
Mar 09 21:59:38 <pflanze>	Hmm, how would you do that though?
Mar 09 21:59:48 <pflanze>	Via build.rs or something?
Mar 09 22:00:10 <danieldg>	not sure.  Someone has done it, I've see it in testing proc macros
Mar 09 22:00:31 <pflanze>	OK. I'll keep those answers in mind, it's nothing urgent.
Mar 09 22:00:44 <Alexendoo>	trybuild or ui_test
Mar 09 22:00:57 <pflanze>	Thanks!
Mar 09 22:02:54 <danieldg>	you could also add a field whose type is deliberately not Clone
Mar 09 22:03:13 <danieldg>	you could call it PhantomNonClone to be blatant
Mar 09 22:06:03 <pflanze>	Heh, true
Mar 09 22:42:23 <lmat>	{ let me : f64 = 2.0; if &me == 3.0 { println!("equel"); } }
Mar 09 22:42:25 <lmat>	What does this mean?
Mar 09 22:42:51 <lmat>	evalr: { let me : f64 = 2.0; if &me == 3.0 { println!("equel"); } }
Mar 09 22:42:53 -evalr/##rust-	lmat: error[E0277]: can't compare `&f64` with `{float}` ...
Mar 09 22:42:54 -evalr/##rust-	lmat: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=c86fda5dca001431500188a78171f92b
Mar 09 22:43:29 <lmat>	In my code, this is a function:   fn fun(me : &f64) { if me == 0.0 .... }
Mar 09 22:43:29 <j`ey>	just use me, not &me
Mar 09 22:43:30 <j`ey>	?
Mar 09 22:43:44 <j`ey>	why are you passing &f64?
Mar 09 22:43:51 <j`ey>	why not f64?
Mar 09 22:44:14 <danieldg>	lmat: if you want to do that, use *me
Mar 09 22:44:27 <danieldg>	lmat: but passing f64 is basically always more efficient than passing &f64
Mar 09 22:44:55 <lmat>	j`ey: I don't know... the function is actually more like this:     avgs.iter().zip(others).map(|(lhs, rhs)| { if lhs == 0.0 ... }   avgs and others is a Vec<f64>.
Mar 09 22:45:19 <j`ey>	|(&lhs, &rhs)|
Mar 09 22:45:23 <danieldg>	right, then use *, or annotate the closure args like that ^^
Mar 09 22:45:27 <j`ey>	stop changing your question :P
Mar 09 22:45:56 <lmat>	j`ey: Sorry, I'm trying to to give you my whole codebase and say, "fix it" :-P
Mar 09 22:46:03 <lmat>	s/to to/not to/
Mar 09 22:46:34 <j`ey>	basically you cant compare &f64 to f64, so you have to deref it
Mar 09 22:46:42 <lmat>	(&lhs, &rhs) is a pattern that says "get the value of the first element in the tuple and assign it to lhs (same for rhs)"?
Mar 09 22:48:17 <j`ey>	something like that yeah
Mar 09 22:49:46 <lmat>	https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=4f70c225f58a01aa4383bd976fdcbb16  but that only goes for one of the arguments???
Mar 09 22:50:33 <j`ey>	because you wrote zip(others)
Mar 09 22:50:39 <j`ey>	not zip(others.iter())
Mar 09 22:51:11 <lmat>	:-D
Mar 09 22:52:01 <lmat>	j`ey: Ahh, zip takes (a:A, b:B), not (a:&A, b:&B). I didn't expect that.
Mar 09 22:52:42 <j`ey>	yeah because with a: A, you can pass &A
Mar 09 22:52:48 <j`ey>	but you cant pass A to a: &A
Mar 09 22:56:59 <lmat>	j`ey: nice
Mar 09 22:57:50 <pflanze>	The "backtrace" crate has stopped giving me useful output. I last used it a while ago and it was fine in one of the compilation modes (release or debug, not sure which anymore), but now it won't give me line numbers except for core files, and it won't give me a full backtrace in debug mode at all. I've upgraded to the newest version, still same.
Mar 09 22:58:20 <pflanze>	I'm on Debian stable, rustc from Debian. Anyone seen anything similar, any idea?
Mar 09 23:03:32 <pflanze>	Hmm, getting line numbers now in latest backtrace version *in debug mode with mold as linker*
Mar 09 23:12:33 <evaloop>	pflanze: l'l use -C link-args=-fuse-ld=mold and any kind cargo command with -vvv, also if BACKTRACE=1 disabled or not prowided as option for debug or just can use DEBUG_RUSTFLAGS="-C debuginfo=2 :) or l'm not exact mean what :D
Mar 09 23:17:13 <evaloop>	pflanze: mb I was wrong about that, but for me that worked. Mine rust
Mar 09 23:17:13 <evaloop>	Version: 1:1.76
Mar 09 23:18:14 <evaloop>	*provided
Mar 09 23:19:06 <evaloop>	mistake correction after send D:
Mar 09 23:21:22 <evaloop>	Also can pass that backtrace before cmd command
Mar 09 23:22:30 <evaloop>	like that maybe BACKTRACE=1 crabgo build/test/install/orelse somecrap -vvv
Mar 09 23:23:29 <pflanze>	I'm using the "backtrace" crate, I'm not referring to the panic feature, which may use different code (the backtrace crate seems to say so)
Mar 09 23:23:54 <Beladona>	HI
Mar 09 23:23:57 <Beladona>	Any clue here? https://imgur.com/ydOcc8g.png
Mar 09 23:24:19 <pflanze>	(evaloop, I'm referring to "backtrace" crate version 0.3.69)
Mar 09 23:26:35 <pflanze>	(I am recompiling with -C debuginfo=2 to see how that goes)
Mar 09 23:33:26 <evaloop>	pflanze: also suggest maybe, sometime's l'l use xargo because maybe now is no-std crate, xargo mostly nice for no-std custom action.
Mar 09 23:35:07 <pflanze>	Adding debuginfo=2 doesn't make a difference for me now (with newest 'backtrace' and mold), both debug and release outputs are unchanged, release remains broken. But whatever, it's ok for me to have to use debug mode right now.
Mar 09 23:43:07 <evaloop>	mold is just linker for speed-up and size, great tool, -vvv expand view of borrow checker at compile/link time, maybe best way for mkae review or debug is use -vvv (max verbosive output)
Mar 09 23:45:34 <j`ey>	pflanze: and your rustc didnt change?
Mar 09 23:46:23 <j`ey>	nvm strip isnt by default, I thought it was for release
Mar 09 23:47:46 <evaloop>	rustc 1.76.0 --version
Mar 09 23:47:53 <pflanze>	j`ey, I did move to different hardware (both intel amd64 though); same Debian release, though, although the first was in a chroot and possibly not up to date
Mar 09 23:48:37 <pflanze>	Also, using nested threads now (scoped thread pool); larger code base.
Mar 09 23:48:38 <evaloop>	oh D:
Mar 10 00:08:15 <Beladona>	fixed
**** BEGIN LOGGING AT Sun Mar 10 00:21:17 2024

Mar 10 00:21:17 *	Now talking on ##rust
Mar 10 00:21:17 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 10 00:21:17 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** BEGIN LOGGING AT Sun Mar 10 00:22:47 2024

Mar 10 00:22:46 *	Now talking on ##rust
Mar 10 00:22:46 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 10 00:22:46 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** BEGIN LOGGING AT Sun Mar 10 00:27:38 2024

Mar 10 00:27:38 *	Now talking on ##rust
Mar 10 00:27:38 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 10 00:27:38 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** BEGIN LOGGING AT Sun Mar 10 00:31:42 2024

Mar 10 00:31:41 *	Now talking on ##rust
Mar 10 00:31:41 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 10 00:31:41 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Mar 10 00:50:35 <neiluj>	Hi! Got a function parametrized by these traits: https://bpa.st/QJ7A. Except a function I'm calling would require further type constraints:  ScalarField = G2Cfg::ScalarField additionally. Is it possible to enforce this?
Mar 10 01:25:42 <pflanze>	neiluj, G2Cfg::ScalarField is a type, not a trait, right?
**** BEGIN LOGGING AT Sun Mar 10 01:38:21 2024

Mar 10 01:38:20 *	Now talking on ##rust
Mar 10 01:38:20 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 10 01:38:20 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Mar 10 01:38:45 <neiluj>	now getting the error `T` cannot be shared between threads safely for a struct containing a PhantomData<T> field
**** BEGIN LOGGING AT Sun Mar 10 01:52:09 2024

Mar 10 01:52:08 *	Now talking on ##rust
Mar 10 01:52:08 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 10 01:52:08 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Mar 10 02:09:05 <TimMc>	Is there some sort of abstraction in Rust's ecosystem for "pull from a stream until you've got all the data"?
Mar 10 02:09:17 <neiluj>	fixed my issue
Mar 10 02:09:24 <TimMc>	\o/
Mar 10 02:09:41 <neiluj>	just followed the compiler's instructions xD
Mar 10 02:10:19 <TimMc>	I want to send a series of msgpack objects over TCP but it would be cool to not have to precede each with a length header. Theoretically this should be fine since msgpack has its own internal length headers, but I'm just not really sure how to hook everything up.
Mar 10 02:20:06 <danieldg>	TimMc: tokio used to have a decoder abstraction on top of Stream
Mar 10 02:21:06 <danieldg>	or just collect what's available into a buffer and run a msgpack decoder on it.  If the decoder returns "message truncated", then collect some more bytes
Mar 10 02:21:55 <danieldg>	if the decoder doesn't tell you truncated vs malformed, then the header length fields aren't good enough
Mar 10 02:25:04 <danieldg>	it doesn't look like msgpack has a fast length field/header
Mar 10 02:25:44 <TimMc>	Each msgpack object tells you how long it is, but not necessarily in bytes. :-)
Mar 10 02:26:06 <TimMc>	So an array says "I'm 100 elements long" but you don't know how large those are.
Mar 10 02:27:10 <TimMc>	I guess I could write a msgpack decoder that knows how to await more bytes on a stream... meh.
Mar 10 02:28:53 <danieldg>	you could certainly write the decoder as an async fn that takes an async buffered reader that it reads byte by byte
Mar 10 02:29:22 <danieldg>	it's more efficient to just have a length field
Mar 10 02:29:41 <danieldg>	plus it helps reject overlong messages before you start to parse them
Mar 10 03:01:40 <Widdershins>	yeah that's one of the weaknesses of msgpack
Mar 10 03:01:50 <Widdershins>	it's one of the It's Just JSON Except Binary encodings
Mar 10 03:02:30 <Widdershins>	because the whole thing is schemaless they didn't bother to design it in a way that can be skip-parsed
Mar 10 03:03:17 <danieldg>	original json can't be skip-parsed either, so it didn't lose anything
Mar 10 03:03:39 <Widdershins>	yeah. potentially a missed opportunity, potentially a pain in the ass. it's a tradeoff
Mar 10 03:03:55 <Widdershins>	looking at my recent adventures in What If We Encoded Backwards
Mar 10 03:05:16 <Widdershins>	because TLV encodings that have a lot of nesting have a lot of advantages for being able to see the "future"
**** ENDING LOGGING AT Sun Mar 10 04:26:38 2024

**** BEGIN LOGGING AT Sun Mar 10 06:42:23 2024

Mar 10 06:42:22 *	Now talking on ##rust
Mar 10 06:42:22 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 10 06:42:22 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Mar 10 12:21:39 <pflanze>	When implementing a self-referential struct via unsafe, if I never give public write access to the self-referenced data, do I need to Pin it?
Mar 10 12:21:58 <pflanze>	Or am I correct in understanding that Pin just prevents swap in the case that it must be writable?
Mar 10 12:22:36 <pflanze>	I.e. Pin isn't also acting as some kind of move prevention indication to the compiler itself, or is it?
Mar 10 12:24:35 <Mutabah>	pflanze: `Pin` prevents you from getting `&mut` effectively
Mar 10 12:24:48 <Mutabah>	while still allowing ownership
Mar 10 12:25:01 <Mutabah>	it ensures reference/pointer stability
Mar 10 12:25:51 <pflanze>	I have experience with C and C++, so I understand the pointer stability.
Mar 10 12:26:09 <pflanze>	But I get pointer stability by using Box, not Pin.
Mar 10 12:26:30 <Mutabah>	Pin is how unsafe code can assume a pointer is stable, without needing it to be on the heap
Mar 10 12:26:30 <pflanze>	Pin is just to prevent the contents of the box from being replaced. Right?
Mar 10 12:26:59 <Mutabah>	If you make a `Pin<&mut T>` you promise that the `T` won't change addresses until it is dropped
Mar 10 12:27:02 <pflanze>	Hmm, okay, I haven't tried to not put things onto the heap.
Mar 10 12:28:39 <pflanze>	My understanding was that Pin prevents the API users from messing up. Not me promising.
Mar 10 12:29:09 <Mutabah>	It's both kinda
Mar 10 12:29:55 <Mutabah>	`Pin::new_unchecked` is where you promise, and then the user (API or whoever) of the `Pin<Ptr>` can assume that they can take the address/raw-pointer and it'll stay valid until the data is dropped
Mar 10 12:47:23 <pflanze>	Is there any problem with my unsafe usage here?: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=9cb76688f8417ad91003ff0ff5724af2
Mar 10 12:48:39 <j`ey>	miri thinks so
Mar 10 12:48:42 <pflanze>	(My followup question will be, I could leave away the Pin here and the external API would still be safe, no? Although I'll admit the Pin may be useful to protect to some extent from people changing the insides of StringSplit's implementation)
Mar 10 12:49:32 <pflanze>	How are you running miri if it's simple enough to say (if it's involved, I'll go read the docs)
Mar 10 12:50:00 <j`ey>	click miri on the playground :P
Mar 10 12:50:09 <pflanze>	Aha, ok :)
Mar 10 12:50:10 <j`ey>	tools -> Miri
Mar 10 12:50:17 <pflanze>	Now, miri of course won't tell whether my API *could* be misused.
Mar 10 12:50:35 <j`ey>	miri thinks there *is* a problem
Mar 10 12:50:45 <pflanze>	Oh!
Mar 10 12:57:20 <pflanze>	Is there something fundamentally unsafe in my program (i.e. if I used ASAN instead and tried to mis-use the API could I trigger an ASAN violation?), or is it "just" that I should do things slightly differently so that miri is happy?
Mar 10 13:19:24 <narodnik2>	is there a way to specify a trait const usize which is a multiple of some value?
Mar 10 13:20:08 <narodnik2>	struct Foo<const N: usize> where N = 2^k for some k
Mar 10 13:20:18 <narodnik2>	or is the only way to make k the parameter?
Mar 10 13:22:56 <saati>	if it has private fields you could assert it's popcount is 1 in all it's constructors
Mar 10 14:44:18 <Widdershins>	you could also just specify the power-of-2 instead
Mar 10 14:44:53 <Widdershins>	maybe that would look worse though
Mar 10 14:47:00 <saati>	still have to ensure it's lower than 64
Mar 10 14:53:02 <yziquel>	Hi. I just rebuilt rust and cargo from source. anyone knows where the binaries are ?
Mar 10 14:53:25 <yziquel>	there are multiple cargo binaries. stage0, stage 2, etc... what's that ?
Mar 10 14:57:41 <j`ey>	stage0 is built with the existing cargo binary, stage1 is built by stage0
Mar 10 15:06:31 <Alexendoo>	https://rustc-dev-guide.rust-lang.org/building/bootstrapping.html
Mar 10 15:07:00 <Alexendoo>	they'll be in build/host/stage1
Mar 10 15:11:37 <Alexendoo>	bootstrap prints a message telling you what rustup link command to use, usually you want that so you don't have to set LD_LIBRARY_PATH (or whatever platform equivalent) yourself
Mar 10 15:33:49 <yziquel>	Alexendoo for cargo binary, I only see build/x86_64-unknown-linus/[stage0/bin/cargo|stage0-sysroot/bin/cargo|stage2-tools-bin/cargo] and one in src/tools/rust-installer/test/inage3/bin/cargo. No stage 1.
Mar 10 15:34:04 <yziquel>	I did ./x.py build after a ./configure on a raw git checkout.
Mar 10 15:40:01 <Alexendoo>	cargo is not built by default
Mar 10 15:42:58 <yziquel>	urgh. I'd need to build cargo, Alexendoo. Does ./x.py build do incremental builds ? seems so.
Mar 10 15:44:11 <yziquel>	not quite incremental...
Mar 10 15:44:38 <Alexendoo>	Not by default, but e.g. the compiler profile has it on
Mar 10 15:46:16 <Alexendoo>	What are you after build wise?
Mar 10 15:47:30 <yziquel>	Alexendoo I want to fix a virtualisation issue with rustc as it misbhaves it a given setup for an os level reason. I'm hunting down all the wrong calls in the rust codebase.
Mar 10 15:47:42 <yziquel>	on a given setup.
Mar 10 15:48:01 <dav1d>	you're looking at the wrong thing
Mar 10 15:48:16 <yziquel>	dav1d tell me more.
Mar 10 15:48:35 <dav1d>	you're building the compiler when your binary produced by the compiler is failing
Mar 10 15:48:48 <dav1d>	the compiler doesn't magically add mmap calls to binaries
Mar 10 15:48:59 <yziquel>	dav1d no. it is the compiler itself that fails.
Mar 10 15:49:10 <yziquel>	dav1d since 2016.
Mar 10 15:49:11 <dav1d>	ah okay, my bad, misremembering the issue then
Mar 10 15:49:39 <Alexendoo>	You wouldn't need to build cargo in that case, rustup will fall back to your own cargo when you use rustup link
Mar 10 15:49:59 <yziquel>	Alexendoo I need to build cargo because I need to run cargo build to test.
Mar 10 15:49:59 <dav1d>	thought your problem was gix or w/e
Mar 10 15:50:07 <Alexendoo>	you can set `profile = "compiler"
Mar 10 15:50:07 <Alexendoo>	` in config.toml to get incremental and other things
Mar 10 15:50:25 <yziquel>	dav1d my problem is across the whole rust ecosystem.
Mar 10 15:50:36 <Alexendoo>	cargo +stage1 build will work if you use rustup link without building cargo
Mar 10 15:50:55 <dav1d>	yeah the source is gonna be the memmap* crates
Mar 10 15:51:17 <yziquel>	dav1d yes.
Mar 10 15:51:49 <yziquel>	Alexendoo what will rustup do for me ??
Mar 10 15:51:49 <danieldg>	yziquel: just make an LD_PRELOAD hook for mmap that changes everything to MAP_PRIVATE
Mar 10 15:52:37 <dav1d>	^
Mar 10 15:52:46 <Alexendoo>	yziquel: https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#creating-a-rustup-toolchain
Mar 10 15:52:56 <yziquel>	danieldg intervene on the github issue if you claim this does not need fixing. For now, I'm fixing it if only for me. here you go: https://github.com/rust-lang/rust/issues/122262
Mar 10 15:53:01 <danieldg>	or, you know, just learn how to use libvirt.  That's *way* less effort than changing every program you use to not use MAP_SHARED
Mar 10 15:53:18 <yziquel>	danieldg or, you know, fix your 2016-old bug.
Mar 10 15:53:25 <danieldg>	not my bug
Mar 10 15:53:35 <yziquel>	danieldg bug in rust.
Mar 10 15:53:48 <yziquel>	anyway. coffee. flame war -> guthub issue. thx.
Mar 10 15:54:26 <dav1d>	jfc
Mar 10 16:09:50 <saati>	lol sure a shitty fs not supporting MAP_SHARED is a rustc bug
Mar 10 16:11:57 <danieldg>	I'm actually surprised it supports mmap at all
Mar 10 16:12:58 <danieldg>	I guess it'd have to if you wanted to run binaries off it
Mar 10 16:14:09 <yziquel>	saati it's not a rust bug. It's a bug that impacts anyone wanting to virtualise. and there are many.
Mar 10 16:14:21 <yziquel>	saati you can keep denying it has an impact. It has one.
Mar 10 16:14:40 <danieldg>	yziquel: 99.9% of people who virtualize don't hit this bug
Mar 10 16:14:41 <yziquel>	saati and it may be a riust bug. to me, it's 1/3 a rust bug, 2/3 a virtiofs bug.
Mar 10 16:15:01 <yziquel>	danieldg indeed. and the happy few who do do not recognise it.
Mar 10 16:15:54 <yziquel>	danieldg it hits various filesystems since 2016. vboxfs. virtiofs with --cache=never (which is becoming the default in kata containers), and people iusing github actions use workarounds they just copy paste.
Mar 10 16:16:57 <yziquel>	danieldg and i hit it. so i fix it.
Mar 10 16:17:19 <danieldg>	right, I think it's a good feature to add
Mar 10 16:17:23 <danieldg>	but it's more of a feature than a bug
Mar 10 16:18:03 <danieldg>	it's a workaround for filesystems that don't support MAP_SHARED
Mar 10 16:19:48 <polychromata{J}>	pflanze: i think your Pin doesn't cover enough—you need to pin the big string and the little strings together
Mar 10 16:19:59 <danieldg>	but that's nitpciking I guess
Mar 10 16:20:02 <polychromata{J}>	and i think the first error is about your 'static lie?
Mar 10 16:20:53 <polychromata{J}>	but i can't speak to whether it's a violation or a flaunt of the unsafe rules
Mar 10 16:22:37 <yziquel>	danieldg for your sore eyes that will make you cry tears of blood: 99% of people who virtualise do not hit this bug, I did. https://github.com/openzfs/zfs/issues/14989
Mar 10 16:23:14 <yziquel>	https://github.com/openzfs/zfs/issues/14989#issuecomment-1980137649
Mar 10 16:24:12 <yziquel>	shitty CPU. Just throw the computer through the window.
Mar 10 16:25:41 <danieldg>	yeah, that's a bug: if you use a register you didn't tell the kernel to save/restore, then of course it can get corrupted
Mar 10 16:26:06 <danieldg>	no different than using a thing protected by a lock without locking it
Mar 10 16:26:07 <yziquel>	danieldg no. It's a bug in the CPU. Not in ZFS. Intel is at fault. Not openzfs.
Mar 10 16:26:20 <danieldg>	huh
Mar 10 16:26:29 <danieldg>	ah
Mar 10 16:27:43 <yziquel>	intel defecated on themselves when implementing avx512f and fell short of their specs on a vmexit event.
Mar 10 16:28:00 <danieldg>	well that looks like one of the dumber errata I've seen
Mar 10 16:28:22 <danieldg>	usually such things require more moving parts to break stuff
Mar 10 16:28:48 <danieldg>	I guess vmexit is probably complex enough for them to screw it up
Mar 10 16:29:32 <yziquel>	yeah. well, so is MAP_SHARED on virtiofs where the memory mapping goes through qemu's own memory.
Mar 10 16:29:54 <danieldg>	that's merely a missing feature
Mar 10 16:30:00 <yziquel>	¨...
Mar 10 16:48:54 <yziquel>	I still do not see how to build cargo from the rust source repo.
Mar 10 16:48:54 <Vorpal>	I'm trying to figure out a good approach to error handling in command line programs and libraries for command line programs. Anyhow is great, but leads to type-erased errors. That is not always appropriate. thiserror is cumbersome and I haven't gotten backtrace reporting to work great on stable rust for nested errors. That last issue (good error causes with backtraces on stable rust) I consider an absolute requirement. If it weren't for that, snafu would look
Mar 10 16:48:56 <Vorpal>	pretty good for example.
Mar 10 16:49:19 <Vorpal>	so, anyone have any suggestions for what to use?
Mar 10 16:51:08 <Vorpal>	I tried error-stack, but I ran into two major issues: It doesn't play well with other error reporting (so transitioning gradually to it is difficult). It has some support for converting anyhow errors, but that looses backtraces. Also I couldn't figure out how to use an error stack report as an Error type for a TryFrom trait impl
Mar 10 16:51:30 <tokie>	why do you need backtraces ?
Mar 10 16:51:49 <Vorpal>	tokie: I consider them essential for debugging and for bug reports.
Mar 10 16:53:06 <yziquel>	Vorpal indeed.
Mar 10 16:53:44 <Vorpal>	So yeah, anyhow is great (and it is easy to attach additional context on the way up), but not great if there are some cases that you actually want to handle instead of just report.
Mar 10 16:54:27 <dav1d>	Vorpal, you can downcast errors with anyhow
Mar 10 16:54:34 <tokie>	yeah, i would go with anyhow
Mar 10 16:54:35 <dav1d>	in case you havent seen
Mar 10 16:54:54 <tokie>	i've found in practice the "i may need to distinguish between errors!" never usually happens
Mar 10 16:55:17 <tokie>	but i write daemons and not command-line programs, so maybe it's more common ...
Mar 10 16:55:38 <Vorpal>	dav1d: hm I do remember seeing something about it, but didn't try it out since it looked hackish. Not good for a public API in a library (I'm making a tool + a reusable library for some of the functionality of that tool).
Mar 10 16:56:04 <Vorpal>	[16:54] <tokie> i've found in practice the "i may need to distinguish between errors!" never usually happens <-- rare, but certain IO errors. That is usually handled locally though
Mar 10 16:56:11 <dav1d>	Vorpal, then there isn't much left other than writing your own error types, with our without thiserror
Mar 10 16:56:18 <tokie>	Vorpal: lol, yeah, i was about to write that
Mar 10 16:56:56 <Vorpal>	another issue with anyhow is that it's error type can't be serialised. As I will be splitting some functionality into a part that is executed via sudo and then doing unix socket IPC back and forth this kind of matters down the road
Mar 10 16:57:15 <Vorpal>	very niche thing, I know
Mar 10 16:58:05 <Vorpal>	dav1d: is there a way to get backtraces to work well with thiserror though? Essentially I want the full on anyhow error handler with "foo, caused by bar, caused by quux, here is a helpful stacktrace if you ran with RUST_BACKTRACE=1"
Mar 10 16:58:25 <tokie>	Vorpal: not so niche! are we coworkers? lol
Mar 10 16:59:39 <Vorpal>	tokie: I'm basically doing a rewrite of https://github.com/CyberShadow/aconfmgr in rust (and with pluggable support for other distros, not just arch). Or that is the plan. So far I wrote some more basic tools that I will need (https://github.com/VorpalBlade/paketkoll)
Mar 10 17:00:03 <Vorpal>	but yeah I use anyhow there, and I'm running into the serialisation issue
Mar 10 17:00:38 <Vorpal>	as well as, the paketkoll_core library having anyhow in it's public API (that API is very much WIP currently)
Mar 10 17:00:43 <tokie>	ohh god, that's all bash
Mar 10 17:00:45 <tokie>	good luck
Mar 10 17:01:18 <Vorpal>	tokie: despite it being bash (I'm probably going with rhai for user config) it actually works extremely well.
Mar 10 17:02:49 <Vorpal>	I wish the provider API got stabilised. Then all of this would just work with snafu etc.
Mar 10 17:03:20 <dav1d>	Vorpal, pretty sure you'd have to capture the backtrace yourself. But tbh might just write the error types yourself without thiserror
Mar 10 17:03:36 <dav1d>	also neat seeing something from CyberShadow
Mar 10 17:03:45 <Vorpal>	oh? you know them?
Mar 10 17:04:06 <Vorpal>	so much boiler plate. Maybe I'll make my own macro to generate error types. Wait a sec...
Mar 10 17:04:28 <dav1d>	yeah from my time doing D
Mar 10 17:04:40 <dav1d>	Vorpal, it's not that bad tbh
Mar 10 17:05:00 <dav1d>	but yeah nothing a macro_rules cant solve
Mar 10 17:05:08 <Vorpal>	mhm
Mar 10 17:05:42 <dav1d>	but thiserror also has #[backtrace], but I've never used it
Mar 10 17:06:59 <Vorpal>	think you still have to capture the backtrace yourself (or take it from a source error)
Mar 10 17:07:24 <tokie>	most of the stuff i write uses thiserror to format errors, but they eventually bubble up into a boxed error like anyhow anyway
Mar 10 17:07:25 <tokie>	so sorta a mix
Mar 10 17:07:31 <dav1d>	yep
Mar 10 17:07:32 <tokie>	but thiserror is nice for formatting the text
Mar 10 17:07:41 <dav1d>	but you can use it to generate the boilerplate
Mar 10 17:07:43 <Vorpal>	it indeed is
Mar 10 17:07:44 <tokie>	yep
Mar 10 17:08:24 <Vorpal>	not sure how to extract the causes and backtraces in the end (like when you return anyhow::Result from main)
Mar 10 17:08:25 <tokie>	just panic and let sentry manage the backtraces
Mar 10 17:08:30 <tokie>	:x
Mar 10 17:08:36 <Vorpal>	hah, nah thanks
Mar 10 17:09:54 <Vorpal>	Error handling in closures is awkward. I use rayon a lot in this project, so I keep running into that.
Mar 10 17:10:25 <tokie>	oh wow
Mar 10 17:11:06 <Vorpal>	Speaking of rayon: sensible backtraces is something it doesn't have. Something I notice when profiling with perf and try to find my own code in the mess of workstealing schedulers. Basically top down flamegraphs are unusuable
Mar 10 17:11:17 <Vorpal>	tokie: hm?
Mar 10 17:12:49 <tokie>	i just never see anyone using rayon. it's nice to see a use case !:P
Mar 10 17:14:06 <Vorpal>	tokie: doing many independent things as fast as possible is a use case
Mar 10 17:14:42 <Vorpal>	which perfectly fits what paketkoll is doing (loading package metadata from many separate files, calculating checksums, walking the the whole file system, etc)
Mar 10 17:20:43 <TimMc>	Oh man, my 300 line program worked perfectly on the first run!
Mar 10 17:20:54 <TimMc>	(Well, the first run where I didn't fat-finger the command line, haha)
Mar 10 17:21:10 <yziquel>	TimMc that's the kind of experience I initially had with OCaml before rust.
Mar 10 17:35:08 <yziquel>	fed up with these annoying git submodules.
Mar 10 17:36:17 <Vorpal>	yziquel: would you say that ocaml (or other MLs) have anything to offer if I learned Rust first?
Mar 10 17:36:46 <yziquel>	Vorpal you want a theological debate ?
Mar 10 17:38:24 <Vorpal>	yziquel: nah, just wondering if it has any neat ideas. I believe that learning more languages makes you a better programmer in all of them
Mar 10 17:38:40 <yziquel>	My opinion: I wish rust syntax was more ocaml like and ocaml could tackle the metal more. ocaml is quicker to develop prototype and has a nicer type-reasoning-feel to it. but it can't reason about lifetimes. Though it does not support some unique keywords allowing for type level resource management.
Mar 10 17:38:42 <Vorpal>	I don't code in scheme, but I think learning a LISP made me think differently
Mar 10 17:38:47 <gastus>	Vorpal: lanugage + ecosystem + knowledge => time to complete a task. You don't teven know your task.
Mar 10 17:38:57 <yziquel>	it does now support
Mar 10 17:39:26 <yziquel>	gastus there are other reasons to dive into a language. Languages are not only tools.
Mar 10 17:39:29 <Vorpal>	hm, interesting
Mar 10 17:39:58 <yziquel>	Vorpal I'd say library support is richer in rust. But I wish rust had ocaml's gc.
Mar 10 17:40:03 <yziquel>	as an option.
Mar 10 17:40:26 <Vorpal>	yziquel: as someone who do command line tools as well as full on embedded I'm so happy rust doesn't have a GC
Mar 10 17:41:19 <Vorpal>	at dayjob we are starting to eye rust (currently C++). With a GC that flat out wouldn't be an option (hard realtime, industrial equipment controller software)
Mar 10 17:41:21 <yziquel>	Vorpal yes. but I'd rather it have an OPTIONAL gc. though that would impact the ecosystem and it would be less friendly to embedded. so....
Mar 10 17:41:44 <gastus>	So Java OO (+ weaving, pointcutns), Python/JS (dynamic), TS = learn that you can type dynamic stuff so is good for tasks requiring such. Haskell/Nix => lazy expressions, Rust, borrowing, urweb shows how crazy you can go about type level, Nim shows that you can have multiple GC implementations within one language.
Mar 10 17:41:49 <Vorpal>	yziquel: it wouldn't be optional. Because a ton of crates you would want to use would suddenly depend on it
Mar 10 17:41:53 <yziquel>	Vorpal it is possible to have real time concurrent gcs. you just do not find them around much. except in the litterature.
Mar 10 17:41:58 <Vorpal>	yziquel: it would be worse than the async/blocking split
Mar 10 17:42:28 <gastus>	Talking about no GC: https://github.com/fitzgen/bumpalo seems to a link also talking about nightly option to pass allocator.
Mar 10 17:42:33 <yziquel>	Vorpal I disagree.
Mar 10 17:42:51 <yziquel>	gastus yes, I'm about to start using bumpaloo for my gc-like requirements
Mar 10 17:43:22 <gastus>	The question I have is more like how to write code which can do both. Like let X = fun(); and have fun use a throw away allocator. Like with with_throw_away do .. code here  and once the block is done have all data erased.
Mar 10 17:43:33 <yziquel>	gastus I need heavily recursive data structure, and rust rules that out without something like bumpaloo anyway.
Mar 10 17:43:46 <Vorpal>	bumpalo is not a GC, it is a bump arena allocator.
Mar 10 17:43:52 <gastus>	The pattern of rewriting libraries (haskell with / without monad) js (with without async) .. rust (with different GC) feels annoying.
Mar 10 17:44:21 <yziquel>	gastus I believe GC should be available but optional. But only later than now, as that would otherwise submerge the ecosystem with gc compatible libs and embedded world would be left dangling.
Mar 10 17:44:25 <Vorpal>	seems quite different to me. I have tried bumpalo in one single-threaded project that did lots of small allocations. Couldn't measure any statistically signficant speedup, so gave up on that
Mar 10 17:45:34 <gastus>	And that's what I was told, too. I wrote my .so file which rewrote malloc. Same for me. So looks like the typcial malloc implementaions do a good job.
Mar 10 17:45:39 <yziquel>	Vorpal try writing a custom lambda-calculus semi-compiled semi-interpreted nonsense. you'll see you'll need hairy memory management and bumpaloo is much like the small heap of ocaml's garbage collector anyway.
Mar 10 17:45:42 <Vorpal>	also bumpalo doesn't play nice with rayon from what I can tell. You could have a bump allocator per thread (bumpalo-heard implements this) but with rayon you don't really know which thread you are on at any time (and you are supposed to get the allocator at the start since that is expensive). Maybe with a thread local, but eww.
Mar 10 17:46:28 <nullie>	hi, which library can I use to make Cookie header from cookie values?
Mar 10 17:46:28 <Vorpal>	yziquel: yeah never done that, I have written a BrainFuck compiler, but that is quite different memory management wise
Mar 10 17:46:32 <yziquel>	Vorpal there is bumpaloo herd. or something like that for rayon support. Not on my roadmap for the moment.
Mar 10 17:46:47 <Vorpal>	yziquel: I just mentioned it?
Mar 10 17:47:08 <yziquel>	Vorpal ah. yes.
Mar 10 17:48:33 <Vorpal>	so yeah bumpalo-heard doesn't fit rayon par_iter() workflow. If you are managing your own long-lived scoped threads I think it could work though
Mar 10 17:49:00 <yziquel>	Vorpal I have other things in mind for that kind of stuff. but i'll say no more.
Mar 10 17:49:01 <Vorpal>	and I can't even begin to imagine the horrors of trying to deal with this in thread locals. The borrow checker won't be happy
Mar 10 17:49:54 <Vorpal>	yziquel: I ended up using lasso for a thread safer string interner instead. That works surprisingly well for heavily reused strings
Mar 10 17:50:09 <Vorpal>	thread safe* (I wonder what thread safer is!)
Mar 10 17:51:49 <yziquel>	Vorpal I don't believe rust's type checker should be force into doing some kind of LTA+ analysis.
Mar 10 17:52:04 <Vorpal>	LTA+?
Mar 10 17:52:46 <Vorpal>	brb, my 3D printer just signaled it finished
Mar 10 17:56:45 <yziquel>	LTA+ is an old specification language (and more) in which you can reason about temporal assignments and prove stuff about distributed computing. Like byzantine problems solutions such as Paxos or Raft. Rust's borrow checker is cool for type systems and language, but does not rise IMO to the standard of such old technologies.
Mar 10 17:56:50 <yziquel>	Vorpal
Mar 10 17:57:30 <tokie>	Vorpal: i wrote a scheme compiler and i write very little scheme ! i think just implementing scheme is an interesting exercise
Mar 10 17:57:47 <Vorpal>	yziquel: the thing with the borrow checker is that it is (somewhat) quick. I suspect the more complicated the slower it would be. Possibly undecidable even.
Mar 10 17:57:56 <Vorpal>	thanks to Rice's theorem
Mar 10 17:58:01 <yziquel>	Vorpal dunno. depends.
Mar 10 17:58:28 <yziquel>	many fragments of logic are suprisingly decidable.
Mar 10 17:59:16 <yziquel>	Much can be combined with Nelson-Oppen. so...
Mar 10 18:03:09 <yziquel>	Can't build rust because I can't fetch the gccjit git submodule. I'm feeling more and more murderous.
Mar 10 18:04:12 <Vorpal>	that is a weird non-standard backend isn't it?
Mar 10 18:04:21 <Vorpal>	you surely shouldn't need that for standard rust
Mar 10 18:04:46 <yziquel>	Vorpal. dunno. I tried the build instructions. ./x setup and ./x check. "can't fetch gccjit".
Mar 10 18:05:36 <yziquel>	Vorpal trying ./configure and ./x.py build. we'll see if it changes something.
Mar 10 18:05:41 <yziquel>	i hate these opaque build systems.
Mar 10 18:06:40 <yziquel>	seems to build something. but I want to get cargo to be built. I still do not know how to do that.
Mar 10 18:09:29 <yziquel>	and you have to log in to get to zulip. i'm annoyed.
Mar 10 18:13:13 <Vorpal>	yziquel: had to deal with hand written Makefiles earlier today, even worse
Mar 10 18:13:31 <yziquel>	Makefiles have been getting better nowadays.
Mar 10 18:26:00 <yziquel>	too long to build
Mar 10 18:29:48 <yziquel>	too long to build
Mar 10 19:03:20 <neiluj>	Hi! seeing that a portion of my application can take up to 80ms to acquire a lock on a mutex, is there a way to avoid waiting too long?
Mar 10 19:03:34 <nullie>	 Can I get raw HTTP request bytes from reqwest::Request?
Mar 10 19:03:59 <rbox>	 neiluj wait until the mutex is not locked b efore acquiring it
Mar 10 19:05:19 <bertptrs>	neiluj: std mutex doesn't offer anything useful for it, but parking_lot offers try_lock_for and try_lock_until which both effectively support some timeout
Mar 10 19:06:45 <dav1d>	neiluj, you can with a Condvar
Mar 10 19:07:02 <dav1d>	which has a wait_timeout method
Mar 10 19:07:42 <bertptrs>	dav1d: that requires you already having the guard
Mar 10 19:09:11 <dav1d>	bertptrs, I guess it's tricky
Mar 10 19:09:23 <bertptrs>	it does something entirely unrelated, rather
Mar 10 19:09:34 <dav1d>	you'd have the guard, unlock it with the condvar just to wait on it, probably not what you'd want
Mar 10 19:10:33 <dav1d>	yeah brainfart, thought you could make it work
Mar 10 19:10:40 <yziquel>	how does cargo select the rustc software to run ? how coupled is it to it ?
Mar 10 19:11:16 <yziquel>	yziquel because if I have to run cargo to debug rustc, I need to control that selection. otherwise, it's useless trying to make a fix and build it if i can'trun it.
Mar 10 19:14:37 <dav1d>	yziquel, RUSTC env var
Mar 10 19:15:10 <dav1d>	(or override it in .cargo/config.toml)
Mar 10 19:20:18 <neiluj>	oh nice thanks bertptrs!
Mar 10 19:21:43 <neiluj>	thanks rbox, too!
Mar 10 20:02:35 <OwlWizard>	ive just read about rust's matching and i have to say this seems like one of the most powerful parts of the langugae
Mar 10 20:03:32 <rbox>	its not that differnt from like switch
Mar 10 20:03:38 <bertptrs>	matching is so good most many major languages have started to incorporate it as well
Mar 10 20:03:45 <bertptrs>	rbox: it's much more powerful than a switch
Mar 10 20:03:48 <polychromata{J}>	It's pretty hecking different from switch as in C.
Mar 10 20:03:53 <polychromata{J}>	Or even switch as in JavaScript.
Mar 10 20:04:04 <bertptrs>	python and java introduced their own matching recently (ish)
Mar 10 20:04:10 <rbox>	guess i'm not that easily impressed
Mar 10 20:04:10 <polychromata{J}>	Rust didn't introduce it, though; Haskell and probably similar languages have had it for a while. :)
Mar 10 20:04:26 <bertptrs>	it's pretty common in functional langauges, yes
Mar 10 20:04:36 <polychromata{J}>	In every other language i try to use, i miss match{} /so bad./
Mar 10 20:04:58 <OwlWizard>	i find the match guard feature to be extremely cool
Mar 10 20:05:19 <polychromata{J}>	Swift actually beat Rust to that one by several years, heh.
Mar 10 20:06:05 <bertptrs>	If swift wasn't so hard to get working under linux I'd probably like it a lot. it makes a lot of nice choices
Mar 10 20:06:05 <spb>	matching is only the same as a switch statement if you never use enums with fields
Mar 10 20:06:12 <OwlWizard>	iirc the point of rust isnt to invent everything
Mar 10 20:06:16 <j`ey>	r nesting
Mar 10 20:06:20 <j`ey>	*or
Mar 10 20:06:29 <spb>	can't nest if your enums have no fields
Mar 10 20:07:59 <bertptrs>	even then you can still match on for example chars much more elegantly than it would be with a switch-case
Mar 10 20:08:49 <bertptrs>	match c { 'a'..='z' => Type::LowerCase, 'A'..='Z' => Type::UpperCase … etc
Mar 10 20:14:09 <polychromata{J}>	Is there a way to impl AsyncRead for a type where the data comes not from an underlying reader but rather from other tasks that push data in by calling async methods with /borrowed/ buffers?
Mar 10 20:14:42 <polychromata{J}>	I can conceptualise this in terms of rawpointers, and i feel like it's sound, but to write it with safe code i think i'd need like a channel over references with lifetimes i couldn't write.
Mar 10 20:16:14 <polychromata{J}>	Essentially the problem is transporting the borrow from the push method to where poll_read can get at it.
Mar 10 20:17:00 <bertptrs>	a VecDeque of pushed data and a mutex to guard it?
Mar 10 20:19:11 <danieldg>	polychromata{J}: you have to transfer ownership out of the writing task
Mar 10 20:19:20 <bertptrs>	Maybe I'm misunderstanding the problem
Mar 10 20:19:22 <danieldg>	even with unsafe you'd have to do that
Mar 10 20:20:41 <danieldg>	a shared buffer is a good way to do it, and pretty easy to do safely if you don't need to hold a lock on the buffer for long periods
Mar 10 20:21:00 <danieldg>	(that is, nothing like calling AsyncRead to fill the buffer)
Mar 10 20:21:39 <polychromata{J}>	bertptrs: That's the simple solution, right. The thing is that it introduces a third, intermediate buffer—and if my choice of size for this third buffer is too small for the usecase, it'll spin in async executor code a lot unnecessarily when it could have just copied straight from the source buffer to the sink buffer.
Mar 10 20:22:21 <danieldg>	polychromata{J}: move the buffer's ownership instead of the data
Mar 10 20:22:37 <polychromata{J}>	It's not an owned buffer.
Mar 10 20:22:37 <bertptrs>	polychromata{J}: you know what they same about the time to start optimizing
Mar 10 20:22:48 <bertptrs>	they say*
Mar 10 20:25:27 <polychromata{J}>	Unsafely, i could make the method that pushes data return a future that borrows the buffer, passes a rawpointer to it, wakes tasks that are waiting to read, and resolves after receiving a signal that the reads are done.
Mar 10 20:26:14 <polychromata{J}>	…maybe i should actually write this out and reframe my question as “how do i make this /safe/”?
Mar 10 20:26:45 <danieldg>	polychromata{J}: and if your push method gets cancelled halfway through?
Mar 10 20:27:05 <danieldg>	I bet that path is what would make things unable to be safe
Mar 10 20:28:34 <polychromata{J}>	hmmm.
Mar 10 20:29:51 <danieldg>	it's basically the same as sending a reference to another thread, which is unsafe without scoped threads
Mar 10 20:30:30 <danieldg>	in fact futures usually can run on another thread
Mar 10 20:30:41 <polychromata{J}>	Right. The thing is, the actual sharing is so short in scope that i figured there must be way to make it work?
Mar 10 20:30:59 <polychromata{J}>	The sharing only needs to last for the length of one poll_read call.
Mar 10 20:31:09 <polychromata{J}>	And that just copies a buffer.
Mar 10 20:31:30 <danieldg>	Arc<Mutex<Buffer>>
Mar 10 20:31:41 <polychromata{J}>	…where buffer = &[u8]
Mar 10 20:31:56 <danieldg>	no, Buffer = Vec<u8>
Mar 10 20:32:00 <polychromata{J}>	hence my “references with lifetimes i couldn't write”
Mar 10 20:32:41 <danieldg>	this is a reason the bytes::Bytes buffers are owned
Mar 10 20:32:42 <polychromata{J}>	See, but then i'm allocating a Vec, which takes us back to “introduces a third, intermediate buffer”
Mar 10 20:34:02 <danieldg>	so you can't get ownership of the first *or* last buffer in any way?
Mar 10 20:35:27 <danieldg>	then yeah, I agree, you can do it with unsafe but not with safe lifetimes
Mar 10 20:35:33 <polychromata{J}>	Right. The push calls work on borrowed data (&[u8], which is borrowed from some other struct, which is borrowed from something else), and poll_read reads into a borrowed buffer
Mar 10 20:37:09 <danieldg>	basically during the copy operation, you must ensure that both buffers are valid, but no single rust function will have more than one available as a parameter
Mar 10 20:37:27 <bertptrs>	You could try to lazily use the buffer. have asyncread mark the entire struct as "I've got a dest buffer for you", and then when a push comes, check if there's a reader waiting, if so, copy to reader, else copy to intermediate
Mar 10 20:37:48 <bertptrs>	Do some destructor magic to ensure the state remains valid
Mar 10 20:38:04 <danieldg>	that's one way to do it with unsafe, eys
Mar 10 20:39:06 <danieldg>	you can actually do it both ways: have enum ChannelState { ReaderHere(*const [u8]), WriterHere(*mut [u8]), OnlyDataHere(Vec<u8>), Empty }
Mar 10 20:40:02 <danieldg>	the push-data transitions Empty->ReaderHere; on Drop it copies and moves to OnlyDataHere
Mar 10 20:40:12 <bertptrs>	I think you have to have the buffer always, to deal with over and underflowing buckets
Mar 10 20:40:22 <danieldg>	the writer (not poll_read, an actual async read) can do the same
Mar 10 20:41:24 <danieldg>	if you insist on poll_read and poll_write, it's impossible; if you get async fn read+async fn write, you can use the full enum; one async + one poll is only that direction 'Here'
Mar 10 20:41:57 <danieldg>	it sounds like you have async write + poll_read right now
Mar 10 20:42:05 <polychromata{J}>	Yep.
Mar 10 20:42:11 <polychromata{J}>	Hmmmmm.
Mar 10 20:42:53 <polychromata{J}>	Alright. Thank you! ^.^
Mar 10 20:43:07 <danieldg>	and the ChannelState must go in an Arc<Mutex<, with Drop on a guard held by the writer locking the mutex
Mar 10 20:43:29 <polychromata{J}>	…oh, there /is/ still a mutex involved.
Mar 10 20:43:32 <danieldg>	yep
Mar 10 20:43:39 <polychromata{J}>	…that makes sense.
Mar 10 20:43:51 <danieldg>	atomics aren't good enough for this
Mar 10 20:44:00 <danieldg>	you need a wait capability
Mar 10 20:44:17 <polychromata{J}>	Yeah.
Mar 10 20:58:24 <Vorpal>	I tried the coz profiler (https://github.com/plasma-umass/coz) which seemed interesting, the idea is it that it can find things that won't stand out in other profilers. A pain to set up (bit rotted academic code, had to get various patches from PRs to make it work on modern Arch Linux with modern DWARF-5). But it found something that hadn't been on my radar. It told me that several functions in some [u8] with hex data -> decoded [u8] functions were slow. So I
Mar 10 20:58:25 <Vorpal>	went ahead and switched out the hex decoding to the faster-hex crate. Runtime went from 287 ms to 268 ms. So it works.
Mar 10 20:59:17 <Vorpal>	Quite a pain to manually add "progress points" etc to the code, and set it up as a looping thing.
Mar 10 20:59:43 <capitol>	this sounds like a nice blog post :)
Mar 10 21:00:04 <nullie>	Vorpal: is it even statistically significant improvement?
Mar 10 21:01:26 <Vorpal>	nullie: yes it is. My stdev is ~4 ms according to hyperfine
Mar 10 21:01:37 <Vorpal>	so 20 ms is well outside that
Mar 10 21:02:46 <Vorpal>	nullie: I'm writing a command line program that runs quite quickly (in this configuration, where it trust filesystem mtimes, when it check checksums this would not be statistically significant)
Mar 10 21:02:52 <nullie>	so less than required for declaring disovery?
Mar 10 21:02:53 <Vorpal>	https://github.com/vorpalblade/paketkoll in case you are interested
Mar 10 21:04:53 <Vorpal>	nullie: it is a repeatable improvement that is outside noise. If I rerun the hyperfine I get the same result. A single hyperfine run is indeed not 5 sigma as in science. But repeatability (across two different computers) I believe improves on that. Not sure how to do the maths on that though.
Mar 10 21:06:37 <Vorpal>	I also make sure to vary the test order between old and new (to try to minimise effects that are temporal such as CPU boost). I turn off as much CPU boosting and clock frequency scaling that I can in Linux also.
Mar 10 21:43:19 <polychromata{J}>	How do you lock an async mutex in a poll method?
Mar 10 21:43:27 <polychromata{J}>	tokio::sync::Mutex doesn't have a poll_lock()
Mar 10 21:43:51 <polychromata{J}>	Does the lock() future cancel the lock attempt if you drop it?
Mar 10 21:44:23 <polychromata{J}>	Do i…poll it, pass the context through, and then forget the future if it wasn't ready? that seems like a bad idea
Mar 10 21:46:11 <polychromata{J}>	There's an issue on the futures repo that was closed as a duplicate of another issue…which added `lock_owned()`? But i don't see how Arc<Mutex> vs &Mutex helps; there's still no poll_lock()
Mar 10 21:46:51 <danieldg>	polychromata{J}: don't use an async mutex for this
Mar 10 21:47:03 <danieldg>	use a *normal* mutex
Mar 10 21:47:20 <polychromata{J}>	And just count on there being low contention?
Mar 10 21:47:25 <danieldg>	you can't lock an async mutex in drop anyway, and that's also what you need
Mar 10 21:47:34 <danieldg>	count on? no
Mar 10 21:48:33 <danieldg>	you only hold the mutex momentarily by the push op, and during memcpy on the read
Mar 10 21:49:30 <danieldg>	neither of those are long operations, so contention isn't the problem
Mar 10 21:49:51 <danieldg>	also, only two users, so not much contention
Mar 10 21:50:36 *	polychromata{J} nods slowly.
**** BEGIN LOGGING AT Sun Mar 10 23:24:28 2024

Mar 10 23:24:27 *	Now talking on ##rust
Mar 10 23:24:27 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 10 23:24:27 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Mar 10 23:24:35 <pflanze>	This version of my StringSplit runs cleanly with miri: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=1f9d4c4353bc997f45ad5c1403409c88
Mar 10 23:24:51 <pflanze>	It uses another Pin<Box< >> around the whole thing.
Mar 10 23:25:08 <pflanze>	I don't see a good reason for that need, though.
Mar 10 23:26:13 <danieldg>	agreed, that seems unneeded
Mar 10 23:29:31 <pflanze>	Actually, none of the Pin:s are needed now.
Mar 10 23:29:56 <pflanze>	miri is happy with just the outer Box. I guess that might change if I move it around outside, though.
Mar 10 23:30:10 <danieldg>	the outer box isn't needed either
Mar 10 23:30:21 <Widdershins>	i think it might be
Mar 10 23:30:32 <Widdershins>	hmmm
Mar 10 23:30:34 <danieldg>	why?  Other than being a miri limitation
Mar 10 23:31:03 <Widdershins>	mostly that, miri gets pissy about pointer tagging
Mar 10 23:31:23 <danieldg>	ok? That's not used here
Mar 10 23:31:24 <Widdershins>	i think it isn't effectively different with it
Mar 10 23:32:05 <pflanze>	miri didn't accept it without the outer Box
Mar 10 23:32:05 <Widdershins>	pointer tags as in attributes of the pointers at the IR level, not bit stuffing
Mar 10 23:32:53 <Widdershins>	pflanze: does removing the pin around the box and just including a phantompinned in the struct also satisfy miri
Mar 10 23:33:23 <pflanze>	Removing the pin around the box is fine as I mentioned. The box must stay.
Mar 10 23:33:34 <pflanze>	Phantompinned?
Mar 10 23:34:07 <danieldg>	just boxing seems worthless to me - you can unbox outside your module with safe code
Mar 10 23:34:32 <danieldg>	no idea why miri would insist on that
Mar 10 23:34:36 <pflanze>	BTW if I box it, return it, then on the user side remove it from the box, miri complains, too
Mar 10 23:35:07 <danieldg>	sounds like a miri limitation then
Mar 10 23:35:13 <pflanze>	miri is runtime only, so it insists that the pointer (the Box<str>) isn't moved, apparently
Mar 10 23:36:18 <pflanze>	I'm going through a pointer into the inner box (into the str), and apparently miri thinks that this entails going through the original pointer to the str (the one in the Box), and if this is moved, it is unhappy? Not sure.
Mar 10 23:37:17 <pflanze>	This seems like about the most basic example, so I'd be confused if miri accidentally doesn't handle this right.
Mar 10 23:38:33 <pflanze>	But Rust has a thing where a Box can't be moved if there's a reference inside, too, right? Or is it special cased for Vec or something, I don't remember.
Mar 10 23:38:41 <pflanze>	*a reference to inside
Mar 10 23:41:16 <danieldg>	that's not special cased for either - if you have a ref to a thing, you can't move that thing
Mar 10 23:41:17 <pflanze>	Confirmed, definitely can't move a Box when a reference to the thing it holds exists.
Mar 10 23:41:42 <pflanze>	So, doesn't miri just follow the same rules?
Mar 10 23:42:27 <pflanze>	Box is moved, hence my reference to its inside is now void.
Mar 10 23:42:33 <Widdershins>	i think there's basically no strict legal limitation that the contents of a box cannot move when the box moves
Mar 10 23:42:55 <danieldg>	except that it's impossible for it to do so
Mar 10 23:42:55 <pflanze>	Well, why does the outer Box help, then? :)
Mar 10 23:43:01 <Widdershins>	in practice it's the always the case today, but it's not allowed to be relied on
Mar 10 23:43:15 <Widdershins>	because then you aren't moving the inner box
Mar 10 23:43:33 <pflanze>	Yep, but if moving the outer box could mean that the inner Box is moved, then...?
Mar 10 23:43:58 <Widdershins>	like i think the fact that the inner box *doesn't actually* move is coming into play there
Mar 10 23:44:17 <pflanze>	But the inner box only doesn't move because the outer box protects it from being moved.
Mar 10 23:44:25 <pflanze>	Which is the point you're trying to contest.
Mar 10 23:44:36 <Widdershins>	it's not legally required to
Mar 10 23:44:58 <Widdershins>	and miri is an empirical emulator
Mar 10 23:45:06 <pflanze>	Ok.
Mar 10 23:45:18 <pflanze>	But the whole point of Box is so that the inner parts *aren't* moved, no?
Mar 10 23:46:19 <pflanze>	Besides dyn Box, and self-referential types, fair enough.
Mar 10 23:51:25 <Widdershins>	the point of box is that it "owns" the data and is responsible for deleting it when it's dropped
Mar 10 23:51:37 <Widdershins>	which is a semantic that miri doesn't know about
Mar 10 23:52:05 <Widdershins>	miri cares only whether the referred to data is guaranteed to stay in place or not
Mar 10 23:52:29 <pflanze>	Sure, but owning the data and being responsible is the case without Box, too.
Mar 10 23:53:04 <Widdershins>	i think miri does have a concept of the box containing the only unique pointer to the data
Mar 10 23:53:07 <pflanze>	Apparently miri also cares that the pointer I was going through to retrieve mine is staying in place.
Mar 10 23:53:24 <Widdershins>	which is what causes its destination to be potentially invalid..?
Mar 10 23:54:37 <pflanze>	Yes, I guess it derives from the pointer move that the lifetime of the pointed-to thing might have changed, hence "bad".
Mar 10 23:54:57 <pflanze>	(Pure guess)
Mar 10 23:55:48 <pflanze>	It doesn't know that if my inner Box disappears that this is when also the references disappear. (But then why not look at it lazily, what actually happens?)
Mar 10 23:56:24 <Widdershins>	soooooomething like that. miri currently operates on "stacked borrows" and when you move a box nothing else can be borrowing from that unique pointer, so the contents of the box could potentially actually be somewhere else after that move in some allowed optimization
Mar 10 23:56:38 <Widdershins>	having a pin inside the referenced structure prevents that optimization
Mar 10 23:56:53 <pflanze>	Anyway, my current hypothesis is that miri simply follows the borrowchecker rules dynamically, in some way. Even if not strictly making sense, perhaps.
Mar 10 23:57:09 <Widdershins>	that's more or less exactly what miri does
Mar 10 23:57:18 <Widdershins>	though it follows a different, slightly stricter interpretation
Mar 10 23:57:29 <Widdershins>	though the difference between one and the other is very narrow
Mar 10 23:57:50 <Widdershins>	it is one of the lifetime-agnostic models that does provide the same guarantees
Mar 10 23:59:06 <pflanze>	"having a pin inside the referenced structure prevents that optimization": why? how?
Mar 10 23:59:26 <pflanze>	Also miri still complained even if I have Pin inside (and outside)
Mar 11 00:00:29 <Widdershins>	pin declares that it will not move
Mar 11 00:00:30 <pflanze>	(I mean, Pin outside is irrelevant; as soon as I have a Box outside, miri is happy)
Mar 11 00:01:26 <pflanze>	I thought Pin is purely a library thing, with no effect on the compiler?
Mar 11 00:01:38 <danieldg>	it is
Mar 11 00:04:19 <pflanze>	Basically the self-referential data structure solution concept is: move the data structure (both pointed-at thing and pointers) inside a Box and Pin that to make sure nobody unboxes it; that makes the address not change. In my case, I have a str that needs boxing anyway, but I have to do that additionally.
Mar 11 00:04:25 <pflanze>	At least, to make miri happy.
Mar 11 00:05:09 <pflanze>	I also seem to remember having read that one of the self-referential infrastructure crate talked about boxing as solution to some reported UB.
Mar 11 00:05:13 <pflanze>	Might have been exactly this.
Mar 11 00:05:53 <pflanze>	(solution as in bug fix; the crate existed for year(s) before already)
Mar 11 00:06:12 <Widdershins>	if i'm playing with this i'm noticing that you're effectively reimplementing Yoke here
Mar 11 00:06:18 <Widdershins>	which is super duper tricky
Mar 11 00:08:38 <Widdershins>	https://manishearth.github.io/blog/2022/08/03/zero-copy-1-not-a-yoking-matter/
Mar 11 00:10:35 <Diablo-D3>	hey guys, I remember someone making a matrix client in rust, but google is being a bitch, anyone know which one Im talking about?
Mar 11 00:10:41 <Diablo-D3>	it doesnt seem to be on matrix.org's list of clients either
Mar 11 00:12:37 <pflanze>	Diablo-D3, the element.io people work on matrix-rust-sdk, and use it to implement iOS and Android apps (and possible parts of the web app, not sure)
Mar 11 00:13:19 <Diablo-D3>	no, not them (also I thought they discontinued that specific sdk, since they're all js weirdos and allergic to actual code)
Mar 11 00:16:04 <pflanze>	Diablo-D3, the last commit to that repo was from a day ago. Also, https://element.io/blog/element-x-ignition/
**** BEGIN LOGGING AT Mon Mar 11 00:20:38 2024

Mar 11 00:20:36 *	Now talking on ##rust
Mar 11 00:20:36 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 11 00:20:36 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** BEGIN LOGGING AT Mon Mar 11 00:24:23 2024

Mar 11 00:24:21 *	Now talking on ##rust
Mar 11 00:24:21 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 11 00:24:21 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Mar 11 00:24:36 <pflanze>	Widdershins, I tried owning_ref a while ago. Yoke just confuses me, it seems to be doing the same thing, with more complicated wording and interfaces?
Mar 11 00:26:04 <Widdershins>	yeah that's similar
Mar 11 00:26:39 <pflanze>	(But Yoke has 1M+ downloads and release in the last months, owning_ref is mostly unused.)
Mar 11 00:27:40 <Widdershins>	yoke seems very well thought out to me
Mar 11 00:31:26 <pflanze>	There are also fortify, self_cell, and pared
Mar 11 01:00:58 <spb>	i'm fairly sure the 'mostly unused' thing is because owning_ref was shown to be unsound quite a long time ago
Mar 11 01:02:12 <danieldg>	yeah, if you put a Cell in it you can extend lifetimes you shouldn't
Mar 11 01:05:50 <Widdershins>	i'm trying to rewrite this with yoke and yeah there's one little thing that i can't figure out to solve a lifetime compliant
Mar 11 01:05:55 <Widdershins>	complaint* even
Mar 11 01:19:58 <rbox>	Which statement is the best explanation for why Rust does not allow string indexing?
Mar 11 01:20:01 <rbox>	Indexing strings would make Rust too easy to use, and Rust developers need job security
Mar 11 01:20:02 <rbox>	HAHA!
Mar 11 01:20:50 <tokie>	is that from a poll?
Mar 11 01:21:11 <rbox>	https://rust-book.cs.brown.edu
Mar 11 01:22:58 <Mutabah>	rbox: Strings don't have good indexing boundaries that apply in all situations
Mar 11 01:23:14 <Mutabah>	do you want code units (UTF-8 bytes), codepoints, or graphemes?
Mar 11 01:23:19 <Mutabah>	it all depends on context...
Mar 11 01:23:28 <rbox>	well yes, i know what the correct answer to the equsetion was
Mar 11 01:23:29 <Mutabah>	and with UTF-8, finding the latter two is O(n)
Mar 11 01:23:35 <rbox>	i just thought that answer was hilarious
Mar 11 01:23:39 <Mutabah>	Ooooh
Mar 11 01:23:50 <Mutabah>	Your link wasn't quite clear
Mar 11 01:23:56 <danieldg>	clearly it should impl Index using an enum that allows all of those
Mar 11 01:23:58 <tokie>	it's because rust programmers want paid better
Mar 11 01:23:58 <rbox>	it was a mulitple choice question
Mar 11 01:29:23 <Widdershins>	ah! it lets you use `Vec` as the yokeable type but it doesn't implement yokeable quite right for it
Mar 11 01:36:11 <Widdershins>	well, miri still doesn't like it
Mar 11 01:38:50 <danieldg>	I'm no longer convinced that's a valuable opinion
Mar 11 01:39:36 <danieldg>	miri likes it -> maybe it's good, or maybe you didn't test it enough; miri doesn't like it -> maybe it's good, just assumes things miri doesn't model
Mar 11 01:45:15 <Widdershins>	it's certainly *a* test that catches a pretty wide class of things that wouldn't otherwise be caught. when it gets nuanced though it's really messy
Mar 11 01:45:39 <danieldg>	right, it's very useful in finding things you should look at
Mar 11 01:47:06 <Widdershins>	https://github.com/unicode-org/icu4x/issues/2095
Mar 11 01:47:35 <Widdershins>	newer default checks in miri seem to have issues with yoke regardless in this way
Mar 11 01:47:45 <Widdershins>	though they do have a goal to make it satisfy miri in general
Mar 11 01:48:35 <Widdershins>	the whole concept just turns out to be annoyingly difficult to express!
Mar 11 01:53:07 <Widdershins>	more here https://github.com/rust-lang/unsafe-code-guidelines/issues/194
**** BEGIN LOGGING AT Mon Mar 11 01:59:30 2024

Mar 11 01:59:28 *	Now talking on ##rust
Mar 11 01:59:28 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 11 01:59:28 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Mar 11 02:26:07 <danieldg>	hmm.  That means that none of the solutions with Box are valid at all
Mar 11 02:26:35 <danieldg>	(assuming the worst-case noalias)
Mar 11 02:42:39 <LuxuryMode>	In my FromRequest impl, when I examine `request.uri().query()`, I can see that there are params present. However, when I attempt to extract these parameters using `request.extensions().get::<Query<HashMap<String, String>>>()`, I consistently receive `None` and do not get any parameters. Any idea what I might be doing wrong here? Here is a snippet of the relevant code: https://gist.github.com/rust-play/71ae1883158be0e76515a457e7d2d715
Mar 11 02:45:37 <LuxuryMode>	Also works fine when I use directly as an extractor, i.e. `async fn my_handler(params: Query<HashMap<String, String>>...`
**** BEGIN LOGGING AT Mon Mar 11 05:24:03 2024

Mar 11 05:24:01 *	Now talking on ##rust
Mar 11 05:24:01 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 11 05:24:01 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
**** BEGIN LOGGING AT Mon Mar 11 06:07:46 2024

Mar 11 06:07:44 *	Now talking on ##rust
Mar 11 06:07:44 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 11 06:07:44 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Mar 11 08:24:50 <osse>	I thought having three class to .flatten() in a row was a bit much. But then I remembered .and_then() exists. Praise be.
**** BEGIN LOGGING AT Mon Mar 11 11:18:07 2024

Mar 11 11:18:05 *	Now talking on ##rust
Mar 11 11:18:05 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 11 11:18:05 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Mar 11 11:45:03 <safsf>	quieres ver videos para adultos
Mar 11 11:45:14 <Lumpio->	¿que?
Mar 11 11:45:23 <safsf>	¿Chat por cámara?
Mar 11 11:45:38 <Lumpio->	no gracias
Mar 11 11:45:44 <safsf>	¿Yo por cámara?
Mar 11 11:45:48 <safsf>	chatear por cámara?
Mar 11 11:46:02 <Lumpio->	no
Mar 11 11:46:28 <safsf>	Primero haga clic en este enlace > https://yourgirlsarcade.life/?u=vtgk60r&o=d7gpk40
Mar 11 11:46:28 <safsf>	Y completa todas las opciones y luego muestra tu tarjeta, pero no te preocupes, es totalmente gratis.
Mar 11 11:46:44 <Lumpio->	Bruh nobody is looking for that here
Mar 11 11:47:03 <safsf>	Primero haga clic en este enlace > https://yourgirlsarcade.life/?u=vtgk60r&o=d7gpk40
Mar 11 11:47:04 <safsf>	Y completa todas las opciones y luego muestra tu tarjeta, pero no te preocupes, es totalmente gratis.
Mar 11 11:47:25 <safsf>	Primero haga clic en este enlace > https://yourgirlsarcade.life/?u=vtgk60r&o=d7gpk40
Mar 11 11:47:26 <safsf>	Y completa todas las opciones y luego muestra tu tarjeta, pero no te preocupes, es totalmente gratis.
Mar 11 11:48:51 <safsf>	Mi nombre de usuario es {Ella_Jennings}
Mar 11 11:48:52 <safsf>	No se requiere información de tarjeta, solo configure su cuenta https://yourgirlsarcade.life/?u=vtgk60r&o=d7gpk40
Mar 11 11:50:28 <safsf>	Ven a mi telgram >> @mariyacs
Mar 11 11:50:34 <safsf>	Ven a mi telgram >> @mariyacs
Mar 11 11:56:45 <gahr>	hi - new to rust, reading the book. I was curious about this example here: https://github.com/rust-lang/book/blob/main/listings/ch04-understanding-ownership/no-listing-19-slice-error/src/main.rs
Mar 11 11:57:09 <gahr>	it made me wonder: how does the compiler infers that the slice returned is linked in any way to the string ref passed in?
Mar 11 11:57:24 <gahr>	then I changed the body of the first word to be if s.is_empty() { "empty" } else { "full" }
Mar 11 11:57:28 <gahr>	and it still errors out the same way
Mar 11 11:58:00 <gahr>	then I added an explicit lifetime and the error went away
Mar 11 11:58:00 <gahr>	fn first_word<'a>(s: &String) -> &'a str {
Mar 11 11:58:22 <gahr>	so, does rust assumes that the lifetime of the return value depends on the lifetime of the argument, *unless told otherwise*?
Mar 11 11:58:32 <j`ey>	yes
Mar 11 11:58:51 <gahr>	where can I read more about it? I.e., under which situations it does so?
Mar 11 11:59:16 <gahr>	I guess if I return a slice into some other container, i.e., not into a string
Mar 11 11:59:18 <j`ey>	probably later on in the book?
Mar 11 11:59:25 <null_ptr>	https://doc.rust-lang.org/reference/lifetime-elision.html
Mar 11 11:59:27 <gahr>	heh ok I'll probably ahve to wait
Mar 11 12:01:59 <gahr>	thanks!
Mar 11 12:07:44 <gahr>	oh, so because both param and output lifetimes are elided, rust infers one for the param and assigns it to the output
Mar 11 12:07:47 <gahr>	that makes sense
Mar 11 12:11:25 <polychromata{J}>	That should actually be `-> &'static str` :3
Mar 11 12:12:27 <polychromata{J}>	<'a> -> &'a _ is almost never what you want: the caller can pick any lifetime and you'll return a reference with that lifetime?
Mar 11 12:13:32 <gahr>	I can't answer that yet, still on chapter 4 :)
Mar 11 12:15:26 <gahr>	is 'static a special lifetime?
Mar 11 12:16:34 <polychromata{J}>	Yeah.
Mar 11 12:16:45 <polychromata{J}>	It's a…keyword?
Mar 11 12:16:48 <polychromata{J}>	…is that right?
Mar 11 12:16:50 <saati>	https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html?highlight=static#the-static-lifetime
Mar 11 12:19:40 <polychromata{J}>	https://doc.rust-lang.org/reference/keywords.html#weak-keywords yep, weak keyword
Mar 11 12:45:16 <gahr>	alright I'll just continue reading the book, thanks all!
Mar 11 12:45:49 <polychromata{J}>	Send us any more questions! :3
Mar 11 13:00:18 <elichai2>	Hi, I'm trying to do `println!("cargo:rustc-cfg=c_api");` in a build.rs and I see `--cfg c_api` in the build command, but the cfg is not enabled (I tried `#[cfg(c_api)] compile_error!("c_api")`)
Mar 11 13:00:46 <neiluj>	Hi! got an async function f that takes an Arc<lock_api::RwLock<RawRwLock, myType>>, but when calling this function in a new thread: tokio::task::spawn(async move { f(a) }) I get the error future created by async block is not `Send`
Mar 11 13:00:59 <neiluj>	not sure what is wrong here
Mar 11 13:05:28 <spb>	neiluj: somewhere in your async function, or somewhere down its call tree, you're creating a value of a type that isn't Send and which lives across an 'await'
Mar 11 13:05:51 <spb>	the detailed error message gives you more information to track it down, but takes a bit of careful unravelling to make sense of it
Mar 11 13:10:13 <neiluj>	many thanks spb, so basically I pass an Arc to the RwLock to the async function running in a dedicated tokio task, but use it elsewhere: let a=RwLock::new(..); tokio::task::spawn(aync move {f(a)}); g(a);
Mar 11 13:10:39 <neiluj>	and f mutates a by writing to it
Mar 11 13:11:55 <neiluj>	but I didn't have this error with a mutex instead of the RwLock
Mar 11 13:12:51 <neiluj>	oh just removed an tokio::time::sleep(..).await; and the code compiled
Mar 11 13:12:53 <neiluj>	:)
Mar 11 13:14:23 <neiluj>	the full error was future is not `Send` as this value is used across an await, so the .await made the returned future not Send somehow
Mar 11 13:16:09 <saati>	Sleep is Send, you have something else there that's not send but you drop it before the next await point
Mar 11 13:20:18 <neiluj>	thanks, will look into it
Mar 11 13:25:41 <spb>	neiluj: the reason this happens is that every time you await something, the async function can pause execution until the thing you're awaiting is ready. in the case of something you pass to tokio::spawn, the next time it wakes up might be on a different thread than the one on which it paused
Mar 11 13:26:12 <spb>	what this means is that any local variable in the function which is used on both sides of an await needs to be Send because it might be created on one thread and used on another
Mar 11 13:31:07 <saati>	or if you really need !Send values you can start a single threaded executor instead
Mar 11 13:40:27 <polychromata{J}>	neiluj: You can't hold sync locks across an await, because the guards are !Send
Mar 11 13:41:42 <polychromata{J}>	You have to unlock to await, and then (because of a compiler limitation) you have to structure your code so that the await happens outside of the scope that the lock was held in (just drop() or unlock() will produce the same error otherwise)
Mar 11 13:42:59 <polychromata{J}>	In the simplest case, `{ let guard = mutex.lock(); drop(guard); future.await; }` won't work, but `{ { let guard = mutex.lock(); } future.await; }` will
Mar 11 13:45:03 <polychromata{J}>	(Something about constructing the type for the async fn state machine happening in a pass before the liveness control flow analysis)
Mar 11 13:45:08 <saati>	holding a lock across an await is just asking for low performance and deadlocks anyway
Mar 11 14:35:13 <neiluj>	thanks a lot for the explanations, indeed the lock spanned across the sleep that was awaited
Mar 11 14:35:22 <neiluj>	it is no longer the case now
Mar 11 15:00:48 <gahr>	polychromata{J}: thanks, will do!
Mar 11 15:07:26 <neiluj>	argh, using a library relying on an older version of a framework I'm using, can't convert the returned types of the library to the new ones from the framework
Mar 11 15:50:20 <lmat>	I think I can get an element of a vec using notation like  my_vec[0];? Where can I find documentation on this operator[]?
Mar 11 15:51:19 <osse>	lmat: Vec implements the Index trait, which provides that operator
Mar 11 15:51:48 <lmat>	osse: Oh, nice seeing you here! I didn't know you were a rustacean...makes sense though.
Mar 11 15:52:04 <osse>	<3
Mar 11 15:52:22 <lmat>	osse: Looking at that trait, it looks like there is no operator[] separate from fn index, right?
Mar 11 15:52:54 <lmat>	So fn index should be about the same as fn get?
Mar 11 15:53:55 <osse>	Same as get() except it panics
Mar 11 15:54:03 <lmat>	sweet, thanks!
Mar 11 16:16:00 <lmat>	How does  my_slice[1..2] work? It looks like 1..2 will create a std::ops::Range, so it's like  my_slice[std::ops::Range{start: 1, end: 2}], and [] is index, so   my_slice.index(std::ops::Range{start: 1, end: 2});  but I don't see any index instance member function that takes a range.
Mar 11 16:16:31 <j`ey>	lmat: https://doc.rust-lang.org/std/primitive.slice.html#impl-Index%3CI%3E-for-%5BT%5D
Mar 11 16:16:43 <j`ey>	-> https://doc.rust-lang.org/std/slice/trait.SliceIndex.html
Mar 11 16:16:58 <lmat>	j`ey: Ah! There they are!
Mar 11 16:17:24 <lmat>	(I used std::ops::Range{start: 1, end: 2} "directly" because I don't see a ::new like I do in std::ops::RangeInclusive)
Mar 11 16:46:46 <evaloop>	Guys, about mold linker, after some update, mold cannot worked anymore
Mar 11 16:47:21 <evaloop>	-C link-arg=-fuse-ld=/usr/bin/mold
Mar 11 16:48:55 <evaloop>	him disappear from debug autput
Mar 11 16:49:18 <evaloop>	-flto=fat,-O3
Mar 11 16:49:44 <evaloop>	DEBUG_RUSTFLAGS="-C debuginfo=2"
Mar 11 16:51:00 <evaloop>	also I have in $PATH d mold
Mar 11 16:51:00 <evaloop>	ld.mold
Mar 11 16:51:00 <evaloop>	mold
Mar 11 16:52:17 <evaloop>	so, for now need manualy add string to build toml that can be work?
Mar 11 17:34:34 <evaloop>	how actualy fully disable -C linker-plugin-lto? I set -C linker-plugin-lto=false and that can't work why?
Mar 11 17:42:51 <evaloop>	also passing -C linker-plugin-lto=false worked, but what mold has gone from output
Mar 11 18:51:30 <evaloop>	oh lol, rustc boot section : linker-flavor
Mar 11 18:51:30 <evaloop>	This flag controls the linker flavor used by rustc. If a linker is given with the -C linker flag, then the linker flavor is inferred from the value provided. If no linker is given then the linker flavor is used to determine the linker to use. Every rustc target defaults to some linker flavor. Valid options are:
Mar 11 18:51:30 <evaloop>	em: use Emscripten emcc.
Mar 11 18:51:30 <evaloop>	gcc: use the cc executable, which is typically gcc or clang on many systems.
Mar 11 18:51:31 <evaloop>	ld: use the ld executable.
Mar 11 18:51:33 <evaloop>	msvc: use the link.exe executable from Microsoft Visual Studio MSVC.
Mar 11 18:51:35 <evaloop>	wasm-ld: use the wasm-ld executable, a port of LLVM lld for WebAssembly.
Mar 11 18:51:37 <evaloop>	ld64.lld: use the LLVM lld executable with the -flavor darwin flag for Apple's ld.
Mar 11 18:51:39 <evaloop>	ld.lld: use the LLVM lld executable with the -flavor gnu flag for GNU binutils' ld.
Mar 11 18:51:41 <evaloop>	lld-link: use the LLVM lld executable with the -flavor link flag for Microsoft's link.exe.
Mar 11 18:52:19 <evaloop>	and . . . not any word about mold, no way :(
Mar 11 18:53:07 <j`ey>	it can use 'ld'
Mar 11 18:53:23 <j`ey>	since its meant to have the same CLI options
Mar 11 18:53:55 <evaloop>	ok, ld, fine :|
Mar 11 18:55:07 <j`ey>	thats just the 'flavor', not what is actually used
Mar 11 20:14:58 <Widdershins>	i suppose you could symlink mold as ld
Mar 11 20:15:53 <Widdershins>	hm
Mar 11 20:28:27 <Widdershins>	oh it goes in config.toml not Cargo.toml
Mar 11 20:28:45 <lmat>	What's the point of building NOT a release build?
Mar 11 20:28:56 <Widdershins>	lmat: lots of reasons
Mar 11 20:28:58 <lmat>	In other words, why would I want to turn optimizations off?
Mar 11 20:29:06 <Widdershins>	because it builds faster
Mar 11 20:29:16 <Widdershins>	release mode also disables debug
Mar 11 20:29:21 <lmat>	Widdershins: What is debug?
Mar 11 20:29:35 <j`ey>	debug information
Mar 11 20:29:41 <j`ey>	stuff that gdb can use etc
Mar 11 20:29:41 <lmat>	Widdershins: (I'm a software developer, and I know what debugging is, I just don't know what it has to do with rust.)
Mar 11 20:29:42 <Widdershins>	debugging symbols and information
Mar 11 20:29:49 <lmat>	j`ey: I can debug rust in gdb?
Mar 11 20:29:52 <j`ey>	yes
Mar 11 20:29:53 <Widdershins>	yes?
Mar 11 20:29:59 <lmat>	j`ey: Enough said, thank you!
Mar 11 20:30:03 <Widdershins>	it works pretty much the same
Mar 11 20:30:15 <Widdershins>	rust builds objects very much like c/++ do
Mar 11 20:30:19 <lmat>	Widdershins: same as C++, I assume
Mar 11 20:30:28 <Widdershins>	it mangles names differently but after the code is emitted it's almost identical
Mar 11 20:30:39 <lmat>	I've been using println! (with a "todo" to implement proper logging), but maybe a debugger will be useful someday!
Mar 11 20:31:11 <Widdershins>	there's also stuff like the debug_assert! macro that only emits code in #[cfg(debug)]
Mar 11 20:32:15 <Widdershins>	frequently tests will always be run in debug. a library of mine builds 30 seconds faster and only runs tests 5 seconds slower for example
Mar 11 20:32:34 <Widdershins>	even though the tests are running like 100x faster in release, it doesn't save time
Mar 11 20:33:03 <Widdershins>	if this isn't what you want you can change optimization modes, debug settings, etc. in the "dev" and "release"
Mar 11 20:33:07 <Widdershins>	profiles, in cargo.toml
Mar 11 20:33:18 <lmat>	Makes sense, thanks for the pointers!
Mar 11 20:33:27 <Widdershins>	so *by default* the dev profile does little optimization, no LTO, etc. but you can change that
Mar 11 20:33:36 <Widdershins>	https://doc.rust-lang.org/cargo/reference/profiles.html
Mar 11 20:34:31 <lmat>	Widdershins: Right, to cook up your own custom profile. nice.
Mar 11 20:34:33 <dav1d>	lmat, I have yet to actually need a debugger to debug something in Rust
Mar 11 20:35:03 <dav1d>	it would have been useful plenty of times but never useful enough where I would have "required" it
Mar 11 20:35:12 <Widdershins>	i've used it because it's super extremely easy to do in jetbrains ides
Mar 11 20:35:13 <lmat>	dav1d: Right, the compiler pretty much takes care of any typos and "simple" errors. What is left is high-level aggregate-type errors which logging seems to address nicely.
Mar 11 20:35:22 <Widdershins>	i literally just click the beetle icon instead of the play button
Mar 11 20:35:23 <dav1d>	Yeah, really comfortable
Mar 11 20:35:40 <dav1d>	and I used to always launch with debugger when I was doing Java for $work
Mar 11 20:35:40 <Widdershins>	i will learn a debugger console when i have to :)
Mar 11 20:35:47 <Widdershins>	which so far is never
Mar 11 20:35:54 <Widdershins>	i have already forgotten pdb
Mar 11 20:35:58 <lmat>	Widdershins: Makes sense. I use vim and tmux, so I would have to `cd target/debug && cgdb ./my_app` or whatever
Mar 11 20:36:06 <dav1d>	yeah jetbrains is nice when it comes to debugging
Mar 11 20:36:17 <dav1d>	lmat, vim or neovim?
Mar 11 20:36:21 <lmat>	dav1d: vim.
Mar 11 20:36:28 <Widdershins>	lmat: i would say you could at least give a shot at the ides, jetbrains has a best-in-class first-class vim mode
Mar 11 20:36:40 <dav1d>	kk, there is a cool neovim plugin with debugger integration which I wanna setup
Mar 11 20:36:40 <Widdershins>	but that's just me. some people hate it ymmv
Mar 11 20:36:44 <lmat>	dav1d: I haven't found a reason to switch to nvim. When I heard that Bram died, I considered it, but it looks like vim development carries on as usual.
Mar 11 20:36:56 <lmat>	dav1d: That could be really sweet!
Mar 11 20:36:57 <dav1d>	I already had it working somewhat but wasnt comfortable enough yet for me
Mar 11 20:37:36 <lmat>	Widdershins: I've used ideas. I've used Jetbrains IntelliJ, eclipse, Microsoft Visual Studio (a long time ago), arduino. I hate all of them.
Mar 11 20:37:45 <dav1d>	lmat, https://github.com/rcarriga/nvim-dap-ui
Mar 11 20:37:48 <lmat>	oops s/ideas/ides/
Mar 11 20:37:49 <Widdershins>	evaloop: where did you try putting your rustflags config? i'm able to get rustc to use any linker i want, by putting it in "./.cargo/config.toml" with, for example, `[target.'cfg(all())'] \n linker = "/usr/bin/wabl"` and then it fails because it can't find /usr/bin/wabl
Mar 11 20:38:20 <Widdershins>	lmat: something for everyone i guess. i've always got huge mileage out of having an ide
Mar 11 20:38:32 <dav1d>	IntelliJ is awesome
Mar 11 20:39:01 <Widdershins>	if your editing is vim brained you can do that there too but i've always been a mouse, keyboard, multi-cursor, ide rename, and regex replace type of guy
Mar 11 20:39:05 <Widdershins>	and it's never slowed me down
Mar 11 20:39:36 <Widdershins>	and all the searches, outlines, jump to definition and list usages keys are top notch stuff to have
Mar 11 20:39:43 <lmat>	but it takes so long to start up...
Mar 11 20:39:45 <Widdershins>	not to mention diff views and three-way resolver ui my god
Mar 11 20:39:51 <Widdershins>	it really doesn't though
Mar 11 20:40:10 <lmat>	Widdershins: "it's never slowed me down" ... that's sort of meaningless.
Mar 11 20:40:10 <Widdershins>	i mean compared to a terminal yeah but you can also just not close it
Mar 11 20:40:19 <Widdershins>	no it isn't?
Mar 11 20:40:46 <Widdershins>	that's the whole justification for doing it a different way: ease and expediency
Mar 11 20:40:56 <lmat>	Widdershins: What matters to me is: would it slow me down. If you've "always been a ... ide ... type of guy", and it's "never slowed you down", there's no control group, my friend.
Mar 11 20:41:30 <Widdershins>	that's why i didn't say you should personally do it. nobody has a control group because everyone is n=1
Mar 11 20:41:30 <dav1d>	<lmat> but it takes so long to start up... | I never understood this complaint. It's a onetime cost, you don't even have to close it ever! And from my experience, it's not significantly slower than rust analyzer for me
Mar 11 20:41:46 <lmat>	Widdershins: The important comparison is: you can type 130 wpm, you know vim, grep, and tmux like the back of your hand, you're just as comfortable working 500 miles away from your computer as right next to it, THEN you switch to IDEs and it never slows you down. That would be meaningful ;-)
Mar 11 20:41:55 <lmat>	Widdershins: yeah.
Mar 11 20:42:39 <Widdershins>	i type 140wpm, i know idea grep and tmux like the back of my hand, and i never have to work 500 miles away from my computer and if i did i have a laptop with just as much ram
Mar 11 20:43:06 <Widdershins>	and i've never run into a task that takes me meaningfully longer to solve than doing it the vim way would be
Mar 11 20:43:27 <Widdershins>	software development is not the process of text production. most of your time is thinking and communicating anyway
Mar 11 20:43:40 <Widdershins>	as long as your editor is low friction and lets you do the text transforms you want it's fine
Mar 11 20:43:55 <Widdershins>	i was just suggesting it since it sounds like there are a few useful things missing from your tooling setup
Mar 11 20:43:58 <lmat>	dav1d: If I only work on one project, okay, but I have maybe 8 clients. Is it so snappy that I can have maybe 5 of them running all the time with no sweat? Also, I use tmux to hold each client's work (tmux at -t <client1>; connects me back to that client's terminal session with vim, grep, less, or whatever tools I was running last time.) And I can access it all remotely just as easily as locally <3
Mar 11 20:44:17 <Widdershins>	don't ask me how many ide windows i have running at any given moment
Mar 11 20:44:31 <lmat>	Widdershins: yup, good reasoning.
Mar 11 20:44:39 <evaloop>	Widdershins: that options in/from makepkg.conf, I'm cannot put any in config.toml, maybe because in another one project toml file writed author, and so, I think maybe better use global config, for compile software, but maybe I was wrong, and something won't know about that. ofc
Mar 11 20:46:13 <Widdershins>	evaloop: https://doc.rust-lang.org/cargo/reference/config.html i was able to make this do things so ymmv
Mar 11 20:46:21 <Widdershins>	it will look in the global config too
Mar 11 20:46:44 <Widdershins>	it seems you can provide rustc flags, i think
Mar 11 20:47:36 <Widdershins>	anyway lmat the startup time being really fast is nice and all. i find ides very snappy nowadays and even though people complain that it uses 3 gigs instead of 10 megabytes i would also observe that that's 3 gigabytes of ram mostly lying fallow
Mar 11 20:47:41 <Widdershins>	ram is meant to be used
Mar 11 20:48:11 <Widdershins>	as long as your pagecache is not starving it's great
Mar 11 20:48:41 <lmat>	sure, most of the time that's fine...until it isn't
Mar 11 20:48:55 <Widdershins>	when's that tho
Mar 11 20:49:23 <Widdershins>	i have like a hundred browser tabs, 3 ides, and numerous miscellania open and i'm sitting at like 16% resident ram
Mar 11 20:49:46 <lmat>	Widdershins: Depends...never know! I write several financial applications and sometimes they like a lot of RAM..
Mar 11 20:50:43 <Widdershins>	i've had memory leaks eat 33 gigabytes of ram before and it was mostly just annoying
Mar 11 20:50:43 <evaloop>	Widdershins: wow, great, THX for expensive answer
Mar 11 20:51:01 <Widdershins>	haha
Mar 11 20:51:14 <Widdershins>	it's cheaper than it used to be! i find it a very expedient solution
Mar 11 20:51:27 <Widdershins>	i do this for a living after all
Mar 11 20:51:55 <Widdershins>	you can get away with like 16 gigs of ram no problem
Mar 11 20:52:09 <Widdershins>	which is like 'found in a trash can' type of memory capacity these days
Mar 11 20:52:46 <spb>	unless you're a mac user, then it's mortgage your house type
Mar 11 20:52:48 <Widdershins>	i don't give the ide jvms half that much
Mar 11 20:53:01 <Widdershins>	oh god yeah i mean if you're a mac user you kinda brought that on yourself though right
Mar 11 20:55:03 <lmat>	spb: :-D
Mar 11 20:55:40 <Widdershins>	i feel real bad for people who actually feel trapped in the mac ecosystem. it seems nightmarish
Mar 11 20:56:10 <saati>	i'm afraid in a decade it will be like that for everyone, ram will move in package and there won't be upgrades separate from the cpu
Mar 11 20:56:30 <lmat>	saati: Why?
Mar 11 21:01:47 <saati>	lmat: ram outside the package won't be able to give the latencies and bandwith of silicon interposers and other new in package interconnects
Mar 11 21:02:26 <lmat>	saati: Oh, I see
Mar 11 21:02:48 <Widdershins>	saati: are they gonna upcharge by 20x though
Mar 11 21:02:54 <Widdershins>	(yes)
Mar 11 21:02:59 <dav1d>	lmat, I have no intention to tell you what you should use, though I feel like there is some misconceptions here. I've ran IntelliJ (Java/Go/Python projects) consistently with 4+ windows open, each having somewhere between 3-6 projects loaded with 24gb of RAM
Mar 11 21:03:04 <Widdershins>	so i don't think it will win
Mar 11 21:03:06 <dav1d>	and a piece of shit cpu
Mar 11 21:03:31 <lmat>	dav1d: Rock on, my man!
Mar 11 21:03:36 <dav1d>	and plenty of RAM to spare for chrome
Mar 11 21:03:41 <lmat>	dav1d: And you leave it open for weeks? ^_^
Mar 11 21:03:45 <Widdershins>	maybe that's a tragedy but there's massive consumer value for the interchangeability
Mar 11 21:04:13 <Widdershins>	lmat: yeah why not. the heap is sandboxed so they actually have to fix memory leaks
Mar 11 21:04:22 <dav1d>	lmat, usually only the first instance loads slower, new instances are almost instant. But yeah I tend to just leave the laptop in standby/hibernation
Mar 11 21:04:54 <lmat>	dav1d: And a very important aspect to me is remote access. I have a machine at home that is much more powerful than any of my laptops and I SSH to it to do any coding while I'm out. What would that look like with an IDE like that?
Mar 11 21:05:02 <dav1d>	these times are over, pretty much exclusively on vim now, but not because of memory consumption or startup times
Mar 11 21:05:36 <Widdershins>	they're working on it, maybe in a couple years it'll be buttery smooth to attach remotely
Mar 11 21:05:53 <dav1d>	lmat, the intellij remote stuff is actually surprisingly good
Mar 11 21:06:02 <dav1d>	not made for this specifically but it is quite good
Mar 11 21:06:12 <Widdershins>	dav1d: not vim mode? wait you're *no longer* using the ides?
Mar 11 21:06:52 <dav1d>	Widdershins, nah, purely vim now. Once upon a time I decided to learn vim and do all my rust projects exclusively in vim and if I miss a feature, I'll add it to vim. Now I gave up all the other shit but Rust -> Only vim left
Mar 11 21:07:26 <Widdershins>	ahh, the dotfile horizon
Mar 11 21:07:33 <dav1d>	although I do miss Intellij at times with the builtin db browser, rest client, easy debugging, ...
Mar 11 21:07:47 <tokie>	i use rust rover
Mar 11 21:07:52 <dav1d>	and obviously excellent editing, but that's just a given
Mar 11 21:08:00 <tokie>	correction: i'm using rust rover with the remote stuff
Mar 11 21:08:03 <tokie>	it mostly works OK
Mar 11 21:09:45 <SoF>	does Rust do any loop unrolling before LLVM?
Mar 11 21:17:25 <Widdershins>	i doubt it
Mar 11 21:17:34 <Widdershins>	it's just an IR emitter
Mar 11 21:26:35 <j`ey>	Widdershins: nah theyre adding more optimisations to 'MIR' now
Mar 11 21:26:47 <j`ey>	(not sure if that includes loop unrolling though, doubt it)
Mar 11 21:26:58 <Widdershins>	:o
Mar 11 21:27:40 <Widdershins>	needs more layers https://blog.rust-lang.org/2016/04/19/MIR.html
Mar 11 21:27:56 <polychromata{J}>	lmat: You can instantiate types directly like that if all their fields are pub.
Mar 11 21:28:30 <lmat>	polychromata{J}: I was surprised there's no "new" like there is for the other type :-D
Mar 11 21:28:43 <Widdershins>	proc macros -> macros -> rust -> HIR -> MIR -> IR -> machine code -> ucode
Mar 11 21:31:13 <polychromata{J}>	It would be kind of redundant. :)
Mar 11 21:31:29 <polychromata{J}>	You do see that sometimes.
Mar 11 21:37:09 <j`ey>	Widdershins: of course LLVM IR actually has 2-3 stages of IR too :P
Mar 11 21:42:17 <Widdershins>	j`ey: https://twitter.com/at_tcsc/status/1573770109537386496
Mar 11 21:43:41 <j`ey>	hehe
Mar 11 23:10:09 <TimMc>	Can I bundle an existing non-Rust executable into a Rust binary so that I can call either one, somehow?
Mar 11 23:11:07 <TimMc>	(I'd like to take an existing Go program and include its functionality in my program.)
Mar 11 23:14:44 <j`ey>	probably not that easy, maybe better to just require they have it in PATH
Mar 11 23:16:58 <Arnavion>	include_bytes + memfd_create + fexecve
Mar 11 23:19:18 <polychromata{J}>	snrk
Mar 11 23:26:03 <TimMc>	This would be for a single, standalone binary.
Mar 11 23:27:04 <TimMc>	Arnavion: That would just be jumping into a big byte array, right? :-)
Mar 11 23:27:10 <j`ey>	baically yeah
Mar 11 23:27:17 <Arnavion>	Yes
Mar 11 23:27:43 <TimMc>	I mean, I'm not above doing something like that. :-P
Mar 11 23:28:06 <j`ey>	could also write it out to a tmp file
Mar 11 23:28:07 <Arnavion>	The cross-platform way would be to create a tempfile and executing that and hoping you don't get TOCTOUd
Mar 11 23:28:09 <j`ey>	and then exec it
Mar 11 23:29:18 <Arnavion>	... and, depending on the method used to create said tempfile, that the underlying filesystem isn't mounted noexec
Mar 11 23:38:05 <TimMc>	...I kind of want to try this just to see what exciting things happen.
Mar 11 23:38:35 <yziquel>	Is it possible to implement a cyclic chained list in safe rust (i don't mind bumpalo). if you ask me why, it's a very specific kind of datastructure that is supposed to be "intepreted" very fast. I really need the cyclicity.
Mar 11 23:39:10 <yziquel>	i don't mind using an arena like bumpalo. i just want to know if it is possible in safe rust or if unsafety is required
Mar 11 23:42:05 <Widdershins>	yziquel: the common way is to refer to indices in a vec and do it that way
Mar 11 23:42:26 <Widdershins>	otherwise it is technically possible to do safely with pointers and so on it's just really hard
Mar 11 23:42:47 <yziquel>	Widdershins it will boil down to that, but i do not the pattern matching as that structure will end up rather involved.
Mar 11 23:43:02 <Widdershins>	you do what the pattern matching?
Mar 11 23:43:45 <yziquel>	implement a weird generalisation of lambda calculus verging towards logic programming. the structures i need for that are involved and cyclic.
Mar 11 23:44:25 <Widdershins>	that's fine
Mar 11 23:44:53 <yziquel>	before going full array of pointers with weird semantics, i need to prototype it with cyclic algebraic datatypes to make it understandable.
Mar 11 23:45:16 <Widdershins>	i'm saying you don't need pointers if you just use indices
Mar 11 23:45:17 <yziquel>	any safe rust implementation of cyclic chained list would be a good prototype to build upon.
Mar 11 23:45:32 <yziquel>	Widdershins i will need pointers.
Mar 11 23:45:41 <Widdershins>	you can represent a structure without making its ownership physically dependent on the cycles
Mar 11 23:45:48 <Widdershins>	you don't ever "need" the pointers
Mar 11 23:46:02 <yziquel>	sigh. i do need the pointers for what i intend.
Mar 11 23:46:07 <Widdershins>	which is?
Mar 11 23:46:26 <yziquel>	an abstract execution machine for that calculus. with pointers.
Mar 11 23:46:49 <Widdershins>	if your hidden premise is that you have to use pointers and not any other method then that's cheating
Mar 11 23:47:06 <yziquel>	? why. that's my spec.
Mar 11 23:47:21 <Widdershins>	you have a collection of objects that want to refer to each other, yes?
Mar 11 23:48:32 <yziquel>	Widdershins more than that. for now, i need cyclic algebraic data types to prototype. Later, I'll need vectors of pointers and rather involved treatment of them.
Mar 11 23:48:52 <Widdershins>	you're skipping a step mate
Mar 11 23:48:56 <yziquel>	?
Mar 11 23:49:31 <yziquel>	Widdershins which step ?
Mar 11 23:49:40 <Widdershins>	the step where you think about whether pointers are required or not
Mar 11 23:49:54 <Widdershins>	because you can get the exact same effect in other ways, without worrying about unsafety
Mar 11 23:50:23 <yziquel>	Widdershins pointers WILL be required.
Mar 11 23:50:38 <yziquel>	it's the whole point of the exercise.
Mar 11 23:50:40 <Widdershins>	you keep saying this but until i know why they're required i can't really say anything new
Mar 11 23:52:19 <yziquel>	Widdershins because I intend to generalise Krivine's machine for semantics of lambda calculus as it pertains to set theory (see Luminy slides 2004 and later) and adapt it to a logic programming setting by revisiting some works in logic about existential quantification as dual to the substitutional fragment of first order logic. And that machine
Mar 11 23:52:19 <yziquel>	will need pointers.
Mar 11 23:52:43 <yziquel>	I tend to be annoyed by people always questioning what I plan to do.
Mar 11 23:52:50 <yziquel>	I already have a mother.
Mar 11 23:53:26 <Widdershins>	you've come here to ask how to do something safely, and i offered a way to do something that has the exact same effect and is trivially safe
Mar 11 23:53:55 <yziquel>	What I have asked is: cyclic chained list in safe rust. nothing else.
Mar 11 23:54:07 <Widdershins>	if this is a school assignment that you flunk if you don't use pointers i suggest not using rust because it's very easy to create extremely invalid programs doing pointer dances like that
Mar 11 23:54:16 <yziquel>	Widdershins no. it's research.
Mar 11 23:54:30 <yziquel>	Widdershins i'm a logician by training.
Mar 11 23:54:35 <Widdershins>	rust's guarantees can make programs invalid and invoke UB much sooner when doing pointer traversal than e.g. c++
Mar 11 23:54:39 <yziquel>	i want to implement some ideas of mine.
Mar 11 23:55:00 <yziquel>	I want to try the pointer dance.
Mar 11 23:55:22 <j`ey>	any actual (raw) pointer in rust is unsafe
Mar 11 23:56:08 <yziquel>	j`ey whch is precisely why I'm asking about cyclic algebraic datatypes safe.
Mar 11 23:56:14 <Widdershins>	well i'll warn you it's a real pain. the safer-ish way is to use Rc<RefCell<T>> instead of pointers, such that it will actually immediately explode with runtime checks if you do something invalid
Mar 11 23:56:23 <yziquel>	if there is an example of a cyclic chained list, I take it.
Mar 11 23:56:30 <spb>	what you are doing requires pointers, if you are using 'pointer' as shorthand for 'a way to persistently reference another object of a given type without lifetime bounds'
Mar 11 23:56:49 <spb>	but there are ways to do that which are not literally `*const T`
Mar 11 23:56:49 <yziquel>	Widdershins i know it's a pain. already in OCaml it's a pain.
Mar 11 23:58:09 <Widdershins>	well if you are set upon using exactly pointers and nothing else you can certainly write that code
Mar 11 23:58:12 <yziquel>	spb if i need a thunk of unsafety to tie the cyclicity, I'm fine with it. If I can do it safely, I'm more fine with it. I intend to eschew most lifetime issues by using an arena like bumpalo.
Mar 11 23:58:57 <yziquel>	Widdershins I want an algebraic data types whose representation is pointers. not indices with lookups.
Mar 11 23:58:59 <Widdershins>	unsafety still requires following the rules, it is only for the purpose of enforcing the unbreakable rules that define a valid rust program in ways that the compiler cannot check for you
Mar 11 23:59:22 <Widdershins>	and it can get very difficult to do that correctly
Mar 11 23:59:46 <yziquel>	Widdershins I did a C level binding with OCaml and R with two GC's stepping over one another. I'm well aware that unsafety has rules.
Mar 11 23:59:48 <Widdershins>	subtle things that cause references to coexist illegally can make the program invalid or even misbehave even if they don't appear to interact
Mar 12 00:01:03 <yziquel>	Widdershins ok. now. anyone knows of a not too ugly implementation of cyclic chained list in rust ?
Mar 12 00:01:17 <Widdershins>	the main thing you get performancewise by using pointers instead of indices is that deleting incrementally doesn't leave allocated dead space in the backing array. otherwise indices pointing to indices is, performance-wise, pretty much equivalent
Mar 12 00:01:35 <Widdershins>	maybe you want https://rust-unofficial.github.io/too-many-lists/
Mar 12 00:01:55 <yziquel>	Widdershins memory management will be a later stage. my machine is quite simple but hairy in details such as that.
Mar 12 00:02:15 <j`ey>	from a quick crates.io look it doesnt look like there is, but maybe there's better search terms
Mar 12 00:02:31 <Widdershins>	ok well good luck with the contraption
Mar 12 00:02:32 <yziquel>	Widdershins i skimmed over too many lists. i haven't seen cyclic chained list. will reread.
Mar 12 00:02:47 <j`ey>	https://crates.io/crates/cdl-list-rs uses rc/refcell
Mar 12 00:05:31 <Widdershins>	the deque in https://rust-unofficial.github.io/too-many-lists/fourth-layout.html is effectively cyclic, the List type has pretty much the same fields as the Node type does
Mar 12 00:06:53 <yziquel>	j`ey I'm fine using RefCell if I need to build the structure. What I want in the end is an immutable algebraic data type. cyclic.
Mar 12 00:07:18 <yziquel>	I really need 1. immutable 2. algebraic 3. cyclic. But only as end result.
Mar 12 00:07:32 <yziquel>	lifetime can be tied to a wider arena to avoid issues.
Mar 12 00:08:44 <yziquel>	Widdershins reference counted. not what I want.
Mar 12 00:09:07 <TimMc>	yziquel: Any chance you can just avoid garbage collection and let program termination take care of everything for you? :-P
Mar 12 00:09:09 <LDericher>	please check out another borrow/lifetime issue I'm currently facing, any suggestions? https://bpa.st/2CDQ
Mar 12 00:13:34 <LDericher>	I don't get why the buffer "escapes the closure body" if I only use an immutable borrow, once
Mar 12 00:13:47 <Widdershins>	LDericher: it's not once, it's inside a loop so it'll live on to the next iteration
Mar 12 00:14:27 <Widdershins>	and you're reassigning tx at which point it must be cleaned up because there's nowhere else to put it, but the new tx you're assigning to it depends on the old one
Mar 12 00:14:40 <Widdershins>	that's what it looks like
Mar 12 00:14:54 <yziquel>	TimMc no garbage collection matters. I just want to construct an immutable circular chained list.
Mar 12 00:17:11 <yziquel>	from what I see, I have to fool the compiler with unsafety. i hate that, but i see no other way around it.
Mar 12 00:18:24 <dav1d>	LDericher, what type is xfer and is it tied to the reference that was passed in?
Mar 12 00:19:17 <LDericher>	xfer holds references to both the "tx" used to transfer and the "buffer" it's transmitting
Mar 12 00:20:32 <dav1d>	LDericher, what does xfer.wait() return, a TX which is still tied to the buffer?
Mar 12 00:21:08 <LDericher>	wait() returns the (buffer, tx), both untied
Mar 12 00:21:41 <yziquel>	Is it possible, in unsafe rust to cast struct with a mutable pointer to the same struct without the mutability of the pointer ?
Mar 12 00:21:49 <yziquel>	or in safe rust even ?
Mar 12 00:23:06 <j`ey>	*mut T I think can be used in place of *const T already?
Mar 12 00:23:57 <j`ey>	evalr: fn bar(a: *const u32){} fn foo(a: *mut u32) {bar(a)}
Mar 12 00:23:59 -evalr/##rust-	j`ey: ()
Mar 12 00:24:21 <j`ey>	but https://doc.rust-lang.org/std/primitive.pointer.html#method.cast_const also exists
Mar 12 00:25:36 <dav1d>	Widdershins, am I missing something, if the new tx is not tied to the buffer, it should be fine right?
Mar 12 00:26:38 <Widdershins>	i think xfer is borrowing tx...?
Mar 12 00:27:06 <Widdershins>	i'm not sure :/
Mar 12 00:27:08 <dav1d>	Yeah, but the wait should consume it and return a new tx without a lifetime to the buffer?
Mar 12 00:28:59 <dav1d>	Looks fine to me, but clearly it's not, hard to guess without actual type info. Already past my bed time, gl
Mar 12 00:29:27 <Widdershins>	yeah need to see more of the crate for this
Mar 12 00:33:18 <yziquel>	Widdershins this seems to allow what I need, though I'd like to see if it works with Enums and not only structs. https://github.com/dtolnay/readonly
Mar 12 00:33:52 <Widdershins>	enums work the same as structs
Mar 12 00:34:32 <j`ey>	also seems quite unrelated to anything you talked about
Mar 12 00:34:45 <Widdershins>	yeah this is about visibility
Mar 12 00:35:46 <LDericher>	Widdershins, I pushed the crate to my git, the last commit is the changes I'm trying to make: https://code.yavook.de/jmm/bluepill-rust-blinky/src/branch/irc
**** BEGIN LOGGING AT Tue Mar 12 00:38:03 2024

Mar 12 00:38:02 *	Now talking on ##rust
Mar 12 00:38:02 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 12 00:38:02 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Mar 12 00:38:03 <polychromata{J}>	<yziquel> I tend to be annoyed by people always questioning what I plan to do.
Mar 12 00:38:03 <polychromata{J}>	<yziquel> I already have a mother.
Mar 12 00:38:03 <polychromata{J}>	off-topic, but i feel like somecreature should mention that this is not normal
Mar 12 00:38:11 <polychromata{J}>	you are gently encouraged to surround yourself with people who respect your autonomy. things tend to be much better that way.
Mar 12 00:38:25 <polychromata{J}>	(speaking from personal experience)
Mar 12 00:38:30 <yziquel>	polychromata{J} you want to go down that lane ?
Mar 12 00:39:10 <polychromata{J}>	depends on what you mean by that? i'll be in ##rust-offtopic
Mar 12 00:39:44 <Widdershins>	cdhowie: as far as i can tell based on its implementation (which is very funny btw) there's no reason it *can't* work on enums
Mar 12 00:40:24 <cdhowie>	Widdershins: i don't see how it could work with enums at all
**** BEGIN LOGGING AT Tue Mar 12 00:55:46 2024

Mar 12 00:55:45 *	Now talking on ##rust
Mar 12 00:55:45 *	Topic for ##rust is: Unofficial channel for the Rust programming language | Don't ask to ask, just ask! | Code of conduct: https://rust-lang.org/policies/code-of-conduct | Playground: https://play.rust-lang.org | evalr: «code» to run Rust code | Other chat/help venues: https://rust-lang.org/community | Moderation concerns: ##rust-ops | Offtopic chatter: ##rust-offtopic
Mar 12 00:55:45 *	Topic for ##rust set by bertptrs!~quassel@user/bertptrs (Mon May 22 14:11:18 2023)
Mar 12 00:56:33 <polychromata{J}>	like a lot of std types do that, things like `pub struct Foo(crate::sys::imp::Foo);`, where that module is #[cfg] based on platform. or something like that
Mar 12 00:56:34 <Widdershins>	explicit privacy is a thing, including by convention a la python's prefixing with an underscore (or with two underscores, for the magic mangle)
Mar 12 00:56:46 <Widdershins>	buuuut we're down the other road now a good ways with rust
Mar 12 00:57:55 <Widdershins>	perhaps you could put `pub(partial)` as the visibility of the enum, and then the variants and fields therein would only have visibility as declared
Mar 12 01:00:40 <yziquel>	Is OnceCell a way to tie the knot of an immutable cyclic (singly) linked list ?
Mar 12 01:01:18 <danieldg>	it could be, though you need to solve the freeing problem too
Mar 12 01:01:39 <yziquel>	danieldg i plan to use bumpalo to eschew that problem.
Mar 12 01:02:17 <yziquel>	doable ?
Mar 12 01:02:38 <danieldg>	sure
Mar 12 01:02:57 <danieldg>	you could use a normal cell too
Mar 12 01:03:00 <yziquel>	danieldg good to know. that will save me some time w/r investigation.
Mar 12 01:03:07 <danieldg>	but yeah, oncecell is probably nicer
Mar 12 01:03:35 <yziquel>	danieldg an normal cell has a runtime penalty, no ?
Mar 12 01:04:28 <danieldg>	no, it's just more annoying to use
Mar 12 01:04:42 <danieldg>	unless the type is Copy
Mar 12 01:05:08 <danieldg>	Cell<Option<T>> and OnceCell<T> are basically identical if T is copy
Mar 12 01:05:20 <danieldg>	other than the ability to write multiple times w/ Cell
Mar 12 01:06:13 <cdhowie>	RefCell<T> has a runtime penalty (unless the optimizer can prove the refcounting redundant), but Cell<T> does not
Mar 12 01:06:19 <yziquel>	and i get get a T out of it, if i understand right ?
Mar 12 01:06:28 <danieldg>	you get &T
Mar 12 01:06:28 <yziquel>	i can get
Mar 12 01:06:40 <yziquel>	danieldg ok. just what I need.
Mar 12 01:06:47 <yziquel>	i'll try it.
Mar 12 01:15:12 <Widdershins>	i think OnceCell<&'a Self> would work to populate a cyclic network of direct references between values as long as all of the values' ownerships outlive 'a
Mar 12 01:15:29 <Widdershins>	and it maintains a trivial drop
Mar 12 01:16:39 <Widdershins>	actually would 'a have to be exactly equal to the lifetime of their ownership. is that allowed? maybe 'a has to outlive the ownership and you must be forced to drop them all before 'a is done actually
Mar 12 01:16:51 <yziquel>	Widdershins kind of what i plan to do for my cyclic lambda terms.
Mar 12 01:17:31 <Widdershins>	you could actually make the ownership arbitrarily extensible with constant references using the dumb clown thing i made the other week that i keep bringing back up
Mar 12 01:17:36 <danieldg>	Widdershins: I think you end up with &'a Node<'a> for everything
Mar 12 01:17:46 <Widdershins>	danieldg: yeah
Mar 12 01:17:54 <danieldg>	it might forbid you from implementing Drop on Node
Mar 12 01:18:26 <Widdershins>	i can imagine that would be the case
Mar 12 01:21:48 <Widdershins>	is this allowed at all? i don't know how it's possible to take apart e.g. a btree of these when deleting a single one would invalidate literally all the rest and make them un-look-at-able
Mar 12 01:22:02 <danieldg>	actually maybe that would just be bumpalo's stipulation, it doesn't Drop at all
Mar 12 01:22:35 <danieldg>	that makes it much simpler
Mar 12 01:47:52 <yziquel>	Where is the value retrieved by OnceCell.get() allocated in memory ?
Mar 12 01:48:06 <danieldg>	inside the cell itself
Mar 12 01:48:13 <danieldg>	you can look at the impl
Mar 12 01:48:26 <danieldg>	it's a thin wrapper around UnsafeCell<Option<T>>
Mar 12 01:52:28 <yziquel>	https://docs.rs/once_cell/latest/once_cell/#lateinit
Mar 12 01:52:40 <yziquel>	but not quite what i seek.
Mar 12 01:52:58 <danieldg>	yziquel: this is in std now
Mar 12 01:53:45 <danieldg>	clarify your question then
Mar 12 01:54:45 <Widdershins>	wondering if there's a reachable soundness hole around this
Mar 12 01:54:48 <yziquel>	wel, i wonder. thinking.
Mar 12 01:55:30 <Widdershins>	or if there's some dance that has to happen or straight up precludes what I'm thinking of
Mar 12 01:55:43 <Widdershins>	taking a nap will look later
Mar 12 01:56:22 <danieldg>	Widdershins: I think it could only happen with Drop impls, but yeah, it does feel like you could get to dead objects after making a self-referential struct
Mar 12 01:57:05 <Widdershins>	if you put them in 2 vecs, make a cycle, and drop one vec. what then
Mar 12 01:57:29 <Widdershins>	is that illegal, do you have to drop both. are the refs present but unlookable
Mar 12 01:57:50 <danieldg>	this is related to #[may_dangle]
Mar 12 01:58:35 <yziquel>	danield it seems it works. the memory layout is just pointers to pointers to pointers. no overhead. what i was looking for.
Mar 12 01:58:37 <cdhowie>	Widdershins: The compiler should not let you do that.  That's effectively a textbook self-referential struct.
Mar 12 01:58:45 <yziquel>	danieldg it seems it works. the memory layout is just pointers to pointers to pointers. no overhead. what i was looking for.
Mar 12 02:00:27 <danieldg>	Widdershins: yep, it rejects it
Mar 12 02:00:47 <Widdershins>	danieldg: where does the crime occur exactly
Mar 12 02:00:53 <danieldg>	on drop
Mar 12 02:01:15 <Widdershins>	do you have to drop both vecs or is the whole thing illegal
Mar 12 02:01:24 <danieldg>	evalr: use std::cell::OnceCell; struct S<'a>(OnceCell<&'a S<'a>>); let x = S(OnceCell::new()); x.0.set(&x); drop(x); impl<'a> Drop for S<'a> { fn drop(&mut self) {}}
Mar 12 02:01:26 -evalr/##rust-	danieldg: error[E0597]: `x` does not live long enough ...
Mar 12 02:01:27 -evalr/##rust-	danieldg: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=5896d72b18bb347398fa9b37707bf7c7
Mar 12 02:01:48 <danieldg>	having more than one x just makes it longer
Mar 12 02:02:19 <Widdershins>	i don't need an impl drop though I'm just wondering how they can be owned
Mar 12 02:02:39 <cdhowie>	They'd be owned by the arena
Mar 12 02:02:41 <danieldg>	if you remove the impl Drop it'll compile
Mar 12 02:02:58 <danieldg>	evalr: use std::cell::OnceCell; struct S<'a>(OnceCell<&'a S<'a>>); let x = std::mem::ManuallyDrop::new(S(OnceCell::new())); x.0.set(&x); impl<'a> Drop for S<'a> { fn drop(&mut self) {}}
Mar 12 02:03:00 -evalr/##rust-	danieldg: ()
Mar 12 02:03:07 <danieldg>	that one kinda surprised me
Mar 12 02:03:37 <danieldg>	it's fine but I expected rustc to reject it anyway
Mar 12 02:03:56 <Widdershins>	hah
Mar 12 02:04:35 <Widdershins>	you have to forget it? or can you actually do the drop because you have to do it unsafely
Mar 12 02:04:52 <danieldg>	you have to forget it if you want to be safe
Mar 12 02:04:54 <yziquel>	danieldg lateinit is not in stdlib.
Mar 12 02:05:03 <yziquel>	i think
Mar 12 02:05:25 <danieldg>	yziquel: lateinit is just a "how do I use this", not an actual feature
Mar 12 02:05:37 <yziquel>	stupid me
Mar 12 02:11:30 <yziquel>	ok. got it. perfect. happy evening.
Mar 12 02:17:55 <danieldg>	evalr: #![feature(dropck_eyepatch)] use std::cell::OnceCell; struct S<'a>(OnceCell<&'a S<'a>>); let x = S(OnceCell::new()); x.0.set(&x); unsafe impl<#[may_dangle] 'a> Drop for S<'a> { fn drop(&mut self) {}}
Mar 12 02:17:57 -evalr/##rust-	danieldg: error[E0554]: `#![feature]` may not be used on the stable releas ...
Mar 12 02:17:58 -evalr/##rust-	danieldg: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=9f6a30f272664760faa91cbe66e4b4e0
Mar 12 02:18:05 <danieldg>	evalr: --unstable #![feature(dropck_eyepatch)] use std::cell::OnceCell; struct S<'a>(OnceCell<&'a S<'a>>); let x = S(OnceCell::new()); x.0.set(&x); unsafe impl<#[may_dangle] 'a> Drop for S<'a> { fn drop(&mut self) {}}
Mar 12 02:18:07 -evalr/##rust-	danieldg: error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an ...
Mar 12 02:18:07 -evalr/##rust-	danieldg: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=85e1c619e50b0f35d243829b1fefa800
Mar 12 02:18:17 <danieldg>	evalr: --nightly #![feature(dropck_eyepatch)] use std::cell::OnceCell; struct S<'a>(OnceCell<&'a S<'a>>); let x = S(OnceCell::new()); x.0.set(&x); unsafe impl<#[may_dangle] 'a> Drop for S<'a> { fn drop(&mut self) {}}
Mar 12 02:18:19 -evalr/##rust-	danieldg: ()
Mar 12 02:19:33 <danieldg>	so you can actually do the drop, you just have to promise not to look at the ref when you are in the drop impl
Mar 12 02:32:58 <Widdershins>	danieldg: ohhh
Mar 12 02:39:15 <Widdershins>	yeah ok so
Mar 12 02:39:37 <Widdershins>	i can use the circus impl to add vecs full of self-referential whatsits
Mar 12 02:39:57 <danieldg>	yep
Mar 12 02:40:12 <Widdershins>	but nothing self-referential or containing anything self-referential can be moved or dropped except in-place
Mar 12 02:40:14 <danieldg>	rustc will stop you if you do it wrong
Mar 12 02:40:26 <danieldg>	also yes
Mar 12 02:40:52 <danieldg>	self-referential things are annoying to use because of this
Mar 12 02:41:10 <Widdershins>	and if dropping is all done implicitly i guess that is sufficient to prove that it happens automatically, effectively instantaneously, and by the book
Mar 12 02:41:14 <yziquel>	seems a cool discussion.
Mar 12 02:42:17 <Widdershins>	for some reason i thought labeled blocks could be named as lifetimes
Mar 12 02:42:43 <danieldg>	they do use the same syntax
Mar 12 02:43:14 <Widdershins>	it would make sense to have 'a: { .. } and anything in that block could name 'a as "promised to live at least as long as the end of this block"
Mar 12 02:43:24 <yziquel>	yes
Mar 12 02:43:25 <Widdershins>	seems that can't be spelled though
Mar 12 02:43:38 <Widdershins>	'a is just a label here, and lifetimes can only be created via parameter
Mar 12 02:45:33 <Widdershins>	i guess fair enough since encouraging people to spell explicit lifetimes can only bake in the current borrowck model annoyingly hard
Mar 12 02:47:48 <Widdershins>	https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=107daf6585e4fe9259be22d109207e61
Mar 12 02:57:23 <Widdershins>	those could probably be Box<[ScaryClown]> but it's surprisingly annoying to turn Box<[T; N]> into Box<[T]>. unless i'm forgetting an easy way to do it
Mar 12 02:57:40 <danieldg>	I think it's just an as?
Mar 12 02:58:16 <Widdershins>	:o you can `as` a Box?
Mar 12 02:58:52 <Widdershins>	or do you `as` the sized array in place without taking it as a reference
Mar 12 02:59:00 <Widdershins>	i wasn't aware you could do either of those things
Mar 12 02:59:30 <danieldg>	it's the same as making a Box<dyn Foo>
Mar 12 02:59:33 <danieldg>	which is also via as
Mar 12 02:59:34 <Widdershins>	wow you can as the box
Mar 12 02:59:41 <Widdershins>	is this a compiler carve-out
Mar 12 03:00:02 <danieldg>	it's an unsizing coersion
Mar 12 03:00:18 <danieldg>	I think it just works for things that are generic with <T:?Sized>
Mar 12 03:01:04 <Widdershins>	interesting... and that goes straight through the generics and makes it a different concrete type you're holding?
Mar 12 03:01:20 <danieldg>	basically it just widens the pointer
Mar 12 03:01:51 <Widdershins>	yeah but if this isn't special for box that's wild, since you could use that to widen any generic pointers within any struct
Mar 12 03:02:01 <danieldg>	it might require CoerceUnsized
Mar 12 03:02:16 <danieldg>	no, you don't widen the pointer *in* the struct
Mar 12 03:02:26 <danieldg>	you widen the pointer to the struct
Mar 12 03:02:42 <Widdershins>	you get a new struct with the same values and the same pointer but now the pointer is wide
Mar 12 03:03:00 <Widdershins>	i can as the box without any features
Mar 12 03:03:46 <Widdershins>	vec also automatically coerces to Box<[T]> apparently, but Box<[T; N]> does not
Mar 12 03:03:58 <Widdershins>	or at least whatever `vec!` spits out does
Mar 12 03:04:01 <Diablo-D3>	[19:16:04] <pflanze> Diablo-D3, the last commit to that repo was from a day ago. Also, https://element.io/blog/element-x-ignition/
Mar 12 03:04:19 <Diablo-D3>	I guess its good news they didnt fuck this up
Mar 12 03:07:32 <Diablo-D3>	btw, apparently I may have been thinking of fractal
Mar 12 03:08:38 <Diablo-D3>	sadly, its gnome's own client
Mar 12 03:08:39 <Widdershins>	danieldg: not having any luck applying it to a type containing a ref
Mar 12 03:08:45 <Diablo-D3>	so thats super doa
Mar 12 03:08:56 <Widdershins>	even with the feature
Mar 12 03:09:43 <Widdershins>	or do you have to impl the feature
Mar 12 03:09:46 <Widdershins>	trait*
Mar 12 03:10:12 <danieldg>	Widdershins: I think you have to have the boxlike impml CoerceUnsized
Mar 12 03:11:48 <Widdershins>	> implement CoerceUnsized<Ptr<U>> for Ptr<T> where T: Unsize<U>, U: ?Sized
Mar 12 03:11:57 <Widdershins>	i see how it is ok
Mar 12 03:14:08 <Widdershins>	and it won't let you implement it on an enum. bummer
Mar 12 03:20:49 <Widdershins>	so the coercion only works if it always knows precisely what to do, you can't have branches in there
Mar 12 03:26:42 <cowboy861>	hey hey
Mar 12 03:34:45 <Widdershins>	haha
Mar 12 03:34:54 <Widdershins>	pro tip: don't actually derive Debug for a self-referential type
